/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling {@link #clearFilter} will return you to a full time axis.

*/
Ext.define("Sch.data.TimeAxis", {
    extend      : "Ext.data.JsonStore",

    requires    : [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],

    model               : 'Sch.model.TimeAxisTick',

    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous          : true,

    originalContinuous  : null,

    /**
    * @cfg {Boolean} autoAdjust
    * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
    * may lead to shifting time/date of ticks.
    */
    autoAdjust          : true,

    unit                : null,
    increment           : null,
    resolutionUnit      : null,
    resolutionIncrement : null,

    weekStartDay        : null,

    mainUnit            : null,
    shiftUnit           : null,

    shiftIncrement      : 1,
    defaultSpan         : 1,

    isConfigured        : false,

    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart       : null,
    adjustedEnd         : null,
    // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
    visibleTickStart    : null,
    // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
    visibleTickEnd      : null,

    // name of the current preset
    presetName          : null,

    /**
     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for calendar we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'calendar']
     */
    mode                : 'plain',

    /**
     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime           : 0,
    
    /**
     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime             : 24,

    /**
     * @event beforereconfigure
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */

    /**
     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */

    /**
     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */

    // private
    constructor : function(config) {
        var me = this;

        config = config || {};

        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }

        me.setMode(config.mode || me.mode);

        me.originalContinuous = me.continuous;

        me.callParent(arguments);

        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function() {
            me.fireEvent('reconfigure', me, false);
        });

        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });

        if (config.viewPreset) {
            var preset      = Sch.preset.Manager.getPreset(config.viewPreset);
            preset && me.consumeViewPreset(preset);
        }

        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },

    /**
     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
     * @param {Object} config
     * @param {Boolean} [suppressRefresh]
     * @private
     */
    reconfigure : function (config, suppressRefresh) {
        this.isConfigured   = true;

        Ext.apply(this, config);

        var adjusted        = this.getAdjustedDates(config.start, config.end, true);
        var normalized      = this.getAdjustedDates(config.start, config.end);

        var start           = normalized.start;
        var end             = normalized.end;

        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {

            this.fireEvent('beginreconfigure', this);

            var unit                = this.unit;
            var increment           = this.increment || 1;
            var ticks               = this.generateTicks(start, end, unit, increment);

            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);

            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();

            var DATE                = Sch.util.Date;
            var count               = ticks.length;

            if (this.isContinuous()) {
                this.adjustedStart      = adjusted.start;
                this.adjustedEnd        = this.getNext(count > 1 ? ticks[ count - 1 ].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart      = this.getStart();
                this.adjustedEnd        = this.getEnd();
            }

            // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust "adjustedStart" accordingly
            do {
                // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
                this.visibleTickStart   = (this.getStart() - this.adjustedStart) / (DATE.getUnitDurationInMs(unit) * increment);

                if (this.visibleTickStart >= 1) this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment);
            } while (this.visibleTickStart >= 1);

            do {
                this.visibleTickEnd     = count - (this.adjustedEnd - this.getEnd()) / (DATE.getUnitDurationInMs(unit) * increment);

                if (count - this.visibleTickEnd >= 1) this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1);
            } while (count - this.visibleTickEnd >= 1);

            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },

    setMode : function (mode) {
        this.mode = mode;
        
        if (mode === 'calendar') {
            this.generateTicksValidatorFn = function (start) { 
                if (this.startTime > 0 || this.endTime < 24) {
                    return (start.getHours() >= this.startTime && start.getHours() < this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function () { return true; };
        }
    },

    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end The new end date
    */
    setTimeSpan : function (start, end) {
        var adjusted    = this.getAdjustedDates(start, end);

        start           = adjusted.start;
        end             = adjusted.end;

        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0) {
            this.reconfigure({
                start   : start,
                end     : end
            });
        }
    },

    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy : function(fn, scope) {
        this.continuous = false;
        scope = scope || this;

        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([{
            filterFn : function(t, index) {
                return fn.call(scope, t.data, index);
            }
        }]);

        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },

    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous : function() {
        var result = this.continuous && !this.isFiltered();
        if (this.mode === 'calendar') {
            result = result && this.startTime === 0 && this.endTime === 24;
        }
        return result;
    },

    /**
     * Clear the current filter of the time axis
     */
    clearFilter : function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },

    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} start The start date of the interval
     * @param {Date} end The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Number} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks : function (start, end, unit, increment) {
        var ticks           = [],
            intervalEnd,
            DATE            = Sch.util.Date,
            dstDiff         = 0;

        unit                = unit || this.unit;
        increment           = increment || this.increment;

        var adjusted        = this.getAdjustedDates(start, end);

        start               = adjusted.start;
        end                 = adjusted.end;

        while (start < end) {
            intervalEnd     = this.getNext(start, unit, increment);

            if (!this.autoAdjust && intervalEnd > end) intervalEnd = end;

            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0) {
                var prev    = ticks[ ticks.length - 1 ];

                dstDiff     = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }

            this.generateTicksValidatorFn(start) && ticks.push({
                start   : start,
                end     : intervalEnd
            });
            
            start           = intervalEnd;
        }

        return ticks;
    },


    getVisibleTickTimeSpan : function () {
        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount();
    },


    getAdjustedDates : function (start, end, forceAdjust) {
        var DATE    = Sch.util.Date;
        start       = start || this.getStart();
        end         = end || DATE.add(start, this.mainUnit, this.defaultSpan);

        if (this.mode === 'calendar') {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit);
                    end = this.ceilDate(end, false, this.mainUnit);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start   : start,
                        end     : end
                    };
                }
            }

            var adjustedStart, adjustedEnd, clone;
            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            adjustedStart   = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart   = this.floorDate(adjustedStart, false, this.mainUnit, 1);

            // https://www.assembla.com/spaces/bryntum/tickets/2811
            // Disabled autoAdjust will allow to show any time span
            if (this.autoAdjust) {
                clone           = this.getNext(start, this.shiftUnit, 1);
                adjustedEnd     = this.ceilDate(clone, false, this.shiftUnit);
                adjustedEnd     = this.ceilDate(adjustedEnd, false, this.mainUnit);
            } else {
                adjustedEnd     = this.ceilDate(end, false, this.shiftUnit);
                adjustedEnd     = this.ceilDate(adjustedEnd, false, this.mainUnit);
            }

            return {
                start   : adjustedStart,
                end     : adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start   : this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end     : this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start   : start,
                end     : end
            };
        }
    },

    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate : function (date) {
        var ticks           = this.data.items;
        var lastTickIndex   = ticks.length - 1;

        // quick bailout
        if (date.valueOf() < ticks[ 0 ].data.start.valueOf() || date.valueOf() > ticks[ lastTickIndex ].data.end.valueOf()) {
            return -1;
        }

        var tick, tickStart, tickEnd;

        if (this.isContinuous()) {
            if (date - ticks[ 0 ].data.start === 0) return this.visibleTickStart;
            if (date - ticks[ lastTickIndex ].data.end === 0) return this.visibleTickEnd;

            var adjustedStart   = this.adjustedStart;
            var adjustedEnd     = this.adjustedEnd;

            var tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));

            // for the date == adjustedEnd case
            if (tickIndex > lastTickIndex) tickIndex = lastTickIndex;

            tickStart           = tickIndex === 0 ? adjustedStart : ticks[ tickIndex ].data.start;
            tickEnd             = tickIndex == lastTickIndex ? adjustedEnd : ticks[ tickIndex ].data.end;

            tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);

            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // but still
            if (tick < this.visibleTickStart || tick > this.visibleTickEnd) return -1;

            return tick;
        } else {
            for (var i = 0; i <= lastTickIndex; i++) {
                tickEnd         = ticks[ i ].data.end;

                if (date <= tickEnd) {
                    tickStart   = ticks[ i ].data.start;

                    // date < tickStart can occur in filtered case
                    tick        = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

                    return tick;
                }
            }
        }

        return -1;
    },

    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Number} tick the tick "coordinate"
    * @param {String} roundingMethod The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick : function (tick, roundingMethod) {
        if (tick === this.visibleTickEnd) return this.getEnd();

        var wholeTick   = Math.floor(tick),
            fraction    = tick - wholeTick,
            t           = this.getAt(wholeTick);

        if (!t) return null;

        var tickData    = t.data;
        var start       = wholeTick === 0 ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end         = (wholeTick == this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : tickData.end;

        var date        = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));

        if (roundingMethod) {
            date        = this[ roundingMethod + 'Date' ](date);
        }

        return date;
    },

    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks : function() {
        var ticks = [];

        this.each(function (r) { ticks.push(r.data); });
        return ticks;
    },

    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart : function() {
        var first = this.first();

        if (first) {
            return new Date(first.data.start);
        }
        return null;
    },

    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd : function() {
        var last = this.last();

        if (last) {
            return new Date(last.data.end);
        }
        return null;
    },

    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate : function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;

        var dt          = Ext.Date.clone(date),
            relativeTo  = relativeToStart ? this.getStart() : null,
            increment   = incr || this.resolutionIncrement,
            unit;

        if (resolutionUnit) {
            unit        = resolutionUnit;
        } else {
            unit        = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        var DATE        = Sch.util.Date;
        var snap        = function (value, increment) { return Math.floor(value / increment) * increment; };

        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                }
                break;

            case DATE.SECOND:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setMilliseconds(0);
                    dt.setSeconds(snap(dt.getSeconds(), increment));
                }
                break;

            case DATE.MINUTE:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setMinutes(snap(dt.getMinutes(), increment));
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                }
                break;

            case DATE.HOUR:
                if (relativeToStart) {
                    dt           = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                    dt.setHours(snap(dt.getHours(), increment));
                }
                break;

            case DATE.DAY:
                if (relativeToStart) {
                    dt            = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                }
                break;

            case DATE.WEEK:
                var day      = dt.getDay()       || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);

                dt      = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));

                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay && dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                }
                break;

            case DATE.MONTH:
                if (relativeToStart) {
                    dt      = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                }
                break;

            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt                      = DATE.add(dt, DATE.MONTH, - (dt.getMonth() % 3));
                break;

            case DATE.YEAR:
                if (relativeToStart) {
                    dt                  = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    dt                  = new Date(snap(date.getFullYear() - 1, increment) + 1, 0, 1);
                }
                break;
        }

        return dt;
    },


    // Rounds the date to nearest unit increment
    // private
    roundDate : function(date, relativeTo) {
        var dt = Ext.Date.clone(date),
            increment = this.resolutionIncrement;

        relativeTo = relativeTo || this.getStart();

        switch(this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                    snappedMilliseconds = Math.round(milliseconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                break;

            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                    snappedSeconds = Math.round(seconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                break;

            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                    snappedMinutes = Math.round(minutes / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                break;

            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt),
                    snappedHours = Math.round(nbrHours / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                break;

            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);

                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay/7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                }

                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;

            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }

        return dt;
    },

    // private
    ceilDate : function(date, relativeToStart, resolutionUnit) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;

        var increment = relativeToStart ? this.resolutionIncrement : 1,
            doCall = false,
            unit;

        if (resolutionUnit){
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            default:
            break;
        }

        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },

    // private
    getNext : function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
    },

    // private
    getResolution : function() {
        return {
            unit : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    },

    // private
    setResolution : function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },

    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function (amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        amount      = amount || this.getShiftIncrement();
        var unit    = this.getShiftUnit();

        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    getShiftUnit: function () {
        return this.shiftUnit || this.mainUnit;
    },

    // private
    getShiftIncrement: function () {
        return this.shiftIncrement || 1;
    },

    // private
    getUnit: function () {
        return this.unit;
    },

    // private
    getIncrement: function () {
        return this.increment;
    },
    
    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
    getRowTicks    : function () {
        if (this.mode !== 'plain') {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);

            var endIndex = this.findBy(function (record) {
                return record.getStartDate().getTime() >= end.getTime();
            });

            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }

            return this.getRange(0, endIndex - 1);
        }
    },

    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date) {
        var result = Sch.util.Date.betweenLesser(date, this.getStart(), this.getEnd());

        // Date is between axis start/end and axis is not continuous - need to perform better lookup
        if (result && !this.isContinuous()) {
            var tickIndex   = this.getTickFromDate(date);
            var tick        = this.getAt(Math.floor(tickIndex));

            result = tick.getStartDate() <= date && tick.getEndDate() >= date;
        }

        return result;
    },

    /**
    * Returns true if the passed timespan is part of the current time axis (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @return {boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, this.getStart(), this.getEnd());
        } else {
            return (start < this.getStart() && end > this.getEnd()) ||
                   this.getTickFromDate(start) !== this.getTickFromDate(end);
        }
    },

    // Accepts a Sch.model.Range model
    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();

        // only consider fully scheduled ranges
        if (!start || !end) return false;

        return this.timeSpanInAxis(start, end);
    },


    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachAuxInterval : function (unit, increment, iteratorFn, scope) {
        scope               = scope || this;

        var end             = this.getEnd(),
            dt              = this.getStart(),
            i               = 0,
            intervalEnd;

        if (dt > end) throw 'Invalid time axis configuration';

        while (dt < end) {
            intervalEnd     =  Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt              = intervalEnd;
            i++;
        }
    },


    consumeViewPreset : function (preset) {
        Ext.apply(this, {
            unit                : preset.getBottomHeader().unit,
            increment           : preset.getBottomHeader().increment || 1,

            resolutionUnit      : preset.timeResolution.unit,
            resolutionIncrement : preset.timeResolution.increment,

            mainUnit            : preset.getMainHeader().unit,
            shiftUnit           : preset.shiftUnit,
            shiftIncrement      : preset.shiftIncrement || 1,

            defaultSpan         : preset.defaultSpan || 1,
            presetName          : preset.name,

            // Calendar columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig        : preset.headerConfig
        });
    }
});
