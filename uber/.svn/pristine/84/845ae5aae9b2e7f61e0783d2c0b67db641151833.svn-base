/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.locale.Locale

Base locale class. You need to subclass it, when creating new locales for Bryntum components. Usually subclasses of this class
will be singletones.

See <a href="#!/guide/gantt_scheduler_localization">Localization guide</a> for additional details.

*/
Ext.define('Sch.locale.Locale', {
    /**
     * @cfg {Object} l10n An object with the keys corresponding to class names and values are in turn objects with "phraseName/phraseTranslation"
     * key/values. For example:
     *
    l10n        : {
        'Sch.plugin.EventEditor' : {
            saveText: 'Speichern',
            deleteText: 'LÃ¶schen',
            cancelText: 'Abbrechen'
        },
        'Sch.plugin.CurrentTimeLine' : {
            tooltipText : 'Aktuelle Zeit'
        },

        ...
    }

     */
    l10n: null,
    legacyMode: true,
    localeName: null,
    namespaceId: null,
    constructor: function() {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire();
        }
        var name = this.self.getName().split('.');
        var localeName = this.localeName = name.pop();
        this.namespaceId = name.join('.');
        var currentLocale = Sch.locale.Active[this.namespaceId];
        // let's localize all the classes that are loaded
        // except the cases when English locale is being applied over some non-english locale
        if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En'))  {
            this.apply();
        }
        
    },
    bindRequire: function() {
        // OVERRIDE
        // we need central hook to localize class once it's been created
        // to achieve it we override Ext.ClassManager.triggerCreated
        var _triggerCreated = Ext.ClassManager.triggerCreated;
        Ext.ClassManager.triggerCreated = function(className) {
            _triggerCreated.apply(this, arguments);
            if (className) {
                var cls = Ext.ClassManager.get(className);
                // trying to apply locales for the loaded class
                for (var namespaceId in Sch.locale.Active) {
                    Sch.locale.Active[namespaceId].apply(cls);
                }
            }
        };
    },
    applyToClass: function(className, cls) {
        var me = this,
            localeId = me.self.getName();
        cls = cls || Ext.ClassManager.get(className);
        if (cls && (cls.activeLocaleId !== localeId)) {
            var locale = me.l10n[className];
            // if it's procedural localization - run provided callback
            if (typeof locale === 'function') {
                locale(className);
            }
            // if it's a singleton - apply to it
            else if (cls.singleton) {
                cls.l10n = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);
            } else // otherwise we override class
            {
                Ext.override(cls, {
                    l10n: locale
                });
            }
            // if we support old locales approach let's duplicate locale to old places
            if (me.legacyMode) {
                var target;
                // we update either class prototype
                if (cls.prototype) {
                    target = cls.prototype;
                }
                // or object itself in case of singleton
                else if (cls.singleton) {
                    target = cls;
                }
                if (target && target.legacyMode) {
                    if (target.legacyHolderProp) {
                        if (!target[target.legacyHolderProp])  {
                            target[target.legacyHolderProp] = {};
                        }
                        
                        target = target[target.legacyHolderProp];
                    }
                    for (var p in locale) {
                        if (typeof target[p] !== 'function')  {
                            target[p] = locale[p];
                        }
                        
                    }
                }
            }
            // keep applied locale
            cls.activeLocaleId = localeId;
            // for singletons we can have some postprocessing
            if (cls.onLocalized)  {
                cls.onLocalized();
            }
            
        }
    },
    /**
     * Apply this locale to classes.
     * @param {String[]/Object[]} [classNames] Array of class names (or classes themself) to localize.
     * If no classes specified then will localize all exisiting classes.
     */
    apply: function(classNames) {
        if (this.l10n) {
            var me = this;
            // if class name is specified
            if (classNames) {
                if (!Ext.isArray(classNames))  {
                    classNames = [
                        classNames
                    ];
                }
                
                var name, cls;
                for (var i = 0,
                    l = classNames.length; i < l; i++) {
                    if (Ext.isObject(classNames[i])) {
                        if (classNames[i].singleton) {
                            cls = classNames[i];
                            name = Ext.getClassName(Ext.getClass(cls));
                        } else {
                            cls = Ext.getClass(classNames[i]);
                            name = Ext.getClassName(cls);
                        }
                    } else {
                        cls = null;
                        name = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
                    }
                    if (name) {
                        if (name in this.l10n) {
                            me.applyToClass(name, cls);
                        }
                    }
                }
            } else // localize all the classes that we know about
            {
                // update active locales
                Sch.locale.Active[this.namespaceId] = this;
                for (var className in this.l10n) {
                    me.applyToClass(className);
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * English translations for the Scheduler component
 *
 * NOTE: To change locale for month/day names you have to use the corresponding Ext JS language file.
 */
Ext.define('Sch.locale.En', {
    extend: 'Sch.locale.Locale',
    singleton: true,
    constructor: function(config) {
        Ext.apply(this, {
            l10n: {
                'Sch.util.Date': {
                    unitNames: {
                        YEAR: {
                            single: 'year',
                            plural: 'years',
                            abbrev: 'yr'
                        },
                        QUARTER: {
                            single: 'quarter',
                            plural: 'quarters',
                            abbrev: 'q'
                        },
                        MONTH: {
                            single: 'month',
                            plural: 'months',
                            abbrev: 'mon'
                        },
                        WEEK: {
                            single: 'week',
                            plural: 'weeks',
                            abbrev: 'w'
                        },
                        DAY: {
                            single: 'day',
                            plural: 'days',
                            abbrev: 'd'
                        },
                        HOUR: {
                            single: 'hour',
                            plural: 'hours',
                            abbrev: 'h'
                        },
                        MINUTE: {
                            single: 'minute',
                            plural: 'minutes',
                            abbrev: 'min'
                        },
                        SECOND: {
                            single: 'second',
                            plural: 'seconds',
                            abbrev: 's'
                        },
                        MILLI: {
                            single: 'ms',
                            plural: 'ms',
                            abbrev: 'ms'
                        }
                    }
                },
                'Sch.panel.TimelineGridPanel': {
                    weekStartDay: 1,
                    loadingText: 'Loading, please wait...',
                    savingText: 'Saving changes, please wait...'
                },
                'Sch.panel.TimelineTreePanel': {
                    weekStartDay: 1,
                    loadingText: 'Loading, please wait...',
                    savingText: 'Saving changes, please wait...'
                },
                'Sch.mixin.SchedulerView': {
                    loadingText: 'Loading events...'
                },
                'Sch.plugin.CurrentTimeLine': {
                    tooltipText: 'Current time'
                },
                'Sch.plugin.EventEditor': {
                    saveText: 'Save',
                    deleteText: 'Delete',
                    cancelText: 'Cancel'
                },
                'Sch.plugin.SimpleEditor': {
                    newEventText: 'New booking...'
                },
                'Sch.widget.ExportDialogForm': {
                    formatFieldLabel: 'Paper format',
                    orientationFieldLabel: 'Orientation',
                    rangeFieldLabel: 'Schedule range',
                    showHeaderLabel: 'Show header',
                    showFooterLabel: 'Show footer',
                    orientationPortraitText: 'Portrait',
                    orientationLandscapeText: 'Landscape',
                    completeViewText: 'Complete schedule',
                    currentViewText: 'Visible schedule',
                    dateRangeText: 'Date range',
                    dateRangeFromText: 'Export from',
                    dateRangeToText: 'Export to',
                    exportersFieldLabel: 'Control pagination',
                    adjustCols: 'Adjust column width',
                    adjustColsAndRows: 'Adjust column width and row height',
                    specifyDateRange: 'Specify date range',
                    columnPickerLabel: 'Select columns',
                    completeDataText: 'Complete schedule (for all events)',
                    dpiFieldLabel: 'DPI (dots per inch)',
                    rowsRangeLabel: 'Rows range',
                    allRowsLabel: 'All rows',
                    visibleRowsLabel: 'Visible rows',
                    columnEmptyText: '[no title]'
                },
                'Sch.widget.ExportDialog': {
                    title: 'Export Settings',
                    exportButtonText: 'Export',
                    cancelButtonText: 'Cancel',
                    progressBarText: 'Exporting...'
                },
                'Sch.plugin.Export': {
                    generalError: 'An error occurred',
                    fetchingRows: 'Fetching row {0} of {1}',
                    builtPage: 'Built page {0} of {1}',
                    requestingPrintServer: 'Please wait...'
                },
                'Sch.plugin.Printable': {
                    dialogTitle: 'Print settings',
                    exportButtonText: 'Print'
                },
                'Sch.plugin.exporter.AbstractExporter': {
                    name: 'Exporter'
                },
                'Sch.plugin.exporter.SinglePage': {
                    name: 'Single page'
                },
                'Sch.plugin.exporter.MultiPageVertical': {
                    name: 'Multiple pages (vertically)'
                },
                'Sch.plugin.exporter.MultiPage': {
                    name: 'Multiple pages'
                },
                // -------------- View preset date formats/strings -------------------------------------
                'Sch.preset.Manager': {
                    hourAndDay: {
                        displayDateFormat: 'G:i',
                        middleDateFormat: 'G:i',
                        topDateFormat: 'D d/m'
                    },
                    secondAndMinute: {
                        displayDateFormat: 'g:i:s',
                        topDateFormat: 'D, d g:iA'
                    },
                    dayAndWeek: {
                        displayDateFormat: 'm/d h:i A',
                        middleDateFormat: 'D d M'
                    },
                    weekAndDay: {
                        displayDateFormat: 'm/d',
                        bottomDateFormat: 'd M',
                        middleDateFormat: 'Y F d'
                    },
                    weekAndMonth: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'm/d',
                        topDateFormat: 'm/d/Y'
                    },
                    weekAndDayLetter: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'D d M Y'
                    },
                    weekDateAndMonth: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'd',
                        topDateFormat: 'Y F'
                    },
                    monthAndYear: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'M Y',
                        topDateFormat: 'Y'
                    },
                    year: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'Y'
                    },
                    manyYears: {
                        displayDateFormat: 'm/d/Y',
                        middleDateFormat: 'Y'
                    }
                }
            }
        });
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.mixin.Localizable

A mixin providing localization functionality to the consuming class.

    Ext.define('My.Toolbar', {
        extend      : 'Ext.Toolbar',
        mixins      : [ 'Sch.mixin.Localizable' ],

        initComponent   : function () {
            Ext.apply(this, {
                items   : [
                    {
                        xtype       : 'button',

                        // get the button label from the current locale
                        text        : this.L('loginText')
                    }
                ]
            });

            this.callParent(arguments);
        }
    });

*/
Ext.define('Sch.mixin.Localizable', {
    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Sch.locale.En class
    //          requires            : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Sch.locale.En' ],
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires: [
        'Sch.locale.En'
    ],
    legacyMode: false,
    activeLocaleId: '',
    /**
     * @cfg {Object} l10n Container of locales for the class.
     */
    l10n: null,
    isLocaleApplied: function() {
        var activeLocaleId = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;
        if (!activeLocaleId)  {
            return false;
        }
        
        for (var ns in Sch.locale.Active) {
            if (activeLocaleId === Sch.locale.Active[ns].self.getName())  {
                return true;
            }
            
        }
        return false;
    },
    applyLocale: function() {
        // loop over activated locale classes and call apply() method of each one
        for (var ns in Sch.locale.Active) {
            Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
        }
    },
    /**
     * This is shorthand reference to {@link #localize}. Retrieves translation of a phrase.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    L: function() {
        return this.localize.apply(this, arguments);
    },
    /**
     * Retrieves translation of a phrase. There is a shorthand {@link #L} for this method.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    localize: function(id, legacyHolderProp, skipLocalizedCheck) {
        // if not localized yet let's do it
        if (!this.isLocaleApplied() && !skipLocalizedCheck) {
            this.applyLocale();
        }
        // `l10n` instance property has highest priority
        if (this.hasOwnProperty('l10n') && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id])  {
            return this.l10n[id];
        }
        
        var clsProto = this.self && this.self.prototype;
        // if there were old properties for localization on this class
        if (this.legacyMode) {
            // if they were kept under some property
            var prop = legacyHolderProp || this.legacyHolderProp;
            // check object instance first
            var instHolder = prop ? this[prop] : this;
            if (instHolder && instHolder.hasOwnProperty(id) && 'function' != typeof instHolder[id])  {
                return instHolder[id];
            }
            
            if (clsProto) {
                // then let's check class definition
                var clsHolder = prop ? clsProto[prop] : clsProto;
                if (clsHolder && clsHolder.hasOwnProperty(id) && 'function' != typeof clsHolder[id])  {
                    return clsHolder[id];
                }
                
            }
        }
        // let's try to get locale from class prototype `l10n` property
        var result = clsProto.l10n && clsProto.l10n[id];
        // if no transalation found
        if (result === null || result === undefined) {
            var superClass = clsProto && clsProto.superclass;
            // if parent class also has localize() method
            if (superClass && superClass.localize) {
                // try to get phrase translation from parent class
                result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
            }
            if (result === null || result === undefined)  {
                throw 'Cannot find locale: ' + id + ' [' + this.self.getName() + ']';
            }
            
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.locale.En', {
    extend: 'Sch.locale.Locale',
    requires: 'Sch.locale.En',
    singleton: true,
    l10n: {
        'Gnt.util.DurationParser': {
            unitsRegex: {
                MILLI: /^ms$|^mil/i,
                SECOND: /^s$|^sec/i,
                MINUTE: /^m$|^min/i,
                HOUR: /^h$|^hr$|^hour/i,
                DAY: /^d$|^day/i,
                WEEK: /^w$|^wk|^week/i,
                MONTH: /^mo|^mnt/i,
                QUARTER: /^q$|^quar|^qrt/i,
                YEAR: /^y$|^yr|^year/i
            }
        },
        'Gnt.util.DependencyParser': {
            typeText: {
                SS: 'SS',
                SF: 'SF',
                FS: 'FS',
                FF: 'FF'
            }
        },
        'Gnt.panel.Timeline': {
            start: 'Start',
            end: 'End',
            format: 'm/d/Y'
        },
        'Gnt.field.ShowInTimeline': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.column.ShowInTimeline': {
            text: 'Show in timeline'
        },
        'Gnt.field.ConstraintType': {
            none: 'None',
            invalidText: 'Invalid value'
        },
        'Gnt.field.Duration': {
            invalidText: 'Invalid value'
        },
        'Gnt.field.Effort': {
            invalidText: 'Invalid value'
        },
        'Gnt.field.Percent': {
            invalidText: 'Invalid value'
        },
        'Gnt.field.SchedulingMode': {
            Normal: 'Normal',
            FixedDuration: 'Fixed duration',
            EffortDriven: 'Effort driven',
            DynamicAssignment: 'Dynamic assignment',
            invalidText: 'Invalid value'
        },
        'Gnt.feature.DependencyDragDrop': {
            fromText: 'From',
            toText: 'To',
            startText: 'Start',
            endText: 'End'
        },
        'Gnt.template.Deadline': {
            deadline: 'Deadline'
        },
        'Gnt.column.DeadlineDate': {
            text: 'Deadline'
        },
        'Gnt.Tooltip': {
            startText: 'Starts: ',
            endText: 'Ends: ',
            durationText: 'Duration: '
        },
        'Gnt.template.TaskTooltip': {
            startText: 'Start',
            endText: 'End',
            percentText: 'Complete',
            format: 'm/d/Y'
        },
        'Gnt.plugin.TaskContextMenu': {
            taskInformation: 'Task information...',
            projectInformation: 'Project information...',
            newTaskText: 'New task',
            deleteTask: 'Delete task(s)',
            editLeftLabel: 'Edit left label',
            editRightLabel: 'Edit right label',
            add: 'Add...',
            deleteDependency: 'Delete dependency...',
            addTaskAbove: 'Task above',
            addTaskBelow: 'Task below',
            addMilestone: 'Milestone',
            addSubtask: 'Sub-task',
            addSuccessor: 'Successor',
            addPredecessor: 'Predecessor',
            convertToMilestone: 'Convert to milestone',
            convertToRegular: 'Convert to regular task',
            splitTask: 'Split task'
        },
        'Gnt.plugin.DependencyEditor': {
            fromText: 'From',
            toText: 'To',
            typeText: 'Type',
            lagText: 'Lag',
            endToStartText: 'Finish-To-Start',
            startToStartText: 'Start-To-Start',
            endToEndText: 'Finish-To-Finish',
            startToEndText: 'Start-To-Finish',
            okButtonText: 'Ok',
            cancelButtonText: 'Cancel',
            deleteButtonText: 'Delete'
        },
        'Gnt.widget.calendar.Calendar': {
            dayOverrideNameHeaderText: 'Name',
            overrideName: 'Name',
            startDate: 'Start Date',
            endDate: 'End Date',
            error: 'Error',
            dateText: 'Date',
            addText: 'Add',
            editText: 'Edit',
            removeText: 'Remove',
            workingDayText: 'Working day',
            weekendsText: 'Weekends',
            overriddenDayText: 'Overridden day',
            overriddenWeekText: 'Overridden week',
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time',
            dayOverridesText: 'Day overrides',
            weekOverridesText: 'Week overrides',
            okText: 'OK',
            cancelText: 'Cancel',
            parentCalendarText: 'Parent calendar',
            noParentText: 'No parent',
            selectParentText: 'Select parent',
            newDayName: '[Without name]',
            calendarNameText: 'Calendar name',
            isProjectCalendarText: 'Project calendar',
            tplTexts: {
                tplWorkingHours: 'Working hours for',
                tplIsNonWorking: 'is non-working',
                tplOverride: 'override',
                tplInCalendar: 'in calendar',
                tplDayInCalendar: 'standard day in calendar',
                tplBasedOn: 'Based on'
            },
            overrideErrorText: 'There is already an override for this day',
            overrideDateError: 'There is already a week override on this date: {0}',
            startAfterEndError: 'Start date should be less than end date',
            weeksIntersectError: 'Week overrides should not intersect'
        },
        'Gnt.widget.calendar.AvailabilityGrid': {
            startText: 'Start',
            endText: 'End',
            addText: 'Add',
            removeText: 'Remove',
            error: 'Error'
        },
        'Gnt.widget.calendar.DayEditor': {
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time'
        },
        'Gnt.widget.calendar.WeekEditor': {
            defaultTimeText: 'Default time',
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time',
            error: 'Error',
            noOverrideError: "Week override contains only 'default' days - can't save it"
        },
        'Gnt.widget.calendar.ResourceCalendarGrid': {
            name: 'Name',
            calendar: 'Calendar'
        },
        'Gnt.widget.calendar.CalendarWindow': {
            title: 'Calendar',
            ok: 'Ok',
            cancel: 'Cancel'
        },
        'Gnt.widget.calendar.CalendarManager': {
            addText: 'Add',
            removeText: 'Remove',
            add_child: 'Add child',
            add_node: 'Add calendar',
            add_sibling: 'Add sibling',
            remove: 'Remove',
            calendarName: 'Calendar',
            confirm_action: 'Confirm action',
            confirm_message: 'Calendar has unsaved changes. Would you like to save your changes?'
        },
        'Gnt.widget.calendar.CalendarManagerWindow': {
            title: 'Calendar manager',
            ok: 'Apply changes',
            cancel: 'Close',
            confirm_action: 'Confirm action',
            confirm_message: 'Calendar has unsaved changes. Would you like to save your changes?'
        },
        'Gnt.field.Assignment': {
            cancelText: 'Cancel',
            closeText: 'Save and Close'
        },
        'Gnt.column.AssignmentUnits': {
            text: 'Units'
        },
        'Gnt.column.Duration': {
            text: 'Duration'
        },
        'Gnt.column.Effort': {
            text: 'Effort'
        },
        'Gnt.column.EndDate': {
            text: 'Finish'
        },
        'Gnt.column.PercentDone': {
            text: '% Done'
        },
        'Gnt.column.ResourceAssignment': {
            text: 'Assigned Resources'
        },
        'Gnt.column.ResourceName': {
            text: 'Resource Name'
        },
        'Gnt.column.Rollup': {
            text: 'Rollup task',
            no: 'No',
            yes: 'Yes'
        },
        'Gnt.field.ManuallyScheduled': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.field.ReadOnly': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.column.ManuallyScheduled': {
            text: 'Manual mode'
        },
        'Gnt.column.SchedulingMode': {
            text: 'Mode'
        },
        'Gnt.column.Predecessor': {
            text: 'Predecessors'
        },
        'Gnt.column.Successor': {
            text: 'Successors'
        },
        'Gnt.column.StartDate': {
            text: 'Start'
        },
        'Gnt.column.WBS': {
            text: 'WBS'
        },
        'Gnt.column.Sequence': {
            text: '#'
        },
        'Gnt.column.Calendar': {
            text: 'Calendar'
        },
        'Gnt.column.ReadOnly': {
            text: 'Read Only'
        },
        'Gnt.widget.taskeditor.ProjectForm': {
            projectText: 'Project',
            nameText: 'Name',
            datesText: 'Dates',
            startText: 'Start',
            finishText: 'Finish',
            calendarText: 'Calendar',
            readOnlyText: 'Read Only',
            allowDependenciesText: 'Allow cross-project dependencies'
        },
        'Gnt.widget.taskeditor.TaskForm': {
            taskNameText: 'Name',
            durationText: 'Duration',
            datesText: 'Dates',
            baselineText: 'Baseline',
            startText: 'Start',
            finishText: 'Finish',
            percentDoneText: 'Percent Complete',
            baselineStartText: 'Start',
            baselineFinishText: 'Finish',
            baselinePercentDoneText: 'Percent Complete',
            effortText: 'Effort',
            invalidEffortText: 'Invalid effort value',
            calendarText: 'Calendar',
            manuallyScheduledText: 'Manually Scheduled',
            schedulingModeText: 'Scheduling Mode',
            rollupText: 'Rollup',
            wbsCodeText: 'WBS code',
            "Constraint Type": "Constraint Type",
            "Constraint Date": "Constraint Date",
            readOnlyText: 'Read Only'
        },
        'Gnt.widget.DependencyGrid': {
            idText: 'ID',
            snText: 'SN',
            taskText: 'Task Name',
            blankTaskText: 'Please select task',
            invalidDependencyText: 'Invalid dependency',
            parentChildDependencyText: 'Dependency between child and parent found',
            duplicatingDependencyText: 'Duplicate dependency found',
            transitiveDependencyText: 'Transitive dependency',
            cyclicDependencyText: 'Cyclic dependency',
            typeText: 'Type',
            lagText: 'Lag',
            clsText: 'CSS class',
            endToStartText: 'Finish-To-Start',
            startToStartText: 'Start-To-Start',
            endToEndText: 'Finish-To-Finish',
            startToEndText: 'Start-To-Finish',
            predecessorsText: 'Predecessors',
            successorsText: 'Successors'
        },
        'Gnt.widget.AssignmentEditGrid': {
            confirmAddResourceTitle: 'Confirm',
            confirmAddResourceText: 'Resource &quot;{0}&quot; not found in list. Would you like to add it?',
            noValueText: 'Please select resource to assign',
            noResourceText: 'No resource &quot;{0}&quot; found in the list'
        },
        'Gnt.widget.taskeditor.TaskEditor': {
            generalText: 'General',
            resourcesText: 'Resources',
            addDependencyText: 'Add new',
            dropDependencyText: 'Remove',
            notesText: 'Notes',
            advancedText: 'Advanced',
            addAssignmentText: 'Add new',
            dropAssignmentText: 'Remove'
        },
        'Gnt.widget.taskeditor.ProjectEditor': {
            generalText: 'General',
            descriptionText: 'Description'
        },
        'Gnt.plugin.taskeditor.BaseEditor': {
            title: 'Task Information',
            alertCaption: 'Information',
            alertText: 'Please correct marked errors to save changes',
            okText: 'Ok',
            cancelText: 'Cancel'
        },
        'Gnt.plugin.taskeditor.ProjectEditor': {
            title: 'Project Information'
        },
        'Gnt.field.EndDate': {
            endBeforeStartText: 'End date is before start date'
        },
        'Gnt.column.Note': {
            text: 'Note'
        },
        'Gnt.column.AddNew': {
            text: 'Add new column...'
        },
        'Gnt.column.EarlyStartDate': {
            text: 'Early Start'
        },
        'Gnt.column.EarlyEndDate': {
            text: 'Early Finish'
        },
        'Gnt.column.LateStartDate': {
            text: 'Late Start'
        },
        'Gnt.column.LateEndDate': {
            text: 'Late Finish'
        },
        'Gnt.field.Calendar': {
            calendarNotApplicable: 'Task calendar has no overlapping with assigned resources calendars',
            invalidText: 'Invalid value'
        },
        'Gnt.column.Slack': {
            text: 'Slack'
        },
        'Gnt.column.Name': {
            text: 'Task Name'
        },
        'Gnt.column.BaselineStartDate': {
            text: 'Baseline Start Date'
        },
        'Gnt.column.BaselineEndDate': {
            text: 'Baseline End Date'
        },
        'Gnt.column.Milestone': {
            text: 'Milestone'
        },
        'Gnt.field.Milestone': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.field.Dependency': {
            invalidFormatText: 'Invalid dependency format',
            invalidDependencyText: 'Invalid dependency found, please make sure you have no cyclic paths between your tasks',
            invalidDependencyType: 'Invalid dependency type {0}. Allowed values are: {1}.'
        },
        'Gnt.constraint.Base': {
            name: "A constraint",
            "Remove the constraint": "Remove the constraint",
            "Cancel the change and do nothing": "Cancel the change and do nothing"
        },
        'Gnt.constraint.FinishNoEarlierThan': {
            name: "Finish no earlier than",
            // {0} constraint date
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.FinishNoLaterThan": {
            name: "Finish no later than",
            // {0} constraint date
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.MustFinishOn": {
            name: "Must finish on",
            // {0} constraint date
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.MustStartOn": {
            name: "Must start on",
            // {0} constraint date
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.constraint.StartNoEarlierThan": {
            name: "Start no earlier than",
            // {0} constraint date
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.constraint.StartNoLaterThan": {
            name: "Start no later than",
            // {0} constraint date
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.column.ConstraintDate": {
            text: "Constraint date"
        },
        "Gnt.column.ConstraintType": {
            text: "Constraint"
        },
        "Gnt.widget.ConstraintResolutionForm": {
            dateFormat: "m/d/Y",
            "OK": 'OK',
            "Cancel": 'Cancel',
            "Resolution options": "Resolution options",
            "Don't ask again": "Don't ask again",
            // {0} task name, {1} constraint name
            "Task {0} violates constraint {1}": "Task \"{0}\" violates constraint {1}",
            // {0} task name, {1} constraint name, {2} constraint date
            "Task {0} violates constraint {1} {2}": "Task \"{0}\" violates constraint {1} {2}"
        },
        "Gnt.widget.ConstraintResolutionWindow": {
            "Constraint violation": "Constraint violation"
        },
        "Gnt.panel.ResourceHistogram": {
            resourceText: 'Resource'
        }
    },
    apply: function(classNames) {
        // apply corresponding scheduler locale first
        Sch.locale.En.apply(classNames);
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.mixin.Localizable

A mixin providing localization functionality to the consuming class.
*/
Ext.define('Gnt.mixin.Localizable', {
    extend: 'Sch.mixin.Localizable',
    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Gnt.locale.En class
    //      requires    : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Gnt.locale.En' ]
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires: [
        'Gnt.locale.En'
    ]
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
@class Gnt.Tooltip
@extends Ext.ToolTip
@private

Internal tooltip class showing task start/end/duration information for a single task.
*/
Ext.define("Gnt.Tooltip", {
    extend: 'Ext.tip.ToolTip',
    alias: 'widget.gantt_task_tooltip',
    requires: [
        'Ext.Template'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText       : 'Starts: ',
            - endText         : 'Ends: ',
            - durationText    : 'Duration:'
     */
    /*
     * @cfg {String} mode Either "startend" - showing start date and end date, or "duration" to show start date and duration
     */
    mode: 'startend',
    anchor: 'bottom',
    autoHide: false,
    maskOnDisable: false,
    taskElAlign: 'bl-tl?',
    /*
     * @cfg {Ext.Template} template An HTML snippet used for the tooltip display.
     * In "startend" mode, it will receive a data object containing "startText", "endText" and "task" (the entire task) properties.
     * In "duration" mode, it will receive a data object containing "startText", "duration", "unit" and "task" (the entire task) properties.
     */
    template: null,
    gantt: null,
    initComponent: function() {
        this.rtl = this.gantt.rtl;
        this.startLabel = this.L('startText');
        this.label2Text = this.mode === 'duration' ? this.L('durationText') : this.L('endText');
        if (!this.template) {
            this.template = new Ext.Template('<div class="sch-timetipwrap {cls}">' + '<table cellpadding="0" cellspacing="0">' + '<tpl if="value1"><tr><td class="sch-gantt-tip-desc">{label1}</td><td class="sch-gantt-tip-value">{value1}</td></tr></tpl>' + '<tr><td class="sch-gantt-tip-desc">{label2}</td><td class="sch-gantt-tip-value">{value2}</td></tr>' + '</table>' + '</div>').compile();
        }
        this.callParent(arguments);
        this.update(this.template.apply({
            value1: '',
            value2: ''
        }));
        this.addCls('gnt-tooltip');
    },
    updateContent: function(start, end, valid, taskRecord) {
        var content;
        if (this.mode === 'duration') {
            content = this.getDurationContent(start, end, valid, taskRecord);
        } else {
            content = this.getStartEndContent(start, end, valid, taskRecord);
        }
        this.update(content);
    },
    // private
    getStartEndContent: function(start, end, valid, taskRecord) {
        var gantt = this.gantt,
            startText = start && gantt.getFormattedDate(start),
            endText;
        if (start) {
            if (end - start > 0) {
                endText = gantt.getFormattedEndDate(end, start);
            } else {
                endText = startText;
            }
        } else {
            // Single point in time
            endText = gantt.getFormattedEndDate(end);
        }
        var retVal = {
                cls: valid ? 'sch-tip-ok' : 'sch-tip-notok',
                label2: this.label2Text,
                value2: endText,
                task: taskRecord
            };
        if (start) {
            retVal.label1 = this.startLabel;
            retVal.value1 = start && gantt.getFormattedDate(start);
        }
        return this.template.apply(retVal);
    },
    getDurationContent: function(start, end, valid, taskRecord) {
        var unit = taskRecord.getDurationUnit() || Sch.util.Date.DAY;
        var duration = taskRecord.calculateDuration(start, end, unit);
        return this.template.apply({
            cls: valid ? 'sch-tip-ok' : 'sch-tip-notok',
            label1: this.startLabel,
            value1: this.gantt.getFormattedDate(start),
            label2: this.label2Text,
            value2: parseFloat(Ext.Number.toFixed(duration, 1)) + ' ' + Sch.util.Date.getReadableNameOfUnit(unit, duration > 1),
            task: taskRecord
        });
    },
    showBy: function(el, xPos) {
        this.setTarget(el);
        this.callParent([
            el,
            this.taskElAlign,
            [
                -18,
                -6
            ]
        ]);
        if (typeof xPos === 'number') {
            this.setX(xPos - 18);
        }
    }
});
// offset to account for arrow offset from tip element left side

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.column.AddNew
@extends Ext.grid.column.Column

A column allowing the user to add a new column to the Gantt chart. To include your own custom columns in this list,
just create an alias for them starting with 'widget.ganttcolumn.XXX'. Example:

    Ext.define('Your.column.DeadlineDate', {
        extend              : 'Ext.grid.column.Date',

        alias               : [
            'widget.ganttcolumn.mydeadlinedate'
        ],

        ...
    });

*/
Ext.define("Gnt.column.AddNew", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.addnewcolumn",
        "widget.ganttcolumn.addnew"
    ],
    requires: [
        'Ext.form.field.ComboBox',
        'Ext.Editor'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text  : 'Add new column...'
     */
    text: '',
    width: 100,
    resizable: false,
    menuDisabled: true,
    sortable: false,
    draggable: false,
    colEditor: null,
    colEditorStore: null,
    layout: 'fit',
    ignoreInAddMenu: true,
    ignoreInExport: true,
    // Sencha flag for copy/paste operations
    ignoreExport: true,
    /**
     * @cfg {Array} [columnList] An array of column definition objects. It should be a list containing data as seen below
     *
     *      [
     *          { clsName : 'Gnt.column.StartDate', text : 'Start Date', config : {...} },
     *          { clsName : 'Gnt.column.Duration', text : 'Duration', config : {...} },
     *          ...
     *      ]
     *
     * If not provided, a list containing all the columns from the `Gnt.column.*` namespace will be created.
     * This default list can also be retrieved by {@link #buildDefaultColumnList} static method:
     *
     *     // get default column list
     *     var columns  = Gnt.column.AddNew.buildDefaultColumnList();
     *
     *     // find Gnt.column.StartDate column entry
     *     var column   = Ext.Array.findBy(columns, function (c) { return c.clsName == 'Gnt.column.StartDate'; });
     *
     *     // set custom date format to Gnt.column.StartDate
     *     column.config    = { format : 'Y' };
     *     column.text      = 'Start year';
     *
     *     Ext.create('Gnt.panel.Gantt', {
     *         ...
     *         columns  : [
     *             ...
     *             {
     *                 xtype        : 'addnewcolumn',
     *                 // provide customized list
     *                 columnList   : columns
     *             }
     *         ]
     *     });
     *
     */
    columnList: null,
    initComponent: function() {
        this.addCls('gnt-addnewcolumn');
        this.items = this.getColEditor();
        this.text = this.text || this.L('text');
        this.callParent(arguments);
    },
    getGantt: function() {
        if (!this.gantt) {
            this.gantt = this.up('ganttpanel');
        }
        return this.gantt;
    },
    /**
     * @protected
     */
    getColEditor: function() {
        var me = this,
            editor;
        if (!me.colEditor) {
            editor = me.colEditor = new Ext.form.field.ComboBox({
                itemId: 'addNewEditor',
                displayField: 'text',
                valueField: 'clsName',
                hideTrigger: true,
                queryMode: 'local',
                multiSelect: false,
                value: this.L('text'),
                listConfig: {
                    itemId: 'addNewEditorComboList',
                    minWidth: 150
                },
                store: me.getColEditorStore(),
                pickerAlign: 'tl-bl',
                // never risk that the editor appears above the column
                listeners: {
                    focus: me.onInputFocus,
                    blur: me.onFieldBlur,
                    select: me.onSelect,
                    scope: me
                }
            });
            if (Ext.isIE8m) {
                // Make IE8 play nice and have text vertically centered
                editor.on('resize', function(field, width, height, oldWidth, oldHeight) {
                    field.inputEl.setStyle('line-height', +height + 'px');
                    // Force repaint of element
                    field.setValue(field.getValue() + ' ');
                });
            }
        }
        return me.colEditor;
    },
    onFieldBlur: function(field, e) {
        var picker = field.getPicker();
        var pickerNode = picker.el && picker.el.dom;
        // Clicks on scrollbar in the picker should not trigger anything
        if (!e.relatedTarget || e.relatedTarget !== pickerNode) {
            this.resetField();
        }
    },
    resetField: function() {
        this.getColEditor().setValue(this.L('text'));
        this.getColEditor().collapse();
    },
    /**
     * @protected
     */
    getColEditorStore: function() {
        var me = this;
        if (!me.colEditorStore) {
            me.columnList = me.columnList || Gnt.column.AddNew.buildDefaultColumnList();
            me.colEditorStore = new Ext.data.Store({
                fields: [
                    'text',
                    'clsName',
                    'config'
                ],
                data: me.columnList,
                sorters: [
                    {
                        property: 'text',
                        direction: 'ASC'
                    }
                ]
            });
        }
        return me.colEditorStore;
    },
    /**
     * @private
     */
    onInputFocus: function(field) {
        field.setValue();
        field.expand();
    },
    /**
     * @private
     */
    onSelect: function(combo, records) {
        this.resetField();
        this.getColEditor().blur();
        this.addColumn(Ext.isArray(records) ? records[0] : records);
    },
    /**
     * @protected
     */
    addColumn: function(record) {
        var me = this;
        var rec = record;
        var owner = me.up('headercontainer');
        // HACK
        var text = rec.get('text');
        var config = Ext.apply({}, rec.get('config'));
        var clsName = rec.get('clsName') || config.xclass || 'Ext.grid.column.Column';
        Ext.require(clsName, function() {
            var cls = Ext.ClassManager.get(clsName);
            config.xclass = clsName;
            config.text = text;
            var col = Ext.create(config);
            owner.insert(owner.items.indexOf(me), col);
        });
    },
    destroy: function() {
        this.colEditorStore && this.colEditorStore.destroy();
        this.callParent(arguments);
    },
    statics: {
        /**
         * Builds the default column list to show in the combo box picker. The list will contain all columns matching the "widget.ganttcolumn.XXX" alias.
         *
         * @return {Object[]} Returns array of objects having following properties:
         * @return {String} return.clsName  Column class name
         * @return {String} return.text     Column label
         * @return {String} return.config   (optional) Column instance configuration
         */
        buildDefaultColumnList: function() {
            var list = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression('widget.ganttcolumn.*'), function(name) {
                var cls = Ext.ClassManager.get(name);
                if (cls && !cls.prototype.ignoreInAddMenu) {
                    list.push({
                        clsName: name,
                        text: cls.prototype.localize ? cls.prototype.localize('text') : cls.prototype.text
                    });
                }
            });
            return list.sort(function(a, b) {
                return a.text > b.text ? 1 : -1;
            });
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

A specialized field to enter percent values.
This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number` configs can be used.

@class Gnt.field.Percent
@extends Ext.form.field.Number

*/
Ext.define('Gnt.field.Percent', {
    extend: 'Ext.form.field.Number',
    alias: 'widget.percentfield',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: 'Gnt.widget.PercentField',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - invalidText : 'Invalid value'
     */
    disableKeyFilter: false,
    minValue: 0,
    maxValue: 100,
    allowExponential: false,
    baseChars: '0123456789%',
    constructor: function() {
        this.callParent(arguments);
        this.invalidText = this.L('invalidText');
    },
    valueToRaw: function(value) {
        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + '%';
        }
        return '';
    },
    getErrors: function(value) {
        var percent = this.parseValue(value);
        if (percent === null) {
            if (value !== null && value !== '') {
                return [
                    this.invalidText
                ];
            } else {
                percent = '';
            }
        }
        return this.callParent([
            percent
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Gnt.column.AssignmentUnits
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define("Gnt.column.AssignmentUnits", {
    extend: "Ext.grid.column.Number",
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    requires: [
        "Gnt.field.Percent"
    ],
    alias: "widget.assignmentunitscolumn",
    dataIndex: 'Units',
    format: '0 %',
    align: 'left',
    editor: {
        xtype: 'percentfield',
        minValue: 0,
        maxValue: undefined,
        step: 10,
        // https://www.sencha.com/forum/showthread.php?305411-Tabbing-in-grid-picker-stops-editing
        // IE10/9 cannot handle this correctly and will stop editing
        selectOnFocus: Ext.isIE ? false : true
    },
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.scope = this;
        this.callParent(arguments);
    },
    // HACK, without 3 arguments the grid doesn't behave sanely
    renderer: function(value, meta, record) {
        if (value)  {
            return Ext.util.Format.number(value, this.format);
        }
        
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.mixin.TaskField

A mixin with common functionality for all fields used to edit {@link Gnt.model.Task} information.

*/
Ext.define('Gnt.field.mixin.TaskField', {
    extend: 'Ext.Mixin',
    taskField: '',
    fieldProperty: '',
    getTaskValueMethod: '',
    setTaskValueMethod: '',
    isTaskField: true,
    /**
     * @cfg {Gnt.model.Task} task Task being edited. Field will apply all it's value changes directly to this task (if {@link #instantUpdate} is `true`).
     */
    task: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore Task store should provided if task being edited is not in any task store yet and thus does not have a calendar.
     * In such case we'll retrieve a calendar from the task store (project calendar).
     */
    taskStore: null,
    /**
     * @cfg {Number} suppressTaskUpdate A number flag, when greater than 0 prevents task updates.
     */
    suppressTaskUpdate: 0,
    /**
     * @cfg {Boolean} highlightTaskUpdates When set to `true`, field will highlight itself when its value is changed due to changes in some other field.
     * For example when changing the end date of the task, its duration will change as well and will highlight itself.
     */
    highlightTaskUpdates: true,
    /**
     * @cfg {String} highlightColor A color to use when highlighting the field. See {@link #highlightTaskUpdates} option.
     */
    highlightColor: '#009900',
    lastHighlight: 0,
    /**
     * @cfg {Boolean} instantUpdate Set to `false` to prevent automatic applying changes to task on each {@link #setValue} call.
     * To apply changes manually one can use {@link #applyChanges} method.
     */
    instantUpdate: true,
    originalInstantUpdate: null,
    readOnlyUpdateSuspended: 0,
    mixinConfig: {
        before: {
            constructor: 'beforeConstructed',
            destroy: 'beforeDestroyed'
        },
        after: {
            constructor: 'afterConstructed'
        }
    },
    beforeConstructed: function() {
        this.setSuppressTaskUpdate(true);
    },
    afterConstructed: function() {
        this.taskField = this.taskField || this.fieldProperty;
        this.task && this.setTask(this.task);
        this.setSuppressTaskUpdate(false);
    },
    setInstantUpdate: function(value) {
        this.instantUpdate = value;
    },
    beforeDestroyed: function() {
        this.destroyTaskListener();
    },
    /**
     * Binds task to the field.
     * @param {Gnt.model.Task} task Task to bind.
     */
    setTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.destroyTaskListener();
        this.updateReadOnly(task);
        this.task = task;
        task.on('taskupdated', this.onTaskUpdateProcess, this);
        // we need calendar to be assigned to task or task should be part of taskStore with
        // assigned calendar, if we dont`t have it lets imitate it by binding task to provided taskStore
        if (!task.getCalendar(true) && !task.getTaskStore(true)) {
            task.taskStore = task.getTaskStore(true) || this.taskStore;
            if (!task.taskStore)  {
                throw 'Configuration issue: Gnt.data.taskStore instance should be provided.';
            }
            
            if (!task.getCalendar(true) && !task.taskStore.getCalendar())  {
                throw 'Configuration issue: Gnt.data.Calendar instance should be provided.';
            }
            
        }
        this.setSuppressTaskUpdate(true);
        this.onSetTask(task);
        this.setSuppressTaskUpdate(false);
    },
    onSetTask: function(task) {
        task = task || this.task;
        this.setValue(this.getTaskValue(task));
    },
    setSuppressTaskUpdate: function(inc) {
        inc ? this.suppressTaskUpdate++ : this.suppressTaskUpdate--;
    },
    getSuppressTaskUpdate: function() {
        return this.suppressTaskUpdate;
    },
    isReadOnlyUpdateSuspended: function() {
        return this.readOnlyUpdateSuspended;
    },
    suspendReadOnlyUpdate: function() {
        this.readOnlyUpdateSuspended++;
    },
    resumeReadOnlyUpdate: function() {
        if (this.isReadOnlyUpdateSuspended())  {
            this.readOnlyUpdateSuspended--;
        }
        
        return this.readOnlyUpdateSuspended;
    },
    updateReadOnly: function(task) {
        if (!this.disabled && !this.forceReadOnly && !this.isReadOnlyUpdateSuspended()) {
            if (this.editable === false) {
                // let's take into account Task.isEditable() result
                if (!task.isEditable(task[this.taskField])) {
                    this.setReadOnly(true);
                }
                // when editable is false `readOnly` should be set to `true`
                else if (this.inputEl) {
                    this.setReadOnly(false);
                    this.inputEl.dom.readOnly = true;
                }
            } else {
                // let's take into account Task.isEditable() result
                this.setReadOnly(!task.isEditable(task[this.taskField]));
            }
        }
    },
    onTaskUpdateProcess: function(task, initiator) {
        if (initiator !== this) {
            var prev = this.getValue();
            // update field editability
            this.updateReadOnly(task);
            this.setSuppressTaskUpdate(true);
            if (this.onTaskUpdate) {
                this.onTaskUpdate(task, initiator);
            } else {
                this.onSetTask(task);
            }
            this.setSuppressTaskUpdate(false);
            if (this.highlightTaskUpdates) {
                var curr = this.getValue(),
                    isDate = Ext.isDate(prev);
                if (isDate && (prev - curr !== 0) || (!isDate && String(prev) !== String(curr))) {
                    this.highlightField();
                }
            }
        }
    },
    highlightField: function(color, options) {
        if (this.rendered && (new Date() - this.lastHighlight > 1000)) {
            this.lastHighlight = new Date();
            this.inputEl.highlight(color || this.highlightColor, options || {
                attr: 'color'
            });
        }
    },
    destroyTaskListener: function() {
        if (this.task) {
            this.task.un('taskupdated', this.onTaskUpdateProcess, this);
        }
    },
    callTaskMethod: function(task, method, args) {
        task = task || this.task;
        return task && task[method].apply(task, args);
    },
    getTaskValue: function(task) {
        return this.callTaskMethod(task, this.getTaskValueMethod, Ext.Array.slice(arguments, 1));
    },
    setTaskValue: function(task) {
        // TODO: HACK: If the task being modified is already in the middle of propagation we cannot start a new propagation process
        // and this happens in ext6 where we have issues w/ uncontrollable "blur" events.
        // (Note: and we assume that "setTaskValueMethod" invokes a propagation (it is true for all our out-of-the-box fields))
        // The issue is covered by columns/1030_duration.t.js test (and seems fixed in ext > 6.0.1)
        if (task.propagating)  {
            return;
        }
        
        return this.callTaskMethod(task, this.setTaskValueMethod, Ext.Array.slice(arguments, 1));
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue());
        toTask.fireEvent('taskupdated', toTask, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.field.Date
 @extends Ext.form.field.Date

 A specialized base class used for task fields of `Date` type. This class inherits from the `Ext.form.field.Date` field so any of its configuration options can be used.

 */
Ext.define('Gnt.field.Date', {
    extend: 'Ext.form.field.Date',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the raw unmodified date.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: false,
    reAssertValue: true,
    /**
     * @cfg {Boolean} keepTime Pass `true` to keep the timepart of the passed date value.
     * Works only if the field format does not contain hours info (so a user is not able to edit time part of the field value).
     */
    keepTime: true,
    // @OVERRIDE
    onExpand: function() {
        var value = this.valueToVisible(this.getValue());
        this._expanding = false;
        if (!this.isValid()) {
            value = this.getRawValue();
            if (value) {
                value = Ext.Date.parse(value, this.format);
            }
        }
        this.picker.setValue(Ext.isDate(value) ? value : new Date());
    },
    applyKeptTimeToValue: function(value) {
        if (this.keepTime && !Ext.Date.formatContainsHourInfo(this.format)) {
            this.applyTimeToValue(value, this.getTaskValue());
        }
        return value;
    },
    applyTimeToValue: function(value, time) {
        time = time || this.getTaskValue();
        if (Ext.isDate(value) && time) {
            value.setHours(time.getHours());
            value.setMinutes(time.getMinutes());
        }
        return value;
    },
    // @OVERRIDE
    onSelect: function(picker, pickerDate) {
        var me = this;
        // if we display the date with hours, then we (probably) want to keep the task end date's hour/minutes
        // after selecting the date from the picker. In the same time picker will clear the time portion
        // so we need to restore it from original date
        // see also: http://www.bryntum.com/forum/viewtopic.php?f=9&t=4294
        if (this.keepTime || Ext.Date.formatContainsHourInfo(this.format)) {
            me.applyTimeToValue(pickerDate, this.getTaskValue());
        }
        var oldValue = me.getValue();
        var newValue = this.visibleToValue(pickerDate);
        var rawValue = Ext.Date.format(pickerDate, this.format);
        if (oldValue != newValue) {
            if (this.getErrors(rawValue).length > 0) {
                me.setRawValue(rawValue);
                me.collapse();
                me.validate();
            } else {
                me.setValue(newValue, true);
                me.fireEvent('select', me, newValue);
                // onSelect method of datefield is changed in 6.0.1
                // 1025_enddate_cancel
                if (Ext.getVersion().isGreaterThan('6.0.1')) {
                    me.onTabOut(picker);
                } else {
                    me.inputEl.focus();
                    me.collapse();
                }
            }
        }
    },
    // @OVERRIDE
    /**
     * Sets the value of the field.
     *
     * **Note**, that this method accept the actual date value, as it is stored in the data model.
     * The displayed value can be different, when editing milestones.
     *
     * @param {Date} value New value of the field.
     */
    setValue: function(value, forceUpdate) {
        // Field looses focus when picker is expanded. We need to prevent setValue calls in case
        // they are originated from expanding picker.
        if (this._expanding)  {
            return;
        }
        
        this.callParent([
            value
        ]);
        var task = this.task;
        if (!this.readOnly && (forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && task && task.taskStore && value) {
            // apply changes to task
            this.applyChanges();
            // potentially value can be changed during set model call
            // so let`s check it after call and set final value again
            if (this.reAssertValue) {
                var taskValue = this.getTaskValue();
                if (taskValue - this.getValue() !== 0) {
                    this.callParent([
                        taskValue
                    ]);
                }
            }
            task.fireEvent('taskupdated', task, this);
        }
    },
    // @OVERRIDE
    rawToValue: function(rawValue) {
        if (!rawValue)  {
            return null;
        }
        
        var parsedDate = this.applyKeptTimeToValue(this.parseDate(rawValue));
        return this.visibleToValue(parsedDate) || rawValue || null;
    },
    // @OVERRIDE
    valueToRaw: function(value) {
        if (!value)  {
            return value;
        }
        
        return Ext.Date.format(this.valueToVisible(value), this.format);
    },
    /**
     * Returns the value of the field.
     *
     * **Note**, that this method returns the actual end date value, as it is stored in the data model.
     * The displayed value can be different, when date does not contain time information or when editing milestones.
     *
     * @return {Date}
     */
    getValue: function() {
        return Ext.isEmpty(this.value) ? null : this.value;
    },
    visibleToValue: function() {
        throw 'Abstract visibleToValue method called';
    },
    valueToVisible: function() {
        throw 'Abstract valueToVisible method called';
    },
    /*
     * We overrode 'getValue' method and broke default 'checkChange' method.
     * This fix is required for validation on-the-fly (as user type).
     * https://www.assembla.com/spaces/bryntum/tickets/1361
     */
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var me = this,
                // we use raw value since 'getValue' method doesn't fire this goal after override
                newVal = me.rawToValue((me.inputEl ? me.inputEl.getValue() : Ext.valueFrom(me.rawValue, ''))),
                oldVal = me.lastValue;
            if (!me.isEqual(newVal, oldVal) && !me.isDestroyed) {
                me.lastValue = newVal;
                me.fireEvent('change', me, newVal, oldVal);
                me.onChange(newVal, oldVal);
            }
        }
    },
    // @private
    // it's called in editor.completeEdit()
    assertValue: function() {
        var me = this,
            oldRaw = me.rawValue,
            newRaw = me.getRawValue(),
            oldValue = me.getValue(),
            newValue = me.rawToValue(newRaw),
            //this can be wrong value should be set
            focusTask = me.focusTask;
        if (focusTask) {
            focusTask.cancel();
        }
        // AND changed to OR because raw values check always return false and values check seem to be enough
        if ((oldRaw != newRaw) || (newValue - oldValue !== 0)) {
            // set value only if field is valid
            if (!me.validateOnBlur || me.isValid()) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newValue, true);
            }
        }
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        var taskStore = toTask.getTaskStore(true) || this.taskStore;
        if (this.value) {
            this.setTaskValue(toTask, this.value, this.keepDuration, taskStore.skipWeekendsDuringDragDrop);
        } else {
            this.setTaskValue(toTask, null);
        }
    },
    expand: function() {
        this._expanding = true;
        this.callParent(arguments);
    },
    // @OVERRIDE
    beforeBlur: function() {
        this.assertValue();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.util.Date
 * @static
 * Static utility class for Date manipulation
 */
Ext.define('Sch.util.Date', {
    requires: 'Ext.Date',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    singleton: true,
    // These stem from Ext.Date in Ext JS but since they don't exist in Sencha Touch we'll need to keep them here
    stripEscapeRe: /(\\.)/g,
    hourInfoRe: /([gGhHisucUOPZ]|MS)/,
    unitHash: null,
    unitsByName: {},
    // Override this to localize the time unit names.
    //unitNames   : {
    //YEAR    : { single : 'year', plural : 'years', abbrev : 'yr' },
    //QUARTER : { single : 'quarter', plural : 'quarters', abbrev : 'q' },
    //MONTH   : { single : 'month', plural : 'months', abbrev : 'mon' },
    //WEEK    : { single : 'week', plural : 'weeks', abbrev : 'w' },
    //DAY     : { single : 'day', plural : 'days', abbrev : 'd' },
    //HOUR    : { single : 'hour', plural : 'hours', abbrev : 'h' },
    //MINUTE  : { single : 'minute', plural : 'minutes', abbrev : 'min' },
    //SECOND  : { single : 'second', plural : 'seconds', abbrev : 's' },
    //MILLI   : { single : 'ms', plural : 'ms', abbrev : 'ms' }
    //},
    constructor: function() {
        var ED = Ext.Date;
        var unitHash = this.unitHash = {
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MILLI: ED.MILLI,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                SECOND: ED.SECOND,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MINUTE: ED.MINUTE,
                /** Date interval constant
             * @static
             * @type String
             */
                HOUR: ED.HOUR,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                DAY: ED.DAY,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                WEEK: "w",
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MONTH: ED.MONTH,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                QUARTER: "q",
                /**
             * Date interval constant
             * @static
             * @type String
             */
                YEAR: ED.YEAR
            };
        Ext.apply(this, unitHash);
        var me = this;
        this.units = [
            me.MILLI,
            me.SECOND,
            me.MINUTE,
            me.HOUR,
            me.DAY,
            me.WEEK,
            me.MONTH,
            me.QUARTER,
            me.YEAR
        ];
    },
    onLocalized: function() {
        this.setUnitNames(this.L('unitNames'));
    },
    /**
     * Call this method to provide your own, localized values for duration unit names. See the "/js/Sch/locale/sch-lang-*.js" files for examples
     *
     * @param {Object} unitNames
     */
    setUnitNames: function(unitNames) {
        var unitsByName = this.unitsByName = {};
        this.l10n.unitNames = unitNames;
        this._unitNames = Ext.apply({}, unitNames);
        var unitHash = this.unitHash;
        // Make it possible to lookup readable date names from both 'DAY' and 'd' etc.
        for (var name in unitHash) {
            if (unitHash.hasOwnProperty(name)) {
                var unitValue = unitHash[name];
                this._unitNames[unitValue] = this._unitNames[name];
                unitsByName[name] = unitValue;
                unitsByName[unitValue] = unitValue;
            }
        }
    },
    /**
     * Checks if this date is >= start and < end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @static
     */
    betweenLesser: function(date, start, end) {
        return start <= date && date < end;
    },
    /**
     * Constrains the date within a min and a max date
     * @param {Date} date The date to constrain
     * @param {Date} min Min date
     * @param {Date} max Max date
     * @return {Date} The constrained date
     * @static
     */
    constrain: function(date, min, max) {
        return this.min(this.max(date, min), max);
    },
    /**
     * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    compareUnits: function(u1, u2) {
        var ind1 = Ext.Array.indexOf(this.units, u1),
            ind2 = Ext.Array.indexOf(this.units, u2);
        return ind1 > ind2 ? 1 : (ind1 < ind2 ? -1 : 0);
    },
    /**
     * Returns true if first unit passed is strictly greater than the second.
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    isUnitGreater: function(u1, u2) {
        return this.compareUnits(u1, u2) > 0;
    },
    /**
     * Copies hours, minutes, seconds, milliseconds from one date to another
     * @static
     *
     * @param {String} targetDate The target date
     * @param {String} sourceDate The source date
     */
    copyTimeValues: function(targetDate, sourceDate) {
        targetDate.setHours(sourceDate.getHours());
        targetDate.setMinutes(sourceDate.getMinutes());
        targetDate.setSeconds(sourceDate.getSeconds());
        targetDate.setMilliseconds(sourceDate.getMilliseconds());
    },
    /**
     * Adds a date unit and interval
     * @param {Date} date The source date
     * @param {String} unit The date unit to add
     * @param {Number} value The number of units to add to the date
     * @return {Date} The new date
     * @static
     */
    add: function(date, unit, value) {
        var d = Ext.Date.clone(date);
        if (!unit || value === 0)  {
            return d;
        }
        
        switch (unit.toLowerCase()) {
            case this.MILLI:
                d = new Date(date.getTime() + value);
                break;
            case this.SECOND:
                d = new Date(date.getTime() + (value * 1000));
                break;
            case this.MINUTE:
                d = new Date(date.getTime() + (value * 60000));
                break;
            case this.HOUR:
                d = new Date(date.getTime() + (value * 3600000));
                break;
            case this.DAY:
                d.setDate(date.getDate() + value);
                if (d.getHours() === 23 && date.getHours() === 0) {
                    d = Ext.Date.add(d, Ext.Date.HOUR, 1);
                };
                break;
            case this.WEEK:
                d.setDate(date.getDate() + value * 7);
                break;
            case this.MONTH:
                var day = date.getDate();
                if (day > 28) {
                    day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
                };
                d.setDate(day);
                d.setMonth(d.getMonth() + value);
                break;
            case this.QUARTER:
                d = this.add(date, this.MONTH, value * 3);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + value);
                break;
        }
        return d;
    },
    getUnitDurationInMs: function(unit) {
        // hopefully there were no DST changes in year 1
        return this.add(new Date(1, 0, 1), unit, 1) - new Date(1, 0, 1);
    },
    getMeasuringUnit: function(unit) {
        if (unit === this.WEEK) {
            return this.DAY;
        }
        return unit;
    },
    /**
     * Returns a duration of the timeframe in the given unit.
     * @static
     * @param {Date} start The start date of the timeframe
     * @param {Date} end The end date of the timeframe
     * @param {String} unit Duration unit
     * @return {Number} The duration in the units
     */
    getDurationInUnit: function(start, end, unit, doNotRound) {
        var units;
        switch (unit) {
            case this.YEAR:
                units = this.getDurationInYears(start, end);
                break;
            case this.QUARTER:
                units = this.getDurationInMonths(start, end) / 3;
                break;
            case this.MONTH:
                units = this.getDurationInMonths(start, end);
                break;
            case this.WEEK:
                units = this.getDurationInDays(start, end) / 7;
                break;
            case this.DAY:
                units = this.getDurationInDays(start, end);
                break;
            case this.HOUR:
                units = this.getDurationInHours(start, end);
                break;
            case this.MINUTE:
                units = this.getDurationInMinutes(start, end);
                break;
            case this.SECOND:
                units = this.getDurationInSeconds(start, end);
                break;
            case this.MILLI:
                units = this.getDurationInMilliseconds(start, end);
                break;
        }
        return doNotRound ? units : Math.round(units);
    },
    getUnitToBaseUnitRatio: function(baseUnit, unit) {
        if (baseUnit === unit) {
            return 1;
        }
        switch (baseUnit) {
            case this.YEAR:
                switch (unit) {
                    case this.QUARTER:
                        return 1 / 4;
                    case this.MONTH:
                        return 1 / 12;
                };
                break;
            case this.QUARTER:
                switch (unit) {
                    case this.YEAR:
                        return 4;
                    case this.MONTH:
                        return 1 / 3;
                };
                break;
            case this.MONTH:
                switch (unit) {
                    case this.YEAR:
                        return 12;
                    case this.QUARTER:
                        return 3;
                };
                break;
            case this.WEEK:
                switch (unit) {
                    case this.DAY:
                        return 1 / 7;
                    case this.HOUR:
                        return 1 / 168;
                };
                break;
            case this.DAY:
                switch (unit) {
                    case this.WEEK:
                        return 7;
                    case this.HOUR:
                        return 1 / 24;
                    case this.MINUTE:
                        return 1 / 1440;
                };
                break;
            case this.HOUR:
                switch (unit) {
                    case this.DAY:
                        return 24;
                    case this.MINUTE:
                        return 1 / 60;
                };
                break;
            case this.MINUTE:
                switch (unit) {
                    case this.HOUR:
                        return 60;
                    case this.SECOND:
                        return 1 / 60;
                    case this.MILLI:
                        return 1 / 60000;
                };
                break;
            case this.SECOND:
                switch (unit) {
                    case this.MILLI:
                        return 1 / 1000;
                };
                break;
            case this.MILLI:
                switch (unit) {
                    case this.SECOND:
                        return 1000;
                };
                break;
        }
        return -1;
    },
    // Returns true if a unit can be expressed as a whole number of subunits
    isUnitDivisibleIntoSubunit: function(unit, subunit) {
        var indivisible = unit === this.MONTH && subunit === this.WEEK;
        return !indivisible;
    },
    /**
     * Returns the number of milliseconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMilliseconds: function(start, end) {
        return (end - start);
    },
    /**
     * Returns the number of seconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of seconds between the two dates
     * @static
     */
    getDurationInSeconds: function(start, end) {
        return (end - start) / 1000;
    },
    /**
     * Returns the number of minutes between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMinutes: function(start, end) {
        return (end - start) / 60000;
    },
    /**
     * Returns the number of hours between the two dates.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of hours between the two dates
     * @static
     */
    getDurationInHours: function(start, end) {
        return (end - start) / 3600000;
    },
    /**
     * This method returns the number of days between the two dates. It assumes a day is 24 hours and tries to take the DST into account.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of days between the two dates
     *
     * @static
     */
    getDurationInDays: function(start, end) {
        var dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        return (end - start + dstDiff * 60 * 1000) / 86400000;
    },
    /**
     * Returns the number of whole months between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInMonths: function(start, end) {
        return ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
    },
    /**
     * Returns the number of years between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInYears: function(start, end) {
        return this.getDurationInMonths(start, end) / 12;
    },
    /**
     * Returns the lesser of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the lesser of the two dates
     * @static
     */
    min: function(d1, d2) {
        return (d1 && d1.valueOf() || d1) < (d2 && d2.valueOf() || d2) ? d1 : d2;
    },
    // valueOf() is better for Chrome optimization
    /**
     * Returns the greater of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the greater of the two dates
     * @static
     */
    max: function(d1, d2) {
        return (d1 && d1.valueOf() || d1) > (d2 && d2.valueOf() || d2) ? d1 : d2;
    },
    // valueOf() is better for Chrome optimization
    /**
     * Returns true if dates intersect
     * @param {Date} start1
     * @param {Date} end1
     * @param {Date} start2
     * @param {Date} end2
     * @return {Boolean} Returns true if dates intersect
     * @static
     */
    intersectSpans: function(date1Start, date1End, date2Start, date2End) {
        return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
    },
    /**
     * Returns a name of the duration unit, matching its property on the Sch.util.Date class.
     * So, for example:
     *
     *      Sch.util.Date.getNameOfUnit(Sch.util.Date.DAY) == 'DAY' // true
     *
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getNameOfUnit: function(unit) {
        unit = this.getUnitByName(unit);
        switch (unit.toLowerCase()) {
            case this.YEAR:
                return 'YEAR';
            case this.QUARTER:
                return 'QUARTER';
            case this.MONTH:
                return 'MONTH';
            case this.WEEK:
                return 'WEEK';
            case this.DAY:
                return 'DAY';
            case this.HOUR:
                return 'HOUR';
            case this.MINUTE:
                return 'MINUTE';
            case this.SECOND:
                return 'SECOND';
            case this.MILLI:
                return 'MILLI';
        }
        throw "Incorrect UnitName";
    },
    /**
     * Returns a human-readable name of the duration unit. For for example for `Sch.util.Date.DAY` it will return either
     * "day" or "days", depending from the `plural` argument
     * @static
     * @param {String} unit Duration unit
     * @param {Boolean} plural Whether to return a plural name or singular
     * @return {String}
     */
    getReadableNameOfUnit: function(unit, plural) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        return this._unitNames[unit][plural ? 'plural' : 'single'];
    },
    /**
     * Returns an abbreviated form of the name of the duration unit.
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getShortNameOfUnit: function(unit) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        return this._unitNames[unit].abbrev;
    },
    getUnitByName: function(name) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        if (!this.unitsByName[name]) {
            Ext.Error.raise('Unknown unit name: ' + name);
        }
        return this.unitsByName[name];
    },
    /**
     * Returns the beginning of the Nth next duration unit, after the provided `date`.
     * For example for the this call:
     *      Sch.util.Date.getNext(new Date('Jul 15, 2011'), Sch.util.Date.MONTH, 1)
     *
     * will return: Aug 1, 2011
     *
     * @static
     * @param {Date} date The date
     * @param {String} unit The duration unit
     * @param {Number} increment How many duration units to skip
     * @param {Number} weekStartDay The day index of the 1st day of the week.
     *                Only required when `unit` is `WEEK`. 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on (defaults to 1).
     * @return {Date} The beginning of the next duration unit interval
     */
    getNext: function(date, unit, increment, weekStartDay) {
        var dt = Ext.Date.clone(date);
        weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
        // support 0 increment
        increment = increment == null ? 1 : increment;
        switch (unit) {
            case this.MILLI:
                dt = this.add(date, unit, increment);
                break;
            case this.SECOND:
                dt = this.add(date, unit, increment);
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                };
                break;
            case this.MINUTE:
                dt = this.add(date, unit, increment);
                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                };
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                };
                break;
            case this.HOUR:
                dt = this.add(date, unit, increment);
                // Without these checks Firefox messes up the date and it changes timezone in certain edge cases
                // See test 021_sch_util_date_dst.t.js
                if (dt.getMinutes() > 0) {
                    dt.setMinutes(0);
                };
                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                };
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                };
                break;
            case this.DAY:
                // Check if date has 23 hrs and is in Chile timezone
                var midnightNotInTimeScale = date.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;
                if (midnightNotInTimeScale) {
                    // Correct the date manually for DST transitions happening at 00:00
                    dt = this.add(dt, this.DAY, 2);
                    this.clearTime(dt);
                    return dt;
                };
                this.clearTime(dt);
                dt = this.add(dt, this.DAY, increment);
                // Brazil timezone issue #1642, tested in 028_timeaxis_dst.t.js
                if (dt.getHours() === 1) {
                    this.clearTime(dt);
                };
                break;
            case this.WEEK:
                this.clearTime(dt);
                var day = dt.getDay();
                dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));
                // For south american timezones, midnight does not exist on DST transitions, adjust...
                if (dt.getDay() !== weekStartDay) {
                    dt = this.add(dt, this.HOUR, 1);
                } else {
                    this.clearTime(dt);
                };
                break;
            case this.MONTH:
                dt = this.add(dt, this.MONTH, increment);
                dt.setDate(1);
                this.clearTime(dt);
                break;
            case this.QUARTER:
                dt = this.add(dt, this.MONTH, ((increment - 1) * 3) + (3 - (dt.getMonth() % 3)));
                this.clearTime(dt);
                dt.setDate(1);
                break;
            case this.YEAR:
                dt = new Date(dt.getFullYear() + increment, 0, 1);
                break;
            default:
                throw 'Invalid date unit';
        }
        return dt;
    },
    getNumberOfMsFromTheStartOfDay: function(date) {
        return date - this.clearTime(date, true) || 86400000;
    },
    getNumberOfMsTillTheEndOfDay: function(date) {
        return this.getStartOfNextDay(date, true) - date;
    },
    getStartOfNextDay: function(date, clone, noNeedToClearTime) {
        var nextDay = this.add(noNeedToClearTime ? date : this.clearTime(date, clone), this.DAY, 1);
        // DST case
        if (nextDay.getDate() == date.getDate()) {
            var offsetNextDay = this.add(this.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
            var offsetDate = date.getTimezoneOffset();
            nextDay = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
        }
        return nextDay;
    },
    getEndOfPreviousDay: function(date, noNeedToClearTime) {
        var dateOnly = noNeedToClearTime ? date : this.clearTime(date, true);
        // dates are different
        if (dateOnly - date) {
            return dateOnly;
        } else {
            return this.add(dateOnly, this.DAY, -1);
        }
    },
    /**
     * Returns true if the first time span completely 'covers' the second time span. E.g.
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
     * @static
     * @param {Date} spanStart The start date for initial time span
     * @param {Date} spanEnd The end date for initial time span
     * @param {Date} otherSpanStart The start date for the 2nd time span
     * @param {Date} otherSpanEnd The end date for the 2nd time span
     * @return {Boolean}
     */
    timeSpanContains: function(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
    },
    /**
     * Compares two days with given precision, for example if `date1` is Aug 1st, 2014 08:00 AM and `date2`
     * is Aug 1st, 2014 09:00 and `precisionUnit` is {@link Sch.util.Date.DAY} then both dates a considered equal
     * since they point to the same day.
     *
     * @param {Date} date1
     * @param {Date} date2
     * @param {String} [precisionUnit=Sch.util.Date.MILLI]
     * @return {Integer}
     * - -1 if `date1` is lesser than `date2`
     * - +1 if `date1` is greater than `date2`
     * -  0 if `date1` is equal to `date2`
     */
    compareWithPrecision: function(date1, date2, precisionUnit) {
        var D = Sch.util.Date,
            ED = Ext.Date,
            result;
        switch (precisionUnit) {
            case D.DAY:
                date1 = Number(ED.format(date1, 'Ymd'));
                date2 = Number(ED.format(date2, 'Ymd'));
                break;
            case D.WEEK:
                date1 = Number(ED.format(date1, 'YmW'));
                date2 = Number(ED.format(date2, 'YmW'));
                break;
            case D.MONTH:
                date1 = Number(ED.format(date1, 'Ym'));
                date2 = Number(ED.format(date2, 'Ym'));
                break;
            case D.QUARTER:
                date1 = date1.getFullYear() * 4 + Math.floor(date1.getMonth() / 3);
                date2 = date2.getFullYear() * 4 + Math.floor(date2.getMonth() / 3);
                break;
            case D.YEAR:
                date1 = date1.getFullYear();
                date2 = date2.getFullYear();
                break;
            default:
            case D.MILLI:
            case D.SECOND:
            case D.MINUTE:
            case D.HOUR:
                precisionUnit = precisionUnit && this.getUnitDurationInMs(precisionUnit) || 1;
                date1 = Math.floor(date1.valueOf() / precisionUnit);
                date2 = Math.floor(date2.valueOf() / precisionUnit);
                break;
        }
        ((date1 < date2) && (result = -1)) || ((date1 > date2) && (result = +1)) || (result = 0);
        return result;
    },
    getValueInUnits: function(date, unit) {
        switch (unit) {
            case this.MONTH:
                return date.getMonth();
            case this.DAY:
                return date.getDate();
            case this.HOUR:
                return date.getHours();
            case this.MINUTE:
                return date.getMinutes();
            case this.SECOND:
                return date.getSeconds();
        }
    },
    setValueInUnits: function(date, unit, value) {
        var result = Ext.Date.clone(date),
            f;
        switch (unit) {
            case this.YEAR:
                f = 'setFullYear';
                break;
            case this.MONTH:
                f = 'setMonth';
                break;
            case this.DAY:
                f = 'setDate';
                break;
            case this.HOUR:
                f = 'setHours';
                break;
            case this.MINUTE:
                f = 'setMinutes';
                break;
            case this.SECOND:
                f = 'setSeconds';
                break;
            case this.MILLI:
                f = 'setMilliseconds';
                break;
        }
        result[f](value);
        return result;
    },
    getSubUnit: function(unit) {
        switch (unit) {
            case this.YEAR:
                return this.MONTH;
            /* falls through */
            case this.MONTH:
                return this.DAY;
            /* falls through */
            case this.DAY:
                return this.HOUR;
            /* falls through */
            case this.HOUR:
                return this.MINUTE;
            /* falls through */
            case this.MINUTE:
                return this.SECOND;
            /* falls through */
            case this.SECOND:
                return this.MILLI;
        }
    },
    /* falls through */
    setValueInSubUnits: function(date, unit, value) {
        unit = this.getSubUnit(unit);
        return this.setValueInUnits(date, unit, value);
    },
    /*
     * section for calendar view related functions
     */
    mergeDates: function(target, source, unit) {
        var copy = Ext.Date.clone(target);
        switch (unit) {
            case this.YEAR:
                copy.setFullYear(source.getFullYear());
            /* falls through */
            case this.MONTH:
                copy.setMonth(source.getMonth());
            /* falls through */
            case this.WEEK:
            /* falls through */
            case this.DAY:
                // we want to return week start day for this case
                if (unit === this.WEEK) {
                    copy = this.add(copy, this.DAY, source.getDay() - copy.getDay());
                } else {
                    copy.setDate(source.getDate());
                };
            /* falls through */
            case this.HOUR:
                copy.setHours(source.getHours());
            /* falls through */
            case this.MINUTE:
                copy.setMinutes(source.getMinutes());
            /* falls through */
            case this.SECOND:
                copy.setSeconds(source.getSeconds());
            /* falls through */
            case this.MILLI:
                copy.setMilliseconds(source.getMilliseconds());
        }
        return copy;
    },
    // splitting specified unit to subunits including start of the next span
    // e.g. week will be split to days, days to hours, etc.
    splitToSubUnits: function(start, unit, increment, weekStartDay) {
        increment = increment || 1;
        weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
        switch (unit) {
            //            case this.YEAR      : return this.splitYear(start, increment, weekStartDay);
            case this.MONTH:
                return this.splitMonth(start, increment, weekStartDay);
            case this.WEEK:
            //return this.splitWeek(start, increment, weekStartDay);
            /* falls through */
            case this.DAY:
                return this.splitDay(start, increment);
            //            case this.HOUR      : return this.splitHour(start, increment);
            //            case this.MINUTE    : return this.splitMinute(start, increment);
            default:
                break;
        }
    },
    splitYear: function(start, increment) {
        var newStart = this.clearTime(start, true);
        newStart.setMonth(0);
        newStart.setDate(1);
        var result = [];
        for (var i = 0; i <= 12; i = i + increment) {
            result.push(this.add(newStart, this.MONTH, i));
        }
        return result;
    },
    splitMonth: function(start, increment, weekStartDay) {
        var newStart = this.clearTime(start, true);
        newStart.setDate(1);
        newStart = this.add(newStart, this.DAY, weekStartDay - newStart.getDay());
        var currentDate = Ext.Date.clone(newStart);
        var monthEnd = this.add(newStart, this.MONTH, 1);
        var result = [];
        for (var i = 0; currentDate.getTime() < monthEnd.getTime(); i = i + increment) {
            currentDate = this.add(newStart, this.WEEK, i);
            result.push(currentDate);
        }
        return result;
    },
    splitWeek: function(start, increment, weekStartDay) {
        var newStart = this.add(start, this.DAY, weekStartDay - start.getDay());
        newStart = this.clearTime(newStart);
        var result = [];
        for (var i = 0; i <= 7; i = i + increment) {
            result.push(this.add(newStart, this.DAY, i));
        }
        return result;
    },
    splitDay: function(start, increment) {
        var copy = this.clearTime(start, true);
        var result = [];
        for (var i = 0; i <= 24; i = i + increment) {
            result.push(this.add(copy, this.HOUR, i));
        }
        return result;
    },
    splitHour: function(start, increment) {
        var copy = new Date(start.getTime());
        copy.setMinutes(0);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        var result = [];
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.MINUTE, i));
        }
        return result;
    },
    splitMinute: function(start, increment) {
        var copy = Ext.Date.clone(start);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        var result = [];
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.SECOND, i));
        }
        return result;
    },
    // Need this to prevent some browsers (Safari in Sydney timezone) to not mess up a date
    // See tests marked *dst* and https://www.assembla.com/spaces/bryntum/tickets/1757#/activity/ticket:
    clearTime: function(dt, clone) {
        if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0) {
            return Ext.Date.clearTime(dt, clone);
        }
        return clone ? Ext.Date.clone(dt) : dt;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.EndDate
@extends Gnt.field.Date

A specialized field for editing the task end date value. This class inherits from the `Ext.form.field.Date` field
and any of its configuration options can be used. You can find this field used in the {@link Gnt.widget.TaskForm}
and in the {@link Gnt.column.StartDate} classes but you can also use it in your own components.
See "Using field standalone" in the documentation of {@link Gnt.field.StartDate}.

This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Task interaction

By default the field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.

#Using field standalone

Please refer to {@link Gnt.field.StartDate} for details.

* **Note**, that the value displayed in the field can be different from the value in the data model when editing milestones
or when the date does not contain any time information (hours/minutes etc). This is because in our component, an end date represents a distinct point
on the timeaxis. For example: if from a user perspective, a task starts at 2013/01/01 and ends at 2013/01/02 -
this means that the task actually ends at 2013/01/02 23:59:59.9999. In the task model we store
2013/01/03 00:00:00, but in the field we show 2013/01/02. See also {@link #adjustMilestones}.

*/
Ext.define('Gnt.field.EndDate', {
    extend: 'Gnt.field.Date',
    requires: [
        'Sch.util.Date'
    ],
    alias: 'widget.enddatefield',
    taskField: 'endDateField',
    getTaskValueMethod: 'getEndDate',
    setTaskValueMethod: 'setEndDate',
    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the field will validate a "startDate <= endDate" condition and will not allow user to save invalid value.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - endBeforeStartText : 'End date is before start date'
     */
    valueToVisible: function(value, task) {
        task = task || this.task;
        return task.getDisplayEndDate(this.format, this.adjustMilestones, value, true);
    },
    visibleToValue: function(value) {
        if (value && this.task) {
            if (!Ext.Date.formatContainsHourInfo(this.format) && value - Ext.Date.clearTime(value, true) === 0) {
                // the standard ExtJS date picker will only allow to choose the date, not time
                // we set the time of the selected date to the latest availability hour for that date
                // in case the date has no availability intervals we use the date itself
                value = this.task.getCalendar().getCalendarDay(value).getAvailabilityEndFor(value) || Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
            }
        } else {
            value = null;
        }
        return value;
    },
    isValidAgainstStartDate: function(value) {
        return !this.task || !value || value >= this.task.getStartDate();
    },
    // @OVERRIDE
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        if (this.validateStartDate) {
            if (!this.isValidAgainstStartDate(this.rawToValue(value))) {
                return [
                    this.L('endBeforeStartText')
                ];
            }
        }
        return [];
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.column.mixin.TaskFieldColumn
This class implement common logic for fields that have a field mixed with {@link Gnt.field.mixin.TaskField} class as an editor.
Also it makes the column localizable by mixing it with {@link Gnt.mixin.Localizable} class.
*/
Ext.define('Gnt.column.mixin.TaskFieldColumn', {
    extend: 'Ext.Mixin',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Boolean} instantUpdate Set to `true` to instantly apply any changes in the field to the task.
     * This option is just translated to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate: false,
    /**
     * @property {Ext.form.field.Field} Reference to the field used by the editor
     */
    field: null,
    fieldProperty: '',
    fieldConfigs: 'instantUpdate,fieldProperty',
    defaultEditor: 'textfield',
    useRenderer: true,
    mixinConfig: {
        after: {
            initComponent: 'afterInitComponent',
            onRender: '_beforeRender'
        },
        // "afterIf" adds a post-action exactly like normal "after" does
        // except in case the method being extended doesn't exist it adds it
        // So for example having this config:
        //      afterIf        : {
        //          applyColumnCls : 'applyColumnCls'
        //      }
        // Will result appending mixin's applyColumnCls code after the existing applyColumnCls method code
        // ..or creating a new applyColumnCls method using mixin's applyColumnCls method
        afterIf: {
            applyColumnCls: 'applyColumnCls'
        }
    },
    _beforeRender: function() {
        // Save original state so we can enable/disable this when needed
        var ed = this.getEditor && this.getEditor();
        if (ed && ed.setInstantUpdate) {
            ed.originalInstantUpdate = ed.instantUpdate;
            ed.setInstantUpdate(false);
        }
    },
    initTaskFieldColumn: function(editorCfg) {
        this.text = this.config.text || this.L('text');
        this.initColumnEditor(editorCfg);
        this.scope = this.scope || this;
        if (this.useRenderer) {
            this.renderer = this.renderer || this.taskFieldRenderer;
        }
        this.on('added', this.onColumnAdded, this);
    },
    applyColumnCls: function(value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        }
    },
    afterInitComponent: function() {
        // Make sure Ext 'understands' this column has its own renderer which makes sure this column is always updated
        // if any task field is changed
        this.hasCustomRenderer = true;
    },
    initColumnEditor: function(editorCfg) {
        var editor = this.editor;
        // if editor provided
        if (editor) {
            // xtype provided
            if ('string' == typeof editor) {
                editor = {
                    xtype: editor
                };
            }
            // if it's not a made instance yet
            if (!editor.isInstance) {
                if (!editor.xtype && !editor.xclass) {
                    editor.xtype = this.defaultEditor;
                }
                // relay configs listed in "fieldConfigs" to the editor
                var cfg = Ext.copyTo(Ext.apply({}, editorCfg), this, this.fieldConfigs, true);
                this.editor = Ext.ComponentManager.create(Ext.apply(cfg, editor));
            }
            this.field = this.editor;
        }
    },
    onColumnAdded: function() {
        var gantt = this.up('[taskStore]');
        var taskStore = gantt.taskStore;
        if (!this.dataIndex) {
            this.dataIndex = taskStore.model.prototype[this.fieldProperty];
        }
        // if the column wants to track the gantt readonly state
        if (this.onReadOnlySet) {
            this.mon(gantt, 'setreadonly', this.onReadOnlySet, this);
        }
    },
    getValueToRender: function(value, meta, task) {
        var field = this.field;
        return field && field.valueToVisible && field.valueToVisible(value, task) || value;
    },
    taskFieldRenderer: function(value, meta, task) {
        var result = Ext.util.Format.htmlEncode(this.getValueToRender.apply(this, arguments));
        this.applyColumnCls(value, meta, task);
        return result;
    },
    afterClassMixedIn: function(cls) {
        var mixin = this.prototype,
            mixinConfig = mixin.mixinConfig,
            befores = mixinConfig && mixinConfig.beforeIf,
            afters = mixinConfig && mixinConfig.afterIf;
        befores && Ext.Object.each(befores, function(key, value) {
            if (key in cls.prototype) {
                cls.addMember(key, function() {
                    if (mixin[value].apply(this, arguments) !== false) {
                        return this.callParent(arguments);
                    }
                });
            } else {
                cls.addMember(key, function() {
                    mixin[value].apply(this, arguments);
                });
            }
        });
        afters && Ext.Object.each(afters, function(key, value) {
            if (key in cls.prototype) {
                cls.addMember(key, function() {
                    this.callParent(arguments);
                    mixin[value].apply(this, arguments);
                });
            } else {
                cls.addMember(key, function() {
                    mixin[value].apply(this, arguments);
                });
            }
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.EndDate
@extends Ext.grid.column.Date

A Column showing the `EndDate` field of the tasks. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height  : 600,
        width   : 1000,

        columns : [
            ...
            {
                xtype : 'enddatecolumn',
                width : 80
            }
            ...
        ],

        plugins : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

Note, that this column will provide only a day-level editor (using a subclassed Ext JS DateField). If you need a more precise editing (ie also specify
the start hour/minute) you will need to provide your own field (which should extend {@link Gnt.field.EndDate}). See this [forum thread][1] for more information.

[1]: http://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964

Note that the end date of task in gantt is not inclusive, however, this column will compensate the value when rendering or editing.
So for example, if you have a 1 day task which starts at 2011/07/20 and ends at 2011/07/21 (remember end date is not inclusive!),
this column will show the `2011/07/20` when rendering. It will also increase the date by 1 day after being edited.

Also note, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format" option.

*/
Ext.define("Gnt.column.EndDate", {
    extend: "Ext.grid.column.Date",
    alias: [
        'widget.enddatecolumn',
        'widget.ganttcolumn.enddate'
    ],
    requires: [
        'Ext.grid.CellEditor',
        'Gnt.field.EndDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Finish'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as `format` configuration
     * option of the column itself.
     */
    editorFormat: null,
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the column will validate a "startDate <= endDate" condition and won't allow user to save the invalid end date.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: false,
    fieldProperty: 'endDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'validateStartDate',
        'fieldProperty'
    ],
    editor: 'enddatefield',
    defaultEditor: 'enddatefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    },
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        if (data && task.getStartDate() && task.getStartDate() > data) {
            task.setDuration(0);
        }
        task.setEndDate(data, task.isMilestone(), false);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.BaselineEndDate
@extends Gnt.field.EndDate

A specialized field for editing the task baseline end date value. This class inherits from the `Ext.form.field.Date` field
and any of its configuration options can be used. You can find this field used in the {@link Gnt.widget.TaskForm}
and in the {@link Gnt.column.BaselineStartDate} classes but you can also use it in your own components.

This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Task interaction

By default the field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.

* **Note**, that the value displayed in the field can be different from the value in the data model when editing milestones
or when the date does not contain any time information (hours/minutes etc). This is because in our component, an end date represents a distinct point
on the timeaxis. For example: if from a user perspective, a task starts at 2013/01/01 and ends at 2013/01/02 -
this means that the task actually ends at 2013/01/02 23:59:59.9999. In the task model we store
2013/01/03 00:00:00, but in the field we show 2013/01/02. See also {@link #adjustMilestones}.

*/
Ext.define('Gnt.field.BaselineEndDate', {
    extend: 'Gnt.field.EndDate',
    alias: 'widget.baselineenddatefield',
    /**
     * @hide
     * @cfg keepDuration
     */
    taskField: 'baselineEndDateField',
    getTaskValueMethod: 'getBaselineEndDate',
    setTaskValueMethod: 'setBaselineEndDate',
    isValidAgainstStartDate: function(value) {
        return !this.task || !value || value >= this.task.getBaselineStartDate();
    },
    applyChanges: function(toTask, silent) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.value || null);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        if (!silent)  {
            toTask.fireEvent('taskupdated', toTask, this);
        }
        
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.BaselineEndDate

A Column displaying the baseline end date of a task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'baselineenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.BaselineEndDate', {
    extend: 'Gnt.column.EndDate',
    requires: [
        'Gnt.field.BaselineEndDate'
    ],
    alias: [
        'widget.baselineenddatecolumn',
        'widget.ganttcolumn.baselineenddate'
    ],
    width: 100,
    fieldProperty: 'baselineEndDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'validateStartDate',
        'fieldProperty'
    ],
    editor: 'baselineenddatefield',
    defaultEditor: 'baselineenddatefield',
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        task.setBaselineEndDate(data);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.field.StartDate
@extends Gnt.field.Date

A specialized field for editing the task start date value. This class inherits from the `Ext.form.field.Date` field
so any of its configuration options can be used. You can find this field in {@link Gnt.widget.TaskForm}
and in {@link Gnt.column.StartDate} but you can use it in your own components as well (see "Using field standalone" below).

This field requires to be bound to {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Task interacting

By default field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.

#Using field standalone

To use this field standalone you have to provide {@link Gnt.model.Task task} instance to it. You can make it by two ways:

 - Set the {@link #task} configuration option at field constructing step. Like this:

        var startDateField = Ext.create('Gnt.field.StartDate', {
            task : someTask
        });

 - Or by calling {@link #setTask} method after field was created. Like this:

        startDateField.setTask(someTask);

* **Note:** If task does not belong to any {@link Gnt.data.TaskStore} you also **have to** specify {@link #taskStore} config option for this field otherwise it won't work:

        // some task not inserted in the task store yet
        var someTask    = new Gnt.model.Task({ ... })

        var startDateField = Ext.create('Gnt.field.StartDate', {
            task        : someTask,
            // need to provide a task store instance in this case
            taskStore   : taskStore
        });

* **Note**, that value displayed in the field can be different from the value in the task model when editing milestones.
Please refer to {@link #adjustMilestones} for details.

*/
Ext.define('Gnt.field.StartDate', {
    extend: 'Gnt.field.Date',
    alias: 'widget.startdatefield',
    keepDuration: true,
    taskField: 'startDateField',
    getTaskValueMethod: 'getStartDate',
    setTaskValueMethod: 'setStartDate',
    isBaseline: false,
    valueToVisible: function(value, task) {
        task = task || this.task;
        return task.getDisplayStartDate(this.format, this.adjustMilestones, value, true, this.isBaseline);
    },
    visibleToValue: function(value) {
        var task = this.task;
        // Special treatment of milestone task dates
        if (task && value) {
            var isMidnight = !Ext.isDate(this.lastValue) || this.lastValue - Ext.Date.clearTime(this.lastValue, true) === 0;
            if (this.adjustMilestones && task.isMilestone(this.isBaseline) && value - Ext.Date.clearTime(value, true) === 0 && isMidnight) {
                // the standard ExtJS date picker will only allow to choose the date, not time
                // we set the time of the selected date to the earliest availability hour for that date
                // in case the date has no availability intervals we use the date itself
                value = task.getCalendar().getCalendarDay(value).getAvailabilityEndFor(value) || value;
            }
        }
        return value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.StartDate
@extends Ext.grid.column.Date

A Column representing a `StartDate` field of a task. The column is editable, however to enable the editing you will need to add a
{@link Sch.plugin.TreeCellEditing} plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height  : 600,
        width   : 1000,

        columns : [
            ...
            {
                xtype : 'startdatecolumn',
                width : 80
            }
            ...
        ],

        plugins : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit : 1
            })
        ],
        ...
    })

Note, that this column will provide only a day-level editor (using a subclassed Ext JS DateField). If you need a more precise editing (ie also specify
the start hour/minute) you will need to provide your own field which should subclass {@link Gnt.field.StartDate}. See [forum thread][1] for more information.

Also note, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format" option.

[1]: http://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964

*/
Ext.define('Gnt.column.StartDate', {
    extend: 'Ext.grid.column.Date',
    alias: [
        'widget.startdatecolumn',
        'widget.ganttcolumn.startdate'
    ],
    requires: [
        'Gnt.field.StartDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Start'
     */
    /**
     * @cfg {Number} width A width of the column, default value is 100
     */
    width: 100,
    /**
     * @cfg {String} align An align of the text in the column, default value is 'left'
     */
    align: 'left',
    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as `format` configuration
     * option of the column itself.
     */
    editorFormat: null,
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: true,
    fieldProperty: 'startDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'fieldProperty'
    ],
    editor: 'startdatefield',
    defaultEditor: 'startdatefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    },
    /**
     * Will validate and insert previously prepared assignment data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        task.setStartDate(data);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.field.BaselineStartDate
@extends Gnt.field.StartDate

A specialized field for editing the task baseline start date value. This class inherits from the `Ext.form.field.Date` field
so any of its configuration options can be used. You can find this field in {@link Gnt.widget.TaskForm}
and in {@link Gnt.column.BaselineStartDate} but you can use it in your own components as well.

*/
Ext.define('Gnt.field.BaselineStartDate', {
    extend: 'Gnt.field.StartDate',
    alias: 'widget.baselinestartdatefield',
    taskField: 'baselineStartDateField',
    getTaskValueMethod: 'getBaselineStartDate',
    setTaskValueMethod: 'setBaselineStartDate',
    isBaseline: true,
    /**
     * @hide
     * @cfg keepDuration
     */
    applyChanges: function(toTask, silent) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.value);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        if (!silent)  {
            toTask.fireEvent('taskupdated', toTask, this);
        }
        
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.BaselineStartDate
@extends Ext.grid.column.Date

A Column displaying the baseline start date of a task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'baselinestartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.BaselineStartDate', {
    extend: 'Gnt.column.StartDate',
    requires: [
        'Gnt.field.BaselineStartDate'
    ],
    alias: [
        'widget.baselinestartdatecolumn',
        'widget.ganttcolumn.baselinestartdate'
    ],
    width: 100,
    fieldProperty: 'baselineStartDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'fieldProperty'
    ],
    editor: 'baselinestartdatefield',
    defaultEditor: 'baselinestartdatefield',
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        task.setBaselineStartDate(data);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Robo.data.Model

This is a mixin for your models, enabling integration with the Robo undo/redo framework.
It should be included in your model classes as any other mixin:

    Ext.define('Example.model.Branch', {
        extend      : 'Ext.data.Model',
        
        mixins      : { robo : 'Robo.data.Model' },
        
        ...
    });

You might want to define an additional method {@link #getTitle} in your models. It will be used to build
a transaction {@link Robo.Transaction#getTitle title}.

*/
Ext.define('Robo.data.Model', {
    extend: 'Ext.Mixin',
    /**
     * @cfg modelName
     * 
     * Human readable name for transaction titles. Should be defined at the class level. This can be used
     * to build a simplified transaction title, including this "modelName" and model id.
     * 
     * For detailed control of transaction titles, see {@link #getTitle} method.
     */
    modelName: null,
    editMementoFix: null,
    mixinConfig: {
        before: {
            endEdit: 'onBeforeEndEdit'
        },
        after: {
            endEdit: 'onAfterEndEdit'
        }
    },
    // Fix for the incorrect behavior of the "previousValues" implementation in ExtJS
    onBeforeEndEdit: function(silent, modifiedFieldNames) {
        var editMemento = this.editMemento;
        if (editMemento) {
            this.editMementoFix = editMemento;
            if (!modifiedFieldNames) {
                modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
            }
            if (!editMemento.previousValues)  {
                editMemento.previousValues = {};
            }
            
            Ext.Array.each(modifiedFieldNames, function(fieldName) {
                editMemento.previousValues[fieldName] = editMemento.data[fieldName];
            });
        }
    },
    onAfterEndEdit: function(silent, modifiedFieldNames) {
        delete this.editMementoFix;
    },
    /**
     * By default this method is empty, but you can override it in your models, to return a human-readable 
     * title of this model instance. String should (probably) include the id of the record, 
     * along with some additional information. 
     * 
     * For example, for the employee model you might want to return the id, first name and last name 
     * (or any other important fields).
     * 

    Ext.define('Example.model.Employee', {
        extend      : 'Ext.data.Model',
        mixins      : { robo : 'Robo.data.Model' },
        
        ...
        
        getTitle : function () {
            return (this.get('firstName') || '') + ' ' + (this.get('lastName') || '') + " (" + this.getId() + ")"
        }
    });

     * 
     * @return {String}
     */
    getTitle: function() {
        return '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.model.Customizable
@extends Ext.data.Model

This class represent a model with customizable field names. Customizable fields are defined in separate
class config `customizableFields`. The format of definition is just the same as for usual fields:

        Ext.define('BaseModel', {
            extend             : 'Sch.model.Customizable',

            customizableFields : [
                { name : 'StartDate', type : 'date', dateFormat : 'c' },
                { name : 'EndDate',   type : 'date', dateFormat : 'c' }
            ],

            fields             : [
                'UsualField'
            ],

            getEndDate : function () {
                return "foo"
            }
        });

For each customizable field will be created getter and setter, using the camel-cased name of the field ("stable name"),
prepended with "get/set" respectively. They will not overwrite any existing methods:

        var baseModel   = new BaseModel({
            StartDate   : new Date(2012, 1, 1),
            EndDate     : new Date(2012, 2, 3)
        });

        // using getter for "StartDate" field
        // returns date for "2012/02/01"
        var startDate   = baseModel.getStartDate();

        // using custom getter for "EndDate" field
        // returns "foo"
        var endDate     = baseModel.getEndDate();

You can change the name of the customizable fields in the subclasses of the model or completely re-define them.
For that, add a special property to the class, name of this property should be formed as name of the field with lowercased first
letter, appended with "Field". The value of the property should contain the new name of the field.

        Ext.define('SubModel', {
            extend         : 'BaseModel',

            startDateField : 'beginDate',
            endDateField   : 'finalizeDate',

            fields         : [
                { name : 'beginDate', type : 'date', dateFormat : 'Y-m-d' },
            ]
        });

        var subModel     = new SubModel({
            beginDate    : new Date(2012, 1, 1),
            finalizeDate : new Date(2012, 2, 3)
        });

        // name of getter is still the same
        var startDate = subModel.getStartDate();

In the example above the `StartDate` field was completely re-defined to the `beginDate` field with different date format.
The `EndDate` has just changed its name to "finalizeDate". Note, that getters and setters are always named after "stable"
field name, not the customized one.
*/
Ext.define('Sch.model.Customizable', function(thisClass) {
    return {
        extend: 'Ext.data.Model',
        mixins: {
            robo: 'Robo.data.Model'
        },
        isCustomizableModel: true,
        /**
        * @cfg {Array} customizableFields
        *
        * The array of customizale fields definitions.
        */
        customizableFields: null,
        // @private
        // Keeps temporary state of the previous state for a model, but is only available
        // when a model has changed, e.g. after 'set' or 'reject'. After those operations are completed, this property is cleared.
        previous: null,
        // temp flag to check if we're currently editing the model
        __editing: null,
        // To support nested beginEdit calls (see 043_nested_beginedit.t.js in Gantt)
        __editCounter: 0,
        constructor: function() {
            // Sencha Touch requires the return value to be returned, hard crash without it
            var retVal = this.callParent(arguments);
            return retVal;
        },
        // Overridden to be able to track previous record field values
        set: function(fieldName, value) {
            var currentValue;
            var retVal;
            this.previous = this.previous || {};
            if (typeof fieldName === 'string') {
                currentValue = this.get(fieldName);
                // convert new value to Date if needed
                if (currentValue instanceof Date && !(value instanceof Date)) {
                    value = this.getField(fieldName).convert(value, this);
                }
                // Store previous field value if it changed, if value didn't change - just return
                if ((currentValue instanceof Date && (currentValue - value)) || !(currentValue instanceof Date) && currentValue !== value) {
                    this.previous[fieldName] = currentValue;
                } else {
                    return null;
                }
            } else {
                for (var o in fieldName) {
                    currentValue = this.get(o);
                    var newValue = fieldName[o];
                    // convert new value to Date if needed
                    if (currentValue instanceof Date && !(newValue instanceof Date)) {
                        newValue = this.getField(o).convert(newValue, this);
                    }
                    // Store previous field value
                    if ((currentValue instanceof Date && (currentValue - newValue)) || !(currentValue instanceof Date) && currentValue !== newValue) {
                        this.previous[o] = currentValue;
                    }
                }
            }
            retVal = this.callParent(arguments);
            if (!this.__editing) {
                delete this.previous;
            }
            return retVal;
        },
        // Overridden to be able to track previous record field values
        reject: function() {
            var me = this,
                modified = me.modified || {},
                field;
            // Ext could call 'set' during the callParent which should not reset the 'previous' object
            me.__editing = true;
            me.previous = me.previous || {};
            for (field in modified) {
                if (modified.hasOwnProperty(field)) {
                    if (typeof modified[field] != "function") {
                        me.previous[field] = me.get(field);
                    }
                }
            }
            me.callParent(arguments);
            // Reset the previous tracking object
            delete me.previous;
            me.__editing = false;
        },
        // -------------- Supporting nested beginEdit calls - see test 043_nested_beginedit.t.js
        beginEdit: function() {
            this.__editCounter++;
            this.__editing = true;
            this.callParent(arguments);
        },
        cancelEdit: function() {
            this.__editCounter = 0;
            this.__editing = false;
            this.callParent(arguments);
            delete this.previous;
        },
        // Overridden to be able to clear the previous record field values. Must be done here to have access to the 'previous' object after
        // an endEdit call.
        endEdit: function(silent, modifiedFieldNames) {
            if (--this.__editCounter === 0) {
                // OVERRIDE HACK: If no fields were changed, make sure no events are fired by signaling 'silent'
                if (!silent && this.getModifiedFieldNames) /* Touch doesn't have this method, skip optimization */
                {
                    var editMemento = this.editMemento;
                    if (!modifiedFieldNames) {
                        modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
                    }
                    if (modifiedFieldNames && modifiedFieldNames.length === 0) {
                        silent = true;
                    }
                }
                this.callParent([
                    silent
                ].concat(Array.prototype.slice.call(arguments, 1)));
                this.__editing = false;
                delete this.previous;
            }
        }
    };
}, // -------------- EOF Supporting nested beginEdit calls - see test 043_nested_beginedit.t.js
function(thisClass) {
    // thisClass.onExtended() used few lines below puts a provided function to the end of thisClass.$onExtended array.
    // That's why we cannot use it. We need this function to start early to be able to backup originally defined "fields" config.
    // Ext.data.Model provided a function to onExtended that removes the config and it stays earlier in the thisClass.$onExtended queue.
    // So we simply put our function to the beginning of thisClass.$onExtended.
    thisClass.$onExtended.unshift({
        fn: function(cls, data) {
            if (data) {
                if (Ext.isArray(data)) {
                    cls.fieldsInitialValue = data.slice();
                } else if (data.fields) {
                    if (!Ext.isArray(data.fields)) {
                        cls.fieldsInitialValue = [
                            data.fields
                        ];
                    } else {
                        cls.fieldsInitialValue = data.fields.slice();
                    }
                }
            }
        }
    });
    thisClass.onExtended(function(cls, data, hooks) {
        var classManager = Ext.ClassManager,
            triggerCreatedOriginal = classManager.triggerCreated;
        // just before the ClassManager notifies that the class is ready we do our fields adjustments
        classManager.triggerCreated = function(className) {
            var proto = cls.prototype;
            // Combining our customizable fields with ones collected by the superclass.
            // This array has all the inherited customizable fields (yet some of them might be duplicated because of overrides)
            if (data.customizableFields) {
                proto.allCustomizableFields = (cls.superclass.allCustomizableFields || []).concat(data.customizableFields);
            } else {
                proto.allCustomizableFields = (cls.superclass.allCustomizableFields || []);
            }
            // we will collect fields here, overwriting old ones with new to remove duplication
            var customizableFieldsByName = {};
            Ext.Array.each(proto.allCustomizableFields, function(field) {
                // normalize to object
                if (typeof field == 'string')  {
                    field = {
                        name: field
                    };
                }
                
                customizableFieldsByName[field.name] = field;
            });
            // already processed by the Ext.data.Model `onBeforeCreated`
            var fields = proto.fields;
            var toAdd = [];
            var toRemove = [];
            Ext.Array.each(fields, function(field) {
                if (field.isCustomizableField) {
                    toRemove.push(field.getName());
                }
            });
            if (proto.idProperty !== 'id' && proto.getField('id')) {
                if (!proto.getField('id').hasOwnProperty('name')) {
                    toRemove.push('id');
                }
            }
            if (proto.idProperty !== 'Id' && proto.getField('Id')) {
                if (!proto.getField('Id').hasOwnProperty('name')) {
                    toRemove.push('Id');
                }
            }
            cls.removeFields(toRemove);
            // Finds the provided field config in the provided array of configs
            // and applies it to the provided resulting object (using Ext.applyIf)
            // @param result Resulting configuration object
            // @param fields Array of field configs
            // @param fieldName Field name
            function applyFieldConfig(result, fields, fieldName) {
                if (!fields)  {
                    return;
                }
                
                if (!Ext.isArray(fields))  {
                    fields = [
                        fields
                    ];
                }
                
                var fieldConfig;
                for (var i = fields.length - 1; i >= 0; i--) {
                    if (fields[i].name == fieldName) {
                        fieldConfig = fields[i];
                        break;
                    }
                }
                Ext.applyIf(result, fieldConfig);
            }
            // Collects the provided customizable field config based on the class inheritance
            // @param stableFieldName Stable field name (the one provided as "name" in the "customizableFields" section)
            // @return Field config
            function getFieldConfig(stableFieldName) {
                var c = cls,
                    proto = c.prototype,
                    fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field',
                    result = {
                        name: proto[fieldProperty] || stableFieldName,
                        isCustomizableField: true
                    },
                    fieldName;
                while (proto && proto.isCustomizableModel) {
                    fieldName = proto[fieldProperty] || stableFieldName;
                    // first apply "customizableFields" config data
                    // ..we use applyIf() and "customizableFields" has higher priority than "fields" config
                    proto.hasOwnProperty('customizableFields') && applyFieldConfig(result, proto.customizableFields, stableFieldName);
                    // apply "fields" config data
                    applyFieldConfig(result, c.fieldsInitialValue, fieldName);
                    // proceed to parent class
                    proto = c.superclass;
                    c = proto && proto.self;
                }
                return result;
            }
            // let's reset array there might be some more fields to remove
            toRemove = [];
            Ext.Object.each(customizableFieldsByName, function(name, customizableField) {
                var stableFieldName = customizableField.name || customizableField.getName();
                var fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
                var realFieldName = proto[fieldProperty] || stableFieldName;
                // if such field already exists we will remove it
                proto.getField(realFieldName) && toRemove.push(realFieldName);
                var field = getFieldConfig(stableFieldName);
                // we create a new copy of the `customizableField` using possibly new name
                toAdd.push(Ext.create('data.field.' + (field.type || 'auto'), field));
                var capitalizedStableName = Ext.String.capitalize(stableFieldName);
                // don't overwrite `getId` method
                if (capitalizedStableName != 'Id') {
                    var getter = 'get' + capitalizedStableName;
                    var setter = 'set' + capitalizedStableName;
                    // overwrite old getters, pointing to a different field name
                    if (!proto[getter] || proto[getter].__getterFor__ && proto[getter].__getterFor__ != realFieldName) {
                        proto[getter] = function() {
                            // Need to read this property from the prototype if it exists, instead of relying on the field
                            // Since if someone subclasses a model and redefines a fieldProperty - the realFieldName variable
                            // will still have the value of the superclass
                            // See test 024_event.t.js
                            return this.get(this[fieldProperty] || realFieldName);
                        };
                        proto[getter].__getterFor__ = realFieldName;
                    }
                    // same for setters
                    if (!proto[setter] || proto[setter].__setterFor__ && proto[setter].__setterFor__ != realFieldName) {
                        proto[setter] = function(value) {
                            // Need to read this property from the prototype if it exists, instead of relying on the field
                            // Since if someone subclasses a model and redefines a fieldProperty - the realFieldName variable
                            // will still have the value of the superclass
                            // See test 024_event.t.js
                            return this.set(this[fieldProperty] || realFieldName, value);
                        };
                        proto[setter].__setterFor__ = realFieldName;
                    }
                }
            });
            cls.replaceFields(toAdd, toRemove);
            // call && restore original Ext.ClassManager.triggerCreated function
            triggerCreatedOriginal.apply(this, arguments);
            classManager.triggerCreated = triggerCreatedOriginal;
        };
    });
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.model.Calendar
@extends Sch.model.Customizable

A model representing a single calendar.
Every model instance will be also decorated with the {@link Gnt.data.Calendar} instance, created based on the model field values.
The fields of the model correspond to the properties of {@link Gnt.data.Calendar} class.

Fields
------

- `Id` - record identifier (corresponds to {@link Gnt.data.Calendar#calendarId})
- `Name` - corresponds to {@link Gnt.data.Calendar#name}
- `DaysPerMonth` - corresponds to {@link Gnt.data.Calendar#daysPerMonth}
- `DaysPerWeek` - corresponds to {@link Gnt.data.Calendar#daysPerWeek}
- `HoursPerDay` - corresponds to {@link Gnt.data.Calendar#hoursPerDay}
- `WeekendsAreWorkdays` - corresponds to {@link Gnt.data.Calendar#weekendsAreWorkdays}
- `WeekendFirstDay` - corresponds to {@link Gnt.data.Calendar#weekendFirstDay}
- `WeekendSecondDay` - corresponds to {@link Gnt.data.Calendar#weekendSecondDay}
- `DefaultAvailability` - corresponds to {@link Gnt.data.Calendar#defaultAvailability}
- `Days` - stores reference to the {@link Gnt.data.Calendar} instance
- `CalendarClass` - calendar class that should be used to create {@link Gnt.data.Calendar} instance
- `PhantomId` - phantom record identifier
- `PhantomParentId` - phantom parent record identifier

A collection of this models is supposed to be provided for the {@link Gnt.data.CalendarManager calendar manager}.
*/
Ext.define('Gnt.model.Calendar', {
    extend: 'Sch.model.Customizable',
    requires: [
        'Ext.data.NodeInterface'
    ],
    idProperty: 'Id',
    calendar: null,
    /**
     * @cfg {String} nameField The name of the field specifying the calendar name.
     */
    nameField: 'Name',
    /**
     * @cfg {String} daysPerMonthField The name of the field specifying the number of days per month
     * (used when converting the big duration units like month/year to days).
     */
    daysPerMonthField: 'DaysPerMonth',
    /**
     * @cfg {String} daysPerWeekField The name of the field specifying the number of days per week
     * (used when converting the duration only).
     */
    daysPerWeekField: 'DaysPerWeek',
    /**
     * @cfg {String} hoursPerDayField The name of the field specifying the number of hours per day
     * (used when converting the duration only).
     */
    hoursPerDayField: 'HoursPerDay',
    /**
     * @cfg {String} weekendsAreWorkdaysField The name of the field specifying if all weekdays are working.
     */
    weekendsAreWorkdaysField: 'WeekendsAreWorkdays',
    /**
     * @cfg {String} weekendFirstDayField The name of the field specifying the index of the first day in weekend.
     */
    weekendFirstDayField: 'WeekendFirstDay',
    /**
     * @cfg {String} weekendSecondDayField The name of the field specifying the index of the second day in weekend.
     */
    weekendSecondDayField: 'WeekendSecondDay',
    /**
     * @cfg {String} defaultAvailabilityField The name of the fields specifying the calendar default availability
     */
    defaultAvailabilityField: 'DefaultAvailability',
    /**
     * @cfg {String} daysField The name of the fields specifying the calendar content ({@link Gnt.data.Calendar} instance)
     */
    daysField: 'Days',
    /**
     * @cfg {String} calendarClassField The name of the fields specifying the class that should be used to
     * to create {@link Gnt.data.Calendar the calendar} instance
     */
    calendarClassField: 'CalendarClass',
    /**
     * @cfg {String} phantomIdField The name of the field specifying the phantom id when this record is being 'realized' by the server.
     */
    phantomIdField: 'PhantomId',
    /**
     * @cfg {String} phantomParentIdField The name of the field specifying the parent calendar phantom id when this record is being 'realized' by the server.
     */
    phantomParentIdField: 'PhantomParentId',
    customizableFields: [
        {
            name: 'Name'
        },
        {
            name: 'DaysPerMonth',
            type: 'number'
        },
        {
            name: 'DaysPerWeek',
            type: 'number'
        },
        {
            name: 'HoursPerDay',
            type: 'number'
        },
        {
            name: 'WeekendsAreWorkdays',
            type: 'boolean'
        },
        {
            name: 'WeekendFirstDay',
            type: 'integer'
        },
        {
            name: 'WeekendSecondDay',
            type: 'integer'
        },
        {
            name: 'DefaultAvailability'
        },
        {
            name: 'Days'
        },
        {
            name: 'CalendarClass',
            defaultValue: 'Gnt.data.Calendar'
        },
        {
            name: 'PhantomId'
        },
        {
            name: 'PhantomParentId'
        }
    ],
    constructor: function(config, id, node) {
        var cfg = config || node || {};
        var days = cfg.calendar || cfg.Days;
        config && delete config.calendar;
        node && delete node.calendar;
        // keep originally provided fields
        this.rawConfig = Ext.apply({}, config);
        this.callParent(arguments);
        this.setDays(days);
        this.data[this.phantomIdField] = this.getId();
    },
    get: function(field) {
        if (field === 'Days') {
            return this.getCalendar() || this.data[this.daysField];
        } else {
            return this.callParent(arguments);
        }
    },
    set: function(field, value) {
        if (field === 'Days') {
            if (value instanceof Gnt.data.Calendar) {
                this.setCalendar(value);
            } else {
                this.data[this.daysField] = value;
            }
        } else {
            return this.callParent(arguments);
        }
    },
    /**
     * Gets a calendar assigned to the record.
     */
    getCalendar: function() {
        return this.calendar;
    },
    /**
     * @private
     * Assign a calendar to the record.
     * @param {Gnt.data.Calendar} calendar The calendar to assign.
     */
    setCalendar: function(calendar) {
        this.calendar = calendar;
    },
    getCalendarConfig: function() {
        var me = this;
        var config = {
                calendarId: me.getId(),
                parent: me.parentNode && me.parentNode.getCalendar()
            };
        // properties we map to the calendar being created
        var properties = [
                'daysPerMonth',
                'daysPerWeek',
                'hoursPerDay',
                'name',
                'weekendFirstDay',
                'weekendSecondDay',
                'weekendsAreWorkdays',
                'defaultAvailability'
            ];
        for (var i = 0,
            l = properties.length; i < l; i++) {
            var property = properties[i];
            // we map only properties that were explicitly provided to the model constructor
            // to give calendar class ability to retrieve others from prototype or parent calendars
            if (me[property + 'Field'] in me.rawConfig) {
                // a customizable field getter
                var getterName = 'get' + Ext.String.capitalize(property);
                config[property] = me[getterName]();
            }
        }
        return config;
    },
    getModelConfig: function(calendar, isPrototype) {
        var result = {};
        // if we retrieve data from class prototype we should not
        // set reference to "calendar" instance ..since "calendar" is not an instance really
        if (!isPrototype) {
            result.parentId = calendar.parent && calendar.parent.calendarId;
            result.calendar = calendar;
        }
        result[this.daysPerMonthField] = calendar.daysPerMonth;
        result[this.daysPerWeekField] = calendar.daysPerWeek;
        result[this.hoursPerDayField] = calendar.hoursPerDay;
        result[this.nameField] = calendar.name;
        result[this.weekendFirstDayField] = calendar.weekendFirstDay;
        result[this.weekendSecondDayField] = calendar.weekendSecondDay;
        // the following two options might be inherited from the calendar parents
        // in this case they should be omitted in the model configuration
        if (calendar.hasOwnProperty('weekendsAreWorkdays')) {
            result[this.weekendsAreWorkdaysField] = calendar.weekendsAreWorkdays;
        }
        if (calendar.hasOwnProperty('defaultAvailability')) {
            result[this.defaultAvailabilityField] = calendar.defaultAvailability;
        }
        result[this.calendarClassField] = Ext.getClassName(calendar);
        return result;
    },
    setCalendarManager: function(calendarManager) {
        this.calendarManager = calendarManager;
    },
    getCalendarManager: function() {
        return this.calendarManager;
    },
    getParentCalendarClass: function() {
        var parent = this.parentNode,
            result;
        while (parent && !result) {
            result = parent.getCalendarClass();
            parent = parent.parentNode;
        }
        return result;
    },
    fillDataFromPrototype: function(nodeData) {
        // try to get proper calendar class:
        //  1. from the "nodeData" itself
        var cls = nodeData[this.calendarClassField] || //  2. from this.treeStore if presented
            this.treeStore && this.treeStore.getCalendarClass() || //  2. from "this" or its parents ("this" is supposed to become the "nodeData" parent)
            this.getCalendarClass() || this.getParentCalendarClass() || this.getField(this.calendarClassField).getDefaultValue();
        if (cls) {
            if (!nodeData[this.calendarClassField])  {
                nodeData[this.calendarClassField] = cls;
            }
            
            var children = nodeData.children;
            if (children && children.length) {
                for (var i = 0; i < children.length; i++) {
                    this.fillDataFromPrototype(children[i]);
                }
            }
        }
    },
    prepareCalendarNode: function(node) {
        // fill model fields with data retrieved from the calendar
        if (node instanceof Gnt.data.Calendar) {
            node = this.getModelConfig(node);
        }
        // .. or from associated CalendarClass prototype
        else if (Ext.isObject(node) && !(node instanceof Gnt.model.Calendar)) {
            this.fillDataFromPrototype(node);
        }
        node = this.createNode(node);
        if (this.phantom) {
            if (this.getId() !== node.data[this.phantomParentIdField]) {
                node.modified = node.modified || {};
                node.modified[this.phantomParentIdField] = node.data[this.phantomParentIdField];
                node.data[this.phantomParentIdField] = this.getId();
            }
        }
        return node;
    }
}, function() {
    // Do this first to be able to override NodeInterface methods
    Ext.data.NodeInterface.decorate(this);
    this.override({
        // @OVERRIDE
        insertBefore: function(node) {
            node = this.prepareCalendarNode(node);
            return this.callParent(arguments);
        },
        // @OVERRIDE
        appendChild: function(node) {
            if (node instanceof Array) {
                for (var i = 0; i < node.length; i++) {
                    node[i] = this.prepareCalendarNode(node[i]);
                }
            } else {
                node = this.prepareCalendarNode(node);
            }
            return this.callParent(arguments);
        }
    });
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.model.CalendarDay
@extends Sch.model.Customizable

A model representing a single day in the calendar. Depending from the `Type` field, day may be a concrete day per se (2012/01/01),
a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
(all Fridays between 2012/01/01 - 2012/01/15, inclusive).

A collection CalendarDay instances is supposed to be provided for the {@link Sch.data.Calendar calendar}

Fields
------

- `Id`   - The id of the date. Can be an arbitrary unique value, assigned by the server. For backward compatibility, if this field has one of the special formats
then some data will be extracted from it. This behavior will be kept for several coming releases, but you should not rely on it anymore.
- `Type` - The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:
    - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only.
    The date is stored in the `Date` field.
    - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the `Weekday` field (0 - Sunday, 1 - Monday and so on).
    For example - all Fridays. `Date` field is ignored.
    - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15.
    Week day index should be stored in the `Weekday` field again, beginning of the timespan - in the `OverrideStartDate` field and the end of timespan - in the `OverrideEndDate`.
    </p>
    <p>
    A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance
    to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every weekday - if some day is not defined - the
    default availability will be used.
    </p>
    <p>
    * **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same
    values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for `Weekday`. Also, the timespans of all week overrides should not intersect.
    </p>
    <p>
    To avoid manual creation of week overrides you can use the calendar API (for example, {@link Sch.data.Calendar#addNonStandardWeek addNonStandardWeek},
    {@link Sch.data.Calendar#removeNonStandardWeek removeNonStandardWeek} methods).
    </p>

- `Date` - the date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this instance
  represents a weekday or week override, this field will be ignored.
- `Weekday` - the index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
Should be set to -1 for the "main" instance of the week overrides.
- `OverrideStartDate` - The start date of the timespan for week day override.
- `OverrideEndDate` - The end date of the timespan for week day override.
- `Name` - optional name of the day (holiday name for example)
- `Cls` - optional name of the CSS class, which can be used by various plugins working with weekends and holidays. Default value is `gnt-holiday`
If a holiday lasts for several days, then all days should have the same `Cls` value.
- `IsWorkingDay` - optional boolean flag, allowing you to specify exceptions - working days which falls on weekends. Default value is `false`. **Please note**, that simply setting this
field to "true" is not enough - you also need to specify the exact hours that are available for work with the `Availability` field (see below).
- `Availability` - should be an array of strings, containing the hourly availability for this day. Strings should have the following format:

        // two working intervals
        [ '08:00-12:00', '13:00-17:00' ]

        // whole 24 hours are available
        [ '00:00-24:00' ]
* **Please note**, that this field overrides the `IsWorkingDay` - for example, a day with "IsWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered as
working day.

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

*/
Ext.define('Sch.model.CalendarDay', {
    requires: [
        'Ext.data.Types'
    ],
    extend: 'Sch.model.Customizable',
    idProperty: 'Id',
    customizableFields: [
        /**
         * @method getDate
         *
         * Returns the value of the `Date` field
         *
         * @return {Date} The date of this calendar day
         */
        {
            name: 'Date',
            type: 'date',
            dateFormat: 'c',
            persist: true,
            convert: function(value, record) {
                if (!value)  {
                    return;
                }
                
                var converted = Ext.data.Types.DATE.convert.call(this, value);
                if (converted) {
                    Ext.Date.clearTime(converted);
                }
                return converted;
            }
        },
        /**
         * @method getWeekday
         *
         * Returns the value of the `Weekday` field
         *
         * @return {Number} The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        /**
         * @method setWeekday
         *
         * Sets value of the `Weekday` field
         *
         * @param {Number} weekday The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        {
            name: 'Weekday',
            type: 'int'
        },
        /**
         * @method getOverrideStartDate
         *
         * Returns the start date of the timespan for the week day override.
         *
         * @return {Date} The start date
         */
        /**
         * @method setOverrideStartDate
         *
         * Sets the start date of the timespan for the week day override
         *
         * @param {Date} startDate The new start date
         */
        {
            name: 'OverrideStartDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @method getOverrideEndDate
         *
         * Returns the end date of the timespan for the week day override.
         *
         * @return {Date} The end date
         */
        /**
         * @method setOverrideEndDate
         *
         * Sets the end date of the timespan for the week day override
         *
         * @param {Date} endDate The new end date
         */
        {
            name: 'OverrideEndDate',
            type: 'date',
            dateFormat: 'c'
        },
        {
            name: 'Type',
            defaultValue: 'DAY'
        },
        // 'DAY', 'WEEKDAY', 'WEEKDAYOVERRIDE'
        {
            name: 'IsWorkingDay',
            type: 'boolean',
            defaultValue: false
        },
        /**
         * @method getCls
         *
         * Gets the "class" of the day
         *
         * @return {String} cls The "class" of the day
         */
        /**
         * @method setCls
         *
         * Sets the CSS class of the day, used when visualised in the UI
         *
         * @param {String} cls The new class of the day
         */
        {
            name: 'Cls',
            defaultValue: 'sch-nonworkingtime'
        },
        /**
         * @method getName
         *
         * Gets the "name" of the day
         *
         * @return {String} name The "name" of the day
         */
        /**
         * @method setName
         *
         * Sets the "name" of the day
         *
         * @param {String} name The new name of the day
         */
        'Name',
        // [ '08:00-12:00', '13:00-17:00' ]
        {
            name: 'Availability',
            persist: true,
            convert: function(value, record) {
                if (value) {
                    return typeof value === 'string' ? [
                        value
                    ] : value;
                } else {
                    return [];
                }
            }
        }
    ],
    availabilityCache: null,
    /**
     * @cfg {String} weekDayField The name of the `Weekday` field.
     */
    weekDayField: 'Weekday',
    /**
     * @cfg {String} overrideStartDateField The name of the `OverrideStartDate` field.
     */
    overrideStartDateField: 'OverrideStartDate',
    /**
     * @cfg {String} overrideEndDateField The name of the `OverrideEndDate` field.
     */
    overrideEndDateField: 'OverrideEndDate',
    /**
     * @cfg {String} typeField The name of the `Type` field.
     */
    typeField: 'Type',
    /**
     * @cfg {String} dateField The name of the `Date` field.
     */
    dateField: 'Date',
    /**
     * @cfg {String} isWorkingDayField The name of the `IsWorkingDay` field.
     */
    isWorkingDayField: 'IsWorkingDay',
    /**
     * @cfg {String} clsField The name of the `Cls` field.
     */
    clsField: 'Cls',
    /**
     * @cfg {String} nameField The name of the `Name` field.
     */
    nameField: 'Name',
    /**
     * @cfg {String} availabilityField The name of the `Availability` field.
     */
    availabilityField: 'Availability',
    /**
     * Sets the date for this day (will clear the time part)
     * @param {Date} date
     */
    setDate: function(date) {
        if (date)  {
            date = Ext.Date.clearTime(date, true);
        }
        
        this.set(this.dateField, date);
    },
    /**
     * Clears the date for this day
     * @param {Date} date
     */
    clearDate: function() {
        this.set(this.dateField, null);
    },
    /**
     * This method returns the availability for this day. By default it will decode an array of strings '08:00-12:00' to an
     * array of objects like:
     *
            {
                startTime       : new Date(0, 0, 0, 8),
                endTime         : new Date(0, 0, 0, 12)
            }

     * You can pass the "asString" flag to disable that and just return strings.
     *
     * @param {Boolean} asString Whether to just return an array of strings, instead of objects.
     * @return {Object[]/String[]} Array of objects with "startTime", "endTime" properties.
     */
    getAvailability: function(asString) {
        var me = this;
        if (asString) {
            // Return the raw availability array with strings
            return this.get(this.availabilityField);
        }
        if (this.availabilityCache) {
            return this.availabilityCache;
        }
        var parsed = Ext.Array.map(this.get(this.availabilityField), function(value) {
                return typeof value === 'string' ? me.parseInterval(value) : value;
            });
        this.verifyAvailability(parsed);
        return this.availabilityCache = parsed;
    },
    /**
     * This method updates the availability information for this day. It accept an array of strings: '08:00-12:00', or
     * objects like:

            {
                startTime       : new Date(0, 0, 0, 8),
                endTime         : new Date(0, 0, 0, 12)
            }

     * @param {Object[]/String[]} intervals Array of availability intervals
     */
    setAvailability: function(intervals) {
        // clear cache
        this.availabilityCache = null;
        this.set(this.availabilityField, this.stringifyIntervals(intervals));
        // to trigger the `verifyAvailability`
        this.getAvailability();
    },
    verifyAvailability: function(intervals) {
        var me = this;
        intervals.sort(function(a, b) {
            return a.startTime - b.startTime;
        });
        Ext.Array.each(intervals, function(interval, i) {
            if (interval.startTime > interval.endTime) {
                throw new Error("Start time " + Ext.Date.format(interval.startTime, 'H:i') + " is greater than end time " + Ext.Date.format(interval.endTime, 'H:i'));
            }
            if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
                throw new Error("Availability intervals should not intersect: [" + me.stringifyInterval(intervals[i - 1]) + "] and [" + me.stringifyInterval(interval) + "]");
            }
        });
    },
    prependZero: function(value) {
        return value < 10 ? '0' + value : value;
    },
    stringifyInterval: function(interval) {
        var startTime = interval.startTime;
        var endTime = interval.endTime;
        return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' + (endTime.getDate() == 1 ? 24 : this.prependZero(endTime.getHours())) + ':' + this.prependZero(endTime.getMinutes());
    },
    stringifyIntervals: function(intervals) {
        var me = this;
        return Ext.Array.map(intervals, function(interval) {
            if (typeof interval === 'string')  {
                return interval;
            }
            
            return me.stringifyInterval(interval);
        });
    },
    parseInterval: function(string) {
        var match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);
        if (!match)  {
            throw "Invalid format for availability string: " + string + ". It should have exact format: hh:mm-hh:mm";
        }
        
        return {
            startTime: new Date(0, 0, 0, match[1], match[2]),
            endTime: new Date(0, 0, 0, match[3], match[4])
        };
    },
    /**
     * Returns the total length of all availability intervals for this day in hours.
     *
     * @return {Number}
     */
    getTotalHours: function() {
        return this.getTotalMS() / 1000 / 60 / 60;
    },
    /**
     * Returns the total length of all availability intervals for this day in milliseconds.
     *
     * @return {Number}
     */
    getTotalMS: function() {
        var totalMS = 0;
        Ext.Array.each(this.getAvailability(), function(interval) {
            totalMS += interval.endTime - interval.startTime;
        });
        return totalMS;
    },
    /**
     * Adds a new availability interval to this day. Both arguments should have the same format.
     *
     * @param {Date/String} startTime Start time of the interval. Can be a Date object (new Date(0, 0, 0, 8)) or just a plain string: '08'
     * @param {Date/String} endTime End time of the interval. Can be a Date object (new Date(0, 0, 0, 12)) or just a plain string: '12'
     */
    addAvailabilityInterval: function(startTime, endTime) {
        var interval;
        if (startTime instanceof Date) {
            interval = {
                startTime: startTime,
                endTime: endTime
            };
        } else {
            interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
        }
        var intervals = this.getAvailability().concat(interval);
        this.verifyAvailability(intervals);
        this.setAvailability(intervals);
    },
    /**
     * Removes the availability interval by its index.
     *
     * @param {Number} index Ordinal position of the interval to be removed
     */
    removeAvailabilityInterval: function(index) {
        var intervals = this.getAvailability();
        intervals.splice(index, 1);
        this.setAvailability(intervals);
    },
    /**
     * Applies the availability intervals to a concrete day. For example the availability intervals [ '08:00-12:00', '13:00-17:00' ],
     * applied to a day 2012/01/01 will return the following result:
     *
    [
        {
            startDate       : new Date(2012, 0, 1, 8),
            endDate         : new Date(2012, 0, 1, 12)
        },
        {
            startDate       : new Date(2012, 0, 1, 13),
            endDate         : new Date(2012, 0, 1, 17)
        }
    ]

     *
     * @param {Date} date The date to apply the intervals to
     *
     * @returns {Object[]} Array of objects with "startDate / endDate" properties.
     */
    getAvailabilityIntervalsFor: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        var year = timeDate.getFullYear();
        var month = timeDate.getMonth();
        var date = timeDate.getDate();
        return Ext.Array.map(this.getAvailability(), function(interval) {
            var endDate = interval.endTime.getDate();
            return {
                startDate: new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
                endDate: new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())
            };
        });
    },
    /**
     * Returns the earliest available time for the given date. If this day has no availability intervals it returns `null`.
     *
     * @param {Date} date The date to get the earliest availability time for.
     *
     * @return {Date}
     */
    getAvailabilityStartFor: function(timeDate) {
        var intervals = this.getAvailabilityIntervalsFor(timeDate);
        if (!intervals.length) {
            return null;
        }
        return intervals[0].startDate;
    },
    /**
     * Returns the latest available time for the given date. If this day has no availability intervals, it returns `null`.
     *
     * @param {Date} date The date to get the latest availability time for.
     *
     * @return {Date}
     */
    getAvailabilityEndFor: function(timeDate) {
        var intervals = this.getAvailabilityIntervalsFor(timeDate);
        if (!intervals.length) {
            return null;
        }
        return intervals[intervals.length - 1].endDate;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.model.Range
 @extends Sch.model.Customizable

 This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.

 Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
 Please refer to documentation of those classes to become familar with the base interface of this class.

 A range has the following fields:

 - `StartDate`   - start date of the task in the ISO 8601 format
 - `EndDate`     - end date of the task in the ISO 8601 format (not inclusive)
 - `Name`        - an optional name of the range
 - `Cls`         - an optional CSS class to be associated with the range.

 The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.
 */
Ext.define('Sch.model.Range', {
    extend: 'Sch.model.Customizable',
    requires: [
        'Sch.util.Date'
    ],
    idProperty: 'Id',
    /**
     * @cfg {String} startDateField The name of the field that defines the range start date. Defaults to "StartDate".
     */
    startDateField: 'StartDate',
    /**
     * @cfg {String} endDateField The name of the field that defines the range end date. Defaults to "EndDate".
     */
    endDateField: 'EndDate',
    /**
     * @cfg {String} nameField The name of the field that defines the range name. Defaults to "Name".
     */
    nameField: 'Name',
    /**
     * @cfg {String} clsField The name of the field that holds the range "class" value (usually corresponds to a CSS class). Defaults to "Cls".
     */
    clsField: 'Cls',
    customizableFields: [
        /**
     * @method getStartDate
     *
     * Returns the range start date
     *
     * @return {Date} The start date
     */
        {
            name: 'StartDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
     * @method getEndDate
     *
     * Returns the range end date
     *
     * @return {Date} The end date
     */
        {
            name: 'EndDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
     * @method getCls
     *
     * Gets the "class" of the range
     *
     * @return {String} cls The "class" of the range
     */
        /**
     * @method setCls
     *
     * Sets the "class" of the range
     *
     * @param {String} cls The new class of the range
     */
        {
            name: 'Cls',
            type: 'string'
        },
        /**
     * @method getName
     *
     * Gets the name of the range
     *
     * @return {String} name The "name" of the range
     */
        /**
     * @method setName
     *
     * Sets the "name" of the range
     *
     * @param {String} name The new name of the range
     */
        {
            name: 'Name',
            type: 'string'
        }
    ],
    /**
     * @method setStartDate
     *
     * Sets the range start date
     *
     * @param {Date} date The new start date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setStartDate: function(date, keepDuration) {
        var endDate = this.getEndDate();
        var oldStart = this.getStartDate();
        this.beginEdit();
        this.set(this.startDateField, date);
        if (keepDuration === true && endDate && oldStart) {
            this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
        }
        this.endEdit();
    },
    /**
     * @method setEndDate
     *
     * Sets the range end date
     *
     * @param {Date} date The new end date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setEndDate: function(date, keepDuration) {
        var startDate = this.getStartDate();
        var oldEnd = this.getEndDate();
        this.beginEdit();
        this.set(this.endDateField, date);
        if (keepDuration === true && startDate && oldEnd) {
            this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
        }
        this.endEdit();
    },
    /**
     * Sets the event start and end dates
     *
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     */
    setStartEndDate: function(start, end) {
        this.beginEdit();
        this.set(this.startDateField, start);
        this.set(this.endDateField, end);
        this.endEdit();
    },
    /**
     * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
     * @return {Date[]}
     */
    getDates: function() {
        var dates = [],
            endDate = this.getEndDate();
        for (var date = Ext.Date.clearTime(this.getStartDate(), true); date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) {
            dates.push(date);
        }
        return dates;
    },
    /**
     * Iterates over the results from {@link #getDates}
     * @param {Function} func The function to call for each date
     * @param {Object} scope The scope to use for the function call
     */
    forEachDate: function(func, scope) {
        return Ext.Array.each(this.getDates(), func, scope);
    },
    /**
     * Checks if the range record has both start and end dates set and start <= end
     *
     * @return {Boolean}
     */
    isScheduled: function() {
        var me = this;
        return Boolean(me.getStartDate() && me.getEndDate() && me.areDatesValid());
    },
    // Simple check if end date is greater than start date
    isValid: function() {
        var me = this,
            result = me.callParent(),
            start, end;
        if (result) {
            start = me.getStartDate() , end = me.getEndDate();
            result = !start || !end || (end - start >= 0);
        }
        return result;
    },
    // Simple check if just end date is greater than start date
    areDatesValid: function() {
        var me = this,
            start = me.getStartDate(),
            end = me.getEndDate();
        return !start || !end || (end - start >= 0);
    },
    /**
     * Shift the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
     * @param {Number} amount The amount to shift
     */
    shift: function(unit, amount) {
        this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), unit, amount), Sch.util.Date.add(this.getEndDate(), unit, amount));
    },
    fullCopy: function() {
        return this.copy.apply(this, arguments);
    },
    intersectsRange: function(start, end) {
        var myStart = this.getStartDate();
        var myEnd = this.getEndDate();
        return myStart && myEnd && Sch.util.Date.intersectSpans(myStart, myEnd, start, end);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin eliminates differences between flat/tree store in get by [internal] id functionality and it should be
 * mixed into data model stores.
 *
 * It adds two methods {@link #getModelById getModelById()} and {@link #getModelByInternalId getModelByInternalId()}
 * which should be used everywhere in the code instead of native getById() / getByInternalId() methods.
 *
 * @private
 */
Ext.define('Sch.data.mixin.UniversalModelGetter', {
    getModelById: function(id) {
        var me = this;
        return me.getNodeById ? me.getNodeById(id) : me.getById(id);
    },
    getModelByInternalId: function(id) {
        var me = this;
        return me.byInternalIdMap ? me.byInternalIdMap[id] : me.getByInternalId(id);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Robo.data.Store

This is a mixin for your data stores, enabling integration with the Robo undo/redo framework.
It should be included in your store classes as any other mixin:

    Ext.define('Example.store.Branch', {
        extend      : 'Ext.data.Store',
        
        mixins      : { robo : 'Robo.data.Store' },
        
        ...
    });

With this mixin, {@link Robo.Manager} will call various "hook" methods of the store, notifying it about
the current state of the data flow, like {@link #beforeUndoRedo}, {@link #afterUndoRedo}.  

The Store might override those methods, for example to turn off/on cache recalculation or other additional
processing during the execution of the transaction.

*/
Ext.define('Robo.data.Store', {
    extend: 'Ext.Mixin',
    requires: [
        'Ext.util.Observable'
    ],
    undoRedoPostponed: null,
    inUndoRedoTransaction: false,
    undoRedoEventBus: null,
    /**
     * This is an important part of undo/redo management, it allows an undo/redo manager to always be notified about
     * low-level events of a store.
     */
    mixinConfig: {
        before: {
            constructor: 'constructor',
            destroy: 'destroy',
            fireEventArgs: 'fireEventArgs',
            setRoot: 'beforeSetRoot',
            fillNode: 'beforeFillNode'
        },
        after: {
            setRoot: 'afterSetRoot',
            fillNode: 'afterFillNode'
        }
    },
    constructor: function() {
        var me = this;
        me.undoRedoEventBus = new Ext.util.Observable();
    },
    destroy: function() {
        Ext.destroy(this.undoRedoEventBus);
    },
    fireEventArgs: function(eventName, args) {
        var me = this;
        // HACK:
        // Args is an array (i.e. passes by reference) we will use it to mark it as being fired already
        // by undo/redo event bus by adding a private property to it, otherwise we will be firing the same event
        // twice if/when the event is suspended on the original bus, queued and then fired again upon resuming.
        // Since the same args array might be used several times (in 'before' event and 'normal' event, for example),
        // we do not use just boolean flag, instead we use a map with event names as keys.
        if (!args.hasOwnProperty('$undoRedoEventBusFired')) {
            args.$undoRedoEventBusFired = {};
        }
        if (!args.$undoRedoEventBusFired[eventName]) {
            args.$undoRedoEventBusFired[eventName] = true;
            me.undoRedoEventBus.hasListener(eventName) && me.undoRedoEventBus.fireEventArgs(eventName, args);
        }
    },
    /**
     * Checks whether an undo/redo transaction is currently in progress. Not to be confused
     * with the {@link #isUndoingOrRedoing}
     *
     * @return {Boolean}
     */
    isInUndoRedoTransaction: function() {
        return this.inUndoRedoTransaction;
    },
    /**
     * Called by undo/redo manager when starting a new undo/redo transaction
     *
     * @param {Robo.Manager} manager
     * @param {Robo.Transaction} transaction
     */
    onUndoRedoTransactionStart: function(manager, transaction) {
        this.inUndoRedoTransaction = true;
    },
    /**
     * Called by undo/redo manager when finishing an undo/redo transaction
     *
     * @param {Robo.Manager} manager
     * @param {Robo.Transaction} transaction
     */
    onUndoRedoTransactionEnd: function(manager, transaction) {
        this.inUndoRedoTransaction = false;
    },
    /**
     * Checks wheither a previously recorded undo/redo transaction is being rolled back or replayed.
     *
     * @return {Boolean}
     */
    isUndoingOrRedoing: function() {
        return !!this.undoRedoPostponed;
    },
    /**
     * Called by undo manager before executing a previously recorded undo/redo transaction
     *
     * @param {Robo.Manager} manager
     */
    beforeUndoRedo: function(manager) {
        this.undoRedoPostponed = [];
    },
    /**
     * Called by undo manager after executing a previously recorded undo/redo transaction
     *
     * @param {Robo.Manager} manager
     */
    afterUndoRedo: function(manager) {
        var me = this;
        Ext.Array.forEach(me.undoRedoPostponed, function(fn) {
            fn();
        });
        me.undoRedoPostponed = null;
    },
    /**
     * Store might use this method to postpone code execution to the moment right before undo/redo transaction is
     * done. The code postponed will be called right before the call to the {@link afterUndoRedo()} method.
     *
     * @param {Function} fn A code to postpone
     */
    postponeAfterUndoRedo: function(fn) {
        Ext.Assert && Ext.Assert.isFunction(fn, 'Parameter must be a function');
        this.undoRedoPostponed.push(fn);
    },
    beforeSetRoot: function() {
        this.__isSettingRoot = true;
    },
    afterSetRoot: function() {
        this.__isSettingRoot = false;
        // https://www.sencha.com/forum/showthread.php?307767-TreeStore-removeAll-doesn-t-fire-quot-clear-quot&p=1124119#post1124119
        if (!this.getRoot()) {
            this.fireEvent('clear', this);
        }
    },
    beforeFillNode: function(node) {
        if (node.isRoot())  {
            this.beforeSetRoot();
        }
        
    },
    afterFillNode: function(node) {
        if (node.isRoot())  {
            this.afterSetRoot();
        }
        
    },
    /**
     * Returns true if this store is in process of loading/filling the root node
     *
     * @return {Boolean}
     */
    isRootSettingOrLoading: function() {
        return this.isLoading() || (this.isTreeStore && this.__isSettingRoot);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.data.Calendar
@extends Ext.data.Store
@aside guide gantt_calendars

A class representing a customizable calendar with weekends, holidays and availability information for any day.
Internally, it's just a subclass of the Ext.data.Store class which should be loaded with a collection
of {@link Sch.model.CalendarDay} instances. Additionally, calendars may have parent-child relations, allowing "child" calendars to "inherit"
all special dates from its "parent" and add its own. See {@link #parent} property for details.

A calendar can be instantiated like this:

    var calendar        = new Sch.data.Calendar({
        data    : [
            {
                Date            : new Date(2010, 0, 13),
                Cls             : 'national-holiday'
            },
            {
                Date            : new Date(2010, 1, 1),
                Cls             : 'company-holiday'
            },
            {
                Date            : new Date(2010, 0, 16),
                IsWorkingDay    : true
            }
        ]
    });

Please refer to the {@link Sch.model.CalendarDay} class to learn the data model used for the calendar.

*/
Ext.define('Sch.data.Calendar', {
    extend: 'Ext.data.Store',
    alias: 'store.calendar',
    requires: [
        'Ext.Date',
        'Sch.model.CalendarDay',
        'Sch.model.Range',
        'Sch.util.Date'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Robo.data.Store'
    ],
    model: 'Sch.model.CalendarDay',
    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     *
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth: 30,
    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     *
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek: 7,
    /**
     * Number of hours per day. Will be used when converting the duration in days to hours.
     *
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     *
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay: 24,
    unitsInMs: null,
    defaultNonWorkingTimeCssCls: 'sch-nonworkingtime',
    /**
     * @cfg {Boolean} weekendsAreWorkdays Setting this option to `true` will treat *all* days as working. Default value is `false`.
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Number} weekendFirstDay The index of the first day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 6 - Saturday
     */
    weekendFirstDay: 6,
    /**
     * @cfg {Number} weekendSecondDay The index of the second day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 0 - Sunday
     */
    weekendSecondDay: 0,
    holidaysCache: null,
    availabilityIntervalsCache: null,
    daysIndex: null,
    // a "cached" array of WEEKDAY days
    weekAvailability: null,
    // the "very default" availability array, calculated based on `defaultAvailability` property
    defaultWeekAvailability: null,
    nonStandardWeeksByStartDate: null,
    nonStandardWeeksStartDates: null,
    /**
     * @cfg {String} calendarId The unique id for the calendar. Providing a `calendarId` will register this calendar in the calendars registry
     * and it can be retrieved later with {@link #getCalendar}. Generally only required if want to use {@link #parent parent-child relations} between the calendars,
     * or assign this calendar to a particular task or resource.
     *
     * Note, that when loading the calendar using ExtJS proxy this field will not be set.
     */
    calendarId: null,
    /**
     * @cfg {String/Sch.data.Calendar} parent The parent calendar. Can be provided as the calendar id or calendar instance itself. If this property is provided
     * or set with {@link #setParent} method, this calendar becomes a "child" of the specified calendar. This means that it will "inherit" all day overrides, week days and
     * week day overrides from its "parent". In the same time, special days, defined in this calendar take priority over the ones from the "parent".
     *
     * You can use this feature if you'd like to create a single "main" calendar for the whole project, and then allow some task or resource to
     * have slightly different calendar (with an additional day off for example). You will not have to re-create all special days in the calendar of such task/resource - just
     * set the "main" calendar as a "parent" for it.
     */
    parent: null,
    /**
     * @cfg {String[]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Sch.model.CalendarDay}) for each working weekday (Monday-Friday). Defaults to whole day (00-24) for backward compatibility.
     */
    defaultAvailability: [
        '00:00-24:00'
    ],
    /**
     * @cfg {String} name The name of this calendar
     */
    name: null,
    suspendCacheUpdate: 0,
    /**
    * @cfg {Number} availabilitySearchLimit Maximum number of days to search for calendar availability intervals.
    * Used in various calculations requiring to respect working time.
    * In these cases system iterate through working time day by day. This option determines a maximum distance iteration will be done.
    * Prevents from infinite loop in case of wrong calendar configuration.
    */
    availabilitySearchLimit: 1825,
    //5*365
    inheritableStatics: {
        /**
         * Returns the registered calendar with the given id.
         *
         * @param {String} id The calendar id
         * @return {Sch.data.Calendar}
         */
        getCalendar: function(id) {
            if (id instanceof Sch.data.Calendar)  {
                return id;
            }
            
            return Ext.data.StoreManager.lookup('GNT_CALENDAR:' + id);
        },
        /**
         * Returns an array of all registered calendars.
         *
         * @return {Sch.data.Calendar[]}
         */
        getAllCalendars: function() {
            var result = [];
            Ext.data.StoreManager.each(function(store) {
                if (store instanceof Sch.data.Calendar) {
                    result.push(store);
                }
            });
            return result;
        },
        /**
         * Destroys all registered calendars.
         *
         * @return {Sch.data.Calendar[]}
         */
        removeAll: function() {
            var sm = Ext.data.StoreManager;
            sm.each(function(store) {
                if (store instanceof Sch.data.Calendar) {
                    sm.unregister(store);
                    Ext.destroy(store);
                }
            });
        }
    },
    constructor: function(config) {
        config = config || {};
        var parent = config.parent;
        delete config.parent;
        var calendarId = config.calendarId;
        delete config.calendarId;
        this.callParent(arguments);
        this.setParent(parent);
        this.setCalendarId(calendarId);
        this.unitsInMs = {
            MILLI: 1,
            SECOND: 1000,
            MINUTE: 60 * 1000,
            HOUR: 60 * 60 * 1000,
            DAY: this.hoursPerDay * 60 * 60 * 1000,
            WEEK: this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000,
            MONTH: this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            QUARTER: 3 * this.daysPerMonth * 24 * 60 * 60 * 1000,
            YEAR: 4 * 3 * this.daysPerMonth * 24 * 60 * 60 * 1000
        };
        this.defaultWeekAvailability = this.getDefaultWeekAvailability();
        // traditional "on-demand" caching seems to be not so efficient for calendar (in theory)
        // calculating any cached property, like, "weekAvailability" or "nonStandardWeeksStartDates" will require full calendar scan each time
        // so we update ALL cached values on any CRUD operations
        this.on({
            // TODO ignore changes of "Name/Cls" field?
            update: this.clearCache,
            datachanged: this.clearCache,
            clear: this.clearCache,
            scope: this
        });
        this.clearCache();
    },
    /**
     * Returns the {@link #calendarId} of the current calendar
     * @return {String}
     */
    getCalendarId: function() {
        return this.calendarId;
    },
    /**
     * Sets the {@link #calendarId} of the current calendar and register it in the calendar registry.
     *
     * @param {String} id
     */
    setCalendarId: function(id) {
        // allow "0" as the calendarId
        if (this.calendarId != null)  {
            Ext.data.StoreManager.unregister(this);
        }
        
        this.calendarId = id;
        if (id != null) {
            this.storeId = 'GNT_CALENDAR:' + id;
            Ext.data.StoreManager.register(this);
        } else  {
            this.storeId = null;
        }
        
        var proxy = this.proxy;
        if (proxy && proxy.extraParams)  {
            proxy.extraParams.calendarId = id;
        }
        
    },
    getDefaultWeekAvailability: function() {
        var availability = this.defaultAvailability;
        var weekendFirstDay = this.weekendFirstDay;
        var weekendSecondDay = this.weekendSecondDay;
        var res = [];
        for (var i = 0; i < 7; i++) {
            res.push(this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay ? new this.model({
                Type: 'WEEKDAY',
                Weekday: i,
                Availability: availability && availability.slice() || [],
                IsWorkingDay: true
            }) : new this.model({
                Type: 'WEEKDAY',
                Weekday: i,
                Availability: []
            }));
        }
        return res;
    },
    // will scan through all calendar days in the store and save references to special ones to the properties, for speedup
    clearCache: function() {
        if (this.suspendCacheUpdate > 0)  {
            return;
        }
        
        this.holidaysCache = {};
        this.availabilityIntervalsCache = {};
        var daysIndex = this.daysIndex = {};
        var weekAvailability = this.weekAvailability = [];
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates = [];
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate = {};
        this.each(function(calendarDay) {
            // backward compat
            var id = calendarDay.getId();
            var overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id);
            var weekDayMatch = /^WEEKDAY:(\d+)$/.exec(id);
            var type = calendarDay.getType();
            var weekDay = calendarDay.getWeekday();
            if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
                var startDate, endDate;
                if (type == 'WEEKDAYOVERRIDE') {
                    startDate = calendarDay.getOverrideStartDate();
                    endDate = calendarDay.getOverrideEndDate();
                }
                // backward compat
                if (overrideMatch) {
                    startDate = Ext.Date.parse(overrideMatch[2], 'Y/m/d');
                    endDate = Ext.Date.parse(overrideMatch[3], 'Y/m/d');
                    weekDay = overrideMatch[1];
                }
                // allow partially defined days - they will not be included in calculations
                if (startDate && endDate && weekDay != null) {
                    var startDateNum = startDate - 0;
                    if (!nonStandardWeeksByStartDate[startDateNum]) {
                        nonStandardWeeksByStartDate[startDateNum] = {
                            startDate: new Date(startDate),
                            endDate: new Date(endDate),
                            name: calendarDay.getName(),
                            weekAvailability: [],
                            // main day representing the week override itself - for example for overrides w/o any re-defined availability
                            mainDay: null
                        };
                        nonStandardWeeksStartDates.push(startDateNum);
                    }
                    if (weekDay >= 0)  {
                        nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
                    }
                    else  {
                        nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
                    }
                    
                }
            } else if (type == 'WEEKDAY' || weekDayMatch) {
                if (weekDayMatch)  {
                    weekDay = weekDayMatch[1];
                }
                
                // again - only fully defined records will be taken into account
                if (weekDay != null) {
                    if (weekDay < 0 || weekDay > 6) {
                        throw new Error("Incorrect week day index");
                    }
                    weekAvailability[weekDay] = calendarDay;
                }
            } else {
                var date = calendarDay.getDate();
                if (date)  {
                    daysIndex[date - 0] = calendarDay;
                }
                
            }
        });
        // Numeric sort, can't use default JS sort which is string based
        nonStandardWeeksStartDates.sort(function(a, b) {
            return a - b;
        });
        this.fireEvent('calendarchange', this);
    },
    /**
     * Returns `true` or `false` depending whether the given time span intersects with one of the defined week day overrides.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     *
     * @return {Boolean}
     */
    intersectsWithCurrentWeeks: function(startDate, endDate) {
        var result = false;
        this.forEachNonStandardWeek(function(week) {
            var weekStartDate = week.startDate;
            var weekEndDate = week.endDate;
            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    },
    /**
     * Adds a week day override ("non-standard" week) to the calendar. As a reminder, week day override consists from up to 7 days,
     * that re-defines the default week days availability only within certain time span.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     * @param {Sch.model.CalendarDay[]/String[][]} weekAvailability The array indexed from 0 to 7, containing items for week days.
     * Index 0 corresponds to Sunday, 1 to Monday, etc. Some items can be not defined or set to `null`, indicating that override does not
     * change this week day. Item can be - an instance of {@link Sch.model.CalendarDay} (only `Availability` field needs to be set), or
     * an array of strings, defining the availability (see the description of the `Availability` field in the {@link Sch.model.CalendarDay}).
     * @param {String} name The name of this week day override
     */
    addNonStandardWeek: function(startDate, endDate, weekAvailability, name) {
        startDate = Ext.Date.clearTime(new Date(startDate));
        endDate = Ext.Date.clearTime(new Date(endDate));
        if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
            throw new Error("Can not add intersecting week");
        }
        var DayModel = this.model;
        var days = [];
        Ext.Array.each(weekAvailability, function(day, index) {
            if (day instanceof Sch.model.CalendarDay) {
                day.setType('WEEKDAYOVERRIDE');
                day.setOverrideStartDate(startDate);
                day.setOverrideEndDate(endDate);
                day.setWeekday(index);
                day.setName(name || 'Week override');
                days.push(day);
            } else if (Ext.isArray(day)) {
                var newDay = new DayModel();
                newDay.setType('WEEKDAYOVERRIDE');
                newDay.setOverrideStartDate(startDate);
                newDay.setOverrideEndDate(endDate);
                newDay.setWeekday(index);
                newDay.setName(name || 'Week override');
                newDay.setAvailability(day);
                days.push(newDay);
            }
        });
        var mainDay = new DayModel();
        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);
        mainDay.setName(name || 'Week override');
        days.push(mainDay);
        this.add(days);
    },
    /**
     * Returns an object describing a week day override ("non-standard" week), that starts at the given date or `null` if there's no any.
     *
     * @param {Date} startDate The start date of the week day override
     *
     * @return {Object} An object with the following properties
     * @return {Object} return.name A "Name" field of the week days in the override
     * @return {Date} return.startDate An "OverrideStartDate" field of the week days in the override
     * @return {Date} return.endDate An "OverrideEndDate" field of the week days in the override
     * @return {Sch.model.CalendarDay[]} return.weekAvailability An array with the week days, defined by this override. May be filled only partially if
     * week day override does not contain all days.
     * @return {Sch.model.CalendarDay} return.mainDay A "main" day instance for this override
     */
    getNonStandardWeekByStartDate: function(startDate) {
        return this.nonStandardWeeksByStartDate[Ext.Date.clearTime(new Date(startDate)) - 0] || null;
    },
    /**
     * Returns an object describing a week day override ("non-standard" week), that contains the given date or `null` if there's no any.
     *
     * @param {Date} startDate The date that falls within some of the week day overrides
     *
     * @return {Object} An object describing week day override. See {@link #getNonStandardWeekByStartDate} method for details.
     */
    getNonStandardWeekByDate: function(timeDate) {
        timeDate = Ext.Date.clearTime(new Date(timeDate)) - 0;
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
        for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
            var week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];
            // since `nonStandardWeeksStartDates` are sorted inc and week overrides do not intersect
            // we can shorcut in this case
            if (week.startDate > timeDate)  {
                break;
            }
            
            if (week.startDate <= timeDate && timeDate <= week.endDate) {
                return week;
            }
        }
        return null;
    },
    /**
     * Removes all calendar day instances, that forms a week day override ("non-standard" week) with the given start date.
     *
     * @param {Date} startDate The start date of the week day override
     */
    removeNonStandardWeek: function(startDate) {
        startDate = Ext.Date.clearTime(new Date(startDate)) - 0;
        var week = this.getNonStandardWeekByStartDate(startDate);
        if (!week)  {
            return;
        }
        
        this.remove(Ext.Array.clean(week.weekAvailability).concat(week.mainDay));
    },
    /**
     * Iterator for each week day override, defined in this calendar.
     *
     * @param {Function} func The function to call for each override. It will receive a single argument - object, describing the override.
     * See {@link #getNonStandardWeekByStartDate} for details. Returning `false` from the function stops the iterator.
     * @param {Object} scope The scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the function calls have returned `false`
     */
    forEachNonStandardWeek: function(func, scope) {
        var me = this;
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
        for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
            if (func.call(scope || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false)  {
                return false;
            }
            
        }
    },
    /**
     * Updates the default availability information based on the value provided.
     *
     * @param {Boolean} value true if weekends should be regarded as working time.
     */
    setWeekendsAreWorkDays: function(value) {
        if (value !== this.weekendsAreWorkdays) {
            this.weekendsAreWorkdays = value;
            // Must generate new defaultWeekAvailability
            this.defaultWeekAvailability = this.getDefaultWeekAvailability();
            this.clearCache();
        }
    },
    /**
     * Returns true if weekends are regarded as working time.
     *
     * @return {Boolean} true if weekends should be regarded as working time.
     */
    areWeekendsWorkDays: function() {
        return this.weekendsAreWorkdays;
    },
    /**
     * Returns a corresponding {@link Sch.model.CalendarDay} instance for the given date. First, this method checks for {@link #getOverrideDay day overrides}
     * (either in this or parent calendars), then for week days (again, in this or parent calendars) and finally fallbacks to the
     * calendar day with the {@link #defaultAvailability} availability.
     *
     * @param {Date} timeDate A date (can contain time portion which will be ignored)
     *
     * @return {Sch.model.CalendarDay}
     */
    getCalendarDay: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
    },
    /**
     * Returns a day override corresponding to the given date (possibly found in the parent calendars) or `null` if the given date
     * has no overrides in this calendar and all its parents.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Sch.model.CalendarDay}
     */
    getOverrideDay: function(timeDate) {
        return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
    },
    /**
     * Returns an "own" day override corresponding to the given date. That is - day override defined in the current calendar only.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Sch.model.CalendarDay}
     */
    getOwnCalendarDay: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        return this.daysIndex[Ext.Date.clearTime(timeDate, true) - 0];
    },
    /**
     * Returns a "special" week day corresponding to the given date. Under "special" week day we mean a calendar day with the `Type = WEEKDAY` or `WEEKDAYOVERRIDE`.
     * See the {@link Sch.model.CalendarDay} class for details. If the concrete date is given as 2nd argument, this method will
     * first check for any week overrides passing on it.
     *
     * If not found in current calendar, this method will consult parent. If no "special" week day found neither in this calendar, no parents - it returns `null`.
     *
     * @param {Number} weekDayIndex The index of the week day to retrieve (0-Sunday, 1-Monday, etc)
     * @param {Date} [timeDate] The date for which the week day is being retrieved.
     * @return {Sch.model.CalendarDay}
     */
    getWeekDay: function(weekDayIndex, timeDate) {
        // if 2nd argument is provided then try to search in non-standard weeks first
        if (timeDate) {
            var week = this.getNonStandardWeekByDate(timeDate);
            if (week && week.weekAvailability[weekDayIndex])  {
                return week.weekAvailability[weekDayIndex];
            }
            
        }
        return this.weekAvailability[weekDayIndex] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
    },
    /**
     * Returns a "default" calendar day instance, corresponding to the one, generated from {@link #defaultAvailability}. By default all working days in the week
     * corresponds to the day with {@link #defaultAvailability} set in the `Availability` field and non-working days has empty `Availability`.
     *
     * @param {Number} weekDayIndex The index of the "default" week day to retrieve (0-Sunday, 1-Monday, etc)
     * @return {Sch.model.CalendarDay}
     */
    getDefaultCalendarDay: function(weekDayIndex) {
        if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
            return this.parent.getDefaultCalendarDay(weekDayIndex);
        }
        return this.defaultWeekAvailability[weekDayIndex];
    },
    /**
     * Returns a boolean indicating whether a passed date falls on the weekend or holiday.
     *
     * @param {Date} timeDate A given date (can contain time portion)
     *
     * @return {Boolean}
     */
    isHoliday: function(timeDate) {
        var secondsSinceEpoch = timeDate - 0;
        var holidaysCache = this.holidaysCache;
        if (holidaysCache[secondsSinceEpoch] != null) {
            return holidaysCache[secondsSinceEpoch];
        }
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        var day = this.getCalendarDay(timeDate);
        if (!day)  {
            throw "Can't find day for " + timeDate;
        }
        
        return holidaysCache[secondsSinceEpoch] = !day.getIsWorkingDay();
    },
    /**
     * Returns `true` if given date passes on the weekend and `false` otherwise. Weekend days can be re-defined with the {@link #weekendFirstDay} and {@link #weekendSecondDay} options.
     *
     * @param {Date} timeDate The date to check
     * @return {Boolean}
     */
    isWeekend: function(timeDate) {
        var dayIndex = timeDate.getDay();
        return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
    },
    /**
     * Returns a boolean indicating whether a passed date is a working day.
     *
     * @param {Date} date A given date (can contain time portion which will be ignored)
     *
     * @return {Boolean}
     */
    isWorkingDay: function(date) {
        return !this.isHoliday(date);
    },
    /**
     * Convert the duration given in milliseconds to a given unit. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs Duration in milliseconds
     * @param {String} unit Duration unit to which the duration should be converted
     *
     * @return {Number} converted value
     */
    convertMSDurationToUnit: function(durationInMs, unit) {
        return durationInMs / this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
    },
    /**
     * Convert the duration given in some unit to milliseconds. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs
     * @param {String} unit
     *
     * @return {Number} converted value
     */
    convertDurationToMs: function(duration, unit) {
        return duration * this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
    },
    /**
     * Returns an array of ranges for non-working days between `startDate` and `endDate`. For example normally, given a full month,
     * it will return an array from 4 `Sch.model.Range` instances, containing ranges for the weekends. If some holiday lasts for several days
     * and all {@link Sch.model.CalendarDay} instances have the same `Cls` value then all days will be combined in single range.
     *
     * @param {Date} startDate - A start date of the timeframe to extract the holidays from
     * @param {Date} endDate - An end date of the timeframe to extract the holidays from
     *
     * @return {Sch.model.Range[]}
     */
    getHolidaysRanges: function(startDate, endDate, includeWeekends) {
        if (startDate > endDate) {
            Ext.Error.raise("startDate can't be bigger than endDate");
        }
        startDate = Ext.Date.clearTime(startDate, true);
        endDate = Ext.Date.clearTime(endDate, true);
        var ranges = [],
            currentRange, date;
        for (date = startDate; date < endDate; date = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1)) {
            if (this.isHoliday(date) || (this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date))) {
                var day = this.getCalendarDay(date);
                var cssClass = day && day.getCls() || this.defaultNonWorkingTimeCssCls;
                var nextDate = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1);
                // starts new range
                if (!currentRange) {
                    currentRange = new Sch.model.Range({
                        StartDate: date,
                        EndDate: nextDate,
                        Cls: cssClass
                    });
                } else {
                    // checks if the range is still the same
                    if (currentRange.getCls() == cssClass) {
                        currentRange.setEndDate(nextDate);
                    } else {
                        ranges.push(currentRange);
                        currentRange = new Sch.model.Range({
                            StartDate: date,
                            EndDate: nextDate,
                            Cls: cssClass
                        });
                    }
                }
            } else {
                if (currentRange) {
                    ranges.push(currentRange);
                    currentRange = null;
                }
            }
        }
        if (currentRange) {
            ranges.push(currentRange);
        }
        return ranges;
    },
    /**
     * This an iterator that passes through the all availability intervals (working time intervals) in the given date range.
     *
     * For example if the default availability in this calendar is [ '09:00-13:00', '14:00-18:00' ] and this function is called, like this:
     *
     *      calendar.forEachAvailabilityInterval(
     *           //             midnight  Friday                 midnight Tuesday
     *          { startDate : new Date(2013, 1, 8), endDate : new Date(2013, 1, 12) },
     *          function (startDate, endDate) { ... }
     *      )
     * then the provided function will be called 4 times with the following arguments:
     *
     *      startDate : new Date(2013, 1, 8, 9),    endDate : new Date(2013, 1, 8, 13)
     *      startDate : new Date(2013, 1, 8, 14),   endDate : new Date(2013, 1, 8, 18)
     *      startDate : new Date(2013, 1, 11, 9),   endDate : new Date(2013, 1, 11, 13)
     *      startDate : new Date(2013, 1, 11, 14),  endDate : new Date(2013, 1, 11, 18)
     *
     *
     * @param {Object} options An object with the following properties:
     * @param {Date} options.startDate A start date of the date range. Can be omitted, if `isForward` flag is set to `false`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Date} options.endDate An end date of the date range. Can be omitted, if `isForward` flag is set to `true`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Boolean} [options.isForward=true] A flag, defining the direction, this iterator advances in. If set to `true` iterations
     * will start from the `startDate` option and will advance in date increasing direction. If set to `false` iterations will start from the `endDate`
     * option and will advance in date decreasing direction.
     * @param {Function} func A function to call for each availability interval, in the given date range. It receives 2 arguments - the start date
     * of the availability interval and the end date.
     * @param {Object} scope A scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the calls to `func` has returned `false`
     */
    forEachAvailabilityInterval: function(options, func, scope) {
        scope = scope || this;
        var me = this;
        var startDate = options.startDate;
        var endDate = options.endDate;
        // isForward by default
        var isForward = options.isForward !== false;
        if (isForward ? !startDate : !endDate) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
        }
        var cursorDate = new Date(isForward ? startDate : endDate);
        var DATE = Sch.util.Date;
        // if no boundary we still have to specify some limit
        if (isForward) {
            if (!endDate) {
                endDate = DATE.add(startDate, 'd', options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365);
            }
        } else {
            if (!startDate) {
                startDate = DATE.add(endDate, 'd', -(options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365));
            }
        }
        // the Ext.Date.clearTime() method is called a lot during this method (like 200k times for 2k tasks project)
        // sometimes w/o real need for it since we always advance to the next day's boundary
        // this optimization brings it down to ~10k, ~10% speed up in the profiles
        var noNeedToClearTime = false;
        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            // - 1 for backward direction ensures that we are checking correct day,
            // since the endDate is not inclusive - 02/10/2012 means the end of 02/09/2012
            // for backward direction we always clear time, because intervals are cached by the beginning of the day
            var intervals = this.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);
            // the order of processing is different for forward / backward processing
            for (var i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
                var interval = intervals[i];
                var intervalStartDate = interval.startDate;
                var intervalEndDate = interval.endDate;
                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate >= endDate || intervalEndDate <= startDate)  {
                    
                    continue;
                }
                
                var countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate;
                var countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;
                if (func.call(scope, countingFrom, countingTill) === false)  {
                    return false;
                }
                
            }
            cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);
            noNeedToClearTime = true;
        }
    },
    /**
     * Calculate the duration in the given `unit` between 2 dates, taking into account the availability/holidays information (non-working time will be excluded from the duration).
     *
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Number} Working time duration between given dates.
     */
    calculateDuration: function(startDate, endDate, unit) {
        var duration = 0;
        this.forEachAvailabilityInterval({
            startDate: startDate,
            endDate: endDate
        }, function(intervalStartDate, intervalEndDate) {
            var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
        });
        return this.convertMSDurationToUnit(duration, unit);
    },
    /**
     * Calculate the end date for the given start date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} startDate The start date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The end date
     */
    calculateEndDate: function(startDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(startDate);
        }
        var DATE = Sch.util.Date,
            endDate;
        duration = this.convertDurationToMs(duration, unit);
        var startFrom = // milestone case, which we don't want to re-schedule to the next business days
            // milestones should start/end in the same day as its incoming dependency
            duration === 0 && Ext.Date.clearTime(startDate, true) - startDate === 0 ? DATE.add(startDate, Sch.util.Date.DAY, -1) : startDate;
        this.forEachAvailabilityInterval({
            startDate: startFrom
        }, function(intervalStartDate, intervalEndDate) {
            var diff = intervalEndDate - intervalStartDate;
            var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            if (diff >= duration) {
                endDate = new Date(intervalStartDate - 0 + duration);
                return false;
            } else {
                duration -= diff + dstDiff * 60 * 1000;
            }
        });
        return endDate;
    },
    /**
     * Calculate the start date for the given end date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} endDate The end date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The start date
     */
    calculateStartDate: function(endDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(endDate);
        }
        var startDate;
        duration = this.convertDurationToMs(duration, unit);
        this.forEachAvailabilityInterval({
            endDate: endDate,
            isForward: false
        }, function(intervalStartDate, intervalEndDate) {
            var diff = intervalEndDate - intervalStartDate;
            if (diff >= duration) {
                startDate = new Date(intervalEndDate - duration);
                return false;
            } else  {
                duration -= diff;
            }
            
        });
        return startDate;
    },
    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `isForward` flag) skiping the non-working time.
     * It returns the nearest edge of the first working time interval it encounters. If the given `date` falls on the working time, then `date` itself is returned.
     *
     * For example, if this function is called with some Saturday as `date` and `isForward` flag is set, it will return the earliest working hours on following Monday.
     * If `isForward` flag will be set to `false` - it will return the latest working hours on previous Friday.
     *
     * @param {Date} date A date (presumably falling on the non-working time).
     * @param {Boolean} isForward Pass `true` to skip the non-working time in forward direction, `false` - in backward
     *
     * @return {Date} Nearest working date.
     */
    skipNonWorkingTime: function(date, isForward) {
        var found = false;
        // reseting the date to the earliest availability interval
        this.forEachAvailabilityInterval(isForward ? {
            startDate: date
        } : {
            endDate: date,
            isForward: false
        }, function(intervalStartDate, intervalEndDate) {
            date = isForward ? intervalStartDate : intervalEndDate;
            found = true;
            return false;
        });
        if (!found)  {
            throw 'skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified';
        }
        
        return new Date(date);
    },
    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `duration` argument).
     * It stops as soon as it skips the amount of *working* time defined by the `duration` and `unit` arguments. Skipped non-working time simply will not
     * be counted.
     *
     * **Note** that this method behaves differently from the {@link #skipNonWorkingTime} - that method stops as soon as it encounters the non-working time.
     * This method stops as soon as it accumulate enough skipped working time.
     *
     * @param {Date} date A starting point
     * @param {Number} duration The duration of the working time. To skip working time in backward direction pass a negative value.
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date}
     */
    skipWorkingTime: function(date, duration, unit) {
        return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
    },
    /**
     * Returns the availability intervals of a specific day. Potentially can consult a parent calendar.
     *
     * @param {Date/Number} timeDate A date or timestamp
     * @return {Object[]} Array of objects, like:

    {
        startDate       : new Date(...),
        endDate         : new Date(...)
    }
     */
    getAvailabilityIntervalsFor: function(timeDate, noNeedToClearTime) {
        // This is more robust method of clearing time than direct call to Ext.Date.clearTime
        if (noNeedToClearTime) {
            timeDate = (timeDate).valueOf();
        } else if (timeDate instanceof Date) {
            timeDate = (new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate())).valueOf();
        } else {
            timeDate = Ext.Date.clearTime(new Date(timeDate)).valueOf();
        }
        return this.availabilityIntervalsCache[timeDate] = (this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate));
    },
    isChildOf: function(calendar) {
        var parent = this,
            found = false;
        while (parent && !found) {
            found = parent === calendar;
            parent = parent.parent;
        }
        return found;
    },
    getParentableCalendars: function() {
        var me = this,
            result = [],
            calendars = Sch.data.Calendar.getAllCalendars();
        Ext.Array.each(calendars, function(calendar) {
            if (calendar !== me && !calendar.isChildOf(me))  {
                result.push({
                    Id: calendar.calendarId,
                    Name: calendar.name || calendar.calendarId
                });
            }
            
        });
        return result;
    },
    /**
     * Sets the {@link #parent} for this calendar. Pass `null` to remove the parent.
     *
     * @param {Null/String/Sch.data.Calendar} parentOrId String with {@link #calendarId} value or calendar instance itself.
     */
    setParent: function(parentOrId) {
        var parent = Sch.data.Calendar.getCalendar(parentOrId);
        if (parentOrId && !parent)  {
            throw new Error("Invalid parent specified for the calendar");
        }
        
        if (this.parent != parent) {
            var proxy = this.proxy;
            var listeners = {
                    calendarchange: this.clearCache,
                    destroy: this.onParentDestroy,
                    scope: this
                };
            var oldParent = this.parent;
            if (oldParent)  {
                oldParent.un(listeners);
            }
            
            this.parent = parent;
            if (parent)  {
                parent.on(listeners);
            }
            
            if (proxy && proxy.extraParams)  {
                proxy.extraParams.parentId = parent ? parent.calendarId : null;
            }
            
            this.clearCache();
            /**
             * @event parentchange
             *
             * @param {Sch.data.Calendar} calendar The calendar which parent has changed
             * @param {Sch.data.Calendar} newParent The new parent of this calendar (can be `null` if parent is being removed)
             * @param {Sch.data.Calendar} oldParent The old parent of this calendar (can be `null` if there were no parent)
             */
            this.fireEvent('parentchange', this, parent, oldParent);
        }
    },
    onParentDestroy: function() {
        this.setParent(null);
    },
    isAvailabilityIntersected: function(withCalendar, startDate, endDate) {
        var ownWeekDay, ownAvailability, testWeekDay, testAvailability;
        // first let's try to find overlapping of weeks (check daily intervals)
        // loop over week days
        for (var i = 0; i < 7; i++) {
            ownWeekDay = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
            testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);
            if (!ownWeekDay || !testWeekDay)  {
                
                continue;
            }
            
            // get daily intervals
            ownAvailability = ownWeekDay.getAvailability();
            testAvailability = testWeekDay.getAvailability();
            // loop over intervals to find overlapping
            for (var j = 0,
                l = ownAvailability.length; j < l; j++) {
                for (var k = 0,
                    ll = testAvailability.length; k < ll; k++) {
                    if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
                        return true;
                    }
                }
            }
        }
        var result = false;
        this.forEachNonStandardWeek(function(week) {
            if (week.startDate >= endDate)  {
                return false;
            }
            
            if (startDate < week.endDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.CalendarDay
@extends Sch.model.CalendarDay

A model representing a single day in the calendar. Depending from the `Type` field, day may be a concrete day per se (2012/01/01),
a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
(all Fridays between 2012/01/01 - 2012/01/15, inclusive).

A collection CalendarDay instances is supposed to be provided for the {@link Gnt.data.Calendar calendar}

Fields
------

- `Id`   - The id of the date. Can be an arbitrary unique value, assigned by the server. For backward compatibility, if this field has one of the special formats
then some data will be extracted from it. This behavior will be kept for several coming releases, but you should not rely on it anymore.
- `Type` - The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:
    - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only.
    The date is stored in the `Date` field.
    - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the `Weekday` field (0 - Sunday, 1 - Monday and so on).
    For example - all Fridays. `Date` field is ignored.
    - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15.
    Week day index should be stored in the `Weekday` field again, beginning of the timespan - in the `OverrideStartDate` field and the end of timespan - in the `OverrideEndDate`.
    </p>
    <p>
    A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance
    to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every weekday - if some day is not defined - the
    default availability will be used.
    </p>
    <p>
    * **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same
    values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for `Weekday`. Also, the timespans of all week overrides should not intersect.
    </p>
    <p>
    To avoid manual creation of week overrides you can use the calendar API (for example, {@link Gnt.data.Calendar#addNonStandardWeek addNonStandardWeek},
    {@link Gnt.data.Calendar#removeNonStandardWeek removeNonStandardWeek} methods), or use a special widget: {@link Gnt.widget.calendar.Calendar}
    </p>

- `Date` - the date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this instance
  represents a weekday or week override, this field will be ignored.
- `Weekday` - the index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
Should be set to -1 for the "main" instance of the week overrides.
- `OverrideStartDate` - The start date of the timespan for week day override.
- `OverrideEndDate` - The end date of the timespan for week day override.
- `Name` - optional name of the day (holiday name for example)
- `Cls` - optional name of the CSS class, which can be used by various plugins working with weekends and holidays. Default value is `gnt-holiday`
If a holiday lasts for several days, then all days should have the same `Cls` value.
- `IsWorkingDay` - optional boolean flag, allowing you to specify exceptions - working days which falls on weekends. Default value is `false`. **Please note**, that simply setting this
field to "true" is not enough - you also need to specify the exact hours that are available for work with the `Availability` field (see below).
- `Availability` - should be an array of strings, containing the hourly availability for this day. Strings should have the following format:

        // two working intervals
        [ '08:00-12:00', '13:00-17:00' ]

        // whole 24 hours are available
        [ '00:00-24:00' ]
* **Please note**, that this field overrides the `IsWorkingDay` - for example, a day with "IsWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered as
working day.

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

*/
Ext.define('Gnt.model.CalendarDay', {
    extend: 'Sch.model.CalendarDay',
    customizableFields: [
        {
            name: 'Cls',
            defaultValue: 'gnt-holiday'
        }
    ]
});
// For backwards compatibility

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.data.Calendar
@extends Sch.data.Calendar
@aside guide gantt_calendars

A class representing a customizable calendar with weekends, holidays and availability information for any day.
Internally, it's just a subclass of the Ext.data.Store class which should be loaded with a collection
of {@link Gnt.model.CalendarDay} instances. Additionally, calendars may have parent-child relations, allowing "child" calendars to "inherit"
all special dates from its "parent" and add its own. See {@link #parent} property for details.

* **Note, that this calendar class is configured for backward compatibility and sets whole 24 hours of every day except weekends,
as available time. If you are looking for a calendar with regular business hours and availability, use {@link Gnt.data.calendar.BusinessTime}**

A calendar can be instantiated like this:

    var calendar        = new Gnt.data.Calendar({
        data    : [
            {
                Date            : new Date(2010, 0, 13),
                Cls             : 'gnt-national-holiday'
            },
            {
                Date            : new Date(2010, 1, 1),
                Cls             : 'gnt-company-holiday'
            },
            {
                Date            : new Date(2010, 0, 16),
                IsWorkingDay    : true
            }
        ]
    });

It can then be provided as a {@link Gnt.data.TaskStore#calendar configuration option} for the {@link Gnt.data.TaskStore}. Note that the calendar should be
loaded prior to loading the taskStore where it's consumed.

Please refer to the {@link Gnt.model.CalendarDay} class to know with what data calendar can be loaded with.

To edit the data in the calendar visually you can use {@link Gnt.widget.calendar.Calendar}

*/
Ext.define('Gnt.data.Calendar', {
    extend: 'Sch.data.Calendar',
    model: 'Gnt.model.CalendarDay',
    defaultNonWorkingTimeCssCls: 'gnt-holiday'
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.field.Calendar
 @extends Ext.form.field.ComboBox

 A specialized field allowing a user to select particular calendar for a task.
 This class inherits from the standard Ext JS "combo box" field, so any standard `Ext.form.field.ComboBox`
 configs can be used.
 */
Ext.define('Gnt.field.Calendar', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.Store',
        'Gnt.model.Calendar',
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarfield',
    alternateClassName: 'Gnt.widget.CalendarField',
    taskField: 'calendarIdField',
    getTaskValueMethod: 'getCalendarId',
    setTaskValueMethod: 'setCalendarId',
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Defines if the picker dropdown width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: true,
    editable: true,
    triggerAction: 'all',
    valueField: 'Id',
    displayField: 'Name',
    queryMode: 'local',
    forceSelection: true,
    allowBlank: true,
    initComponent: function() {
        var me = this,
            config = me.getInitialConfig();
        if (!config.store || me.store.isEmptyStore) {
            me.store = {
                xclass: 'Ext.data.Store',
                autoDestroy: true,
                model: 'Gnt.model.Calendar'
            };
        }
        if (!(me.store instanceof Ext.data.Store)) {
            me.store = Ext.create(me.store);
        }
        me.callParent(arguments);
        // load calendars list
        me.updateCalendarsStore();
        // listen to new calendars creation/removal and update the field store
        me.mon(Ext.data.StoreManager, {
            add: function(index, store, key) {
                if (store instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore();
                }
            },
            remove: function(index, store, key) {
                if (store instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore();
                }
            },
            scope: me
        });
        me.on({
            show: function() {
                me.setReadOnly(me.readOnly);
            }
        });
        me.on('change', me.onFieldChange, me);
    },
    updateCalendarsStore: function() {
        this.store.loadData(this.getCalendarData());
    },
    setReadOnly: function(readOnly) {
        readOnly = readOnly || this.store.count() === 0;
        this.callParent([
            readOnly
        ]);
    },
    getCalendarData: function() {
        return Ext.Array.map(Gnt.data.Calendar.getAllCalendars(), function(cal) {
            return {
                Id: cal.calendarId,
                Name: cal.name || cal.calendarId
            };
        });
    },
    onSetTask: function() {
        // set field to readonly if no calendars
        this.setReadOnly(this.readOnly);
        this.setValue(this.getTaskValue());
    },
    // Used in the column renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        var record = this.findRecordByValue(value);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText) && typeof me.valueNotFoundText == 'string') {
            displayTplData.push(me.valueNotFoundText);
        }
        return me.displayTpl.apply(displayTplData);
    },
    // @OVERRIDE
    getValue: function() {
        return this.value || '';
    },
    getErrors: function(value) {
        if (value) {
            var record = this.findRecordByDisplay(value);
            if (record) {
                if (this.task && !this.task.isCalendarApplicable(record.getId()))  {
                    return [
                        this.L('calendarNotApplicable')
                    ];
                }
                
            }
        }
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    onFieldChange: function(field, value) {
        this.setValue(value);
    },
    // @OVERRIDE
    // We need to have both onFieldChange and setValue
    // since setValue is not called when user select an option from the dropdown list
    setValue: function(value) {
        this.callParent([
            value
        ]);
        // we keep '' for empty field
        if (undefined === value || null === value || '' === value)  {
            this.value = '';
        }
        
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.getTaskValue() != this.value) {
                // apply changes to task
                this.applyChanges();
            }
        }
    },
    // @OVERRIDE
    assertValue: function() {
        var raw = this.getRawValue();
        if (!raw && this.value) {
            this.setValue('');
        } else {
            this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.column.Calendar
 * @extends Ext.grid.column.Column
 *
 *
 * A column representing a 'CalendarId' field of a task. The column is editable, however to enable the editing you will
 * need to add a `Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:
 *
 *        var gantt = Ext.create('Gnt.panel.Gantt', {
 *            height      : 600,
 *            width       : 1000,
 *
 *            // Setup your static columns
 *            columns         : [
 *                ...
 *                {
 *                    xtype       : 'calendarcolumn',
 *                    width       : 80
 *                }
 *                ...
 *            ],
 *
 *            plugins             : [
 *                Ext.create('Sch.plugin.TreeCellEditing', {
 *                    clicksToEdit: 1
 *                })
 *            ],
 *            ...
 *        });
 *
 * This column uses a field - {@link Gnt.field.Calendar} as the editor.
 */
Ext.define('Gnt.column.Calendar', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.calendarcolumn',
        'widget.ganttcolumn.calendar'
    ],
    requires: [
        'Gnt.model.Calendar',
        'Gnt.field.Calendar'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     *  - text : 'Calendar'
     */
    /**
     * @cfg {Number} width
     * The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align
     * The alignment of the text in the column.
     */
    align: 'left',
    instantUpdate: true,
    store: null,
    fieldProperty: 'calendarIdField',
    fieldConfigs: [
        'instantUpdate',
        'store',
        'fieldProperty'
    ],
    editor: 'calendarfield',
    defaultEditor: 'calendarfield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    applyColumnCls: function(value, meta, task, col, index, store) {
        if (!value) {
            meta.tdCls = (meta.tdCls || '') + ' gnt-default';
        }
    },
    getValueToRender: function(value, meta, task, col, index, store) {
        value = value || (store.calendar ? store.calendar.calendarId : '');
        return this.field.valueToVisible(value, task) || value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.field.ConstraintDate', {
    extend: 'Gnt.field.Date',
    alias: 'widget.constraintdatefield',
    // This is required to properly handle the field's read only state as designated in task's isEditable() method
    taskField: 'constraintDateField',
    getTaskValueMethod: 'getConstraintDate',
    setTaskValueMethod: 'setConstraintDate',
    reAssertValue: false,
    valueToVisible: function(value, task) {
        task = task || this.task;
        var me = this,
            constraintClass = task && task.getConstraintClass(),
            format = me.format || Ext.Date.defaultFormat;
        if (constraintClass) {
            return constraintClass.getDisplayableConstraintDateForFormat(value, format, task);
        } else {
            return value;
        }
    },
    visibleToValue: function(value) {
        var me = this,
            format = me.format || Ext.Date.defaultFormat,
            task = me.task,
            constraintClass = task && task.getConstraintClass();
        if (constraintClass && !Ext.isEmpty(value)) {
            value = constraintClass.adjustConstraintDateFromDisplayableWithFormat(value, format, task);
        }
        return value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 *
 * @class Gnt.column.ConstraintDate
 * @extends Ext.grid.column.Date
 *
 * A Column displaying a task's constraint date. The column is editable when adding a
 * `Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:
 *
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 *
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'constraintdatecolumn',
 *                 width       : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     })
 *
 * Note that this class inherit from {@link Ext.grid.column.Date} and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.ConstraintDate', {
    extend: 'Ext.grid.column.Date',
    alias: [
        'widget.constraintdatecolumn',
        'widget.ganttcolumn.constraintdate'
    ],
    requires: [
        'Gnt.field.ConstraintDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {string} text The text to show in the column header, defaults to `Mode`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n A object, purposed for the class localization.
     * @cfg {String} l10n.text Column title
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    // Need to properly obtain the data index if none is given
    fieldProperty: 'constraintDateField',
    editor: 'constraintdatefield',
    defaultEditor: 'constraintdatefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat,
            taskField: this.fieldProperty
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * A specialized field, allowing a user to specify task constraint type.
 * This class inherits from the standard Ext JS "combo" field, so any usual `Ext.form.field.ComboBox` configs can be used.
 *
 * In default setup the value of this field can be one of the following strings:
 * - finishnoearlythan
 * - finishnolaterthan
 * - mustfinishon
 * - muststarton
 * - startnoearlierthan
 * - startnolaterthan
 * but if one has created a new constraint class (see {@link Gnt.constraint.Base}) then this field value
 * might be that new class alias part after the 'gntconstraint.' prefix.
 *
 * @class Gnt.field.ConstraintType
 * @extends Ext.form.field.ComboBox
 */
Ext.define('Gnt.field.ConstraintType', {
    extend: 'Ext.form.field.ComboBox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    uses: [
        'Gnt.constraint.Base'
    ],
    alias: 'widget.constrainttypefield',
    alternateClassName: 'Gnt.widget.ConstraintType.Field',
    taskField: 'constraintTypeField',
    getTaskValueMethod: 'getConstraintType',
    setTaskValueMethod: 'setConstraint',
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: false,
    forceSelection: true,
    triggerAction: 'all',
    /**
     * Localication object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - none : 'None'
     */
    initComponent: function() {
        var me = this;
        var noneString = me.L('none');
        me.store = me.store || Gnt.field.ConstraintType.buildDefaultConstraintTypeList(noneString);
        me.emptyText = me.emptyText || noneString;
        this.on('change', this.onFieldChange, this);
        me.callParent(arguments);
    },
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    // will be used in the column's renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        var record = this.findRecordByValue(!Ext.isEmpty(value) ? value : null);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText || "");
        }
        return me.displayTpl.apply(displayTplData);
    },
    applyChanges: function(task) {
        var me = this,
            value = me.getValue(),
            constraintClass;
        task = task || me.task;
        constraintClass = Gnt.constraint.Base.getConstraintClass(value);
        me.setTaskValue(task, value, constraintClass && constraintClass.getInitialConstraintDate(task) || null);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        task.fireEvent('taskupdated', task, me);
    },
    findRecordByDisplay: function(value) {
        if (!value)  {
            return this.store.first();
        }
        
        return this.callParent(arguments);
    },
    onFieldChange: function(field, value) {
        var me = this;
        if (!me.getSuppressTaskUpdate() && me.task && (value || this.getRawValue() == me.L('none') || (!value && !this.getRawValue()))) {
            // apply changes to task
            me.applyChanges();
        }
    },
    statics: {
        /**
         * Builds default constraint type list by scanning Gnt.constraint namespace for suitable constraint classes
         *
         * @param {String} [noneText] Text to use for no constraint item, no constraint will be prepended to the list
         *  if text is given.
         */
        buildDefaultConstraintTypeList: function(noneText) {
            var result = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression('gntconstraint.*'), function(name) {
                var singleton = Ext.ClassManager.get(name),
                    alias = singleton.alias[0],
                    id = alias.split('.').pop();
                singleton && (result.push([
                    id,
                    singleton.L('name')
                ]));
            });
            result = Ext.Array.sort(result, function(a, b) {
                return a[1] > b[1] ? 1 : -1;
            });
            noneText && result.unshift([
                null,
                noneText
            ]);
            return result;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * A Column showing the `ConstraintType` field of a task. The column is editable when adding a
 * `Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:
 *
 *      var gantt = Ext.create('Gnt.panel.Gantt', {
 *           height      : 600,
 *           width       : 1000,
 *
 *           columns         : [
 *               ...
 *               {
 *                   xtype       : 'constrainttypecolumn',
 *                   width       : 80
 *               }
 *               ...
 *           ],
 *
 *           plugins             : [
 *               Ext.create('Sch.plugin.TreeCellEditing', {
 *                   clicksToEdit: 1
 *               })
 *           ],
 *           ...
 *       })
 *
 * @class Gnt.column.ConstraintType
 * @extends Ext.grid.column.Column
 */
Ext.define("Gnt.column.ConstraintType", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.ConstraintType'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        'widget.constrainttypecolumn',
        'widget.ganttcolumn.constrainttype'
    ],
    /**
     * @cfg {Object} l10n A object, purposed for the class localization.
     * @cfg {String} l10n.text Column title
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Array} data The to pass to Constraint Type field to be created in case the column is not configured with one already.
     * @cfg {String} data[][0] Valid constraint type
     * @cfg {String} data[][1] Constraint name
     */
    data: null,
    // Need to properly obtain the data index if none is given
    fieldProperty: 'constraintTypeField',
    editor: 'constrainttypefield',
    defaultEditor: 'constrainttypefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            store: this.data,
            taskField: this.fieldProperty
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && this.field.valueToVisible(value, task) || '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.DeadlineDate
@extends Gnt.field.Date

A specialized field for editing the task deadline date value. This class inherits from the `Ext.form.field.Date` field
and any of its configuration options can be used.

This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Using field standalone

Please refer to {@link Gnt.field.StartDate} for details.

* **Note**, that the value displayed in the field can be different from the value in the data model since an end date represents a distinct point
on the timeaxis but we want to render just the date part. For example: If deadline is set to 2013/01/02 -
this means that the data model value would be 2013/01/03 00:00:00, but in the field we show 2013/01/02.
*/
Ext.define('Gnt.field.DeadlineDate', {
    extend: 'Gnt.field.Date',
    requires: [
        'Sch.util.Date'
    ],
    alias: 'widget.deadlinedatefield',
    taskField: 'deadlineDateField',
    getTaskValueMethod: 'getDeadlineDate',
    setTaskValueMethod: 'setDeadlineDate',
    valueToVisible: function(value, task) {
        task = task || this.task;
        return task.getDisplayEndDate(this.format, true, value, true);
    },
    visibleToValue: function(value) {
        if (value && value - Ext.Date.clearTime(value, true) === 0) {
            // the standard ExtJS date picker will only allow to choose the date, not time
            // we set the time of the selected date to the latest availability hour for that date
            // in case the date has no availability intervals we use the date itself
            value = Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
        }
        return value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.DeadlineDate
@extends Ext.grid.Column.Date

A Column representing the `Deadline` date field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel.
*/
Ext.define('Gnt.column.DeadlineDate', {
    extend: 'Ext.grid.column.Date',
    requires: [
        'Gnt.field.DeadlineDate'
    ],
    alias: [
        'widget.deadlinecolumn',
        'widget.ganttcolumn.deadline'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Deadline'
     */
    // Ext 5.1.0 sets this to false
    draggable: true,
    fieldProperty: 'deadlineDateField',
    editor: 'deadlinedatefield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.util.DurationParser
 * @private
 * Internal class handling the duration parsing.

 Recognizable values for duration unit part are (the trailing `..` symbols means anything will match):

- Milliseconds: `ms` or `mil..`
- Seconds: `s` or `sec..`
- Minutes: `m` or `min..`
- Hours: `h` or `hr` or `hour..`
- Days: `d` or `day..`
- Weeks: `w` or `wk` or `week..`
- Months: `mo..` or `mnt..`
- Quarters: `q` or `quar..` or `qrt..`
- Years: `y` or `yr..` or `year..`

You can change that using the `unitsRegex` configuration option.

 */
Ext.define("Gnt.util.DurationParser", {
    requires: [
        "Sch.util.Date"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    parseNumberFn: null,
    durationRegex: null,
    /*
     * @cfg {Boolean} allowDecimals Set to `false` to disable parsing duration values with decimals component
     */
    allowDecimals: true,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - unitsRegex : {
                - MILLI       : /^ms$|^mil/i,
                - SECOND      : /^s$|^sec/i,
                - MINUTE      : /^m$|^min/i,
                - HOUR        : /^h$|^hr$|^hour/i,
                - DAY         : /^d$|^day/i,
                - WEEK        : /^w$|^wk|^week/i,
                - MONTH       : /^mo|^mnt/i,
                - QUARTER     : /^q$|^quar|^qrt/i,
                - YEAR        : /^y$|^yr|^year/i
            }
     */
    constructor: function(config) {
        Ext.apply(this, config);
        if (this.unitsRegex)  {
            Ext.apply(this.l10n.unitsRegex, this.unitsRegex);
        }
        
        if (!this.durationRegex) {
            this.durationRegex = this.allowDecimals ? /^\s*([\-+]?\d+(?:[.,]\d*)?|[\-+]?(?:[.,]\d+))\s*(\w+)?/i : /^\s*([\-+]?\d+)(?![.,])\s*(\w+)?/i;
        }
    },
    parse: function(value) {
        var match = this.durationRegex.exec(value);
        if (value == null || !match)  {
            return null;
        }
        
        var durationValue = this.parseNumberFn(match[1]);
        var durationUnitName = match[2];
        var durationUnit;
        if (durationUnitName) {
            Ext.iterate(this.L('unitsRegex'), function(name, regex) {
                if (regex.test(durationUnitName)) {
                    durationUnit = Sch.util.Date.getUnitByName(name);
                    return false;
                }
            });
            if (!durationUnit)  {
                return null;
            }
            
        }
        return {
            value: durationValue,
            unit: durationUnit
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.util.DependencyParser
 * @private
 * Internal class handling the dependency string parsing related functionality. Used by {@link Gnt.field.Dependency} field.
 */
Ext.define("Gnt.util.DependencyParser", {
    requires: [
        'Gnt.util.DurationParser'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     - typeText :
         - SS : 'SS'
         - SF : 'SF'
         - FS : 'FS'
         - FF : 'FF'
     */
    separator: /\s*;\s*/,
    parseNumberFn: null,
    dependencyRegex: null,
    types: null,
    constructor: function(config) {
        Ext.apply(this, config);
        // fill types array with values
        this.initTypes();
        var typeText = this.L('typeText');
        for (var i = 0; i < this.types.length; i++) {
            this.types[i] = (typeText[this.types[i]] || this.types[i]);
        }
        var re = "(-?\\d+)(" + this.types.join('|') + ")?([\\+\\-].*)?";
        this.dependencyRegex = this.dependencyRegex || new RegExp(re, "i");
        this.durationParser = new Gnt.util.DurationParser({
            parseNumberFn: this.parseNumberFn
        });
    },
    initTypes: function() {
        this.types = this.types || [
            'SS',
            // Start-To-Start
            'SF',
            // Start-To-Finish
            'FS',
            // Finish-To-Start
            'FF'
        ];
    },
    // Finish-To-Finish
    /*
     * Returns an object with the following properties (or null if the parsing fails):
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            }
    **/
    parse: function(value) {
        if (!value) {
            return [];
        }
        var parts = value.split(this.separator);
        var result = [];
        var depRe = this.dependencyRegex;
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            // allow ";" at the end of the string - will lead to empty element
            if (!part && i == parts.length - 1)  {
                
                continue;
            }
            
            var match = depRe.exec(part);
            var data = {};
            if (!match) {
                // Tolerate no sloppy input
                return null;
            }
            data.taskId = parseInt(match[1], 10);
            data.type = Ext.Array.indexOf(this.types, (match[2] || this.types[2]).toUpperCase());
            var lagValue = match[3];
            if (lagValue) {
                var lag = this.durationParser.parse(lagValue);
                if (!lag) {
                    // Tolerate no sloppy input
                    return null;
                }
                data.lag = lag.value;
                data.lagUnit = lag.unit || 'd';
            }
            result.push(data);
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.Dependency
@extends Ext.form.field.Text

A specialized field allowing a user to change the dependencies of a task. The type of dependecies
created by this field is controlled by the {@link #type} config.

The text describing a dependency can be one or more values in the following format, separated with a {@link #separator} string:

    [TaskId][DependencyType][Lag]

where:

- `TaskId` is the id of the predecessor/successor task, can be a "real" or "sequential" id, see below.
- `DependencyType` (optional, default value is "FS") is one of the following (based on the {@link Gnt.util.DependencyParser#l10n}) property.
* **Please note** that dependency types are localized and depend on selected language (following values present English translation):
    - `FS` - for "Finish-To-Start"
    - `FF` - for "Finish-To-Finish"
    - `SF` - for "Start-To-Finish"
    - `SS` - for "Start-To-Start"
- `Lag` (optional). Should start with `+` or `-` followed by a number indicating the lag amount
and duration unit.


The `TaskId` part can contain either "real" id of the task (the id that is stored in the database) or "sequential" id.
The sequential id corresponds to the ordinal position of the task in the whole dataset. When you add or remove tasks
from the dataset, the sequential id of the tasks may change. Which type of id is used is controled by the
{@link #useSequenceNumber} config.

For example:
    10          - Finish to start dependency from task with Id 10
    10SS        - Start to start dependency from task with Id 10
    3FS+1d      - Finish to start dependency from task with Id 3, with +1 day lag
    3FS-10h      - Finish to start dependency from task with Id 3, with -10 hours lag

*/
Ext.define("Gnt.field.Dependency", {
    extend: "Ext.form.field.Text",
    alternateClassName: "Gnt.widget.DependencyField",
    alias: "widget.dependencyfield",
    requires: [
        'Gnt.util.DependencyParser'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {String} type Either `predecessors` or `successors`. Defines the type of dependencies managed by this field. Defaults to 'predecessors'.
     */
    type: 'predecessors',
    // Or successors
    /**
     * @cfg {String} separator A separator between the dependency values in the text field.
     */
    separator: ';',
    task: null,
    /**
     * @property {Gnt.util.DependencyParser} dependencyParser
     * An object used to parse entered string to a proper dependency data.
     * **See also** {@link #dependencyParserConfig} config.
     */
    dependencyParser: null,
    /**
     * @cfg {Object} dependencyParserConfig
     * A config object to be passed to {@link Gnt.util.DependencyParser} constructor.
     */
    dependencyParserConfig: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - invalidFormatText   : 'Invalid dependency format',
            - invalidDependencyText : 'Invalid dependency found, please make sure you have no cyclic paths between your tasks',
            - invalidDependencyType : 'Invalid dependency type {0}. Allowed values are: {1}.'
     */
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false`then "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        this.dependencyParser = new Gnt.util.DependencyParser(Ext.apply({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn: function() {
                return Gnt.widget.DurationField.prototype.parseValue.apply(me, arguments);
            }
        }, this.dependencyParserConfig));
        this.callParent(arguments);
        this.addCls('gnt-field-dependency');
    },
    isPredecessor: function() {
        return this.type === 'predecessors';
    },
    /**
     * Set the task this field is bound to.
     *
     * @param {Gnt.model.Task} task
     */
    setTask: function(task) {
        this.task = task;
        this.setRawValue(this.getFieldDisplayValue(task));
    },
    /**
     * Returns an array of dependency objects representing the current value of the field:

        [
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            },
            ...
        ]

     * @return {Object} The dependencies
     */
    getDependencies: function() {
        return this.dependencyParser.parse(this.getRawValue());
    },
    getTaskIdFromDependency: function(dependencyData) {
        var store = this.task.getTaskStore(),
            taskId = dependencyData.taskId,
            task;
        if (this.useSequenceNumber) {
            task = store.getBySequenceNumber(taskId);
            taskId = task && task.getId();
        }
        return taskId;
    },
    getErrors: function(value) {
        if (!value)  {
            return [];
        }
        
        var parsed = this.dependencyParser.parse(value);
        if (!parsed) {
            return [
                this.L('invalidFormatText')
            ];
        }
        var dependencies = this.getDependencies(),
            isPredecessor = this.isPredecessor(),
            task = this.task,
            dependencyStore = task.getTaskStore().dependencyStore,
            // existing dependencies
            oldDependencies = task[isPredecessor ? 'predecessors' : 'successors'],
            typeAbbrs = this.dependencyParser.types,
            allowedTypes = dependencyStore.allowedDependencyTypes,
            typeCodes = dependencyStore.model.Type,
            taskId;
        // build list of tasks to be created, we need to provide it to isValidDependency() for correct validation
        var newDeps = [];
        for (var i = 0; i < dependencies.length; i++) {
            var depData = dependencies[i];
            taskId = this.getTaskIdFromDependency(depData);
            if (!taskId) {
                return [
                    this.L('invalidDependencyText')
                ];
            }
            // validate dependency type used
            if (dependencyStore.allowedDependencyTypes && !dependencyStore.isValidDependencyType(depData.type)) {
                var allowed = '';
                for (var j = 0,
                    k = allowedTypes.length; j < k; j++) {
                    allowed += typeAbbrs[typeCodes[allowedTypes[j]]] + ',';
                }
                return [
                    Ext.String.format(this.L('invalidDependencyType'), typeAbbrs[depData.type], allowed.substring(0, allowed.length - 1))
                ];
            }
            var dep = new dependencyStore.model();
            dep.setSourceId(isPredecessor ? taskId : task.getId());
            dep.setTargetId(isPredecessor ? task.getId() : taskId);
            dep.setType(depData.type);
            dep.setLag(depData.lag, depData.lagUnit);
            newDeps.push(dep);
        }
        // loop over dependencies to be created
        for (i = 0; i < newDeps.length; i++) {
            // validate dependency: we ask store if `newDeps[i]` is valid if we remove `oldDependencies` and add `newDeps` dependencies
            if (!dependencyStore.isValidDependency(newDeps[i], newDeps, oldDependencies)) {
                return [
                    this.L('invalidDependencyText')
                ];
            }
        }
        return this.callParent([
            parsed.value
        ]);
    },
    getFieldDisplayValue: function(task) {
        var isPredecessor = this.isPredecessor(),
            deps = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            dpTypes = this.dependencyParser.types,
            endToStart = Gnt.model.Dependency.Type.EndToStart,
            strings = [],
            depTask;
        for (var i = 0; i < deps.length; i++) {
            var dep = deps[i];
            depTask = isPredecessor ? dep.getSourceTask() : dep.getTargetTask();
            if (depTask && dep.isValid(false)) {
                var type = dep.getType(),
                    lag = dep.getLag(),
                    lagUnit = dep.getLagUnit();
                strings.push(Ext.String.format('{0}{1}{2}{3}{4}', this.useSequenceNumber ? depTask.getSequenceNumber() : depTask.getId(), lag || type !== endToStart ? dpTypes[type] : '', lag > 0 ? '+' : '', lag || '', lag && lagUnit !== 'd' ? lagUnit : ''));
            }
        }
        return strings.join(this.separator);
    },
    isDirty: function(task) {
        task = task || this.task;
        if (!task)  {
            return false;
        }
        
        var isPredecessor = this.isPredecessor(),
            depStore = task.getTaskStore().dependencyStore,
            deps = isPredecessor ? task.getIncomingDependencies() : task.getOutgoingDependencies(),
            taskId = task.getId();
        // check if some of task dependencies are dirty
        for (var i = 0,
            l = deps.length; i < l; i++) {
            if (deps[i].dirty || deps[i].phantom)  {
                return true;
            }
            
        }
        if (depStore) {
            var fn = isPredecessor ? 'getTargetId' : 'getSourceId';
            // check if there are some unsaved removed dependencies
            deps = depStore.getRemovedRecords();
            for (i = 0 , l = deps.length; i < l; i++) {
                if (deps[i][fn]() == taskId)  {
                    return true;
                }
                
            }
        }
        return false;
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     *
     * @param {Gnt.model.Task} [task] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(task) {
        task = task || this.task;
        var depStore = task.getTaskStore().dependencyStore,
            dependencies = this.getDependencies(),
            isPredecessor = this.isPredecessor(),
            currentDeps = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            toRemove = [],
            i;
        var ids = Ext.Array.map(dependencies, function(dep) {
                return this.getTaskIdFromDependency(dep);
            }, this);
        // First remove deleted dependencies
        for (i = 0; i < currentDeps.length; i++) {
            if (!Ext.Array.contains(ids, currentDeps[i][isPredecessor ? 'getSourceId' : 'getTargetId']())) {
                toRemove.push(currentDeps[i]);
            }
        }
        if (toRemove.length > 0) {
            depStore.remove(toRemove);
        }
        var toAdd = [];
        // Now iterate cell value, to update or add new dependencies
        for (i = 0; i < dependencies.length; i++) {
            var depData = dependencies[i];
            var predId = this.getTaskIdFromDependency(depData);
            var dep = depStore.getByTaskIds(predId, task.getId());
            if (dep) {
                dep.beginEdit();
                dep.setType(depData.type);
                dep.setLag(depData.lag, depData.lagUnit);
                dep.endEdit();
            } else {
                dep = new depStore.model();
                dep.setSourceId(isPredecessor ? predId : task.getId());
                dep.setTargetId(isPredecessor ? task.getId() : predId);
                dep.setType(depData.type);
                dep.setLag(depData.lag, depData.lagUnit);
                toAdd.push(dep);
            }
        }
        if (toAdd.length > 0) {
            depStore.add(toAdd);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Dependency
@extends Ext.grid.column.Column
@private

An internal private class serving as base class for Predecessor and Successor column classes.

*/
Ext.define("Gnt.column.Dependency", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.Dependency'
    ],
    separator: ';',
    type: 'predecessors',
    // Or 'successors'
    // Reference to the field used by the Editor
    field: null,
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false`then the "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    constructor: function(config) {
        config = config || {};
        var field = config.editor;
        delete config.editor;
        Ext.apply(this, config);
        config.editor = field || Ext.create('Gnt.field.Dependency', {
            type: this.type,
            separator: this.separator,
            useSequenceNumber: this.useSequenceNumber
        });
        if (!(config.editor instanceof Gnt.widget.DependencyField)) {
            config.editor = Ext.ComponentManager.create(config.editor, 'dependencyfield');
        }
        config.field = config.editor;
        this.scope = this;
        this.callParent([
            config
        ]);
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    getContainingPanel: function() {
        if (!this.panel) {
            this.panel = this.up('tablepanel');
        }
        return this.panel;
    },
    setDirtyClass: function(meta, task) {
        var view = this.getContainingPanel().getView();
        if (view.markDirty && this.field.isDirty(task)) {
            meta.tdCls = view.dirtyCls;
        }
    },
    /**
     * @protected
     * Gantt panel is aware of this method and uses it (if the method is presented)
     * to check if corresponding column is editable.
     * @param  {Gnt.model.Task}  task Task about to being edited
     * @return {Boolean}      Return false to prevent editing
     */
    isEditable: function(task) {
        var panel = this.gantt || this.up('ganttpanel');
        if (task.isProject)  {
            return false;
        }
        
        return !task.isProject && (panel && panel.allowParentTaskDependencies || task.isLeaf());
    },
    /**
     * Return dependencies to be copied to memory, only works with 'raw' format
     * @param {Gnt.model.Task} task Task being copied
     * @return {Object[]}
     */
    getRawData: function(task) {
        var dependencies;
        if (this.type === 'predecessors') {
            dependencies = task.getIncomingDependencies(true);
        } else {
            dependencies = task.getOutgoingDependencies(true);
        }
        return Ext.Array.map(dependencies, function(dependency) {
            var data = dependency.copy(null).data;
            delete data[dependency.idProperty];
            return data;
        });
    },
    renderer: function(value, meta, task) {
        if (!task.isEditable(this.dataIndex) || !this.isEditable(task)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        } else {
            this.setDirtyClass(meta, task);
        }
        return this.field.getFieldDisplayValue(task);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Private class used to allow row reordering when using the SpreadSheet selection model
Ext.define('Gnt.column.DragDrop', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.dragdropcolumn',
        'widget.ganttcolumn.dragdrop'
    ],
    width: 35,
    tdCls: 'sch-gantt-column-dragdrop',
    cls: 'sch-gantt-column-dragdrop-header',
    ignoreInAddMenu: true,
    ignoreExport: true,
    ignoreInExport: true,
    sortable: false,
    resizable: false,
    hideable: false,
    menuDisabled: true,
    draggable: false,
    align: 'center',
    // private override
    processEvent: function(type) {
        return type !== 'click';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2424
// This spinner is used in duration field to keep it visible in IE
Ext.define('Gnt.field.trigger.DurationSpinner', {
    extend: 'Ext.form.trigger.Spinner',
    alias: 'trigger.gantt_durationspinner',
    initEvents: function() {
        var me = this,
            isFieldEnabled = me.isFieldEnabled,
            stateEl = me.getStateEl(),
            el = me.el;
        stateEl.addClsOnOver(me.overCls, isFieldEnabled, me);
        stateEl.addClsOnClick(me.clickCls, isFieldEnabled, me);
        if (me.repeatClick) {
            me.clickRepeater = new Ext.util.ClickRepeater(el, Ext.apply({
                preventDefault: true,
                handler: me.onClick,
                // increase delay to avoid one click to start infinite spinning
                delay: Ext.isIE ? 1000 : 250,
                listeners: {
                    mousedown: me.onClickRepeaterMouseDown,
                    scope: me
                },
                scope: me
            }, this.repeaterConfig));
        } else {
            me.field.mon(el, {
                click: me.onClick,
                mousedown: me.onMouseDown,
                scope: me
            });
        }
    },
    onClick: function() {
        var me = this,
            args = arguments,
            e = me.clickRepeater ? args[1] : args[0],
            field = me.field;
        if (!field.readOnly && !field.disabled) {
            if (me.upEl.contains(e.target)) {
                Ext.callback(me.upHandler, me.scope, [
                    field,
                    me,
                    e
                ], 0, field);
            } else if (me.downEl.contains(e.target)) {
                Ext.callback(me.downHandler, me.scope, [
                    field,
                    me,
                    e
                ], 0, field);
            }
        }
        // When changing duration with click, some itemupdates will be fired and ext will try to restore focus to field,
        // but following focusing will cause field to loose focus and view to exit actionable mode.
        !Ext.isIE && field.inputEl.focus();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.Duration
@extends Ext.form.field.Number

A specialized field allowing a user to also specify duration unit when editing the duration value.
This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number`
configs can be used (like `minValue/maxValue` etc).



*/
Ext.define('Gnt.field.Duration', {
    extend: 'Ext.form.field.Number',
    requires: [
        'Gnt.util.DurationParser',
        'Gnt.field.trigger.DurationSpinner'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.durationfield',
    alternateClassName: 'Gnt.widget.DurationField',
    disableKeyFilter: true,
    allowExponential: false,
    minValue: 0,
    /**
     * @cfg {String} durationUnit The default duration unit to use when editing the value.
     * This is usually being set automatically, using the `DurationUnit` field of the task.
     */
    durationUnit: 'h',
    config: {
        triggers: {
            spinner: {
                type: 'gantt_durationspinner',
                upHandler: 'onSpinnerUpClick',
                downHandler: 'onSpinnerDownClick',
                scope: 'this'
            }
        }
    },
    /**
     * @cfg {String} invalidText Text shown when field value cannot be parsed to valid duration.
     * If you want to change the text for all instances of this class please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - invalidText : 'Invalid duration value'
     */
    /**
     * @cfg {Boolean} useAbbreviation When set to `true` the field will use short names of unit durations
     * (as returned by {@link Sch.util.Date#getShortNameOfUnit})
     */
    useAbbreviation: false,
    getDurationUnitMethod: 'getDurationUnit',
    setTaskValueMethod: 'setDuration',
    getTaskValueMethod: 'getDuration',
    taskField: 'durationField',
    durationParser: null,
    durationParserConfig: null,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        this.durationParser = new Gnt.util.DurationParser(Ext.apply({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn: function() {
                return me.parseValue.apply(me, arguments);
            },
            allowDecimals: this.decimalPrecision > 0
        }, this.durationParserConfig));
        this.callParent(arguments);
        this.invalidText = this.L('invalidText');
    },
    onSetTask: function() {
        this.durationUnit = this.task[this.getDurationUnitMethod]();
        var value = this.getTaskValueMethod ? this.getTaskValue() : this.task.get(this.task[this.taskField]);
        this.setValue(value);
        this.setSpinUpEnabled(value == null || value < this.maxValue, true);
        this.setSpinDownEnabled(value > this.minValue, true);
    },
    rawToValue: function(rawValue) {
        var parsed = this.parseDuration(rawValue);
        if (!parsed)  {
            return null;
        }
        
        this.durationUnit = parsed.unit;
        return parsed.value != null ? parsed.value : null;
    },
    valueToVisible: function(value, durationUnit) {
        if (Ext.isNumber(value)) {
            var valueInt = parseInt(value, 10),
                valueFixed = Ext.Number.toFixed(value, this.decimalPrecision);
            return String(valueInt == valueFixed ? valueInt : valueFixed).replace('.', this.decimalSeparator) + ' ' + Sch.util.Date[this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit'](durationUnit || this.durationUnit, value !== 1);
        }
        return '';
    },
    valueToRaw: function(value) {
        return this.valueToVisible(value, this.durationUnit, this.decimalPrecision, this.useAbbreviation);
    },
    parseDuration: function(value) {
        if (value == null) {
            return null;
        }
        var duration = this.durationParser.parse(value);
        if (!duration) {
            return null;
        }
        duration.unit = duration.unit || this.durationUnit;
        return duration;
    },
    /**
     * Returns an object, representing the current value of the field:

    {
        value   : ... // duration value,
        unit    : ... // duration unit
    }

     * @return {Object}
     */
    getDurationValue: function() {
        return this.parseDuration(this.getRawValue());
    },
    getErrors: function(value) {
        var parsed;
        if (value) {
            parsed = this.parseDuration(value);
            if (!parsed) {
                return [
                    this.L('invalidText')
                ];
            }
            value = parsed.value;
        }
        // https://www.sencha.com/forum/showthread.php?306347-Number-field-throw-exception-when-validating-value
        if (arguments.length > 0 && value == null) {
            value = '';
        }
        return this.callParent(arguments);
    },
    // @OVERRIDE
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var me = this,
                newVal = me.getDurationValue(),
                oldVal = me.lastValue;
            var isDifferent = newVal && !oldVal || !newVal && oldVal || newVal && oldVal && (newVal.value != oldVal.value || newVal.unit != oldVal.unit);
            if (isDifferent && !me.isDestroyed) {
                me.lastValue = newVal;
                me.fireEvent('change', me, newVal, oldVal);
                me.onChange(newVal, oldVal);
            }
        }
    },
    // @OVERRIDE
    getValue: function() {
        return this.value;
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue(), this.durationUnit);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        toTask.fireEvent('taskupdated', toTask, this);
    },
    // @OVERRIDE
    setValue: function(value, forceUpdate) {
        var val = value;
        if (Ext.isObject(value)) {
            this.durationUnit = value.unit;
            val = value.value;
        }
        this.callParent([
            val
        ]);
        if (!this.readOnly && (forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    },
    // @private
    // it's called in editor.completeEdit()
    assertValue: function() {
        var me = this,
            oldVal = me.getValue(),
            oldUnit = me.durationUnit,
            newVal = me.getDurationValue();
        if (this.isValid()) {
            var isDifferent = /*newVal && !oldVal ||*/
                !newVal && oldVal || newVal && (newVal.value != oldVal || newVal.unit != oldUnit);
            if (isDifferent) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newVal, true);
            }
        }
    },
    // @OVERRIDE
    beforeBlur: function() {
        this.assertValue();
    },
    onSpinUp: function() {
        var me = this;
        if (!me.readOnly) {
            var value = me.getValue() || 0;
            me.setSpinValue(Ext.Number.constrain(value + me.step, me.minValue, me.maxValue));
        }
    },
    onSpinDown: function() {
        var me = this;
        if (!me.readOnly) {
            var value = me.getValue() || 0;
            me.setSpinValue(Ext.Number.constrain(value - me.step, me.minValue, me.maxValue));
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Duration
@extends Ext.grid.column.Column

A Column representing a `Duration` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'durationcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

{@img gantt/images/duration-field.png}

This column uses a field - {@link Gnt.field.Duration} which allows the
user to specify not only the duration value, but also the duration units.

When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
method will be used to retrieve the name of the unit.

*/
Ext.define('Gnt.column.Duration', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.durationcolumn',
        'widget.ganttcolumn.duration'
    ],
    requires: [
        'Gnt.field.Duration'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Duration'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 80,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the duration values containing decimals part (like "6.5 days") will be considered invalid.
     */
    decimalPrecision: 2,
    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated duration unit name, not full. Abbreviation will also be used
     * when editing the value. Useful if the column width is limited.
     */
    useAbbreviation: false,
    instantUpdate: true,
    fieldProperty: 'durationField',
    fieldConfigs: [
        'instantUpdate',
        'useAbbreviation',
        'decimalPrecision',
        'fieldProperty'
    ],
    editor: 'durationfield',
    defaultEditor: 'durationfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        return this.field.valueToVisible(value, task.getDurationUnit());
    },
    putRawData: function(data, task) {
        task.setDuration(data);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.EarlyEndDate
@extends Ext.grid.column.Date

A column displaying the earliest possible end date of a task.
This value is calculated based on the earliest end dates of the task predecessors.
If a task has no predecessors then its end date will be equal to its earliest end date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'earlyenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherits from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.EarlyEndDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.earlyenddatecolumn',
        'widget.ganttcolumn.earlyenddate'
    ],
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the raw unmodified date.
     */
    adjustMilestones: true,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        return task.getDisplayEndDate(this.format, this.adjustMilestones, task.getEarlyEndDate());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.EarlyStartDate
@extends Ext.grid.column.Date

A Column displaying the earliest possible start date of a task.
This value is calculated based on earliest end dates of task's incoming dependencies.
If a task has no incoming dependencies then its start date is taken as earliest start date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'earlystartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.EarlyStartDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.earlystartdatecolumn',
        'widget.ganttcolumn.earlystartdate'
    ],
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones: true,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        return task.getDisplayStartDate(this.format, this.adjustMilestones, task.getEarlyStartDate());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.field.Effort
@extends Gnt.field.Duration

A specialized field, allowing a user to also specify a duration unit when editing the effort value.
This class inherits from the {@link Gnt.field.Duration} field, which inherits from `Ext.form.field.Number` so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).

*/
Ext.define('Gnt.field.Effort', {
    extend: 'Gnt.field.Duration',
    requires: [
        'Gnt.util.DurationParser'
    ],
    alias: 'widget.effortfield',
    alternateClassName: 'Gnt.widget.EffortField',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - invalidText : 'Invalid value'
     */
    taskField: 'effortField',
    getDurationUnitMethod: 'getEffortUnit',
    setTaskValueMethod: 'setEffort',
    getTaskValueMethod: 'getEffort',
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue() || null, this.durationUnit);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        toTask.fireEvent('taskupdated', toTask, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Effort
@extends Gnt.column.Duration

A Column representing a `Effort` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'effortcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

{@img gantt/images/duration-field.png}

This column uses a field - {@link Gnt.field.Effort} which allows the
user to specify not only the duration value, but also the duration units.

When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
method will be used to retrieve the name of the unit.

*/
Ext.define('Gnt.column.Effort', {
    extend: 'Gnt.column.Duration',
    alias: [
        'widget.effortcolumn',
        'widget.ganttcolumn.effort'
    ],
    requires: [
        'Gnt.field.Effort'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Effort'
     */
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the effort values containing decimals part (like "6.5 days") will be considered invalid.
     */
    fieldProperty: 'effortField',
    editor: 'effortfield',
    defaultEditor: 'effortfield',
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        return this.field.valueToVisible(value, task.getEffortUnit());
    },
    putRawData: function(data, task) {
        task.setEffort(data);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.LateEndDate
@extends Ext.grid.column.Date

A Column displaying the latest possible end date of a task.
This value is calculated based on the latest start date of the task successors.
If a task has no successors then the project end date is used as its latest end date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'lateenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.LateEndDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.lateenddatecolumn',
        'widget.ganttcolumn.lateenddate'
    ],
    width: 100,
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the unmodified date.
     */
    adjustMilestones: true,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        return task.getDisplayEndDate(this.format, this.adjustMilestones, task.getLateEndDate());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.LateStartDate
@extends Ext.grid.column.Date

A Column displaying the latest possible start date of a task.
This value is calculated as the latest start date of the dependent tasks for this task.
If a task has no successors then the column value is calculated as the project end date minus the task duration
(_project end date_ is the latest end date of all the tasks in the task store).

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'latestartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.LateStartDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.latestartdatecolumn',
        'widget.ganttcolumn.latestartdate'
    ],
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones: true,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        return task.getDisplayStartDate(this.format, this.adjustMilestones, task.getLateStartDate());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 A specialized field, allowing a user to also specify task manually scheduled value.
 This class inherits from the standard Ext JS "checkbox" field, so any usual `Ext.form.field.Checkbox` configs can be used.

 @class Gnt.field.ManuallyScheduled
 @extends Ext.form.field.Checkbox

 */
Ext.define('Gnt.field.ManuallyScheduled', {
    extend: 'Ext.form.field.Checkbox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.manuallyscheduledfield',
    alternateClassName: [
        'Gnt.widget.ManuallyScheduledField'
    ],
    taskField: 'manuallyScheduledField',
    setTaskValueMethod: 'setManuallyScheduled',
    getTaskValueMethod: 'isManuallyScheduled',
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    getValue: function() {
        return this.value;
    },
    setValue: function(value) {
        this.callParent([
            value
        ]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.column.ManuallyScheduled
 @extends Ext.grid.column.Column

 A Column showing the `Manually Scheduled` field of a task.
 */
Ext.define("Gnt.column.ManuallyScheduled", {
    extend: "Ext.grid.Column",
    alias: [
        'widget.manuallyscheduledcolumn',
        'widget.ganttcolumn.manuallyscheduledcolumn'
    ],
    requires: [
        'Gnt.field.ManuallyScheduled'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    width: 50,
    align: 'center',
    instantUpdate: false,
    fieldProperty: 'manuallyScheduledField',
    editor: 'manuallyscheduledfield',
    defaultEditor: 'manuallyscheduledfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(task.isManuallyScheduled());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.field.Milestone
 @extends Ext.form.field.ComboBox

 A specialized field allowing a user to convert regular task to milestone and back.

 */
Ext.define('Gnt.field.Milestone', {
    extend: 'Ext.form.field.ComboBox',
    requires: 'Ext.data.JsonStore',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.milestonefield',
    instantUpdate: false,
    allowBlank: false,
    forceSelection: true,
    displayField: 'text',
    valueField: 'value',
    queryMode: 'local',
    constructor: function(config) {
        Ext.apply(this, config);
        this.store = new Ext.data.JsonStore({
            fields: [
                'value',
                'text'
            ],
            autoDestroy: true,
            data: [
                {
                    value: 0,
                    text: this.L('no')
                },
                {
                    value: 1,
                    text: this.L('yes')
                }
            ]
        });
        this.callParent(arguments);
        this.on('change', this.onFieldChange, this);
    },
    onSetTask: function() {
        this.setValue(this.task.isMilestone() ? 1 : 0);
    },
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    onFieldChange: function(field, value) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.task.isMilestone() != Boolean(this.value)) {
                // apply changes to task
                this.applyChanges();
            }
        }
    },
    getValue: function() {
        return this.value;
    },
    applyChanges: function(task) {
        task = task || this.task;
        if (this.getValue()) {
            task.convertToMilestone();
        } else {
            task.convertToRegular();
        }
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        task.fireEvent('taskupdated', task, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.column.Milestone
 @extends Ext.grid.column.Column

 A Column showing if a task is a milestone or not.

        var gantt = Ext.create('Gnt.panel.Gantt', {
            height      : 600,
            width       : 1000,

            // Setup your static columns
            columns         : [
                ...
                {
                    xtype       : 'milestonecolumn',
                    width       : 80
                }
                ...
            ],

            plugins             : [
                Ext.create('Sch.plugin.TreeCellEditing', {
                    clicksToEdit: 1
                })
            ],
            ...
        });


 */
Ext.define('Gnt.column.Milestone', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.milestonecolumn',
        'widget.ganttcolumn.milestone'
    ],
    requires: [
        'Gnt.field.Milestone'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    width: 50,
    align: 'center',
    editor: 'milestonefield',
    defaultEditor: 'milestonefield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(task.isMilestone());
    },
    applyColumnCls: function(value, meta, task) {
        // There's no milestone field that we can use, so we check if both fields that can set task to be a milestone
        // are not editable
        if (!task.isEditable(task.durationField) && !task.isEditable(task.endDateField)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Name
@extends Ext.tree.Column

A Column representing the `Name` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'namecolumn',
                width       : 200
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

*/
Ext.define('Gnt.column.Name', {
    extend: 'Ext.tree.Column',
    alias: [
        'widget.namecolumn',
        'widget.ganttcolumn.name'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Task Name'
     */
    // Ext 5.1.0 sets this to false
    draggable: true,
    fieldProperty: 'nameField',
    editor: 'textfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    applyColumnCls: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '');
        if (task.isProject) {
            meta.tdCls += ' sch-gantt-project-name';
        }
        if (!task.isLeaf()) {
            meta.tdCls += ' sch-gantt-parent-cell';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.field.Note
 @extends Ext.form.field.Picker

 A specialized field to be used for editing in the {@link Gnt.column.Note} column.

 */
Ext.define('Gnt.field.Note', {
    extend: 'Ext.form.field.Picker',
    alias: [
        'widget.notefield',
        'widget.noteeditor'
    ],
    alternateClassName: 'Gnt.widget.NoteField',
    requires: [
        'Ext.form.field.HtmlEditor'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    matchFieldWidth: false,
    editable: false,
    /**
     * @cfg {Object} pickerConfig Configuration of the field picker (Ext.form.field.HtmlEditor instance)
     */
    pickerConfig: null,
    /**
     * @cfg {Function} previewFn
     * Function to return raw field value. If not provided the field uses text stripped of tags
     */
    previewFn: null,
    /**
     * @cfg {Function} previewFnScope
     * Scope for {!link #previewFn} function to return raw field value
     */
    previewFnScope: null,
    taskField: 'noteField',
    getTaskValueMethod: 'getNote',
    setTaskValueMethod: 'setNote',
    afterRender: function() {
        this.callParent(arguments);
        this.on('collapse', this.onPickerCollapse, this);
    },
    valueToVisible: function(value) {
        if (this.previewFn) {
            return this.previewFn.call(this.previewFnScope || this, value);
        } else {
            return Ext.util.Format.stripTags(value);
        }
    },
    createPicker: function() {
        var field = new Ext.form.field.HtmlEditor(Ext.apply({
                frame: true,
                shadow: false,
                floating: true,
                height: 200,
                width: 300,
                listeners: {
                    change: this.onPickerChange,
                    initialize: this.onPickerInit,
                    scope: this
                }
            }, this.pickerConfig || {}));
        return field;
    },
    onPickerInit: function(picker) {
        var body = picker.win.document.body;
        var me = this;
        // https://www.sencha.com/forum/showthread.php?303342
        // disable iframe window focus to avoid picker collapse
        picker.win.focus = Ext.emptyFn;
        // Abort editing on ESC keypress
        picker.win.document.onkeydown = function(evt) {
            var extEv = new Ext.event.Event(evt);
            if (extEv.keyCode === extEv.ESC) {
                me.collapse();
            }
        };
    },
    onPickerChange: function(picker, value) {
        this.setRawValue(this.valueToVisible(value));
    },
    getValue: function() {
        return this.getPicker().getValue();
    },
    setValue: function(value) {
        this.callParent([
            this.valueToVisible(value)
        ]);
        this.getPicker().setValue(value);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges();
        }
    },
    onPickerCollapse: function() {
        this.setValue(this.getPicker().getValue());
    },
    onTriggerClick: function() {
        var me = this;
        if (!me.readOnly && !me.disabled) {
            if (me.isExpanded) {
                me.collapse();
            } else {
                me.expand();
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.column.Note
@extends Ext.grid.column.Column

A Column showing the `Note` field of the task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'notecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

*/
Ext.define("Gnt.column.Note", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.Note'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        "widget.notecolumn",
        "widget.ganttcolumn.note"
    ],
    editor: 'notefield',
    defaultEditor: 'notefield',
    fieldProperty: 'noteField',
    previewFn: null,
    previewFnScope: null,
    fieldConfigs: [
        'instantUpdate',
        'previewFn',
        'previewFnScope',
        'fieldProperty'
    ],
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.column.PercentDone
@extends Ext.grid.column.Number

A Column representing the `PercentDone` field of the task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'percentdonecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })


*/
Ext.define("Gnt.column.PercentDone", {
    extend: "Ext.grid.column.Number",
    requires: [
        'Gnt.field.Percent'
    ],
    alias: [
        "widget.percentdonecolumn",
        "widget.ganttcolumn.percentdone"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    width: 50,
    format: '0',
    align: 'center',
    editor: 'percentfield',
    defaultEditor: 'percentfield',
    fieldProperty: 'percentDoneField',
    useRenderer: false,
    initComponent: function() {
        this.initTaskFieldColumn({
            decimalPrecision: 0
        });
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Predecessor
@extends Gnt.column.Dependency

A Column showing the predecessors of a task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'predecessorcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
user to specify multiple predecessor including lag. Please refer to {@link Gnt.field.Dependency}
documentation for expected value format.

*/
Ext.define("Gnt.column.Predecessor", {
    extend: "Gnt.column.Dependency",
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        "widget.predecessorcolumn",
        "widget.ganttcolumn.predecessor"
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Predecessors'
     */
    type: 'predecessors',
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
    },
    /**
     * Will validate and insert previously prepared predecessors data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        var dependencyStore = task.getDependencyStore();
        var toAdd = [];
        dependencyStore.remove(task.getIncomingDependencies(true));
        Ext.isArray(data) && Ext.Array.each(data, function(item) {
            // check if source task exists
            if (task.getTaskStore().getById(item[dependencyStore.model.prototype.fromField])) {
                var newDependency = new dependencyStore.model(item);
                newDependency.setTargetId(task.getId());
                if (dependencyStore.isValidDependency(newDependency)) {
                    toAdd.push(newDependency);
                }
            }
        });
        dependencyStore.add(toAdd);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.column.ReadOnly
 @extends Ext.grid.Column

 A Column which displays if the task is readonly.
 */
Ext.define("Gnt.column.ReadOnly", {
    extend: "Ext.grid.Column",
    alias: [
        "widget.readonlycolumn",
        "widget.ganttcolumn.readonly"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    fieldProperty: 'readOnlyField',
    defaultEditor: 'readonlyfield',
    editor: 'readonlyfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(value);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Gnt.column.ResourceName
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define('Gnt.column.ResourceName', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.resourcenamecolumn',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    flex: 1,
    align: 'left',
    resourceStore: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        Ext.apply(this, config);
        this.scope = this.scope || this;
        this.callParent(arguments);
    },
    renderer: function(value, m, assignment) {
        var resource = assignment.getResource(this.resourceStore);
        return Ext.String.htmlEncode(resource && resource.getName() || value);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.AssignmentGrid
 @extends Ext.grid.Panel

 A class used to display and edit the task assignments. You can configure this through the {@link Gnt.widget.AssignmentField#gridConfig gridConfig} object
 available on the {@link Gnt.widget.AssignmentField} class.

 */
Ext.define('Gnt.widget.AssignmentGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.assignmentgrid',
    requires: [
        'Ext.data.Store',
        'Ext.grid.plugin.CellEditing',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits'
    ],
    /**
     * @cfg {Ext.data.Store} assignmentStore A store with assignments
     */
    assignmentStore: null,
    /**
     * @cfg {Ext.data.Store} resourceStore A store with resources
     */
    resourceStore: null,
    readOnly: false,
    cls: 'gnt-assignmentgrid',
    taskId: null,
    cellEditing: null,
    // The sorting function defining the order of the resources
    sortResourcesFn: null,
    assignmentUnitsEditor: null,
    selModel: {
        selType: 'checkboxmodel',
        mode: 'MULTI',
        checkOnly: true
    },
    viewConfig: {
        markDirty: false
    },
    initComponent: function(config) {
        var me = this;
        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }
        this.store = this.store || new Ext.data.Store({
            proxy: 'memory',
            autoDestroy: true,
            model: this.assignmentStore.getModel()
        });
        this.columns = this.columns || this.buildColumns();
        this.sortResourcesFn = this.sortResourcesFn || function(assignment1, assignment2) {
            var units1 = assignment1.getUnits(),
                units2 = assignment2.getUnits();
            // If both resources are assigned, sort them by Name
            if ((!units1 && !units2) || (units1 && units2)) {
                return assignment1.getResource(me.resourceStore).getName() < assignment2.getResource(me.resourceStore).getName() ? -1 : 1;
            }
            return units1 ? -1 : 1;
        };
        this.loadResources();
        this.mon(this.resourceStore, {
            datachanged: this.loadResources,
            scope: this
        });
        this.callParent(arguments);
        this.getSelectionModel().on({
            select: this.onSelect,
            deselect: this.onDeselect,
            scope: this
        });
    },
    onSelect: function(sm, rec) {
        if ((!this.cellEditing || !this.cellEditing.getActiveEditor()) && !rec.getUnits()) {
            rec.setUnits(rec.getField(rec.unitsField).defaultValue);
        }
    },
    onDeselect: function(sm, rec) {
        rec.setUnits(0);
    },
    loadResources: function() {
        var resourceIdField = this.assignmentStore.getModel().prototype.resourceIdField;
        var unitsField = this.assignmentStore.getModel().prototype.unitsField;
        var data = Ext.Array.map(this.resourceStore.getRange(), function(resource) {
                var assignmentData = {};
                assignmentData[resourceIdField] = resource.getId();
                assignmentData[unitsField] = '';
                return assignmentData;
            });
        this.store.loadData(data);
    },
    // @private
    buildPlugins: function() {
        var cellEditing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
                clicksToEdit: 1
            });
        cellEditing.on('edit', this.onEditingDone, this);
        return [
            cellEditing
        ];
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments);
    },
    onEditingDone: function(ed, e) {
        // Make sure row is selected after editing a cell
        if (e.value) {
            this.getSelectionModel().select(e.record, true);
        } else {
            this.getSelectionModel().deselect(e.record);
            e.record.reject();
        }
    },
    // @private
    buildColumns: function() {
        return [
            {
                xtype: 'resourcenamecolumn',
                resourceStore: this.resourceStore
            },
            {
                xtype: 'assignmentunitscolumn'
            }
        ];
    },
    setEditableFields: function(taskId) {
        if (!this.assignmentUnitsEditor) {
            var column = this.down('assignmentunitscolumn');
            this.assignmentUnitsEditor = column && column.getEditor();
        }
        if (this.assignmentUnitsEditor) {
            var taskStore = this.assignmentStore && this.assignmentStore.getTaskStore(),
                task = taskStore && taskStore.getModelById(taskId);
            if (task) {
                switch (task.getSchedulingMode()) {
                    case 'DynamicAssignment':
                        this.assignmentUnitsEditor.setReadOnly(true);
                        break;
                    default:
                        this.assignmentUnitsEditor.setReadOnly(false);
                }
            }
        }
    },
    loadTaskAssignments: function(taskId) {
        var store = this.store,
            sm = this.getSelectionModel();
        this.taskId = taskId;
        // clear all checkboxes
        sm.deselectAll(true);
        // Reset all "Units" values of all resource assignment records first
        for (var i = 0,
            l = store.getCount(); i < l; i++) {
            // should be ok to use field names here, since we are inheriting directly from Gnt.model.Assignment
            var record = store.getAt(i);
            record.data[record.unitsField] = 0;
            record.data[record.idProperty] = null;
            // after each saveTaskAssignments we should call loadTaskAssignments to set proper __id__'s on task assignments
            delete record.__id__;
        }
        var taskAssignments = this.assignmentStore.getAssignmentsForTask(taskId);
        Ext.Array.each(taskAssignments, function(assignment) {
            var resourceAssignmentRecord = store.findRecord(assignment.resourceIdField, assignment.getResourceId(), 0, false, true, true);
            if (resourceAssignmentRecord) {
                var data = Ext.apply({}, assignment.data);
                delete data[assignment.idProperty];
                resourceAssignmentRecord.set(data);
                // can't assign to "idProperty" of the record because if "id" is missing
                // the store internal mapping will be broken (and "indexOf" method of the store will stop working)
                resourceAssignmentRecord.__id__ = assignment.getId();
                // mark the record with checkbox
                sm.select(resourceAssignmentRecord, true, true);
            }
        });
        // HACK: Weird Safari only bug
        // https://www.assembla.com/spaces/bryntum/tickets/1810-assignment-editor-doesn-t-work-on-safari#/activity/ticket:
        if (Ext.isSafari) {
            this.focus();
        }
        // Apply sort to show assigned resources at the top
        store.sort({
            sorterFn: this.sortResourcesFn
        });
        // HACK Ext JS saves the sorter, remove it explicitly
        store.getSorters().removeAll();
        var view = this.getView();
        // HACK
        // setPosition in 6.0.0 won't change position in filtered view: https://fiddle.sencha.com/#fiddle/1904
        // Not reproducible in 6.0.1+ so no point to report to sencha.
        if (Ext.getVersion().equals('6.0.0.640')) {
            view.navigationModel.setPosition(null);
        }
        // https://www.assembla.com/spaces/bryntum/tickets/2602
        var newPosition = (new Ext.grid.CellContext(view)).setPosition(0, 0);
        // focus first cell to enable key navigation
        view.focusCell(newPosition);
        this.setEditableFields(taskId);
    },
    saveTaskAssignments: function() {
        var aStore = this.assignmentStore,
            taskId = this.taskId;
        var assignmentsToStay = {};
        var newAssignments = [];
        this.getSelectionModel().selected.each(function(resourceAssignmentRecord) {
            var units = resourceAssignmentRecord.getUnits();
            if (units > 0) {
                // if not undefined that means resource was assigned to another task
                var id = resourceAssignmentRecord.__id__;
                if (id) {
                    var newData = Ext.apply({}, resourceAssignmentRecord.data);
                    delete newData[resourceAssignmentRecord.idProperty];
                    assignmentsToStay[id] = true;
                    aStore.getModelById(id).set(newData);
                } else {
                    var newAssignment = resourceAssignmentRecord.copy();
                    newAssignment.setTaskId(taskId);
                    assignmentsToStay[newAssignment.internalId] = true;
                    newAssignments.push(newAssignment);
                }
            }
        });
        var assignmentsToRemove = [];
        // Remove any assignments that
        // - are not phantom
        // - and have been unchecked (and thus are not included in `assignmentsToStay`)
        aStore.each(function(assignment) {
            //   assignment is for our task       | not phantom |       was unchecked
            if (assignment.getTaskId() == taskId && !assignmentsToStay[assignment.getId() || assignment.internalId]) {
                assignmentsToRemove.push(assignment);
            }
        });
        // Fire this event so UI can ignore the datachanged events possibly fired below
        aStore.fireEvent('beforetaskassignmentschange', aStore, taskId, newAssignments);
        aStore.suspendAutoSync();
        aStore.remove(assignmentsToRemove);
        // Add selected assignments for this task
        aStore.add(newAssignments);
        aStore.resumeAutoSync();
        // Fire this event so UI can just react and update the row for the task
        aStore.fireEvent('taskassignmentschanged', aStore, taskId, newAssignments);
        if (aStore.autoSync) {
            aStore.sync();
        }
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    isDataValid: function() {
        return this.store.findBy(function(record) {
            return !record.isValid();
        }) < 0;
    },
    isEditing: function() {
        return Boolean(this.cellEditing.getActiveEditor());
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.util.Patch
 * @static
 * @private
 * Private utility class for Ext JS patches for the Bryntum components.
 *
 * Each subclass of this should patch *ONE* platform bug, to be able to easily scope the fix only to affected versions
 */
Ext.define('Sch.util.Patch', {
    /**
     * @cfg {String} target The class name to override
     */
    target: null,
    /**
     * @cfg {String} minVersion The minimum Ext JS version for which this override is applicable. E.g. "4.0.5"
     */
    minVersion: null,
    /**
     * @cfg {String} maxVersion The highest Ext JS version for which this override is applicable. E.g. "4.0.7"
     */
    maxVersion: null,
    /**
     * @cfg {String} reportUrl A url to the forum post describing the bug/issue in greater detail
     */
    reportUrl: null,
    /**
     * @cfg {String} description A brief description of why this override is required
     */
    description: null,
    /**
     * @cfg {Function} applyFn A function that will apply the patch(es) manually, instead of using 'overrides';
     */
    applyFn: null,
    /**
     * @cfg {Boolean} ieOnly true if patch is only applicable to IE
     */
    ieOnly: false,
    /**
     * @cfg {Boolean} macOnly true if patch is only applicable for Mac
     */
    macOnly: false,
    /**
     * @cfg {Object} overrides a custom object containing the methods to be overridden.
     */
    overrides: null,
    onClassExtended: function(cls, data) {
        if (Sch.disableOverrides) {
            return;
        }
        if (data.ieOnly && !Ext.isIE) {
            return;
        }
        if (data.macOnly && !Ext.isMac) {
            return;
        }
        if ((!data.minVersion || Ext.versions.extjs.equals(data.minVersion) || Ext.versions.extjs.isGreaterThan(data.minVersion)) && (!data.maxVersion || Ext.versions.extjs.equals(data.maxVersion) || Ext.versions.extjs.isLessThan(data.maxVersion))) {
            // Make sure class is loaded before applying override
            Ext.require(data.target, function() {
                if (data.applyFn) {
                    // Custom override, implementor has full control
                    data.applyFn();
                } else if (data.overrides) {
                    // Simple case, just an Ext override
                    Ext.ClassManager.get(data.target).override(data.overrides);
                }
            });
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2415-assignment-column-editor-collapses-on-checkcolumn-click/details#
Ext.define('Gnt.patches.CheckboxModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.selection.CheckboxModel',
    overrides: {
        renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
            return '<div class="' + Ext.baseCSSPrefix + 'grid-row-checker" role="button" tabIndex="-1">&#160;</div>';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2415-assignment-column-editor-collapses-on-checkcolumn-click/details#
Ext.define('Gnt.patches.NavigationModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    maxVersion: '6.0.2',
    overrides: {
        onCellMouseDown: function(view, cell, cellIndex, record, row, recordIndex, mousedownEvent) {
            var targetComponent = Ext.Component.fromElement(mousedownEvent.target, cell),
                ac;
            // If actionable mode, and
            //  (mousedown on a tabbable, or anywhere in the ownership tree of the active component),
            // we should not get involved.
            // The tabbable element will be part of actionability.
            if (view.actionableMode && (mousedownEvent.getTarget(null, null, true).isTabbable() || ((ac = Ext.ComponentManager.getActiveComponent()) && ac.owns(mousedownEvent)))) {
                return;
            }
            // If the event is a touchstart, leave it until the click to focus.
            if (mousedownEvent.pointerType !== 'touch') {
                mousedownEvent.preventDefault();
                this.setPosition(mousedownEvent.position, null, mousedownEvent);
            }
            // If mousedowning on a focusable Component.
            // After having set the position according to the mousedown, we then
            // enter actionable mode and focus the component just as if the user
            // Had navigated here and pressed F2.
            if (targetComponent && targetComponent.isFocusable && targetComponent.isFocusable()) {
                view.setActionableMode(true, mousedownEvent.position);
                // Focus the targeted Component
                targetComponent.focus();
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.field.Assignment
 @extends Ext.form.field.Picker

 A specialized field to be used for editing in the {@link Gnt.column.ResourceAssignment} column.

 */
Ext.define('Gnt.field.Assignment', {
    extend: 'Ext.form.field.Picker',
    alias: [
        'widget.assignmentfield',
        'widget.assignmenteditor'
    ],
    alternateClassName: 'Gnt.widget.AssignmentField',
    requires: [
        'Gnt.widget.AssignmentGrid',
        'Gnt.patches.CheckboxModel',
        'Gnt.patches.NavigationModel'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    matchFieldWidth: false,
    editable: false,
    task: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - cancelText : 'Cancel',
     - closeText  : 'Save and Close'
     */
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources
     */
    resourceStore: null,
    /**
     * @cfg {Object} gridConfig A custom config object used to configure the Gnt.widget.AssignmentGrid instance
     */
    gridConfig: null,
    /**
     * @cfg {String} formatString A string defining how an assignment should be rendered. Defaults to '{0} [{1}%]'
     */
    formatString: '{0} [{1}%]',
    /**
     * @cfg {Boolean} expandPickerOnFocus true to show the grid picker when this field receives focus.
     */
    expandPickerOnFocus: false,
    afterRender: function() {
        this.callParent(arguments);
        this.on('expand', this.onPickerExpand, this);
        if (this.expandPickerOnFocus) {
            this.on('focus', function() {
                this.expand();
            }, this);
        }
    },
    createPicker: function() {
        var grid = new Gnt.widget.AssignmentGrid(Ext.apply({
                frame: true,
                floating: true,
                ownerCmp: this,
                height: 200,
                width: 300,
                resourceStore: this.task.getResourceStore(),
                assignmentStore: this.task.getAssignmentStore(),
                fbar: this.buildButtons(),
                listeners: {
                    cellkeydown: function(view, cell, cellIndex, record, tr, rowIndex, e) {
                        // Collapse picker on ESC key press
                        if (e.getKey() === e.ESC && !grid.isEditing()) {
                            this.collapse();
                        }
                    },
                    scope: this
                }
            }, this.gridConfig || {}));
        return grid;
    },
    buildButtons: function() {
        return [
            '->',
            {
                text: this.L('closeText'),
                handler: function() {
                    // when clicking on "close" button with editor visible
                    // grid will be destroyed right away and seems in IE there will be no
                    // "blur" event for editor
                    // this is also sporadically reproducable in FF
                    // doing a defer to let the editor to process the "blur" first (will take 1 + 10 ms delay)
                    // only then close the editor window
                    Ext.Function.defer(this.onSaveClick, Ext.isIE && !Ext.isIE9 ? 60 : 30, this);
                },
                scope: this
            },
            {
                text: this.L('cancelText'),
                handler: function() {
                    this.collapse();
                },
                scope: this
            }
        ];
    },
    setTask: function(task) {
        this.task = task;
        this.setRawValue(this.getFieldDisplayValue(task));
    },
    onPickerExpand: function() {
        // Select the assigned resource in the grid
        this.picker.loadTaskAssignments(this.task.getId());
    },
    onSaveClick: function() {
        // Update the assignment store with the assigned resource data
        var sm = this.picker.getSelectionModel(),
            selections = sm.selected;
        this.collapse();
        this.fireEvent('select', this, selections);
        this.picker.saveTaskAssignments();
    },
    isDirty: function(task) {
        task = task || this.task;
        if (!task)  {
            return false;
        }
        
        var assignmentStore = this.picker && this.picker.assignmentStore || task.getAssignmentStore(),
            assignments = task.getAssignments();
        // check if some of task assignments are dirty
        for (var i = 0,
            l = assignments.length; i < l; i++) {
            if (assignments[i].dirty || assignments[i].phantom)  {
                return true;
            }
            
        }
        if (assignmentStore) {
            assignments = assignmentStore.getRemovedRecords();
            // check if there are some unsaved assignments removed from the task
            for (i = 0 , l = assignments.length; i < l; i++) {
                if (assignments[i].getTaskId() == task.getId())  {
                    return true;
                }
                
            }
        }
        return false;
    },
    getFieldDisplayValue: function(task) {
        task = task || this.task;
        var resourceNames = Ext.Array.map(task.getAssignments(), function(assignment) {
                var formattedName = Ext.String.format(this.formatString, assignment.getResourceName(), assignment.getUnits());
                return Ext.String.htmlEncode(formattedName);
            }, this);
        return resourceNames.join(', ');
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.ResourceAssignment
@extends Ext.grid.column.Column

A Column showing the resource assignments of a task. To make the column editable,
add the {@link Sch.plugin.TreeCellEditing} plugin to your gantt panel:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'resourceassignmentcolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

 {@img gantt/images/resource-assignment.png 2x}

 */
Ext.define("Gnt.column.ResourceAssignment", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.resourceassignmentcolumn",
        "widget.ganttcolumn.resourceassignment"
    ],
    requires: [
        'Gnt.field.Assignment'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    tdCls: 'sch-assignment-cell',
    /**
     * @cfg {Boolean} showUnits Set to `true` to show the assignment units (in percent). Default value is `true`.
     */
    showUnits: true,
    // Reference to the field used by the Editor
    field: null,
    // Copied from the panel view if cells for this columns should be marked dirty
    dirtyCls: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        var field = config.editor;
        var showUnits = config.showUnits || this.showUnits;
        delete config.editor;
        config.editor = field || {};
        if (!(config.editor instanceof Ext.form.Field)) {
            config.editor = Ext.ComponentManager.create(Ext.applyIf(config.editor, {
                expandPickerOnFocus: true,
                formatString: '{0}' + (showUnits ? ' [{1}%]' : '')
            }), 'assignmentfield');
        }
        config.field = config.editor;
        this.callParent([
            config
        ]);
        this.scope = this;
        if (this.field) {
            // HACK, complete editing when the field is collapsed
            this.field.on('collapse', function() {
                this.up('treepanel').getView().setActionableMode(false);
            }, this);
        }
    },
    sorterFn: function(task1, task2) {
        var me = this;
        var name1 = me.field.getFieldDisplayValue(task1),
            name2 = me.field.getFieldDisplayValue(task2);
        return name1 && (name1 > name2) ? -1 : 1;
    },
    afterRender: function() {
        var view = this.up('treepanel').getView();
        var gantt = view.up('ganttpanel');
        // Check if the current view is configured to highlight dirty cells
        if (view.markDirty) {
            this.dirtyCls = view.dirtyCls;
        }
        this.callParent(arguments);
        this.setSorter(Ext.Function.bind(this.sorterFn, this));
        if (gantt.ganttEditingPlugin) {
            gantt.ganttEditingPlugin.on({
                edit: this.onAfterEdit,
                canceledit: this.onAfterEdit,
                scope: this
            });
        }
    },
    /**
     * Return assignment data to be saved to memory, only works with 'raw' format
     * @param {Gnt.model.Task} task Task being copied
     * @return {Object[]}
     */
    getRawData: function(task) {
        return Ext.Array.map(task.getAssignments(), function(assignment) {
            var data = assignment.copy(null).data;
            delete data[assignment.idProperty];
            return data;
        });
    },
    /**
     * Will validate and insert previously prepared assignment data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        var assignmentStore = task.getAssignmentStore();
        var toAdd = [];
        assignmentStore.removeAssignmentsForTask(task);
        Ext.isArray(data) && Ext.Array.each(data, function(item) {
            if (task.getResourceStore().getById(item[assignmentStore.model.prototype.resourceIdField])) {
                item[assignmentStore.model.prototype.taskIdField] = task.getId();
                toAdd.push(item);
            }
        });
        assignmentStore.add(toAdd);
    },
    renderer: function(value, meta, task) {
        if (this.dirtyCls && this.field.isDirty(task)) {
            meta.tdCls = this.dirtyCls;
        }
        return this.field.getFieldDisplayValue(task);
    },
    // Restore focus to original Gantt cell after editing is done
    onAfterEdit: function(editor, context) {
        if (context.column === this) {
            var gridView = context.grid.getView();
            var cell = (new Ext.grid.CellContext(gridView)).setPosition(context.rowIdx, context.colIdx);
            gridView.focusCell(cell);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Rollup
@extends Ext.tree.Column

A Column which displays if the task should rollup to the parent task.
*/
Ext.define("Gnt.column.Rollup", {
    extend: 'Ext.grid.Column',
    alias: [
        'widget.rollupcolumn',
        'widget.ganttcolumn.rollup'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    fieldProperty: 'rollupField',
    editor: 'combobox',
    defaultEditor: 'combobox',
    initComponent: function() {
        this.initTaskFieldColumn({
            store: [
                [
                    false,
                    this.L('no')
                ],
                [
                    true,
                    this.L('yes')
                ]
            ]
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.L(value ? 'yes' : 'no');
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Scale
@extends Ext.grid.column.Template

A Column used to to display a vertical coordinate axis (numeric scale). This column is used by the {@link Gnt.panel.ResourceHistogram ResourceHistogram} panel.

Usage example:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 0, 21),
        renderTo            : Ext.getBody(),
        columns             : [
            {
                flex      : 1,
                dataIndex : 'Name'
            },
            {
                xtype           : 'scalecolumn'
            }
        ]
    });

#Defining the scale

The column supports two configuration modes for the numeric scale. The first one is incremental and the second one is using a fixed set of points.

#Incremental approach

To use this approach you must define the following parameters: {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep}.
Based on them, the column will build scale points taking the {@link #scaleMin} value as a start value and the {@link #scaleMax} as the last scale point.
Values between {@link #scaleMin} and {@link #scaleMax} will be calculated as:

    valueN = scaleMin + N * scaleStep

Normally this approach is meant to be used for linear scales.

#Fixed set of points

As an option to the earlier approach, you can use the {@link #scalePoints} config. This config can be used to specify an array af scale points.
The array should contain objects describing the scale points, having the following properties:

 - `value`   Scale point value. **This property is required**.
 - `label`   Label for the scale point
 - `cls`     CSS class for corresponding scale point.

For example:

    var scaleColumn = new Gnt.column.Scale({
        scalePoints : [
            {
                value   : 0
            },
            {
                value   : 1,
                label   : 'Day',
                cls     : 'dayend'
            },
            {
                value   : 0.5
            }
        ]
    });

*/
Ext.define('Gnt.column.Scale', {
    extend: 'Ext.grid.column.Template',
    alias: 'widget.scalecolumn',
    sortable: false,
    /**
     * @cfg {Object[]} scalePoints An array of scale points. Each point should be represented as an object containing the following properties:
     *
     * - `value`   Scale point value **(required)**.
     * - `label`   Label for the scale point
     * - `cls`     CSS class for corresponding scale point.
     */
    scalePoints: null,
    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale points.
     *
     * **Also,** this value is used as the margin between the top scale line (defined by {@link #scaleMax} option) and the top border of the cell.
     */
    scaleStep: 2,
    /**
     * @cfg {Number} scaleLabelStep Defines the interval between the scale points with labels.
     * By default the scale values are used for the labels. To use custom labels please use the {@link #scalePoints} config.
     */
    scaleLabelStep: 4,
    /**
     * @cfg {Number} scaleMin Minimum scale point value.
     */
    scaleMin: 0,
    /**
     * @cfg {Number} scaleMax Maximum scale point value.
     */
    scaleMax: 24,
    width: 40,
    //availableHeight     : 48,
    scaleCellCls: 'gnt-scalecolumn',
    tpl: '<div class="gnt-scalecolumn-wrap" style="height:{scaleHeight}px;">' + '<tpl for="scalePoints">' + '<tpl if="label !== \'\'">' + '<span class="gnt-scalecolumn-label-line {cls}" style="bottom:{bottom}px"><span class="gnt-scalecolumn-label">{label}</span></span>' + '<tpl else>' + '<span class="gnt-scalecolumn-line {cls}" style="bottom:{bottom}px"></span>' + '</tpl>' + '</tpl>' + '</div>',
    initComponent: function() {
        this.tdCls = (this.tdCls || '') + ' ' + this.scaleCellCls;
        this.callParent(arguments);
    },
    onAdded: function() {
        this.callParent(arguments);
        this.setAvailableHeight(this.up('timelinegrid').rowHeight, true);
    },
    setAvailableHeight: function(height, initial) {
        this.availableHeight = height;
        // if no ready scalePoints array specified
        if (!this.scalePoints) {
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            // build scale point based on min/max/step size params
            this.scalePoints = this.buildScalePoints();
        } else // if scale points array provided
        {
            if (initial) {
                this.scalePoints.sort(function(a, b) {
                    return a.value - b.value;
                });
                this.scaleMin = this.scalePoints[0].value;
                this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
                this.scaleStep = (this.scaleMax - this.scaleMin) / 10;
            }
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            // let's fill it with calculated coordinates
            this.updateScalePoints();
        }
    },
    defaultRenderer: function(value, meta, record) {
        var data = {
                record: Ext.apply({}, record.data, record.getAssociatedData()),
                scaleHeight: this.availableHeight,
                scalePoints: this.scalePoints
            };
        return this.tpl.apply(data);
    },
    buildScalePoints: function() {
        var minValue = this.scaleMin,
            value = minValue,
            step = this.scaleStep,
            labelStep = this.scaleLabelStep,
            stepHeight = this.scaleStepHeight,
            availableHeight = this.availableHeight,
            scaleCellCls = this.scaleCellCls,
            // additional css class for scaleMin point
            cls = scaleCellCls + '-min',
            result = [];
        // shorthand
        var makePoint = function(value, label, cls) {
                return {
                    bottom: Math.round((value - minValue) * stepHeight),
                    value: value,
                    label: label != 'undefined' ? label : '',
                    cls: cls || ''
                };
            };
        // push scale points starting from scaleMin
        while (value < this.scaleMax) {
            if (value > 0) {
                result.push(makePoint(value, value % labelStep || value === minValue ? '' : value, cls));
            }
            cls = '';
            value += step;
        }
        // push scaleMax point
        result.push(makePoint(this.scaleMax, this.scaleMax, scaleCellCls + '-max'));
        return result;
    },
    updateScalePoints: function() {
        var stepHeight = this.scaleStepHeight,
            availableHeight = this.availableHeight;
        Ext.Array.each(this.scalePoints, function(point) {
            point.bottom = Math.round(point.value * stepHeight);
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

A specialized field, allowing a user to also specify task scheduling mode value.
This class inherits from the standard Ext JS "combo" field, so any usual `Ext.form.field.ComboBox` configs can be used.

The value of this field can be one of the following strings: `Normal`, `FixedDuration`,
`EffortDriven`, `DynamicAssignment`.

@class Gnt.field.SchedulingMode
@extends Ext.form.field.ComboBox

*/
Ext.define('Gnt.field.SchedulingMode', {
    extend: 'Ext.form.field.ComboBox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.schedulingmodefield',
    alternateClassName: 'Gnt.widget.SchedulingmodeField',
    taskField: 'schedulingModeField',
    setTaskValueMethod: 'setSchedulingMode',
    getTaskValueMethod: 'getSchedulingMode',
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: true,
    editable: false,
    forceSelection: true,
    triggerAction: 'all',
    constructor: function(config) {
        config = config || {};
        if (!config.store)  {
            this.initStore(config);
        }
        
        this.callParent([
            config
        ]);
        this.on('change', this.onFieldChange, this);
    },
    initStore: function(config) {
        var me = this;
        config.store = me.getDefaultSchedulingModes();
    },
    getDefaultSchedulingModes: function() {
        var me = this;
        return [
            [
                'Normal',
                me.L('Normal')
            ],
            [
                'FixedDuration',
                me.L('FixedDuration')
            ],
            [
                'EffortDriven',
                me.L('EffortDriven')
            ],
            [
                'DynamicAssignment',
                me.L('DynamicAssignment')
            ]
        ];
    },
    // will be used in the column's renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        var record = this.findRecordByValue(value);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText);
        }
        return me.displayTpl.apply(displayTplData);
    },
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    getValue: function() {
        return this.value;
    },
    onFieldChange: function(field, value) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task && this.value) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.SchedulingMode
@extends Ext.grid.column.Column

A Column showing the `SchedulingMode` field of a task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        columns         : [
            ...
            {
                xtype       : 'schedulingmodecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })


*/
Ext.define("Gnt.column.SchedulingMode", {
    extend: 'Ext.grid.column.Column',
    requires: [
        'Gnt.field.SchedulingMode'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        'widget.schedulingmodecolumn',
        'widget.ganttcolumn.schedulingmode'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Mode'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Array} data A 2-dimensional array used for editing in combobox. The first item of inner arrays will be treated as "value" and 2nd - as "display"
     */
    data: null,
    fieldProperty: 'schedulingModeField',
    editor: 'schedulingmodefield',
    defaultEditor: 'schedulingmodefield',
    instantUpdate: false,
    initComponent: function() {
        this.initTaskFieldColumn({
            store: this.data
        });
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Sequence
@extends Ext.grid.column.Column

A "calculated" column which displays the sequential position of the task in the project. 
See {@link Gnt.model.Task#getSequenceNumber} for details.


*/
Ext.define("Gnt.column.Sequence", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.sequencecolumn",
        "widget.ganttcolumn.sequence"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : '#'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 40,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'right',
    sortable: false,
    dataIndex: 'index',
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
    },
    renderer: function(value, meta, task) {
        return task.getSequenceNumber();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.column.ShowInTimeline
@extends Ext.grid.column.Check

A Column showing if a task has to be displayed in the {@link Gnt.panel.Timeline project timeline}.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'showintimelinecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    });

*/
Ext.define("Gnt.column.ShowInTimeline", {
    extend: 'Ext.grid.column.Check',
    alias: [
        'widget.showintimelinecolumn',
        'widget.ganttcolumn.showintimeline'
    ],
    uses: [
        'Gnt.patches.CheckColumn'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    fieldProperty: 'showInTimelineField',
    initComponent: function(config) {
        this.initTaskFieldColumn();
        this.callParent([
            config
        ]);
        this.tdCls = (this.tdCls || '') + ' gnt-showintimeline-cell';
    },
    onReadOnlySet: function(gantt, readOnly) {
        this.setDisabled(readOnly);
    },
    taskFieldRenderer: function() {
        var result = this.defaultRenderer.apply(this, arguments);
        this.applyColumnCls.apply(this, arguments);
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Slack
@extends Ext.grid.column.Column

A column showing the available amount of slack for a task. The _slack_ (or _float_) is the amount of time that a task can be delayed
without causing a delay to any of its successors.

The slack is displayed in units specified by the {@link #slackUnit} config (by default it's displayed in _days_).


    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'slackcolumn',
                width       : 70
            }
            ...
        ],
        ...
    })

*/
Ext.define('Gnt.column.Slack', {
    extend: 'Ext.grid.column.Column',
    requires: [
        'Ext.Number',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.slackcolumn',
        'widget.ganttcolumn.slack'
    ],
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the slack.
     */
    decimalPrecision: 2,
    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated slack unit name, not full.
     * Useful if the column width is limited.
     */
    useAbbreviation: false,
    /**
     * @cfg {String} slackUnit The time unit to use when displaying the slack amount.
     */
    slackUnit: 'd',
    width: 100,
    align: 'left',
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        value = task.getSlack();
        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + ' ' + Sch.util.Date[this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit'](this.slackUnit, value !== 1);
        }
        return '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.Successor
@extends Gnt.column.Dependency

A Column showing the successors of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'successorcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
user to specify multiple successors including lag. Please refer to {@link Gnt.field.Dependency}
documentation for the expected format when editing data in this column.

*/
Ext.define("Gnt.column.Successor", {
    extend: "Gnt.column.Dependency",
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        "widget.successorcolumn",
        "widget.ganttcolumn.successor"
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text : 'Successors'
     */
    type: 'successors',
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
    },
    /**
     * Will validate and insert previously prepared predecessors data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        var dependencyStore = task.getDependencyStore();
        var toAdd = [];
        dependencyStore.remove(task.getOutgoingDependencies(true));
        Ext.isArray(data) && Ext.Array.each(data, function(item) {
            // check if source task exists
            if (task.getTaskStore().getById(item[dependencyStore.model.prototype.toField])) {
                var newDependency = new dependencyStore.model(item);
                newDependency.setSourceId(task.getId());
                if (dependencyStore.isValidDependency(newDependency)) {
                    toAdd.push(newDependency);
                }
            }
        });
        dependencyStore.add(toAdd);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.column.WBS
@extends Ext.grid.column.Date

A "calculated" Column which displays the WBS (Work Breakdown Structure) for the tasks - the position of the task in the project tree structure.
*/
Ext.define("Gnt.column.WBS", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.wbscolumn",
        "widget.ganttcolumn.wbs"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'WBS'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 40,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    sortable: false,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.tdCls = (this.tdCls || '') + ' gnt-wbs-cell';
    },
    renderer: function(value, meta, task) {
        return task.getWBSCode();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.Base', {
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "A constraint",
     *      - "Remove the constraint" : "Remove the constraint",
     *      - "Cancel the change and do nothing" : "Cancel the change and do nothing"
     */
    isSatisfied: function(task, date, precision) {
        throw "Abstract method";
    },
    getResolution: function(callback, task, date) {
        var me = this,
            called = false;
        date = date || task.getConstraintDate();
        var next = function() {
                if (!called) {
                    called = true;
                    callback.apply(this, arguments);
                }
            };
        return {
            title: me.L("name"),
            task: task,
            date: date,
            resolutions: this.getResolutionOptions(next, task, date),
            getCancelActionOption: function() {
                return this.resolutions[0];
            },
            cancelAction: function() {
                return this.getCancelActionOption().resolve();
            },
            proceedAction: function() {
                next();
            },
            getResolution: function(id) {
                return Ext.Array.findBy(this.resolutions, function(item) {
                    return item.id == id;
                });
            }
        };
    },
    getResolutionOptions: function(callback, task, date, precision) {
        date = date || task.getConstraintDate();
        var me = this;
        var resolutions = [
                {
                    id: 'cancel',
                    title: me.L("Cancel the change and do nothing"),
                    resolve: function() {
                        callback(true);
                    }
                }
            ];
        me.hasThisConstraintApplied(task) && resolutions.push({
            id: 'remove-constraint',
            title: me.L("Remove the constraint"),
            resolve: function() {
                task.setConstraintType('');
                callback();
            }
        });
        return resolutions;
    },
    hasThisConstraintApplied: function(task) {
        return task.getConstraintClass() === this;
    },
    getInitialConstraintDate: function(task) {
        return task.getConstraintDate();
    },
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        return date;
    },
    shiftToNearestValidConstraintDate: function(date, format, task) {
        return date;
    },
    statics: {
        /**
         * Returns constraint instance by its type, if type is null or empty string returns null
         *
         * @param {String} type Constraint type to return instance for.
         * @return {Gnt.constraint.Base|null} Constraint class singleton
         */
        getConstraintClass: function(type) {
            var result = !Ext.isEmpty(type) && Ext.ClassManager.getByAlias('gntconstraint.' + type);
            // Postcondition: constraint class must exist
            Ext.isEmpty(type) || result || Ext.Error.raise("Can't get constraint class, unrecognized constraint type: " + type);
            return result || null;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// This class is not part of the build, we do not support scheduling from the end project data (to the start, i.e.
// right to left scheduling), and we do not have ASAP constraint in the build either, thus we do not need this constraint.
Ext.define('Gnt.constraint.AsLateAsPossible', {
    extend: 'Gnt.constraint.Base',
    singleton: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:

            - "name" : "As late as possible"
     */
    isSatisfied: function(task) {
        throw "Abstract method";
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// This class is not part of the build, Gantt default scheduling behaviour is as soon as possible by default,
// thus we do not need this constraint
Ext.define('Gnt.constraint.AsSoonAsPossible', {
    extend: 'Gnt.constraint.Base',
    singleton: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:

            - "name" : "As soon as possible"
     */
    isSatisfied: function(task) {
        throw "Abstract method";
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.FinishNoEarlierThan', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.finishnoearlierthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Finish no earlier then",
     *      - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isSatisfied: function(task, date) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        return !date || !endDate || endDate >= date;
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to finish on {0}"),
            resolve: function() {
                task.setEndDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getEndDate();
    },
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, -1);
        }
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1);
        }
        return date;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.FinishNoLaterThan', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.finishnolaterthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *       - "name" : "Finish no later than",
     *       - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isSatisfied: function(task, date, precision) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !endDate || endDate <= date
        return !date || !endDate || (Sch.util.Date.compareWithPrecision(endDate, date, precision) !== 1);
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to finish on {0}"),
            resolve: function() {
                task.setEndDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getEndDate();
    },
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, -1);
        }
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1);
        }
        return date;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.MustFinishOn', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.mustfinishon',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Must finish on",
     *      - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isSatisfied: function(task, date, precision) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !endDate || (endDate.valueOf() == date.valueOf())
        return !date || !endDate || (Sch.util.Date.compareWithPrecision(endDate, date, precision) === 0);
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to finish on {0}"),
            resolve: function() {
                task.setEndDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getEndDate();
    },
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, -1);
        }
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        if (date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1);
        }
        return date;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.MustStartOn', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.muststarton',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Must start on",
     *      - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isSatisfied: function(task, date, precision) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !startDate || (startDate.valueOf() == date.valueOf())
        return !date || !startDate || (Sch.util.Date.compareWithPrecision(startDate, date, precision) === 0);
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to start at {0}"),
            resolve: function() {
                task.setStartDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getStartDate();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.StartNoEarlierThan', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.startnoearlierthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Start no earlier than",
     *      - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isSatisfied: function(task, date, precision) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        // read the followinig as: !date || !startDate || (startDate >= date)
        return !date || !startDate || (Sch.util.Date.compareWithPrecision(startDate, date, precision) !== -1);
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to start at {0}"),
            resolve: function() {
                task.setStartDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getStartDate();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.constraint.StartNoLaterThan', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.startnolaterthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *     - "name" : "Start no later than",
     *     - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isSatisfied: function(task, date, precision) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !startDate || (startDate <= date)
        return !date || !startDate || (Sch.util.Date.compareWithPrecision(startDate, date, precision) !== 1);
    },
    getResolutionOptions: function(callback, task, date, precision) {
        var me = this,
            resolutions = me.callParent(arguments);
        date = date || task.getConstraintDate();
        resolutions.push({
            id: 'move-task',
            title: me.L("Move the task to start at {0}"),
            resolve: function() {
                task.setStartDateWithoutPropagation(date, true);
                callback();
            }
        });
        return resolutions;
    },
    getInitialConstraintDate: function(task) {
        return task.getStartDate();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Sch.patches.CollectionKey', {
    extend: 'Sch.util.Patch',
    target: 'Ext.util.CollectionKey',
    minVersion: '6.0.0',
    maxVersion: '6.0.3',
    // Though by the time it out the issue reported might not be fixed yet.
    reportUrl: 'https://www.sencha.com/forum/showthread.php?310532-Ext.util.Collection-key-configuration-application-and-cloning-is-broken',
    description: [
        'Ext.util.CollectionKey::clone() is broken due to wrong usage of Ext\'s configuration facility.',
        'We relay on the (though) private Ext.data.LocalStore::extraKeys configuration, we use it to define additional',
        'unique but complex keys for Assignment and Dependency stores. Upon store filtering such keys are being cloned',
        'but due to the broken config key\'s clone() method throws an exception'
    ].join(' '),
    applyFn: function() {
        var applyFn;
        applyFn = Ext.util.CollectionKey.prototype.applyKeyFn;
        Ext.util.CollectionKey.prototype.applyKeyFn = Ext.identityFn;
        Ext.util.CollectionKey.prototype.updateKeyFn = applyFn;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin intercepts a set of store methods and firing a set of events providing a cache with a better hint
 * when to update itself.
 *
 * @private
 */
Ext.define('Sch.data.mixin.CacheHintHelper', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        before: {
            loadRecords: 'loadRecords',
            removeAll: 'removeAll'
        }
    },
    // Call to loadRecords() results in 'datachanged' and 'refresh' events, but 'datachanged' is also fired upon
    // call to add/remove/write/filter/sort/removeAll so a cache cannot detect what method call results in 'datachanged'
    // in case of previosly mentioned methods a cache shouldn't handle 'datachanged' event it is not affected by
    // write/filter/sort at all, as for add/remove/removeAll it listens to preceding events like 'add'/'remove'/'clear'
    // and reflects updates correspondingly. But in case of loadRecords() the sequence of events fired 'datachanged' and
    // 'refresh' provides too little information to make right decision whether to reset a cache or not, moreover resetting
    // a cache on 'refresh' is to late since a lot of logic (rendering logic especially) start quering the store
    // upon 'datachanged' event and thus if cache wasn't reset it will provide that logic with outdated data.
    // Thus I have to override loadRecords() and make it fire private 'cacheresethint' event to provide a cache with
    // a way to reset itself beforehand.
    loadRecords: function() {
        this.fireEvent('cacheresethint', this);
    },
    // If no event is fired for the removal, we need to clear cache manually
    removeAll: function(silent) {
        if (silent) {
            this.fireEvent('cacheresethint', this);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.model.Assignment
 * @extends Sch.model.Customizable
 *
 * This class represent a single assignment of a resource to an event in scheduler.
 * It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * An Assignment has the following fields:
 * - `Id` - The id of the assignment
 * - `ResourceId` - The id of the resource assigned
 * - `EventId` - The id of the event to which the resource is assigned
 *
 * The names of these fields can be customized by subclassing this class.
 * Please refer to {@link Sch.model.Customizable} for details.
 */
Ext.define('Sch.model.Assignment', {
    extend: 'Sch.model.Customizable',
    idProperty: 'Id',
    customizableFields: [
        {
            name: 'ResourceId'
        },
        {
            name: 'EventId'
        }
    ],
    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an assignment belongs.
     * Defaults to "ResourceId".
     */
    resourceIdField: 'ResourceId',
    /**
     * @cfg {String} eventIdField The name of the field identifying an event to which an assignment belongs.
     * Defaults to "EventId".
     */
    eventIdField: 'EventId',
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * Returns an assigment store this assignment is part of. Assignment must be part of an assigment store
     * to be able to retrieve it.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        return this.joined && this.joined[0];
    },
    /**
     * Returns an event store this assignment uses as default event store. Assignment must be part
     * of an assignment store to be able to retrieve default event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore: function() {
        var assignmentStore = this.getAssignmentStore();
        return assignmentStore && assignmentStore.getEventStore();
    },
    /**
     * Returns a resource store this assignment uses as default resource store. Assignment must be part
     * of an assignment store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },
    /**
     * Returns an event associated with this assignment.
     *
     * @privateparam  {Sch.data.EventStore} [eventStore]
     * @return {Sch.model.Range} Event instance
     */
    getEvent: function(eventStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get an event via provided
        // event store
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getModelById(me.getEventId());
    },
    /**
     * Returns the resource associated with this assignment.
     *
     * @privateparam {Sch.data.ResourceStore} [resourceStore]
     * @return {Sch.model.Resource} Instance of resource
     */
    getResource: function(resourceStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get a resource via provided
        // resource store
        resourceStore = resourceStore || me.getResourceStore();
        return resourceStore && resourceStore.getModelById(me.getResourceId());
    },
    /**
     * Convenience method to get a name of the associated event.
     *
     * @privateparam  {Sch.data.EventStore} [eventStore]
     * @return {String} name
     */
    getEventName: function(eventStore) {
        var evnt = this.getEvent(eventStore);
        return evnt && evnt.getName() || '';
    },
    /**
     * Convenience method to get a name of the associated resource.
     *
     * @privateparam {Sch.data.ResourceStore} [resourceStore]
     * @return {String} name
     */
    getResourceName: function(resourceStore) {
        var resource = this.getResource(resourceStore);
        return resource && resource.getName() || '';
    },
    /**
     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var me = this,
            event = me.getEvent(),
            resource = me.getResource();
        return event && !event.phantom && resource && !resource.phantom;
    },
    fullCopy: function() {
        return this.copy.apply(this, arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.data.AssignmentStore
 * @extends Ext.data.Store
 *
 * A class representing a collection of assignments between events in the {@link Sch.data.EventStore} and resources
 * in the {@link Sch.data.ResourceStore}.
 *
 * Contains a collection of {@link Sch.model.Assignment} records.
 */
Ext.define('Sch.data.AssignmentStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Sch.patches.CollectionKey'
    ],
    uses: [
        'Sch.data.util.EventAssignmentsCache',
        'Sch.data.util.ResourceAssignmentsCache',
        'Sch.data.util.AssignmentStoreEventResourcesCache',
        'Sch.data.util.AssignmentStoreResourceEventsCache'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Robo.data.Store'
    ],
    config: {
        // WARNING: this is a private config in Ext.data.LocalStore
        extraKeys: {
            byEventIdResourceId: {
                keyFn: function(assignment) {
                    return Sch.data.AssignmentStore.makeAssignmentEventResourceCompositeKey(assignment.getEventId(), assignment.getResourceId());
                }
            }
        }
    },
    model: 'Sch.model.Assignment',
    alias: 'store.assignmentstore',
    storeId: 'assignments',
    eventResourceCache: null,
    resourceEventsCache: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    /**
     * @property {Sch.data.EventStore} eventStore The event store to which this assignment store is associated.
     * Usually it is configured automatically, by the event store itself.
     *
     * @readonly
     */
    eventStore: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.eventAssignmentsCache = me.eventAssignmentsCache || me.createEventAssignmentCache();
        me.resourceAssignmentsCache = me.resourceAssignmentsCache || me.createResourceAssignmentCache();
    },
    // The caches commented are conflicting with the fact that assignments might be added to assignment store
    // before corresponding events/records are. For example SchedulerDragZone::updateRecords() does that
    // as soon as it's fixed this might be uncommented thus we might gain more performace at
    // event::getResources()/resource::getEvents() and corresponding methods
    //me.eventResourceCache       = me.eventResourceCache       || me.createAssignmentStoreEventResourcesCache();
    //me.resourceEventsCache      = me.resourceEventsCache      || me.createAssignmentStoreResourceEventsCache();
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventResourceCache', 'resourceEventsCache', 'eventAssignmentsCache', 'resourceEventsCache', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.callParent();
    },
    createEventAssignmentCache: function() {
        return new Sch.data.util.EventAssignmentsCache(this);
    },
    createResourceAssignmentCache: function() {
        return new Sch.data.util.ResourceAssignmentsCache(this);
    },
    createAssignmentStoreEventResourcesCache: function() {
        return new Sch.data.util.AssignmentStoreEventResourcesCache(this);
    },
    createAssignmentStoreResourceEventsCache: function() {
        return new Sch.data.util.AssignmentStoreResourceEventsCache(this);
    },
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore = me.eventStore;
        me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
        me.attachToEventStore(me.eventStore);
        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.AssignmentStore} this
             * @param {Sch.data.EventStore} newEventStore
             * @param {Sch.data.EventStore} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    attachToEventStore: function(eventStore) {
        var me = this;
        Ext.destroy(me.eventStoreDetacher);
        if (eventStore && eventStore.isTreeStore) {
            me.eventStoreDetacher = eventStore.on({
                'noderemove': me.onEventNodeRemove,
                'resourcestorechange': me.onEventStoreResourceStoreChange,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher then in cache, we need those handlers to do their job before cache update
        else if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                'remove': me.onEventRemove,
                'resourcestorechange': me.onEventStoreResourceStoreChange,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher then in cache, we need those handlers to do their job before cache update
        me.attachToResourceStore(eventStore && eventStore.getResourceStore());
    },
    attachToResourceStore: function(resourceStore) {
        var me = this;
        Ext.destroy(me.resourceStoreDetacher);
        if (resourceStore) {
            if (resourceStore.isTreeStore) {
                me.resourceStoreDetacher = resourceStore.on({
                    'noderemove': me.onResourceNodeRemove,
                    scope: me,
                    destroyable: true,
                    priority: 200
                });
            } else // higher then in cache
            {
                me.resourceStoreDetacher = resourceStore.on({
                    'remove': me.onResourceRemove,
                    scope: me,
                    destroyable: true,
                    priority: 200
                });
            }
        }
    },
    // higher then in cache
    onEventStoreResourceStoreChange: function(eventStore, newResourceStore, oldResourceStore) {
        this.attachToResourceStore(newResourceStore);
    },
    onEventRemove: function(eventStore, events, index, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            Ext.Array.each(events, function(event) {
                assignments = assignments.concat(me.getAssignmentsForEvent(event));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onEventNodeRemove: function(eventStore, event, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            event.cascadeBy(function(cascadingEvent) {
                assignments = assignments.concat(me.getAssignmentsForEvent(cascadingEvent));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onResourceRemove: function(resourceStore, resources, index, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            Ext.Array.each(resources, function(resource) {
                assignments = assignments.concat(me.getAssignmentsForResource(resource));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onResourceNodeRemove: function(resourceStore, resource, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            resource.cascadeBy(function(cascadingResource) {
                assignments = assignments.concat(me.getAssignmentsForResource(cascadingResource));
            });
            assignments.length && me.remove(assignments);
        }
    },
    /**
     * Maps over event assignments.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForEvent: function(event, fn, filterFn) {
        var me = this,
            result = [];
        fn = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;
        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.each(me.eventAssignmentsCache.get(event), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        } else {
            result = result.concat(me.eventAssignmentsCache.get(event));
        }
        return result;
    },
    /**
     * Maps over resource assignments.
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForResource: function(resource, fn, filterFn) {
        var me = this,
            result = [];
        fn = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;
        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.each(me.resourceAssignmentsCache.get(resource), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        } else {
            result = [].concat(me.resourceAssignmentsCache.get(resource));
        }
        return result;
    },
    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Range/Mixed} event
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForEvent: function(event) {
        return this.mapAssignmentsForEvent(event);
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Range/Mixed} event
     */
    removeAssignmentsForEvent: function(event) {
        var me = this;
        me.remove(me.getAssignmentsForEvent(event));
    },
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource/Mixed} event
     * @return {Sch.model.Range[]}
     */
    getAssignmentsForResource: function(resource) {
        return this.mapAssignmentsForResource(resource);
    },
    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     */
    removeAssignmentsForResource: function(resource) {
        var me = this;
        me.remove(me.getAssignmentsForResource(resource));
    },
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Range/Mixed} event
     * @return {Sch.model.Resource[]}
     */
    getResourcesForEvent: function(event) {
        var me = this,
            result;
        if (me.eventResourceCache) {
            result = me.eventResourceCache.get(event);
        } else {
            result = me.mapAssignmentsForEvent(event, function mapper(assignment) {
                return assignment.getResource();
            }, function filter(resource) {
                return !!resource;
            });
        }
        return result;
    },
    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Range[]}
     */
    getEventsForResource: function(resource) {
        var me = this,
            result;
        if (me.resourceEventsCache) {
            result = me.resourceEventsCache.get(resource);
        } else {
            result = me.mapAssignmentsForResource(resource, function mapper(assignment) {
                return assignment.getEvent();
            }, function filter(event) {
                return !!event;
            });
        }
        return result;
    },
    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed/Array} resource The resource(s) to assign to the event
     * @privateparam {Function} [assignmentSetupFn=Ext.identityFn]
     * @return {Sch.model.Assignment[]} An array with the created assignment(s)
     */
    assignEventToResource: function(event, resource, assignmentSetupFn) {
        var me = this,
            assignments = [];
        assignmentSetupFn = assignmentSetupFn || Ext.identityFn;
        var resources = Ext.isArray(resource) ? resource : [
                resource
            ];
        Ext.Array.each(resources, function(resource) {
            if (!me.isEventAssignedToResource(event, resource)) {
                var assignment = new me.model();
                assignment.setEventId(event instanceof Ext.data.Model && event.getId() || event);
                assignment.setResourceId(resource instanceof Ext.data.Model && resource.getId() || resource);
                assignment = assignmentSetupFn(assignment);
                assignments.push(assignment);
            }
        });
        me.add(assignments);
        return assignments;
    },
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed} [resource] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
     * @return {Sch.model.Assignment}
     */
    unassignEventFromResource: function(event, resource) {
        var me = this,
            assignment;
        if (!resource) {
            this.removeAssignmentsForEvent(event);
        } else if (me.isEventAssignedToResource(event, resource)) {
            assignment = me.getAssignmentForEventAndResource(event, resource);
            me.remove(assignment);
        }
        return assignment;
    },
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Boolean}
     */
    isEventAssignedToResource: function(event, resource) {
        var me = this,
            records = me.getResourcesForEvent(event),
            result = false,
            i, len;
        resource = resource instanceof Ext.data.Model && resource.getId() || resource;
        for (i = 0 , len = records.length; !result && i < len; i++) {
            result = records[i];
            result = result.getId() == resource;
        }
        return result;
    },
    /**
     * Returns assignment record for given event and resource
     *
     * @param {Sch.model.Range} event
     * @param {Sch.model.Resource} resource
     * @return {Sch.model.Assignment}
     */
    getAssignmentForEventAndResource: function(event, resource) {
        // NOTE: if something breaks remove this code and restore commented one, also remove extraKeys config
        var me = this;
        event = event instanceof Ext.data.Model && event.getId() || event;
        resource = resource instanceof Ext.data.Model && resource.getId() || resource;
        return me.byEventIdResourceId.get(me.self.makeAssignmentEventResourceCompositeKey(event, resource));
    },
    // NOTE: if something breaks then uncoment it and remove extraKeys config
    /*
        var me = this,
            records = me.getAssignmentsForEvent(event),
            result = null,
            i, len;

        resource = resource instanceof Ext.data.Model && resource.getId() || resource;

        for (i = 0, len = records.length; !result && i < len; i++) {
            result = records[i];
            result = result.getResourceId() == resource && result || null;
        }

        return result;
        */
    inheritableStatics: {
        makeAssignmentEventResourceCompositeKey: function() {
            var arr = [];
            return function(eventId, resourceId) {
                arr.length = 0;
                arr.push('event(', eventId, ')-resource(', resourceId, ')');
                return arr.join('');
            };
        }()
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.model.Assignment
 *
 * This class represent a single assignment of a resource to a task in your gantt chart. It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * An Assignment has the following fields:
 *
 *   - `Id` - The id of the assignment
 *   - `ResourceId` - The id of the resource assigned
 *   - `TaskId` - The id of the task to which the resource is assigned
 *   - `Units` - An integer value representing how much of the resource's availability that is dedicated to this task
 *
 * The names of these fields can be customized by subclassing this class. Please refer to {@link Sch.model.Customizable} for details.
 *
 * See also: {@link Gnt.column.ResourceAssignment}
 */
Ext.define('Gnt.model.Assignment', {
    extend: 'Sch.model.Assignment',
    uses: [
        'Sch.util.Date'
    ],
    customizableFields: [
        {
            name: 'TaskId'
        },
        {
            name: 'Units',
            type: 'float',
            defaultValue: 100
        }
    ],
    /**
     * @cfg {String} taskIdField The name of the field identifying the task to which an event belongs. Defaults to "TaskId".
     */
    taskIdField: 'TaskId',
    eventIdField: 'TaskId',
    constructor: function(data, session) {
        var me = this;
        me.eventIdField = me.taskIdField;
        me.callParent([
            data,
            session
        ]);
    },
    getEventId: function() {
        var me = this;
        return me.get(me.taskIdField);
    },
    setEventId: function(eventId) {
        var me = this;
        return me.set(me.taskIdField, eventId);
    },
    /**
     * @cfg {String} unitsField The name of the field identifying the units of this assignment. Defaults to "Units".
     */
    unitsField: 'Units',
    /**
     * Returns the associated task store instance
     *
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.store && this.store.getTaskStore() || null;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Returns the units of this assignment
     *
     * @return {Number} units
     */
    getUnits: function() {
        var me = this;
        return Math.max(0, me.get(me.unitsField));
    },
    /**
     * Sets the units of this assignment
     *
     * @param {Number} value The new value for units
     */
    setUnits: function(value) {
        var me = this;
        value < 0 && Ext.Error.raise("`Units` value for an assignment can't be less than 0");
        me.set(me.unitsField, value);
    },
    /**
     * Returns the task associated with this assignment.
     *
     * @privateparam {Gnt.data.TaskStore} [taskStore]
     * @return {Gnt.model.Task} Instance of task
     */
    getTask: function(taskStore) {
        var me = this;
        return me.getEvent(taskStore);
    },
    /**
     * Returns associated task name
     *
     * @privateparam {Gnt.data.TaskStore} [taskStore]
     * @return {String}
     */
    getTaskName: function(taskStore) {
        var task = this.getTask(taskStore);
        return task && task.getName() || '';
    },
    /**
     * Returns the effort, contributed by the resource of this assignment to a task of this assignment.
     *
     * @param {String} unit Unit to return the effort in. Defaults to the `EffortUnit` field of the task
     *
     * @return {Number} effort
     */
    getEffort: function(unit) {
        var me = this,
            task = me.getTask(),
            totalEffort = 0;
        task.forEachAvailabilityIntervalWithResources({
            startDate: task.getStartDate(),
            endDate: task.getEndDate(),
            resources: [
                me.getResource()
            ]
        }, function(intervalStartDate, intervalEndDate, currentAssignments) {
            var i, totalUnits;
            for (i in currentAssignments) {
                totalUnits = currentAssignments[i].units;
            }
            totalEffort += (intervalEndDate - intervalStartDate) * totalUnits / 100;
        });
        return task.getProjectCalendar().convertMSDurationToUnit(totalEffort, unit || task.getEffortUnit());
    },
    /**
     * Returns an effort which will be spent by the resource assignment designated resource on the assignment
     * designated task at the given date.
     *
     * @param {Date} date
     * @param {String} [unit]
     */
    getEffortAtDate: function(date, unit) {
        var SUD = Sch.util.Date,
            me = this,
            task = me.getTask(),
            startDate = task && task.getStartDate(),
            endDate = task && task.getEndDate(),
            resource = me.getResource(),
            totalEffort = 0;
        if (task && resource && startDate && endDate) {
            date = SUD.constrain(date, startDate, endDate);
            task.forEachAvailabilityIntervalWithResources({
                startDate: startDate,
                endDate: date,
                resources: [
                    resource
                ]
            }, function(from, till, assignments) {
                var totalUnits = 0;
                // Actually we have an object with one key, and the loop here is just to get to that key
                // since it's name is unknown
                for (var i in assignments) totalUnits = assignments[i].units;
                totalEffort += (till - from) * totalUnits / 100;
            });
            totalEffort = task.getCalendar().convertMSDurationToUnit(totalEffort, unit || task.getEffortUnit());
        }
        return totalEffort;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.data.AssignmentStore
 * @extends Schdata.AssignmentStore
 *
 * A class representing a collection of assignments between tasks in the {@link Gnt.data.TaskStore} and resources
 * in the {@link Gnt.data.ResourceStore}.
 *
 * Contains a collection of {@link Gnt.model.Assignment} records.
 */
Ext.define('Gnt.data.AssignmentStore', {
    extend: 'Sch.data.AssignmentStore',
    requires: [
        'Gnt.model.Assignment'
    ],
    model: 'Gnt.model.Assignment',
    alias: 'store.gantt_assignmentstore',
    storeId: 'assignments',
    // Overriden from Sch.data.AssignmentStore due to the logic required is handled by the Gantt codebase
    attachToEventStore: Ext.emptyFn,
    attachToResourceStore: Ext.emptyFn,
    /**
     * Returns the associated task store instance.
     *
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.getEventStore();
    },
    /**
     * Sets associated task store instance
     *
     * @parem {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        return this.setEventStore(store);
    },
    /**
     * Maps over task assignments.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForTask: function(task, fn, filterFn) {
        return this.mapAssignmentsForEvent(task, fn, filterFn);
    },
    /**
     * Returns all assignments for a given task.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @return {Gnt.model.Assignment[]}
     */
    getAssignmentsForTask: function(task) {
        return this.getAssignmentsForEvent(task);
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Gnt.model.Task/Mixed} task
     */
    removeAssignmentsForTask: function(task) {
        return this.removeAssignmentsForEvent(task);
    },
    /**
     * Returns all resources assigned to a task.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @return {Gnt.model.Resource[]}
     */
    getResourcesForTask: function(task) {
        return this.getResourcesForEvent(task);
    },
    /**
     * Returns all tasks assigned to a resource
     *
     * @param {Gnt.model.Resource/Mixed} resource
     * @return {Gnt.model.Task[]}
     */
    getTasksForResource: function(resource) {
        return this.getEventsForResource(resource);
    },
    /**
     * Creates and adds assignment record for a given task and a resource.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @param {Gnt.model.Resource/Mixed} resource
     * @return {Gnt.model.Assignment}
     */
    assignTaskToResource: function(task, resource, units) {
        return this.assignEventToResource(task, resource, function(assignment) {
            assignment.setUnits(units);
            return assignment;
        });
    },
    /**
     * Removes assignment record for a given task and a resource.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @param {Gnt.model.Resource/Mixed} resource
     * @return {Gnt.model.Assignment}
     */
    unassignTaskFromResource: function(task, resource) {
        return this.unassignEventFromResource(task, resource);
    },
    /**
     * Checks whether a task is assigned to a resource.
     *
     * @param {Gnt.model.Task/Mixed} evnt
     * @param {Gnt.model.Resource/Mixed} resource
     * @param {Function} [fn] Function which will resieve assignment record if one present
     * @return {Boolean}
     */
    isTaskAssignedToResource: function(task, resource, fn) {
        return this.isEventAssignedToResource(task, resource, fn);
    },
    /**
     * Returns assignment record for given task and resource
     *
     * @param {Gnt.model.Task} event
     * @param {Gnt.model.Resource} resource
     * @return {Gnt.model.Assignment}
     */
    getAssignmentForTaskAndResource: function(task, resource) {
        return this.getAssignmentForEventAndResource(task, resource);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.data.CalendarManager
@extends Ext.data.TreeStore

Class implements a central storage of all project calendars. Technically it's a collection of {@link Gnt.model.Calendar} records.

    var calendarManager = Ext.create('Gnt.data.CalendarManager');

Calendars loading
=================

This class is mainly designed to facilitate calendars loading/persisting. You can use both default Ext JS proxies approach:

    var calendarManager = Ext.create('Gnt.data.CalendarManager', {
        proxy : {
            type : 'ajax',
            url  : 'calendars.php'
        },
        listeners : {
            load : function () {
                // set project calendar when all calendars get loaded
                taskStore.setCalendar(123);
            }
        }
    });

Or the {@link Gnt.data.CrudManager} class to load all project stores by batch:

    var calendarManager = Ext.create('Gnt.data.CalendarManager');

    var taskStore = Ext.create('Gnt.data.TaskStore', {
        // taskStore calendar will automatically be set when calendarManager gets loaded
        calendarManager : calendarManager,
        resourceStore   : resourceStore,
        dependencyStore : dependencyStore,
        assignmentStore : assignmentStore
    });

    var crudManager = Ext.create('Gnt.data.CrudManager', {
        taskStore       : taskStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

Each record in the store, except the root node, automatically gets linked to its {@link Gnt.data.Calendar calendar instance}
which can be retrieved by {@link #getCalendar} method.

    // gets calendar instance having calendar Id equal to 'general'
    var calendar = calendarManager.getCalendar('general');

    // and here we do the same using {@link Gnt.model.Calendar} {@link Gnt.model.Calendar#getCalendar getCalendar} method.
    calendar = calendarManager.getById('general').getCalendar();

Please note that root node does not correspond to the project calendar (main calendar of the task store).
Any node can be the project calendar. See {@link #setProjectCalendar} for details.

Automatic calendar building
===========================

When you add a new record to the store a new calendar is automatically gets created:

    var calendarManager = Ext.create('Gnt.data.CalendarManager');

    // append new record to the calendar manager
    var record = calendarManager.getRoot().appendChild({
        leaf                : true,
        Name                : 'General II',
        DaysPerMonth        : 30,
        DaysPerWeek         : 7,
        HoursPerDay         : 24,
        WeekendsAreWorkdays : true,
        WeekendFirstDay     : 6,
        WeekendSecondDay    : 0,
        DefaultAvailability : [ '00:00-24:00' ]
    });

    // get newly created calendar to calendar2 variable
    var calendar2 = record.getCalendar();

Calendar class customization
==========================

The class that should be used to instantiate a calendar (during loading or manual adding) can be customized by the {@link #calendarClass} config:

    var calendarManager = Ext.create('Gnt.data.CalendarManager', {
        // by default we will create BusinessTime calendars
        calendarClass   : 'Gnt.data.calendar.BusinessTime'
    });

*/
Ext.define('Gnt.data.CalendarManager', {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Robo.data.Store',
        'Sch.data.mixin.UniversalModelGetter'
    ],
    model: 'Gnt.model.Calendar',
    alias: 'store.calendarmanager',
    storeId: 'calendars',
    /**
     * @cfg {String} calendarClass
     * The name of a class that will be used to create calendar instances.
     * If {@link Gnt.model.Calendar.calendarClass calendarClass} field is specified on a {@link Gnt.model.Calendar record} then it will be used instead.
     */
    calendarClass: 'Gnt.data.Calendar',
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}.
     */
    calendarConfig: null,
    projectCalendar: null,
    myListeners: null,
    proxy: 'memory',
    constructor: function(config) {
        this.callParent(arguments);
        this.myListeners = this.on({
            idchanged: this.onChangeId,
            rootchange: this.onNewRoot,
            nodeappend: this.onNewNode,
            nodeinsert: this.onNewNode,
            noderemove: this.onRemoveNode,
            destroyable: true,
            scope: this
        });
        var root = this.getRoot();
        if (root) {
            this.bindCalendars(root);
        } else {
            this.setRoot({
                expanded: true
            });
        }
    },
    destroy: function() {
        this.myListeners.destroy();
        this.callParent(arguments);
    },
    onChangeId: function(store, node, oldId, newId, oldInternalId) {
        if (!(node instanceof Gnt.model.Calendar))  {
            return;
        }
        
        var calendar = this.getCalendar(oldId || oldInternalId);
        calendar.setCalendarId(newId);
    },
    onNewNode: function(parent, node) {
        // create/bind calendar for the new node and for each of its children
        this.bindCalendars(node);
        if (node !== this.getRoot()) {
            this.fixCalendarParent(node);
        }
        var me = this;
        node.cascadeBy(function(node) {
            node.setCalendarManager(me);
        });
    },
    onNewRoot: function(root) {
        this.onNewNode(null, root);
    },
    onRemoveNode: function(parent, node, isMove) {
        if (!isMove) {
            var calendar = node.calendar;
            if (calendar) {
                this.unbindCalendarEvents(calendar);
                // if we're not in the middle of calendar manager loading
                // let's destroy the calendar instance
                if (!this.__loading) {
                    calendar.destroy();
                    Ext.data.StoreManager.unregister(calendar);
                }
                node.setCalendarManager(null);
            }
        }
    },
    suspendCalendarsEvents: function(queueSuspended) {
        this.getRoot().cascadeBy(function(node) {
            var c = node.getCalendar();
            if (c)  {
                c.suspendEvents(queueSuspended);
            }
            
        }, this);
    },
    resumeCalendarsEvents: function() {
        this.getRoot().cascadeBy(function(node) {
            var c = node.getCalendar();
            if (c)  {
                c.resumeEvents();
            }
            
        }, this);
    },
    getCalendarClass: function() {
        return this.calendarClass;
    },
    /**
     * Returns the project calendar.
     * @return {Gnt.data.Calendar} The project calendar.
     */
    getProjectCalendar: function() {
        return this.projectCalendar;
    },
    /**
     * Sets the project calendar.
     * @param {Gnt.data.Calendar/String} calendar The project calendar or its identifier.
     */
    setProjectCalendar: function(calendar) {
        // to avoid nested calls
        if (this.settingProjectCalendar)  {
            return;
        }
        
        if (typeof calendar !== 'object') {
            calendar = this.getCalendar(calendar) || Gnt.data.Calendar.getCalendar(calendar);
        }
        // ignore if no calendar found or we assign the same calendar
        if (!calendar || this.getProjectCalendar() === calendar)  {
            return;
        }
        
        this.settingProjectCalendar = true;
        this.projectCalendar = calendar;
        /**
         * @event projectcalendarset
         * Fires after {@link #setProjectCalendar} completion.
         * @param {Gnt.data.CalendarManager} calendarManager The calendar manager.
         * @param {Gnt.data.Calendar} calendar The calendar that was set as a project calendar.
         */
        this.fireEvent('projectcalendarset', this, calendar);
        this.settingProjectCalendar = false;
    },
    /**
     * Returns the calendar instance by specified identifier.
     * @param {String} calendarId Calendar identified.
     * @return {Gnt.data.Calendar}
     */
    getCalendar: function(calendarId) {
        var record = this.getModelById(calendarId);
        return record && record.getCalendar();
    },
    getNodeByCalendar: function(calendar) {
        // only root node is supposed to not have a calendar assigned
        if (!calendar)  {
            return this.getRoot();
        }
        
        var result = this.getModelById(calendar.calendarId);
        if (!result) {
            this.getRoot().cascadeBy(function(node) {
                var c = node.getCalendar();
                if (c === calendar) {
                    result = node;
                    return false;
                }
            }, this);
        }
        return result;
    },
    onParentChange: function(calendar, parent, oldParent) {
        var node = this.getNodeByCalendar(calendar);
        if (node && !node.syncingCalendarParent) {
            this.fixNodeParent(node);
        }
    },
    bindCalendarEvents: function(calendar) {
        /**
         * @event calendarload
         * Fires after a calendar instance was loaded.
         * @param {Gnt.data.Calendar} calendar Calendar that was loaded.
         * @param {Gnt.model.CalendarDay[]} days An array of records
         * @param {Boolean} successful True if the operation was successful.
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        this.relayEvents(calendar, [
            'load'
        ], 'calendar');
        /**
         * @event dayadd
         * Fired when a {@link Gnt.model.CalendarDay} instance has been added to a calendar.
         * @param {Gnt.data.Calendar} calendar Calendar that got new record.
         * @param {Gnt.model.CalendarDay[]} days The days that were added.
         * @param {Number} index The index at which the instances were inserted
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        /**
         * @event dayupdate
         * Fired when a {@link Gnt.model.CalendarDay} instance has been updated.
         * @param {Gnt.data.Calendar} calendar Calendar that holds the modified record.
         * @param {Gnt.model.CalendarDay} day The day record that was added.
         * @param {String} operation The update operation being performed. Value may be one of:
         *
         *  - `Ext.data.Model.EDIT`
         *  - `Ext.data.Model.REJECT`
         *  - `Ext.data.Model.COMMIT`
         * @param {String[]} modifiedFieldNames Array of field names changed during edit.
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        /**
         * @event dayremove
         * Fired when a {@link Gnt.model.CalendarDay} instance has been removed from a calendar.
         *
         * **If many days may be removed in one go, then it is more efficient to listen for the {@link #event-daybulkremove} event
         * and perform any processing for a bulk remove than to listen for this {@link #event-dayremove} event.**
         * @param {Gnt.data.Calendar} calendar The calendar object.
         * @param {Gnt.model.CalendarDay} day The day record that was removed.
         * @param {Number} index The index of the day record that was removed.
         */
        /**
         * @event daybulkremove
         * Fired at the *end* of the {@link Gnt.data.Calendar#method-remove remove} method when all days in the passed array have been removed.
         *
         * If many records may be removed in one go, then it is more efficient to listen for this event
         * and perform any processing for a bulk remove than to listen for many {@link #event-dayremove} events.
         * @param {Gnt.data.Calendar} calendar The calendar object.
         * @param {Gnt.model.CalendarDay[]} days The array of days that were removed (In the order they appear in the calendar).
         * @param {Number[]} indexes The indexes of the days that were removed.
         */
        this.relayEvents(calendar, [
            'add',
            'update',
            'remove',
            'bulkremove'
        ], 'day');
        /**
         * @event calendarchange
         * Fired after calendar data has been changed (like day add, edit, remove).
         * @param {Gnt.data.Calendar} calendar The calendar object.
         */
        this.relayEvents(calendar, [
            'calendarchange'
        ]);
        calendar.on('parentchange', this.onParentChange, this);
        // we listen to relayed versions of events here since they fired before
        // original calendar add/update/remove events and we need our onDayAdd/onDayUpdate/onDayRemove to get executed
        // before gantt CRUD manager notice changes (and it listens to dayadd/dayupdate/dayremove)
        this.on({
            dayadd: this.onDayAdd,
            dayupdate: this.onDayUpdate,
            dayremove: this.onDayRemove,
            scope: this
        });
    },
    unbindCalendarEvents: function(calendar) {
        this.un({
            dayadd: this.onDayAdd,
            dayupdate: this.onDayUpdate,
            dayremove: this.onDayRemove,
            scope: this
        });
        calendar && calendar.un({
            parentchange: this.onParentChange,
            scope: this
        });
    },
    onDayAdd: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    onDayUpdate: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    onDayRemove: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    fixCalendarParent: function(node) {
        if (node.syncingCalendarParent)  {
            return;
        }
        
        var parentNodeCalendar = node.parentNode.getCalendar(),
            nodeCalendar = node.getCalendar();
        if (parentNodeCalendar !== nodeCalendar.parent) {
            node.syncingCalendarParent = true;
            nodeCalendar.setParent(parentNodeCalendar);
            node.syncingCalendarParent = false;
        }
    },
    fixNodeParent: function(node) {
        var parentNodeCalendar = node.parentNode.getCalendar(),
            calendarParent = node.getCalendar().parent;
        // here we put "node" to the proper "parentNode" based on "calendar.parent"
        if (parentNodeCalendar !== calendarParent) {
            var properParentNode = this.getNodeByCalendar(calendarParent);
            properParentNode && properParentNode.appendChild(node);
        }
    },
    bindCalendar: function(record) {
        if (!record || this.getRoot() === record)  {
            return;
        }
        
        var calendar = record.getCalendar();
        var days = record.getDays();
        var id = record.getId() || record.internalId;
        days = Ext.isArray(days) && days;
        // if no calendar specified on the record or provided array of days to build new calendar
        if (!calendar || days) {
            if (!calendar) {
                // // let's try to get calendar by record identifier
                // calendar    = this.getCalendar(id);
                // // if this calendar is already bound to calendar manager
                // if (calendar) {
                //     // let's set link to it from the record
                //     record.setCalendar(calendar);
                //     return;
                // }
                // try to find calendar by record Id
                calendar = Gnt.data.Calendar.getCalendar(id);
            }
            // if we don't have the calendar registered yet
            if (!calendar) {
                // get parent calendar
                var parent = record.parentNode && record.parentNode.getCalendar();
                var calendarClass = Ext.ClassManager.get(record.getCalendarClass() || this.calendarClass);
                var calendarConfig = Ext.applyIf(record.getCalendarConfig(), {
                        data: days,
                        parent: parent
                    });
                // create calendar instance
                calendar = Ext.create(calendarClass, Ext.apply(calendarConfig, this.calendarConfig));
            }
            record.setCalendar(calendar);
            this.bindCalendarEvents(calendar);
        }
        // if calendar specified on the record but not registered in the calendar manager
        else if (!this.getCalendar(calendar.calendarId)) {
            // bind calendar manager listeners to it
            this.bindCalendarEvents(calendar);
        }
        /**
         * @event calendarbound
         * Fires after a calendar instance has been assigned to a record.
         * @param {Gnt.data.CalendarManager} calendarManager Calendar manager instance.
         * @param {Gnt.data.Calendar} calendar Calendar assigned to a record.
         * @param {Gnt.model.Calendar} record Record that was bound to a calendar.
         */
        this.fireEvent('calendarbound', this, calendar, record);
    },
    unbindCalendar: function(record) {
        if (!record || this.getRoot() === record)  {
            return;
        }
        
        var calendar = record.getCalendar();
        if (!calendar)  {
            return;
        }
        
        this.unbindCalendarEvents(calendar);
        this.fireEvent('calendarunbound', this, calendar, record);
    },
    bindCalendars: function(node) {
        var me = this;
        if (node) {
            Ext.Array.each([].concat(node), function(node) {
                node.cascadeBy(me.bindCalendar, me);
            });
        }
    },
    unbindCalendars: function(node) {
        var me = this;
        if (node) {
            Ext.Array.each([].concat(node), function(node) {
                node.cascadeBy(me.unbindCalendar, me);
            });
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.crud.AbstractManager
 @abstract

 This is an abstract class serving as the base for the Sch.data.CrudManager class.
 It implements basic mechanisms to organize batch communication with a server.
 Yet it does not contain methods related to _data transfer_ nor _encoding_.
 These methods are to be provided in sub-classes by consuming the appropriate mixins.

 For example, this is how the class can be used to implement an XML encoding system:

     // let's make new CrudManager using AJAX as a transport system and XML for encoding
     Ext.define('MyCrudManager', {
         extend  : 'Sch.crud.AbstractManager',

         mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
     });

 Data transfer and encoding methods
 ======================================

 Here are the methods that must be provided by subclasses of this class:

 - {@link #sendRequest}
 - {@link #cancelRequest}
 - {@link #encode}
 - {@link #decode}

 */
Ext.define('Sch.crud.AbstractManager', {
    requires: [
        'Ext.data.StoreManager'
    ],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    /**
     * @property {Number} revision
     * @readonly
     * The server revision stamp.
     * The _revision stamp_ is a number which should be incremented after each server-side change.
     * This property reflects the current version of the data retrieved from the server and gets updated after each {@link #load} and {@link #sync} call.
     */
    revision: null,
    /**
     * @property {Object[]} stores
     * A list of registered stores whose server communication will be collected into a single batch.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} stores.storeId Unique store identifier.
     * @property {Ext.data.AbstractStore} stores.store Store itself.
     * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    /**
     * @cfg {Ext.data.AbstractStore[]/String[]/Object[]} stores
     * Sets the list of stores controlled by the CRUD manager.
     * Store can be provided by itself, its storeId or an object having the following structure:
     * @cfg {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
     * @cfg {Ext.data.AbstractStore} stores.store The store itself.
     * @cfg {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
     * @cfg {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    stores: null,
    /**
     * @cfg {String} storeIdProperty Name of a store property to retrieve store identifiers from.
     * Store identifier is used as a container name holding corresponding store data while transferring them to/from the server.
     * By default `storeId` property is used. And in case a container identifier has to differ this config can be used:
     *
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON, so we create a new property "storeIdForCrud"
     *         storeId          : 'meow',
     *         storeIdForCrud   : 'cats',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow'],
     *         // crud manager will get store identifier from "storeIdForCrud" property
     *         storeIdProperty  : 'storeIdForCrud'
     *     });
     *
     * The `storeIdProperty` property can also be specified directly on a store:
     *
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON
     *         storeId          : 'meow',
     *         // so we create a new property "storeIdForCrud"..
     *         storeIdForCrud  : 'cats',
     *         // and point CrudManager to use it as the store identifier source
     *         storeIdProperty  : 'storeIdForCrud',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('DogStore', {
     *         model            : 'MyModel',
     *         // storeId is "dogs" and it will be used as a container name for the store data
     *         storeId          : 'dogs',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow', 'dogs']
     *     });
     *
     */
    storeIdProperty: 'storeId',
    /**
     * @cfg {String} filterParam The name of the 'filter' parameter to send in a load request.
     * This config is also can be defined and a store level:
     *
     *
     */
    filterParam: 'filter',
    storesIndex: null,
    activeRequests: null,
    delayedSyncs: null,
    /**
     * @method sendRequest
     * @abstract
     * Sends request to the server.
     * @param {Object} request The request to send. An object having following properties:
     * @param {String} request.data {@link #encode Encoded} request.
     * @param {String} request.type Request type, can be either `load` or `sync`
     * @param {Function} request.success Callback to be started on successful request transferring
     * @param {Function} request.failure Callback to be started on request transfer failure
     * @param {Object} request.scope A scope for the above `success` and `failure` callbacks
     * @return {Object} The request descriptor.
     */
    /**
     * @method cancelRequest
     * @abstract
     * Cancels request to the server.
     * @param {Object} request The request to cancel (a value returned by corresponding {@link #sendRequest} call).
     */
    /**
     * @method encode
     * @abstract
     * Encodes request to the server.
     * @param {Object} request The request to encode.
     * @returns {String} The encoded request.
     */
    /**
     * @method decode
     * @abstract
     * Decodes response from the server.
     * @param {String} response The response to decode.
     * @returns {Object} The decoded response.
     */
    transport: null,
    /**
     * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
     * So `load` request may be responded with `sync` response for example.
     * Can be used for smart server logic allowing the server to decide when it's better to respond with a complete data set (`load` response)
     * or it's enough to return just a delta (`sync` response).
     * @cfg {Boolean} trackResponseType
     */
    trackResponseType: false,
    /**
     * @cfg {String} phantomIdField
     * Field name to be used to transfer a phantom record identifier.
     */
    phantomIdField: '$PhantomId',
    /**
     * @cfg {Boolean} autoLoad
     * `true` to automatically call {@link #load} method after creation.
     */
    autoLoad: false,
    /**
     * @cfg {Number} autoSyncTimeout
     * The timeout in milliseconds to wait before persisting changes to the server.
     * Used when {@link #autoSync} is set to `true`.
     */
    autoSyncTimeout: 100,
    /**
     * @cfg {Boolean} autoSync
     * `true` to automatically persist store changes after edits are made in any of the stores monitored.
     * Please note that sync request will not be invoked immediately but only after {@link #autoSyncTimeout} interval.
     */
    autoSync: false,
    /**
     * @cfg {Boolean} resetIdsBeforeSync
     * `True` to reset identifiers (defined by `idProperty` config) of phantom records before submitting them to the server.
     */
    resetIdsBeforeSync: true,
    /**
     * @property {Object[]} syncApplySequence
     * An array of stores presenting an alternative sync responses apply order.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} syncApplySequence.storeId Unique store identifier.
     * @property {Ext.data.Store/Ext.data.TreeStore} syncApplySequence.store Store itself.
     * @property {String} [syncApplySequence.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [syncApplySequence.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    /**
     * @cfg {String[]} syncApplySequence
     * An array of store identifiers sets an alternative sync responses apply order.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But in case of some tricky dependencies between stores this order can be changed:

    Ext.create('MyCrudManager', {
        // register stores (they will be loaded in the same order: 'store1' then 'store2' and finally 'store3')
        stores : ['store1', 'store2', 'store3'],
        // but we apply changes from server to them in an opposite order
        syncApplySequence : ['store3', 'store2', 'store1']
    });

     */
    syncApplySequence: null,
    /**
     * @cfg {Boolean} writeAllFields true to write all fields from the record to the server.
     * If set to false it will only send the fields that were modified.
     * Note that any fields that have Ext.data.field.Field.persist set to false will still be
     * ignored while those with Ext.data.field.Field.critical set to true will be included.
     */
    writeAllFields: false,
    /**
     * @property {Boolean} destroyed
     * This property is set to `true` after the `destroy` method is called.
     * @protected
     */
    destroyed: false,
    ignoreUpdates: 0,
    // Flag that shows if crud manager performed successful load request
    loaded: false,
    createMissingRecords: false,
    autoSyncTimerId: null,
    constructor: function(config) {
        config = config || {};
        this.mixins.observable.constructor.call(this, config);
        this.activeRequests = {};
        this.delayedSyncs = [];
        this.transport = config.transport || this.transport || {};
        // support stores defined in the class prototype as well
        var stores = config.stores || this.stores;
        this.stores = [];
        this.addStore(stores);
        var syncApplySequence = config.syncApplySequence || this.syncApplySequence;
        if (syncApplySequence) {
            // reset this.syncApplySequence since addStoreToApplySequence() will build it
            this.syncApplySequence = null;
            this.addStoreToApplySequence(syncApplySequence);
        }
        if (this.autoLoad)  {
            this.load();
        }
        
    },
    updateStoreIndex: function() {
        var storesIndex = {};
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var store = this.stores[i];
            if (store.storeId) {
                storesIndex[store.storeId] = this.stores[i];
            }
        }
        this.storesIndex = storesIndex;
    },
    /**
     * Returns a registered store descriptor.
     * @param {String/Ext.data.AbstractStore} storeId The store identifier or registered store instance.
     * @returns {Object} The descriptor of the store.
     * Store descriptor is an object having following structure:
     *
     *  - `storeId` The store identifier that will be used as a key in requests.
     *  - `store` The store itself.
     *  - `idProperty` The idProperty of the store.
     *  - `phantomIdField` The field holding unique Ids of phantom records (if store has such model).
     */
    getStoreDescriptor: function(storeId) {
        if (!storeId)  {
            return;
        }
        
        if (storeId.isStore) {
            for (var i = 0,
                l = this.stores.length; i < l; i++) {
                if (this.stores[i].store === storeId)  {
                    return this.stores[i];
                }
                
            }
        } else if (typeof storeId == 'object') {
            return this.storesIndex[storeId.storeId];
        } else {
            return this.storesIndex[storeId] || this.getStoreDescriptor(Ext.data.StoreManager.get(storeId));
        }
    },
    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Ext.data.AbstractStore} Found store instance.
     */
    getStore: function(storeId) {
        var storeInfo = this.getStoreDescriptor(storeId);
        return storeInfo && storeInfo.store;
    },
    forEachStore: function(fn, scope) {
        if (!fn)  {
            return;
        }
        
        var stores = this.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            if (fn.call(scope || this, stores[i].store, stores[i].storeId, stores[i]) === false)  {
                break;
            }
            
        }
    },
    /**
     * Adds a store to the collection.

     // append stores to the end of collection
     crudManager.addStore([
         store1,
         // storeId
         'bar',
         // store descriptor
         {
             storeId : 'foo',
             store   : store3
         },
         {
             storeId         : 'bar',
             store           : store4,
             // to write all fields of modified records
             writeAllFields  : true
         }
     ]);

     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Ext.data.AbstractStore/String/Object/Ext.data.AbstractStore[]/String[]/Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {String} [store.filterParam] The name of the 'filter' parameter to send in a load request
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.

    // insert stores store4, store5 to the start of collection
    crudManager.addStore([ store4, store5 ], 0);

     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link #getStoreDescriptor} call).

    // insert store6 just before a store having storeId equal to 'foo'
    crudManager.addStore(store6, 0, 'foo');

    // insert store7 just after store3 store
    crudManager.addStore(store7, 1, store3);

     */
    addStore: function(store, position, fromStore) {
        if (!store)  {
            return;
        }
        
        if (!Ext.isArray(store))  {
            store = [
                store
            ];
        }
        
        var data = [];
        // loop over list of stores to be added
        for (var i = 0,
            l = store.length; i < l; i++) {
            var storeInfo = store[i];
            // if store instance provided
            if (storeInfo.isStore) {
                storeInfo = {
                    store: storeInfo
                };
            } else if (typeof storeInfo == 'object') {
                // normalize sub-stores (if any)
                if (storeInfo.stores) {
                    if (!Ext.isArray(storeInfo.stores))  {
                        storeInfo.stores = [
                            storeInfo.stores
                        ];
                    }
                    
                    for (var j = 0,
                        n = storeInfo.stores.length; j < n; j++) {
                        var subStore = storeInfo.stores[j],
                            subStoreInfo = subStore;
                        if ('string' === typeof subStore) {
                            subStoreInfo = {
                                storeId: subStore
                            };
                        }
                        // keep reference to the "master" store descriptor
                        subStoreInfo.masterStoreInfo = storeInfo;
                        storeInfo.stores[j] = subStoreInfo;
                    }
                }
            } else // if it's a store identifier
            {
                storeInfo = {
                    store: Ext.data.StoreManager.get(storeInfo)
                };
            }
            data.push(this.fillStoreDescriptor(storeInfo));
            storeInfo.store.crudManager = this;
            // Prevent any ajax proxy from loading data into the store
            if (storeInfo.store.isTreeStore) {
                storeInfo.store.setProxy({
                    type: 'memory'
                });
            }
            // Required to prevent Sencha from using setTimeout
            // https://www.sencha.com/forum/showthread.php?316098-Store.setProxy-should-change-value-of-asynchronousLoad
            storeInfo.store.setAsynchronousLoad(false);
            // listen to store changes
            this.bindStoreListeners(storeInfo.store);
        }
        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            this.stores.push.apply(this.stores, data);
        } else // if position specified
        {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore.isStore || typeof fromStore !== 'object')  {
                    fromStore = this.getStoreDescriptor(fromStore);
                }
                
                // get its position
                pos += Ext.Array.indexOf(this.stores, fromStore);
            }
            // insert new store(-s)
            this.stores.splice.apply(this.stores, [].concat([
                pos,
                0
            ], data));
        }
        this.updateStoreIndex();
    },
    bindStoreListeners: function(store, un) {
        var listeners = {
                update: this.onStoreUpdate,
                clear: this.onStoreChange,
                scope: this
            };
        // tree store has specific event names
        if (store.isTreeStore) {
            Ext.apply(listeners, {
                nodeappend: this.onTreeStoreInsertOrAppend,
                nodeinsert: this.onTreeStoreInsertOrAppend,
                noderemove: this.onNodeRemove
            });
        } else {
            Ext.apply(listeners, {
                add: this.onStoreChange,
                remove: this.onStoreChange
            });
        }
        if (un) {
            this.mun(store, listeners);
        } else {
            this.mon(store, listeners);
        }
    },
    unbindStoreListeners: function(store) {
        this.bindStoreListeners(store, true);
    },
    fillStoreDescriptor: function(descriptor) {
        var store = descriptor.store,
            storeIdProperty = store.storeIdProperty || this.storeIdProperty,
            model = store.getModel && store.getModel() || store.model;
        model = model && model.prototype;
        Ext.applyIf(descriptor, {
            storeId: store[storeIdProperty],
            phantomIdField: model && model.phantomIdField,
            idProperty: model && model.idProperty,
            writeAllFields: store.writeAllFields
        });
        return descriptor;
    },
    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.

    // remove store having storeId equal to "foo"
    crudManager.removeStore("foo");

    // remove store3
    crudManager.removeStore(store3);

     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStore: function(store) {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var s = this.stores[i];
            if (s === store || s.store === store || s.storeId === store) {
                // unbind store listeners
                this.unbindStoreListeners(s.store);
                delete this.storesIndex[s.storeId];
                this.stores.splice(i, 1);
                if (this.syncApplySequence) {
                    this.removeStoreFromApplySequence(store);
                }
                break;
            }
        }
    },
    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #syncApplySequence} option
     * or but calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:

    // alternative sequence was not set for this crud manager
    // so let's fill it with existing stores keeping the same order
    crudManager.addStoreToApplySequence(crudManager.stores);

    // and now we can add our new store

    // we will load its data last
    crudManager.addStore(someNewStore);
    // but changes to it will be applied first
    crudManager.addStoreToApplySequence(someNewStore, 0);

     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Ext.data.AbstractStore/Object/Ext.data.AbstractStore[]/Object[]} store The store to add or its _descriptor_ (or array of stores or descriptors).
     * Where _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).

     * @param {Integer} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.

    // insert stores store4, store5 to the start of sequence
    crudManager.addStoreToApplySequence([ store4, store5 ], 0);

     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of {@link #getStoreDescriptor} call).

    // insert store6 just before a store having storeId equal to 'foo'
    crudManager.addStoreToApplySequence(store6, 0, 'foo');

    // insert store7 just after store3 store
    crudManager.addStoreToApplySequence(store7, 1, store3);

     */
    addStoreToApplySequence: function(store, position, fromStore) {
        if (!store)  {
            return;
        }
        
        if (!Ext.isArray(store))  {
            store = [
                store
            ];
        }
        
        var data = [];
        // loop over list of stores to add
        for (var i = 0,
            l = store.length; i < l; i++) {
            var s = this.getStoreDescriptor(store[i]);
            if (s)  {
                data.push(s);
            }
            
        }
        if (!this.syncApplySequence)  {
            this.syncApplySequence = [];
        }
        
        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            this.syncApplySequence.push.apply(this.syncApplySequence, data);
        } else // if position specified
        {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore.isStore || typeof fromStore !== 'object')  {
                    fromStore = this.getStoreDescriptor(fromStore);
                }
                
                // get its position
                pos += Ext.Array.indexOf(this.syncApplySequence, fromStore);
            }
            // insert new store(-s)
            this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([
                pos,
                0
            ], data));
        }
    },
    /**
     * Removes a store from the alternative sync sequence.

    // remove store having storeId equal to "foo"
    crudManager.removeStore("foo");

    // remove store3
    crudManager.removeStore(store3);

     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStoreFromApplySequence: function(store) {
        for (var i = 0,
            l = this.syncApplySequence.length; i < l; i++) {
            var s = this.syncApplySequence[i];
            if (s === store || s.store === store || s.storeId === store) {
                this.syncApplySequence.splice(i, 1);
                break;
            }
        }
    },
    onNodeRemove: function(oldParent, node) {
        var treeStore = oldParent && oldParent.getTreeStore();
        // "noderemove" event is fired too early and getRemovedRecords() don't not have the removed node yet
        // so we wait till tree store "endupdate" event and only then invoke "onStoreChange" method
        treeStore && treeStore.on('endupdate', this.onStoreChange, this, {
            single: true
        });
    },
    onStoreUpdate: function(store, record, operation, fields) {
        if ((!store.isTreeStore || record !== store.getRoot())) {
            // If only a single field was changed, make sure it's a persistable field to avoid full scan of the store
            // Collapsing/expanding a tree node will trigger this behavior otherwise
            var isSingleNonPersistField = fields && fields.length === 1 && record.getField(fields[0]) && !record.getField(fields[0]).persist;
            if (!isSingleNonPersistField) {
                this.onStoreChange();
            }
        }
    },
    onTreeStoreInsertOrAppend: function(parent, child) {
        if (!child.isRoot()) {
            this.onStoreChange();
        }
    },
    onStoreChange: function() {
        if (this.ignoreUpdates)  {
            return;
        }
        
        var me = this;
        /**
         * @event haschanges
         * Fires when any record in a registered stores is changed.
         *
         *     @example
         *     crudManager.on('haschanges', function (crud) {
         *         // enable persist changes button when some store gets changed
         *         saveButton.enable();
         *     });
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         */
        this.fireEvent(this.hasChanges() ? 'haschanges' : 'nochanges', this);
        if (this.autoSync) {
            // add deferred call if it's not scheduled yet
            if (!this.autoSyncTimerId) {
                this.autoSyncTimerId = setTimeout(function() {
                    me.autoSyncTimerId = null;
                    me.sync();
                }, this.autoSyncTimeout);
            }
        }
    },
    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.

    // if we have any unsaved changes
    if (crudManager.hasChanges()) {
        // persist them
        crudManager.sync();
    // otherwise
    } else {
        alert("There are no unsaved changes...");
    }

     * @param {String/Ext.data.AbstractStore} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     */
    hasChanges: function(storeId) {
        var store;
        if (storeId) {
            store = this.getStore(storeId);
            if (!store)  {
                return false;
            }
            
            return this.isStoreDirty(store);
        }
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            if (this.isStoreDirty(this.stores[i].store))  {
                return true;
            }
            
        }
        return false;
    },
    isStoreDirty: function(store) {
        if (store.getRemovedRecords().length)  {
            return true;
        }
        
        if (store.isTreeStore) {
            for (var o in store.byIdMap) {
                var record = store.byIdMap[o];
                // root node "expanded" state should not be regarded as a dirty record
                if (record.dirty === true && (!record.get('root') || Ext.Object.getKeys(record.modified).length !== 1 || !("expanded" in record.modified))) {
                    return true;
                } else if (!record.get('root') && record.phantom && record.isValid()) {
                    return true;
                }
            }
        } else {
            var records = store.getData().items;
            for (var i = 0,
                l = records.length; i < l; i++) {
                if (records[i].dirty || records[i].phantom)  {
                    return true;
                }
                
            }
        }
        return false;
    },
    getLoadPackage: function(options) {
        var pack = {
                type: 'load',
                requestId: this.getRequestId(),
                stores: []
            };
        var stores = this.stores,
            packStores = pack.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var store = stores[i],
                filterParam = store.filterParam || store.store.filterParam || this.filterParam,
                opts = options && options[store.storeId],
                pageSize = store.pageSize || store.store.pageSize;
            // if the store uses remote filtering
            if (store.store.remoteFilter && filterParam) {
                opts = opts || {};
                var filters = [];
                store.store.getFilters().each(function(f) {
                    filters.push(f.serialize());
                });
                // put filters info into the package
                opts[filterParam] = filters;
            }
            if (opts || pageSize) {
                var params = Ext.apply({
                        storeId: store.storeId,
                        page: 1,
                        pageSize: pageSize
                    }, opts);
                stores[i].currentPage = params.page;
                packStores.push(params);
            } else {
                packStores.push(store.storeId);
            }
        }
        return pack;
    },
    prepareAdded: function(list, phantomIdField, stores) {
        var result = [];
        for (var i = 0,
            l = list.length; i < l; i++) {
            var record = list[i],
                data = {},
                fields = record.getFields();
            if (!data.hasOwnProperty(phantomIdField)) {
                data[phantomIdField] = record.getId();
            }
            for (var f = 0,
                fLen = fields.length; f < fLen; f++) {
                var field = fields[f];
                if (field) {
                    if (field.persist && (record.data.hasOwnProperty(field.name) || field.critical)) {
                        if (field.serialize) {
                            data[field.name] = field.serialize(record.data[field.name], record);
                        } else {
                            data[field.name] = record.data[field.name];
                        }
                    }
                }
            }
            if (this.resetIdsBeforeSync)  {
                delete data[record.idProperty];
            }
            
            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, data, stores);
            }
            result.push(data);
        }
        return result;
    },
    prepareUpdated: function(list, stores, storeInfo) {
        var result = [],
            writeAllFields = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields),
            data, field;
        for (var i = 0,
            l = list.length; i < l; i++) {
            var record = list[i],
                f;
            if (writeAllFields) {
                //write all fields
                data = record.getData();
                data[record.idProperty] = record.getId();
                for (f in data) {
                    field = record.getField(f);
                    // remove not persistable/critical fields
                    if (!field || !field.persist && !field.critical) {
                        delete data[f];
                    } else if (field.serialize) {
                        data[f] = field.serialize(data[f], record);
                    } else {
                        data[f] = record.get(f);
                    }
                }
            } else {
                data = record.getChanges();
                data[record.idProperty] = record.getId();
                // process fields to get rid of non-persistable ones
                // and use "serialize" when it's presented
                for (f in data) {
                    field = record.getField(f);
                    if (!field || !field.persist) {
                        delete data[f];
                    } else if (field.serialize) {
                        data[f] = field.serialize(data[f], record);
                    } else {
                        data[f] = record.get(f);
                    }
                }
                // critical fields should always be presented
                var criticalFields = record.getCriticalFields();
                for (var j = 0; j < criticalFields.length; j++) {
                    field = criticalFields[j];
                    if (field.serialize) {
                        data[field.getName()] = field.serialize(record.get(field.getName()), record);
                    } else {
                        data[field.getName()] = record.get(field.getName());
                    }
                }
            }
            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, data, stores);
            }
            result.push(data);
        }
        return result;
    },
    prepareRemoved: function(list) {
        var result = [],
            data;
        for (var i = 0,
            l = list.length; i < l; i++) {
            data = {};
            data[list[i].idProperty] = list[i].getId();
            result.push(data);
        }
        return result;
    },
    processSubStores: function(record, data, stores) {
        for (var j = 0,
            n = stores.length; j < n; j++) {
            var id = stores[j].storeId,
                store = record.get(id);
            // if embedded store is assigned to the record
            if (store) {
                // let's collect its changes as well
                var changes = this.getStoreChanges(Ext.apply({
                        store: store
                    }, stores[j]));
                if (changes) {
                    data[id] = Ext.apply(changes, {
                        $store: true
                    });
                } else {
                    delete data[id];
                }
            } else {
                delete data[id];
            }
        }
    },
    getStoreChanges: function(store, phantomIdField) {
        phantomIdField = phantomIdField || store.phantomIdField || this.phantomIdField;
        var s = store.store,
            added = s.getNewRecords(),
            updated = s.getUpdatedRecords(),
            removed = s.getRemovedRecords(),
            // sub-stores
            stores = store.stores;
        var result;
        if (added.length)  {
            added = this.prepareAdded(added, phantomIdField, stores);
        }
        
        if (updated.length)  {
            updated = this.prepareUpdated(updated, stores, store);
        }
        
        if (removed.length)  {
            removed = this.prepareRemoved(removed);
        }
        
        // if this store has changes
        if (added.length || updated.length || removed.length) {
            result = {};
            if (added.length)  {
                result.added = added;
            }
            
            if (updated.length)  {
                result.updated = updated;
            }
            
            if (removed.length)  {
                result.removed = removed;
            }
            
        }
        return result;
    },
    getChangeSetPackage: function() {
        var pack = {
                type: 'sync',
                requestId: this.getRequestId(),
                revision: this.revision
            };
        var stores = this.stores,
            found = 0;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var store = stores[i],
                phantomIdField = store.phantomIdField || this.phantomIdField,
                storeId = store.storeId;
            var changes = this.getStoreChanges(store, phantomIdField);
            if (changes) {
                found++;
                pack[storeId] = changes;
            }
        }
        return found ? pack : null;
    },
    getSubStoresData: function(rows, subStores, idProperty, isTree) {
        if (!rows)  {
            return;
        }
        
        var result = [];
        var processRow = function(row, subStores) {
                for (var j = 0,
                    m = subStores.length; j < m; j++) {
                    var storeId = subStores[j].storeId;
                    // if row contains data for this sub-store
                    if (row[storeId]) {
                        // keep them for the later loading
                        result.push({
                            id: row[idProperty],
                            storeDesc: subStores[j],
                            data: row[storeId]
                        });
                        // and remove reference from the row
                        delete row[storeId];
                    }
                }
            };
        var i = 0,
            l = rows.length;
        // if it's a TreeStore
        if (isTree) {
            // loop over nodes
            for (; i < l; i++) {
                processRow(rows[i], subStores);
                // also let's grab sub-stores from node children
                var childrenSubData = this.getSubStoresData(rows[i].children, subStores, idProperty, true);
                if (childrenSubData) {
                    result = result.concat(childrenSubData);
                }
            }
        } else // if it's a "flat" store
        {
            for (; i < l; i++) processRow(rows[i], subStores);
        }
        return result;
    },
    loadDataToTreeStore: function(store, data, options, storeDesc) {
        var rows = data && data.rows;
        // Root might contain modified fields, clear them
        store.getRoot() && store.getRoot().reject();
        store.proxy.data = rows;
        store.load();
    },
    loadDataToFlatStore: function(store, data, options, storeDesc) {
        var rows = data && data.rows;
        store.totalCount = data.total;
        store.currentPage = storeDesc.currentPage;
        // instantiate models since we have to pass them to "load" event
        var records = Ext.Array.map(rows, function(recordData) {
                return new store.model(recordData);
            });
        store.loadData(records, options && options.append || data.append);
        store.fireEvent('load', store, records, true);
    },
    loadDataToStore: function(storeDesc, data, options) {
        var store = storeDesc.store,
            model = store.getModel(),
            // nested stores list
            subStores = storeDesc.stores,
            idProperty = storeDesc.idProperty || model && model.prototype && model.prototype.idProperty || 'id',
            isTree = store.isTreeStore,
            subData;
        var rows = data && data.rows;
        // apply server provided meta data to the store
        store.metaData = data && data.metaData;
        if (rows) {
            if (subStores)  {
                subData = this.getSubStoresData(rows, subStores, idProperty, isTree);
            }
            
            store.__loading = true;
            // use load method dependeing on store type (tree/flat)
            var loadMethod = isTree ? this.loadDataToTreeStore : this.loadDataToFlatStore;
            loadMethod.call(this, store, data, options, storeDesc);
            if (subData) {
                // load sub-stores as well (if we have them)
                for (var i = 0,
                    l = subData.length; i < l; i++) {
                    var subDatum = subData[i];
                    this.loadDataToStore(Ext.apply({
                        store: store[isTree ? 'getNodeById' : 'getById'](subDatum.id).get(subDatum.storeDesc.storeId)
                    }, subDatum.storeDesc), subDatum.data);
                }
            }
            store.__loading = false;
        }
    },
    loadData: function(response, options) {
        options = options || {};
        // we don't want reacting on store changes during loading of them
        this.ignoreUpdates++;
        // we load data to the stores in the order they're kept in this.stores array
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var storeDesc = this.stores[i],
                storeId = storeDesc.storeId,
                data = response[storeId];
            if (data)  {
                this.loadDataToStore(storeDesc, data, options[storeId]);
            }
            
        }
        this.ignoreUpdates--;
    },
    applyChangesToRecord: function(record, changes, stores, store) {
        var data = record.data,
            done = {},
            editStarted = false,
            name;
        // if this store has sub-stores assigned to some fields
        if (stores) {
            // then first we apply changes to that stores
            for (var j = 0,
                n = stores.length; j < n; j++) {
                name = stores[j].storeId;
                if (changes.hasOwnProperty(name)) {
                    // remember that we processed this field
                    done[name] = true;
                    var subStore = record.get(name);
                    if (subStore) {
                        this.applyChangesToStore(Ext.apply({
                            store: subStore
                        }, stores[j]), changes[name]);
                    } else {
                        Ext.log("Can't find store for the response sub-package");
                    }
                }
            }
        }
        for (name in changes) {
            if (changes.hasOwnProperty(name) && !done[name]) {
                var value = changes[name];
                if (!record.isEqual(data[name], value)) {
                    // we call beginEdit/endEdit only if real changes were applied
                    if (!editStarted) {
                        editStarted = true;
                        record.beginEdit();
                    }
                    // for the record ID we will use setId() call
                    if (name === record.idProperty) {
                        record.setId(value);
                    }
                    // TODO: need to support parentIdProperty
                    // parentId requires special treatment
                    else if (name == 'parentId' && store.isTreeStore) {
                        var parent = (value && store.getNodeById(value)) || store.getRoot();
                        parent.appendChild(record);
                    } else {
                        record.set(name, value);
                    }
                }
            }
        }
        this.ignoreUpdates++;
        // we call beginEdit/endEdit only if real changes were applied
        if (editStarted)  {
            record.endEdit();
        }
        
        this.ignoreUpdates--;
        record.commit();
    },
    applyRemovals: function(store, removed, context) {
        var idProperty = context.idProperty,
            removedStash = store.isTreeStore ? store.removedNodes : store.removed,
            findByIdFn = context.findByIdFn,
            removeRecordFn = context.removeRecordFn,
            applied = 0;
        for (var j = 0,
            k = removed.length; j < k; j++) {
            var done = false;
            var id = removed[j][idProperty];
            // just find the record in store.removed array and delete it from it
            for (var jj = 0,
                kk = removedStash.length; jj < kk; jj++) {
                if (removedStash[jj].getId() == id) {
                    removedStash.splice(jj, 1);
                    done = true;
                    // number of removals applied
                    applied++;
                    break;
                }
            }
            // if responded removed record isn`t found in store.removed
            // probably don't removed on the client side yet (server driven removal)
            if (!done) {
                var record = findByIdFn(id);
                if (record) {
                    this.ignoreUpdates++;
                    removeRecordFn(record);
                    Ext.Array.remove(removedStash, record);
                    // number of removals applied
                    applied++;
                    this.ignoreUpdates--;
                } else {
                    Ext.log("Can't find record to remove from the response package");
                }
            }
        }
        return applied;
    },
    getApplyChangesToStoreHelpers: function(store) {
        // TODO: this might need to be refactored taking Sch.data.mixin.UniversalModelGetter methods into account
        // if it's a tree store
        if (store.isTreeStore) {
            var findNode = function(id) {
                    return store.getNodeById(id);
                };
            return {
                findByPhantomFn: findNode,
                findByIdFn: findNode,
                // TODO: need to support parentIdProperty
                addRecordFn: function(data) {
                    var parent = (data.parentId && store.getNodeById(data.parentId)) || store.getRoot();
                    return parent.appendChild(data);
                },
                removeRecordFn: function(record) {
                    return record.parentNode.removeChild(record);
                }
            };
        } else // plain store
        {
            return {
                findByPhantomFn: function(id) {
                    return store.data.getByKey(id);
                },
                findByIdFn: function(id) {
                    return store.getById(id);
                },
                addRecordFn: function(data) {
                    return store.add(data)[0];
                },
                removeRecordFn: function(record) {
                    return store.remove(record);
                }
            };
        }
    },
    applyChangesToStore: function(storeDesc, storeResponse) {
        var me = this,
            phantomIdField = storeDesc.phantomIdField || me.phantomIdField,
            idProperty = storeDesc.idProperty,
            store = storeDesc.store;
        if (!idProperty) {
            var model = store.getModel && store.getModel() || store.model;
            model = model && model.prototype;
            idProperty = model && model.idProperty || 'id';
        }
        var helpers = me.getApplyChangesToStoreHelpers(store),
            findByPhantomFn = helpers.findByPhantomFn,
            findByIdFn = helpers.findByIdFn,
            addRecordFn = helpers.addRecordFn,
            removeRecordFn = helpers.removeRecordFn;
        var rows = storeResponse.rows,
            removed = storeResponse.removed,
            record;
        // process added/updated records
        if (rows) {
            var data, id, phantomId,
                // sub-stores
                stores = storeDesc.stores;
            for (var j = 0,
                k = rows.length; j < k; j++) {
                data = rows[j];
                phantomId = data[phantomIdField];
                id = data[idProperty];
                record = null;
                // if phantomId is provided then we will use it to find added record
                if (phantomId != null) {
                    record = findByPhantomFn(phantomId);
                }
                // if id is provided then we will use it to find updated record
                else if (idProperty) {
                    record = findByIdFn(id);
                }
                if (record) {
                    me.applyChangesToRecord(record, data, stores, store);
                } else {
                    me.ignoreUpdates++;
                    // create new record in the store
                    record = addRecordFn(data);
                    me.ignoreUpdates--;
                    record.commit();
                }
            }
        }
        // process removed records
        if (removed && me.applyRemovals(store, removed, {
            idProperty: idProperty,
            findByIdFn: findByIdFn,
            removeRecordFn: removeRecordFn
        })) {
            store.fireEvent('datachanged', store);
        }
    },
    applySyncResponse: function(response) {
        // we apply received changes to the stores in the order they're kept in either this.syncApplySequence or this.stores array
        var stores = this.syncApplySequence || this.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var storeResponse = response[stores[i].storeId];
            if (storeResponse) {
                this.applyChangesToStore(stores[i], storeResponse);
            }
        }
    },
    applyLoadResponse: function(response, options) {
        this.loadData(response, options);
    },
    applyResponse: function(requestType, response, options) {
        // in trackResponseType we check response type before deciding how to react on the response
        if (this.trackResponseType) {
            requestType = response.type || requestType;
        }
        switch (requestType) {
            case 'load':
                this.applyLoadResponse(response, options);
                break;
            case 'sync':
                this.applySyncResponse(response);
                break;
        }
    },
    /**
     * Generates unique request identifier.
     * @protected
     * @template
     * @return {Integer} The request identifier.
     */
    getRequestId: function() {
        // TODO: this is not very reliable, two calls to this method withing one ms will ruin the logic
        return Ext.Date.now();
    },
    onResponse: function(requestType, rawResponse, responseOptions, options) {
        // reset last requested package ID
        this.activeRequests[requestType] = null;
        var response = this.decode(rawResponse);
        if (!response || !response.success) {
            /**
             * @event requestfail
             * Fires when a request gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent('requestfail', this, requestType, response, responseOptions);
            /**
             * @event loadfail
             * Fires when {@link #load load request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             * @params {Object} options Options provided to the {@link #load} method.
             */
            /**
             * @event syncfail
             * Fires when {@link #sync sync request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent(requestType + 'fail', this, response, responseOptions, options);
            this.warn('CrudManager: ' + requestType + ' failed, please inspect the server response', rawResponse);
            return response;
        }
        /**
         * @event beforeresponseapply
         * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {String} requestType The request type (`sync` or `load`).
         * @param {Object} response The decoded server response object.
         */
        /**
         * @event beforeloadapply
         * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         * @params {Object} options Options provided to the {@link #load} method.
         */
        /**
         * @event beforesyncapply
         * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         */
        if ((this.fireEvent('beforeresponseapply', this, requestType, response) !== false) && (this.fireEvent('before' + requestType + 'apply', this, response, options) !== false)) {
            this.revision = response.revision;
            this.applyResponse(requestType, response, options);
            /**
             * @event requestdone
             * Fires on successful request completion after data gets applied to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            this.fireEvent('requestdone', this, requestType, response, responseOptions);
            /**
             * @event load
             * Fires on successful {@link #load load request} completion after data gets loaded to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             * @params {Object} options Options provided to the {@link #load} method.
             */
            /**
             * @event sync
             * Fires on successful {@link #sync sync request} completion.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            this.fireEvent(requestType, this, response, responseOptions, options);
            if (requestType === 'load' || !this.hasChanges()) {
                /**
                 * @event nochanges
                 * Fires when registered stores get into state when they don't have any
                 * not persisted change. This happens after {@link #method-load load} or {@link #method-sync sync} request
                 * completion. Or this may happen after a record update which turns its fields back to their original state.
                 *
                 *     @example
                 *     crudManager.on('nochanges', function (crud) {
                 *         // disable persist changes button when there is no changes
                 *         saveButton.disable();
                 *     });
                 *
                 * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                 */
                this.fireEvent('nochanges', this);
            }
        }
        return response;
    },
    onLoad: function(rawResponse, responseOptions, options) {
        // Successfull load request, mark crud manager as loaded
        this.loaded = true;
        return this.onResponse('load', rawResponse, responseOptions, options);
    },
    onSync: function(rawResponse, responseOptions, options) {
        return this.onResponse('sync', rawResponse, responseOptions, options);
    },
    /**
     * Loads data to the stores registered in the crud manager. For example:

    crudManager.load(
        // here are request parameters
        {
            store1 : { append : true, page : 3, smth : 'foo' },
            store2 : { page : 2, bar : '!!!' }
        },
        // here is callback
        function () { alert('OMG! It works!') },
        // here is errback
        function (response) { alert('Oops: '+response.message); }
    );

     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by {@link #cancelRequest} calling.

     * @param {Object} [parameters] The request parameters. This argument can be omitted like this:

    crudManager.load(
        // here is callback
        function () { alert('OMG! It works!') },
        // here is errback
        function (response) { alert('Oops: '+response.message); }
    );

     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. And these parameters will be transferred with a load request.

    {
        store1 : { page : 3, append : true, smth : 'foo' },
        store2 : { page : 2, bar : '!!!' }
    },

     * Additionally for flat stores `append: true` can be specified to add loaded records to the existing records, default is to remove corresponding store's existing records first.
     * And for tree stores you can use Ext.data.TreeStore.clearOnLoad option to achieve a similar result.
     * **Please note** that for delta loading you can also use an {@link #trackResponseType alternative approach}.

     * @param {Function} [callback] An optional callback to be started on successful request completion.
     * There is also a {@link #event-load load} event which can be used for load request completion processing.
     * @param {Function} [errback] A callback to be started on request failure.
     * There is also an {@link #loadfail} event which can be used for load request failures processing.
     * @param {Object/Function} [scope] A scope to be used for `callback` and `errback` calls.
     */
    load: function(callback, errback, scope) {
        var options;
        if (typeof callback === 'object') {
            options = callback;
            callback = errback;
            errback = scope;
            scope = arguments[3];
        }
        var pack = this.getLoadPackage(options);
        /**
         * @event beforeload
         * Fires before {@link #load load request} is sent. Return `false` to cancel load request.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforeload', this, pack) !== false) {
            scope = scope || this;
            // if another load request is in progress let's cancel it
            if (this.activeRequests.load) {
                this.cancelRequest(this.activeRequests.load.desc);
                this.fireEvent('loadcanceled', this, pack);
            }
            this.activeRequests.load = {
                id: pack.requestId
            };
            this.activeRequests.load.desc = this.sendRequest({
                data: this.encode(pack),
                type: 'load',
                success: function(rawResponse, responseOptions) {
                    var response = this.onLoad(rawResponse, responseOptions, options);
                    if (errback && (!response || !response.success)) {
                        errback.call(scope, response, rawResponse, options);
                    } else if (callback) {
                        callback.call(scope, response, rawResponse, options);
                    }
                },
                failure: function(rawResponse, responseOptions) {
                    this.onLoad(rawResponse, responseOptions);
                    if (errback)  {
                        errback.apply(scope, arguments);
                    }
                    
                },
                scope: this
            });
        } else // if loading was canceled let's fire event
        {
            /**
             * @event loadcanceled
             * Fired after {@link #load load request} was canceled by some {@link #beforeload} listener
             * or due to incomplete prior load request.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('loadcanceled', this, pack);
        }
    },
    /**
     * Persists changes made on the registered stores to the server.
     * Request runs asynchronously so if user need to execute some code after request completion it has to be provided in the `callback` function:
     *
     *     // persist and run a callback on request completion
     *     sync(function(){ alert("Changes saved..."); }, function(response){ alert("Error: "+response.message); });
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it until previous request completion.
     * In this case {@link #syncdelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #autoSync} config. This option allows to persist changes automatically after any data modification.
     *
     * @param {Function} [callback] A function to start on successful request completion.
     * There is also a {@link #event-sync sync} event which can be used for sync request completion processing.
     *
     * **Note:** If there is no changes to persist then callback will be started immediately without sending any request
     * and {@link #event-sync sync} event will not be fired.
     * @param {Function} [errback] A function to start on request failure.
     * There is also an {@link #syncfail} event which can be used for sync request failures processing.
     * @param {Object} [scope] A scope for above `callback` and `errback` functions.
     */
    sync: function(callback, errback, scope) {
        if (this.activeRequests.sync) {
            // let's delay this call and start it only after server response
            this.delayedSyncs.push(arguments);
            /**
             * @event syncdelayed
             * Fires after {@link #sync sync request} was delayed due to incomplete previous one.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} arguments The arguments of {@link #sync} call.
             */
            this.fireEvent('syncdelayed', this, arguments);
            return;
        }
        // get current changes set package
        var pack = this.getChangeSetPackage();
        scope = scope || this;
        // if no data to persist we run callback and exit
        if (!pack) {
            if (callback)  {
                callback.call(scope, null, null);
            }
            
            return;
        }
        /**
         * @event beforesync
         * Fires before {@link #sync sync request} is sent. Return `false` to cancel sync request.
         *
         *     @example
         *     crudManager.on('beforesync', function() {
         *        // cannot persist changes before at least one record is added
         *        // to the `someStore` store
         *        if (!someStore.getCount()) return false;
         *     });
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforesync', this, pack) === false) {
            // if this sync was canceled let's fire event about it
            /**
             * @event synccanceled
             * Fires after {@link #sync sync request} was canceled by some {@link #beforesync} listener.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('synccanceled', this, pack);
            return;
        }
        // keep active reaqest Id
        this.activeRequests.sync = {
            id: pack.requestId
        };
        // send sync package
        this.activeRequests.sync.desc = this.sendRequest({
            data: this.encode(pack),
            type: 'sync',
            success: function(rawResponse, options) {
                var request = this.activeRequests.sync;
                var response = this.onSync(rawResponse, options);
                if (errback && (!response || !response.success)) {
                    errback.call(scope, response, rawResponse, request);
                } else if (callback) {
                    callback.call(scope, response, rawResponse, request);
                }
                // execute delayed sync() call
                this.runDelayedSync();
            },
            failure: function(rawResponse, options) {
                this.onSync(rawResponse, options);
                if (errback)  {
                    errback.apply(scope, arguments);
                }
                
                // execute delayed sync() call
                this.runDelayedSync();
            },
            scope: this
        });
    },
    runDelayedSync: function() {
        var args = this.delayedSyncs.shift();
        if (!args)  {
            return;
        }
        
        this.sync.apply(this, args);
    },
    /**
     * Commits all records changes of all the registered stores.
     */
    commit: function() {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            this.stores[i].store.commitChanges();
        }
    },
    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     */
    reject: function() {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            this.stores[i].store.rejectChanges();
        }
    },
    warn: function() {
        if ('console' in window) {
            var c = console;
            c.log && c.log.apply && c.log.apply(c, arguments);
        }
    },
    // Used to help the UI know if the manager is already working and a loadmask should be shown when a consuming UI panel is created.
    isLoading: function() {
        return !!this.activeRequests.load;
    },
    /**
     * Removes all stores and cancels active requests.
     */
    destroy: function() {
        var me = this;
        me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
        me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);
        while (me.stores.length > 0) {
            me.removeStore(me.stores[0]);
        }
        clearTimeout(me.autoSyncTimerId);
        me.destroyed = true;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.crud.encoder.Json
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _JSON_ as an encoding system.

    // let's make new CrudManager using AJAX as a transport system and JSON for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Json', 'Sch.crud.transport.Ajax']
    });

*/
Ext.define('Sch.crud.encoder.Json', {
    format: 'json',
    /**
     * Encodes an request object to _JSON_ encoded string.
     * @param {Object} request The request to encode.
     */
    encode: function(request) {
        return Ext.JSON.encode(request);
    },
    /**
     * Decodes (parses) a _JSON_ response string to an object.
     * @param {Object} response The response to decode.
     */
    decode: function(response) {
        if (typeof response == 'object')  {
            return response;
        }
        
        return Ext.JSON.decode(response, true);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.crud.transport.Ajax
@abstract
Implements data transferring functional that can be used for {@link Sch.crud.AbstractManager} super classing.
Uses AJAX as a transport system.

    // let's make new CrudManager using AJAX as a transport system and XML for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
    });

*/
Ext.define('Sch.crud.transport.Ajax', {
    /**
     * @cfg {Object} transport
     * Configuration of the AJAX requests used to communicate with a server-side.
     * An object where you can set the following possible properties:
     * @cfg {Object} transport.load Load requests configuration:
     * @cfg {String} transport.load.url URL to request for data loading.
     * @cfg {String} [transport.load.method='POST'] HTTP method to be used for load requests.
     * @cfg {String} [transport.load.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.load.params] Extra load request params if needed.
     * @cfg {Object} [transport.load.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     *      transport   : {
     *          load    : {
     *              requestConfig : {
     *                  url             : 'http://some-url',
     *                  method          : 'GET',
     *                  // get rid of cache-buster parameter
     *                  disableCaching  : false,
     *                  // extra request parameters
     *                  params          : {
     *                      foo         : 'bar'
     *                  },
     *                  // custom request headers
     *                  headers         : {
     *                      ...
     *                  }
     *              }
     *          }
     *      }
     *
     * @cfg {Object} transport.sync Sync requests configuration:
     * @cfg {String} transport.sync.url URL to request for data persisting.
     * @cfg {String} [transport.sync.method='POST'] HTTP method to be used for sync requests.
     * @cfg {String} [transport.sync.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.sync.params] Extra sync request params if needed.
     * @cfg {Object} [transport.sync.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     *      transport   : {
     *          sync    : {
     *              requestConfig : {
     *                  url             : 'http://some-url',
     *                  method          : 'GET',
     *                  // get rid of cache-buster parameter
     *                  disableCaching  : false,
     *                  // extra request parameters
     *                  params          : {
     *                      foo         : 'bar'
     *                  },
     *                  // custom request headers
     *                  headers         : {
     *                      ...
     *                  }
     *              }
     *          }
     *      }
     */
    defaultMethod: {
        load: 'GET',
        sync: 'POST'
    },
    /**
     * Cancels sent request.
     * @param {Object} request The descriptor of request to be canceled. The _request descriptor_ is a value returned by corresponding {@link #sendRequest} call.
     */
    cancelRequest: function(request) {
        Ext.Ajax.abort(request);
    },
    /**
     * Sends request to the server.
     * @param {Object} request The request configuration object having following properties:
     * @param {String} request.data The encoded request.
     * @param {String} request.type The request type. Either `load` or `sync`.
     * @param {Function} request.success A function to be started on successful request transferring.
     * @param {Function} request.failure A function to be started on request transfer failure.
     * @param {Object} request.scope A scope for the above `success` and `failure` functions.
     * @return {Object} The request descriptor.
     */
    sendRequest: function(config) {
        var pack = config.data,
            packCfg = this.transport[config.type],
            paramName = packCfg.paramName,
            params = Ext.apply({}, packCfg && packCfg.params),
            method = packCfg.method || this.defaultMethod[config.type];
        var requestConfig = Ext.apply({
                url: packCfg.url,
                method: method,
                params: params,
                failure: config.failure,
                success: function(response, options) {
                    if (config.success) {
                        config.success.call(config.scope || this, response.responseXml || response.responseText);
                    }
                },
                scope: config.scope
            }, packCfg.requestConfig);
        // if no param name specified then we'll transfer package in the request body
        if (!paramName) {
            if (this.format === 'xml') {
                Ext.apply(requestConfig, {
                    xmlData: pack
                });
            } else {
                Ext.apply(requestConfig, {
                    jsonData: pack
                });
            }
        } else // ..otherwise we use parameter
        {
            requestConfig.params = requestConfig.params || {};
            requestConfig.params[paramName] = pack;
        }
        /**
         * @event beforesend
         * Fires before a request is sent to the server.

        crudManager.on('beforesend', function (crud, params, requestType) {
            // let's set "sync" request parameters
            if (requestType == 'sync') {
                // dynamically depending on "flag" value
                if (flag) {
                    params.foo = 'bar';
                } else {
                    params.foo = 'smth';
                }
            }
        });

         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} params Request params
         * @param {String} requestType Request type (`load`/`sync`)
         * @param {Object} requestConfig Configuration object for Ext.Ajax.request call
         */
        this.fireEvent('beforesend', this, params, config.type, requestConfig);
        return Ext.Ajax.request(requestConfig);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.data.CrudManager

A class implementing a central collection of all data stores related to the Gantt chart.
It allows you to load all stores in a single server request and persist all of their changes in one request as well. This
 helps you use a transactional 'all-or-nothing' approach to saving your data.
This class uses AJAX as a transport mechanism and JSON as the encoding format.

# Gantt stores

The class supports all the Gantt specific stores: resources, assignments, dependencies, calendars and tasks.
For these stores, the class has separate configs ({@link #resourceStore}, {@link #assignmentStore}, {@link #dependencyStore}, {@link #taskStore})
to register them. The class can also grab them from the task store (this behavior can be changed using {@link #addRelatedStores} config).

    var taskStore = Ext.create('Gnt.data.TaskStore', {
        calendarManager : calendarManager,
        resourceStore   : resourceStore,
        dependencyStore : dependencyStore,
        assignmentStore : assignmentStore
    });

    var crudManager = Ext.create('Gnt.data.CrudManager', {
        autoLoad        : true,
        // We specify TaskStore only. The rest stores will be taken from it.
        taskStore       : taskStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });


# Calendars

The CrudManager class supports bulk loading of project calendars.
To do this, the {@link #calendarManager} config has to be specified or it can be specified on a {@link Gnt.data.TaskStore#calendarManager task store}
(while having {@link #addRelatedStores} is enabled).

    var calendarManager   = Ext.create('Gnt.data.CalendarManager', {
        calendarClass   : 'Gnt.data.calendar.BusinessTime'
    });

    ...

    var taskStore     = Ext.create('MyTaskStore', {
        // taskStore calendar will automatically be set when calendarManager gets loaded
        calendarManager : calendarManager,
        resourceStore   : resourceStore,
        dependencyStore : dependencyStore,
        assignmentStore : assignmentStore
    });

    var crudManager   = Ext.create('Gnt.data.CrudManager', {
        autoLoad        : true,
        taskStore       : taskStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

# AJAX request configuration

To configure AJAX request parameters please take a look at the {@link #transport} config.

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        taskStore       : taskStore,
        transport       : {
            load    : {
                url         : 'php/read.php',
                // use GET request
                method      : 'GET',
                // pass request JSON in "rq" parameter
                paramName   : 'rq',
                // extra HTTP request parameters
                params      : {
                    foo     : 'bar'
                }
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });


# Extra stores

Along with the Gantt specific stores any number of additional stores can be specified
using {@link #stores} config on a construction step or {@link #addStore} method in the runtime:

    var crudManager = Ext.create('Gnt.data.CrudManager', {
        // extra stores
        stores          : [ 'departments', 'messages' ],
        taskStore       : taskStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

    // append 'documents' store
    crudManager.addStore('documents');

    // now when we registered all the stores let's load them
    crudManager.load();

* **Note:** Any extra stores provided in {@link #stores} config will be loaded **before** the gantt specific stores.
If for some reason you need to change that loading order you should use {@link #addStore} method:

    // append store3 to the end so it will be loaded last
    crudManager.addStore(store3);

*/
Ext.define('Gnt.data.CrudManager', {
    extend: 'Sch.crud.AbstractManager',
    mixins: [
        'Sch.crud.encoder.Json',
        'Sch.crud.transport.Ajax'
    ],
    /**
     * @cfg {Gnt.data.CalendarManager/Object} calendarManager A calendar manager instance or its descriptor.
     */
    calendarManager: null,
    /**
     * @cfg {Gnt.data.TaskStore/String/Object} taskStore Tasks store or its descriptor or its identifier.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.DependencyStore/Object} dependencyStore A store with dependencies or its descriptor.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore/Object} resourceStore A store with resources or its descriptor.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore/Object} assignmentStore A store with assignments or its descriptor.
     */
    assignmentStore: null,
    /**
     * @cfg {Boolean} addRelatedStores
     * When set to `true` this class will try to get the {@link #calendarManager}, {@link #dependencyStore}, {@link #resourceStore} and {@link #assignmentStore} stores from
     * the specified {@link #taskStore} instance.
     */
    addRelatedStores: true,
    constructor: function(config) {
        config = config || {};
        var calendarManager = config.calendarManager || this.calendarManager,
            taskStore = config.taskStore || this.taskStore || new Gnt.data.TaskStore({
                proxy: 'memory'
            }),
            assignmentStore = config.assignmentStore || this.assignmentStore,
            resourceStore = config.resourceStore || this.resourceStore,
            dependencyStore = config.dependencyStore || this.dependencyStore,
            // list of stores to add
            stores = [];
        // retrieve stores registered on the provided taskStore
        if (taskStore && config.addRelatedStores !== false) {
            var extracted = this.getTaskStoreInfo(taskStore, config);
            calendarManager = calendarManager || extracted.calendarManager;
            assignmentStore = assignmentStore || extracted.assignmentStore;
            resourceStore = resourceStore || extracted.resourceStore;
            dependencyStore = dependencyStore || extracted.dependencyStore;
        }
        // calendars go first in the stores loading order
        if (calendarManager) {
            // Call this early manually to be able to add listeners before calling the superclass constructor
            this.mixins.observable.constructor.call(this, config);
            this.addCalendarManager(calendarManager, stores);
        }
        // ..then resources, assignments, dependencies and finally tasks
        if (resourceStore)  {
            stores.push(resourceStore);
        }
        
        if (assignmentStore)  {
            stores.push(assignmentStore);
        }
        
        if (dependencyStore)  {
            stores.push(dependencyStore);
        }
        
        if (taskStore)  {
            stores.push(taskStore);
        }
        
        if (stores.length) {
            var syncSequence = [];
            // For applying sync results we have a different order:
            // calendars -> resources -> tasks -> assignments -> dependencies
            if (calendarManager)  {
                syncSequence.push(calendarManager);
            }
            
            if (resourceStore)  {
                syncSequence.push(resourceStore);
            }
            
            if (taskStore)  {
                syncSequence.push(taskStore);
            }
            
            if (assignmentStore)  {
                syncSequence.push(assignmentStore);
            }
            
            if (dependencyStore)  {
                syncSequence.push(dependencyStore);
            }
            
            if (syncSequence.length) {
                config.syncApplySequence = (config.syncApplySequence || config.stores || []).concat(syncSequence);
            }
            var _stores = config.stores || this.stores;
            if (_stores && !Ext.isArray(_stores))  {
                _stores = [
                    _stores
                ];
            }
            
            // all the Gantt related stores will go after the user defined stores (specified in config.stores)
            config.stores = (_stores || []).concat(stores);
        }
        this.callParent([
            config
        ]);
        // make sure we have properties set to proper stores descriptors
        this.calendarManager = this.getStoreDescriptor(calendarManager);
        this.resourceStore = this.getStoreDescriptor(resourceStore);
        this.assignmentStore = this.getStoreDescriptor(assignmentStore);
        this.dependencyStore = this.getStoreDescriptor(dependencyStore);
        this.taskStore = this.getStoreDescriptor(taskStore);
    },
    getTaskStoreInfo: function(taskStore, config) {
        if (!(taskStore instanceof Ext.data.AbstractStore)) {
            if (typeof taskStore == 'string') {
                taskStore = Ext.data.StoreManager.get(taskStore);
            } else {
                taskStore = taskStore.store;
            }
        }
        var result = {},
            calendarManager = config.calendarManager,
            assignmentStore = config.assignmentStore,
            resourceStore = config.resourceStore,
            dependencyStore = config.dependencyStore;
        if (!calendarManager)  {
            result.calendarManager = taskStore.calendarManager;
        }
        
        if (!assignmentStore)  {
            result.assignmentStore = taskStore.getAssignmentStore();
        }
        
        if (!resourceStore)  {
            result.resourceStore = taskStore.getResourceStore();
        }
        
        if (!dependencyStore)  {
            result.dependencyStore = taskStore.getDependencyStore();
        }
        
        return result;
    },
    addCalendarManager: function(calendarManager, stores) {
        var store, descriptor;
        if (calendarManager instanceof Ext.data.AbstractStore) {
            store = calendarManager;
            descriptor = {
                store: calendarManager
            };
        } else if (typeof calendarManager == 'object') {
            store = calendarManager.store;
            descriptor = calendarManager;
        } else {
            calendarManager = Ext.data.StoreManager.get(calendarManager);
            store = calendarManager;
            descriptor = {
                store: calendarManager
            };
        }
        var model = (store.getModel && store.getModel() || store.model).prototype;
        // register calendar manager sub-stores being kept in "Days" field
        if (!descriptor.stores) {
            descriptor.stores = [
                {
                    storeId: model.daysField,
                    idProperty: model.idProperty
                }
            ];
        }
        this.calendarManager = descriptor;
        // on calendar manager data get loaded we gonna set the project calendar
        store.on('load', this.onCalendarManagerLoad, this);
        this.mon(store, {
            dayadd: this.onStoreChange,
            dayupdate: this.onStoreChange,
            dayremove: this.onStoreChange,
            daybulkremove: this.onStoreChange,
            scope: this
        });
        stores.push(descriptor);
    },
    onCalendarManagerLoad: function(store) {
        var projectCalendar = store.getProjectCalendar(),
            oldCalendarId = projectCalendar && projectCalendar.getCalendarId(),
            newCalendarId = store.metaData && store.metaData.projectCalendar;
        // if project calendar has changed
        if (oldCalendarId != newCalendarId) {
            store.setProjectCalendar(newCalendarId);
        }
    },
    applyLoadResponse: function() {
        // let's ignore calendars events during data loading since we don't want tasks to get moved after stores loading
        var cm = this.getCalendarManager();
        cm && cm.suspendCalendarsEvents();
        this.callParent(arguments);
        cm && cm.resumeCalendarsEvents();
    },
    /**
     * Returns the calendar manager bound to the crud manager.
     * @return {Gnt.data.CalendarManager} The calendar manager bound to the crud manager.
     */
    getCalendarManager: function() {
        return this.calendarManager && this.calendarManager.store;
    },
    /**
     * Returns the resource store bound to the crud manager.
     * @return {Gnt.data.ResourceStore} The resource store bound to the crud manager.
     */
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store;
    },
    /**
     * Returns the dependency store bound to the crud manager.
     * @return {Gnt.data.DependencyStore} The dependency store bound to the crud manager.
     */
    getDependencyStore: function() {
        return this.dependencyStore && this.dependencyStore.store;
    },
    /**
     * Returns the assignment store bound to the crud manager.
     * @return {Gnt.data.AssignmentStore} The assignment store bound to the crud manager.
     */
    getAssignmentStore: function() {
        return this.assignmentStore && this.assignmentStore.store;
    },
    /**
     * Returns the task store bound to the crud manager.
     * @return {Gnt.data.TaskStore} The task store bound to the crud manager.
     */
    getTaskStore: function() {
        return this.taskStore && this.taskStore.store;
    },
    prepareUpdated: function(list, stores, storeInfo) {
        if (list[0] instanceof Gnt.model.Task) {
            // Root should not be updated since the gantt doesn't modify this (though Ext JS might)
            list = Ext.Array.filter(list, function(node) {
                return !node.isRoot();
            });
            var result = this.callParent([
                    list,
                    stores,
                    storeInfo
                ]);
            // if resetIdsBeforeSync mode is enabled and we deal with tasks
            // we need to reset ids for tasks segments as well
            if (this.resetIdsBeforeSync) {
                var segmentsField = list[0].segmentsField,
                    proto = Ext.ClassManager.get(list[0].segmentClassName).prototype,
                    idProperty = proto.idProperty,
                    phantomIdField = proto.phantomIdField;
                for (var i = 0; i < result.length; i++) {
                    var segmentsData = result[i][segmentsField];
                    if (segmentsData) {
                        for (var j = 0; j < segmentsData.length; j++) {
                            var segment = segmentsData[j];
                            if (segment[phantomIdField])  {
                                delete segment[idProperty];
                            }
                            
                        }
                    }
                }
            }
            return result;
        }
        return this.callParent(arguments);
    },
    prepareAdded: function(list) {
        var result = this.callParent(arguments);
        // if resetIdsBeforeSync mode is enabled and we deal with tasks
        // we need to reset ids for tasks segments as well
        if (this.resetIdsBeforeSync && list[0] instanceof Gnt.model.Task) {
            var segmentsField = list[0].segmentsField,
                idProperty = Ext.ClassManager.get(list[0].segmentClassName).prototype.idProperty;
            for (var i = 0; i < result.length; i++) {
                var segmentsData = result[i][segmentsField];
                if (segmentsData) {
                    for (var j = 0; j < segmentsData.length; j++) {
                        delete segmentsData[j][idProperty];
                    }
                }
            }
        }
        return result;
    },
    applyChangesToTask: function(record, changes) {
        // apply changes to segments
        if (changes.hasOwnProperty(record.segmentsField)) {
            var segments = record.getSegments(),
                segmentsField = record.segmentsField,
                phantomIdField = segments && segments[0].phantomIdField,
                idProperty = segments && segments[0].idProperty,
                segmentsChanges = changes[segmentsField];
            // If the task is segmented we're gonna try to modify existing segments one by one
            if (segments) {
                // loop over transferred segments if any
                if (segmentsChanges) {
                    for (var i = segmentsChanges.length - 1; i >= 0; i--) {
                        // get transferred segment change
                        var segmentChange = segmentsChanges[i],
                            phantomId = segmentChange[phantomIdField],
                            id = segmentChange[idProperty],
                            segment = null;
                        // let's find corresponding segment to update
                        for (var j = 0; j < segments.length; j++) {
                            segment = segments[j];
                            // we detect it using either phantom or real id
                            if ((segment.get(phantomIdField) == phantomId) || (segment.getId() == id)) {
                                // let's apply transferred changes to found segment
                                this.applyChangesToRecord(segment, segmentChange);
                                break;
                            }
                        }
                    }
                }
                // need to get rid of "Segments" field since we already loaded segments changes
                // (otherwise the task will do a simple setSegments() call)
                delete changes[segmentsField];
            }
        }
    },
    applyChangesToRecord: function(record, changes, stores) {
        // if we deal with a task let's call special applyChangesToTask method before
        // it will apply changes to the task segments (if they passed)
        if (record instanceof Gnt.model.Task) {
            this.ignoreUpdates++;
            this.applyChangesToTask.apply(this, arguments);
            this.ignoreUpdates--;
        }
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.model.Dependency
@extends Sch.model.Customizable

This class represents a single Dependency between two events. It is a subclass of the {@link Sch.model.Customizable}
class, which in its turn subclasses {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of this class.

A Dependency has the following fields:

- `Id` - The id of the dependency itself
- `From` - The id of the event at which the dependency starts
- `To` - The id of the event at which the dependency ends
- `Cls` - A CSS class that will be applied to each rendered dependency DOM element
- `Type` - An integer constant representing the type of the dependency:
    - 0 - start-to-start dependency
    - 1 - start-to-end dependency
    - 2 - end-to-start dependency
    - 3 - end-to-end dependency
- `Bidirectional` - A boolean indicating if a dependency goes both directions (default false)

Subclassing the Dependency class
--------------------

The name of any field can be customized in the subclass, see the example below. Please also refer to {@link Sch.model.Customizable}
for details.

    Ext.define('MyProject.model.Dependency', {
        extend      : 'Sch.model.Dependency',

        toField     : 'targetId',
        fromField   : 'sourceId',

        ...
    })

*/
Ext.define('Sch.model.Dependency', {
    extend: 'Sch.model.Customizable',
    requires: [
        'Sch.model.Range'
    ],
    inheritableStatics: {
        /**
         * @static
         * @property {Object} Type The enumerable object, containing names for the dependency types integer constants.
         */
        Type: {
            StartToStart: 0,
            StartToEnd: 1,
            EndToStart: 2,
            EndToEnd: 3
        }
    },
    idProperty: 'Id',
    customizableFields: [
        // 3 mandatory fields
        {
            name: 'From'
        },
        {
            name: 'To'
        },
        {
            name: 'Type',
            type: 'int',
            defaultValue: 2
        },
        {
            name: 'Cls',
            defaultValue: ''
        },
        {
            name: 'Bidirectional',
            type: 'boolean'
        }
    ],
    /**
     * @cfg {String} fromField The name of the field that contains the id of the source event.
     */
    fromField: 'From',
    /**
     * @cfg {String} toField The name of the field that contains the id of the target event.
     */
    toField: 'To',
    /**
     * @cfg {String} typeField The name of the field that contains the dependency type.
     */
    typeField: 'Type',
    /**
     * @cfg {String} clsField The name of the field that contains a CSS class that will be added to the rendered dependency elements.
     */
    clsField: 'Cls',
    /**
     * @cfg {String} clsField The name of the boolean field that controls if arrows should be drawn at both start and end points.
     */
    bidirectionalField: 'Bidirectional',
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (config) {
            // Allow passing in event instances too
            if (config[me.fromField] && config[me.fromField] instanceof Sch.model.Range) {
                me.setSourceEvent(config[me.fromField]);
                delete config.fromField;
            }
            if (config[me.toField] && config[me.toField] instanceof Sch.model.Range) {
                me.setTargetEvent(config[me.toField]);
                delete config.toField;
            }
        }
    },
    getEventStore: function() {
        return this.store.getEventStore();
    },
    /**
     * Returns the source event of the dependency
     *
     * @return {Sch.model.Event} The source event of this dependency
     */
    getSourceEvent: function(eventStore) {
        var me = this;
        return (eventStore || me.getEventStore()).getModelById(me.getSourceId());
    },
    /**
     * Sets the source event of the dependency
     *
     * @param {Sch.model.Event} event The new source event of this dependency
     */
    setSourceEvent: function(event) {
        this.setSourceId(event.getId());
    },
    /**
     * Returns the target event of the dependency
     *
     * @return {Sch.model.Event} The target event of this dependency
     */
    getTargetEvent: function(eventStore) {
        var me = this;
        return (eventStore || me.getEventStore()).getModelById(me.getTargetId());
    },
    /**
     * Sets the target event of the dependency
     *
     * @param {Sch.model.Event} event The new target event of this dependency
     */
    setTargetEvent: function(event) {
        this.setTargetId(event.getId());
    },
    /**
     * Returns the source event id of the dependency
     *
     * @return {Mixed} The id of the source event for the dependency
     *
     * @method getFrom
     */
    /**
     * Returns the source event id of the dependency
     *
     * @return {Mixed} The id of the source event for the dependency
     */
    getSourceId: function() {
        return this.getFrom();
    },
    // TODO: remove commented if everything is ok
    /*
    getSourceId : function() {
        return this.get(this.fromField);
    },
    */
    /**
     * Sets the source event id of the dependency
     *
     * @param {Mixed} id The id of the source event for the dependency
     *
     * @method setFrom
     */
    /**
     * Sets the source event id of the dependency
     *
     * @param {Mixed} id The id of the source event for the dependency
     */
    setSourceId: function(id) {
        return this.setFrom(id);
    },
    // TODO: remove commented if everything is ok
    /*
    setSourceId : function(id) {
        var me = this;
        me.set(me.fromField, id);
    },
    */
    /**
     * Returns the target event id of the dependency
     *
     * @return {Mixed} The id of the target event for the dependency
     *
     * @method getTo
     */
    /**
     * Returns the target event id of the dependency
     *
     * @return {Mixed} The id of the target event for the dependency
     */
    getTargetId: function() {
        return this.getTo();
    },
    // TODO: remove commented if everything is ok
    /*
    getTargetId : function() {
        var me = this;
        return me.get(me.toField);
    },
    */
    /**
     * Sets the target event id of the dependency
     *
     * @param {Mixed} id The id of the target event for the dependency
     *
     * @method setTo
     */
    /**
     * Sets the target event id of the dependency
     *
     * @param {Mixed} id The id of the target event for the dependency
     */
    setTargetId: function(id) {
        return this.setTo(id);
    },
    // TODO: remove commented if everything is ok
    /*
    setTargetId : function(id) {
        var me = this;
        me.set(me.toField, id);
    },
    */
    /**
     * @method getType
     *
     * Returns the dependency type
     * @return {Mixed} The type of the dependency
     */
    /**
     * @method setType
     *
     * Sets the dependency type
     * @param {Mixed} type The type of the dependency
     */
    /**
     * @method getCls
     *
     * Returns the name of field holding the CSS class for each rendered dependency element
     *
     * @return {String} The cls field
     */
    /**
     * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var me = this,
            source = me.getSourceEvent(),
            target = me.getTargetEvent();
        return source && !source.phantom && target && !target.phantom;
    },
    /**
     * Returns `true` if the dependency is valid. Has valid type and both source and target ids set and not links to itself.
     *
     * @return {Boolean}
     */
    isValid: function(taskStore) {
        var me = this,
            valid = me.callParent(arguments),
            sourceId = me.getSourceId(),
            targetId = me.getTargetId(),
            type = me.getType();
        return Ext.isNumber(type) && !Ext.isEmpty(sourceId) && !Ext.isEmpty(targetId) && sourceId != targetId;
    },
    getDateRange: function() {
        var sourceTask = this.getSourceEvent();
        var targetTask = this.getTargetEvent();
        if (sourceTask && targetTask && sourceTask.isScheduled() && targetTask.isScheduled()) {
            var Type = this.self.Type;
            var sourceDate, targetDate;
            switch (this.getType()) {
                case Type.StartToStart:
                    sourceDate = sourceTask.getStartDate();
                    targetDate = targetTask.getStartDate();
                    break;
                case Type.StartToEnd:
                    sourceDate = sourceTask.getStartDate();
                    targetDate = targetTask.getEndDate();
                    break;
                case Type.EndToEnd:
                    sourceDate = sourceTask.getEndDate();
                    targetDate = targetTask.getEndDate();
                    break;
                case Type.EndToStart:
                    sourceDate = sourceTask.getEndDate();
                    targetDate = targetTask.getStartDate();
                    break;
            }
            return {
                start: Sch.util.Date.min(sourceDate, targetDate),
                end: Sch.util.Date.max(sourceDate, targetDate)
            };
        }
        return null;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.data.DependencyStore
 * @extends Ext.data.Store
 *
 * A class representing a collection of dependencies between events in the {@link Sch.data.EventStore}.
 * Contains a collection of {@link Sch.model.Dependency} records.
 */
Ext.define('Sch.data.DependencyStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Sch.patches.CollectionKey'
    ],
    uses: [
        'Ext.data.Model',
        'Sch.data.util.EventDependencyCache'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Robo.data.Store'
    ],
    config: {
        // WARNING: this is a private config in Ext.data.LocalStore
        extraKeys: {
            bySourceTargetId: {
                keyFn: function(dependency) {
                    return Sch.data.DependencyStore.makeDependencySourceTargetCompositeKey(dependency.getSourceId(), dependency.getTargetId());
                }
            }
        }
    },
    model: 'Sch.model.Dependency',
    alias: 'store.sch_dependencystore',
    storeId: 'dependencies',
    eventDependencyCache: null,
    eventStoreDetacher: null,
    /**
     * @property {Sch.data.EventStore} eventStore The event store to which this assignment store is associated.
     * Usually it is configured automatically, by the event store itself.
     *
     * @readonly
     * @deprecated 4.2 Use {@link getEventStore} instead
     */
    eventStore: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.eventDependencyCache = me.eventDependencyCache || me.createEventDependencyCache();
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventDependencyCache', 'eventStoreDetacher');
        me.callParent();
    },
    createEventDependencyCache: function() {
        return new Sch.data.util.EventDependencyCache(this);
    },
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore = me.eventStore;
        me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
        me.attachToEventStore(me.eventStore);
        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * @event eventstorechange
             * Fires when a new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.DependencyStore} this
             * @param {Sch.data.EventStore} newEventStore
             * @param {Sch.data.EventStore} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    attachToEventStore: function(eventStore) {
        var me = this;
        Ext.destroy(me.eventStoreDetacher);
        if (eventStore && eventStore.isTreeStore) {
            me.eventStoreDetacher = eventStore.on({
                'noderemove': me.onEventNodeRemove,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher than in cache, we need those handlers to do their job before cache update
        else if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                'remove': me.onEventRemove,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
    },
    // higher than in cache, we need those handlers to do their job before cache update
    onEventRemove: function(eventStore, events, index, isMove) {
        !isMove && this.removeEventDependencies(events, false);
    },
    onEventNodeRemove: function(eventStore, event, isMove) {
        !isMove && this.removeEventDependencies(event, false);
    },
    // TODO: document
    reduceEventDependencies: function(event, reduceFn, result, flat, depsGetterFn) {
        var me = this;
        depsGetterFn = depsGetterFn || function(event) {
            return me.eventDependencyCache.get(event);
        };
        event = Ext.isArray(event) ? event : [
            event
        ];
        flat = flat === undefined ? true : false;
        Ext.Array.reduce(event, function(result, event) {
            if (event.isNode && !flat) {
                event.cascadeBy(function(event) {
                    result = Ext.Array.reduce(depsGetterFn(event), reduceFn, result);
                });
            } else {
                result = Ext.Array.reduce(depsGetterFn(event), reduceFn, result);
            }
        }, result);
        return result;
    },
    // TODO: document
    reduceEventIncomingDependencies: function(event, reduceFn, result, flat) {
        var me = this;
        return me.reduceEventDependencies(event, reduceFn, result, flat, function(event) {
            return me.eventDependencyCache.getPredecessors(event);
        });
    },
    // TODO: document
    reduceEventOutgoingDependencies: function(event, reduceFn, result, flat) {
        var me = this;
        return me.reduceEventDependencies(event, reduceFn, result, flat, function(event) {
            return me.eventDependencyCache.getSuccessors(event);
        });
    },
    // TODO: document
    mapEventDependencies: function(event, fn, filterFn, flat, depsGetterFn) {
        return this.reduceEventDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat, depsGetterFn);
    },
    // TODO: document
    mapEventIncomingDependencies: function(event, fn, filterFn, flat) {
        return this.reduceEventIncomingDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    },
    // TODO: document
    mapEventOutgoingDependencies: function(event, fn, filterFn, flat) {
        return this.reduceEventOutgoingDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    },
    /**
     * Returns all dependencies of for a certain event (both incoming and outgoing)
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventDependencies: function(event, flat) {
        return this.mapEventDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    /**
     * Returns all incoming dependencies of the given event
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventIncomingDependencies: function(event, flat) {
        return this.mapEventIncomingDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    /**
     * Returns all outcoming dependencies of a event
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventOutgoingDependencies: function(event, flat) {
        return this.mapEventOutgoingDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    // TODO: document
    getEventPredecessors: function(event, flat) {
        var me = this,
            eventStore = me.getEventStore();
        Ext.Assert && Ext.Assert.truthy(eventStore, "Can't get event predecessors, no event store configured");
        return me.reduceEventDependencies(event, function(result, dependency) {
            var predecessorId = dependency.getFrom(),
                predecessor = predecessorId && eventStore.getModelById(predecessorId);
            if (predecessor) {
                result.push(predecessor);
            }
            return result;
        }, [], flat, function(event) {
            return me.eventDependencyCache.getPredecessors(event);
        });
    },
    // TODO: document
    getEventSuccessors: function(event, flat) {
        var me = this,
            eventStore = me.getEventStore();
        Ext.Assert && Ext.Assert.truthy(eventStore, "Can't get event successors, no event store configured");
        return me.reduceEventDependencies(event, function(result, dependency) {
            var successorId = dependency.getTo(),
                successor = successorId && eventStore.getModelById(successorId);
            if (successor) {
                result.push(successor);
            }
            return result;
        }, [], flat, function(event) {
            return me.eventDependencyCache.getSuccessors(event);
        });
    },
    // TODO: document
    removeEventDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    // TODO: document
    removeEventIncomingDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventIncomingDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    // TODO: document
    removeEventOutgoingDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventOutgoingDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Sch.model.Event|String} sourceEvent 1st event
     * @param {Sch.model.Event|String} targetEvent 2nd event
     * @return {Sch.model.Dependency|Null}
     */
    getDependencyForSourceAndTargetEvents: function(sourceEvent, targetEvent) {
        // NOTE: In case this will not work switch to cache get and linear search
        var me = this;
        sourceEvent = sourceEvent instanceof Ext.data.Model && sourceEvent.getId() || sourceEvent;
        targetEvent = targetEvent instanceof Ext.data.Model && targetEvent.getId() || targetEvent;
        return me.bySourceTargetId.get(me.self.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
    },
    /**
     * Returns a dependency model instance linking given events if such dependency exists in the store.
     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Sch.model.Event|String} sourceEvent
     * @param {Sch.model.Event|String} targetEvent
     * @return {Scm.model.Dependency|null}
     */
    getEventsLinkingDependency: function(event1, event2) {
        var me = this;
        return me.getDependencyForSourceAndTargetEvents(event1, event2) || me.getDependencyForSourceAndTargetEvents(event2, event1);
    },
    inheritableStatics: {
        makeDependencySourceTargetCompositeKey: function() {
            var arr = [];
            return function(sourceId, targetId) {
                arr.length = 0;
                arr.push('source(', sourceId, ')-target(', targetId, ')');
                return arr.join('');
            };
        }()
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.Dependency
@extends Sch.model.Dependency

This class represents a single Dependency in your gantt chart. It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of this class.

A Dependency has the following fields:

- `Id` - The id of the dependency itself
- `From` - The id of the task at which the dependency starts
- `To` - The id of the task at which the dependency ends
- `Lag` - A numeric part of the lag value between the tasks. Negative values are supported. Please note, that any lag-related calculations will be performed
  using project calendar. Also only working time is counted as "lag" time.
- `LagUnit` - A duration unit part of the lag value between the tasks. Default value is "d" (days). Valid values are:
    - "ms" (milliseconds)
    - "s" (seconds)
    - "mi" (minutes)
    - "h" (hours)
    - "d" (days)
    - "w" (weeks)
    - "mo" (months)
    - "q" (quarters)
    - "y" (years)

- `Cls` - A CSS class that will be applied to each rendered dependency DOM element
- `Type` - An integer constant representing the type of the dependency:
    - 0 - start-to-start dependency
    - 1 - start-to-end dependency
    - 2 - end-to-start dependency
    - 3 - end-to-end dependency

Subclassing the Dependency class
--------------------

The name of any field can be customized in the subclass, see the example below. Please also refer to {@link Sch.model.Customizable} for details.

    Ext.define('MyProject.model.Dependency', {
        extend      : 'Gnt.model.Dependency',

        toField     : 'targetId',
        fromField   : 'sourceId',

        ...
    })

*/
Ext.define('Gnt.model.Dependency', {
    extend: 'Sch.model.Dependency',
    customizableFields: [
        {
            name: 'Lag',
            type: 'number',
            defaultValue: 0
        },
        {
            name: 'LagUnit',
            type: 'string',
            defaultValue: "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert: function(value) {
                return value || "d";
            }
        }
    ],
    /**
     * @cfg {String} lagField The name of the field that contains the lag amount.
     */
    lagField: 'Lag',
    /**
     * @cfg {String} lagUnitField The name of the field that contains the lag unit duration.
     */
    lagUnitField: 'LagUnit',
    isHighlighted: false,
    getTaskStore: function() {
        return Ext.isFunction(this.store.getTaskStore) ? this.store.getTaskStore() : this.store.taskStore;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Returns the source task of the dependency
     *
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask: function(taskStore) {
        return this.getSourceEvent(taskStore);
    },
    /**
     * Sets the source task of the dependency
     *
     * @param {Gnt.model.Task} task The new source task of this dependency
     */
    setSourceTask: function(task) {
        return this.setSourceEvent(task);
    },
    /**
     * Returns the target task of the dependency
     *
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask: function(taskStore) {
        return this.getTargetEvent(taskStore);
    },
    /**
     * Sets the target task of the dependency
     *
     * @param {Gnt.model.Task} task The new target task of this dependency
     */
    setTargetTask: function(task) {
        return this.setTargetEvent(task);
    },
    /**
     * @method getLag
     *
     * Returns the amount of lag for the dependency
     *
     * @return {Number} The amount of lag for the dependency
     */
    /**
     * @method setLag
     *
     * Sets the amount of lag for the dependency
     *
     * @param {Number} amount The amount of lag for the dependency
     * @param {String} [unit] Lag duration unit
     */
    setLag: function(amount, unit) {
        var me = this;
        me.beginEdit();
        me.set(me.lagField, amount);
        if (arguments.length > 1) {
            me.setLagUnit(unit);
        }
        me.endEdit();
    },
    /**
     * Returns the duration unit of the lag.
     *
     * @return {String} Lag duration unit
     */
    getLagUnit: function() {
        var me = this;
        return me.get(me.lagUnitField) || 'd';
    },
    /**
     * @method setLagUnit
     *
     * Updates the lag unit of the dependency.
     *
     * @param {String} unit Lag duration unit
     */
    /**
     * Returns `true` if the dependency is valid. Note, this method assumes that the model is part of a {@link Gnt.data.DependencyStore}.
     * Invalid dependencies are:
     * - a task linking to itself
     * - a dependency between a child and one of its parent
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid
     *
     * @return {Boolean}
     */
    isValid: function(taskStore) {
        var me = this,
            valid = me.callParent(arguments),
            sourceId = me.getSourceId(),
            targetId = me.getTargetId(),
            type = me.getType();
        if (valid && taskStore !== false && me.store) {
            valid = me.store.isValidDependency(sourceId, targetId, type, null, null, me);
        }
        return valid;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.data.DependencyStore
@extends Ext.data.Store

 A class representing a collection of dependencies between the tasks in the {@link Gnt.data.TaskStore}.
 Contains a collection of {@link Gnt.model.Dependency} records.

## Custom validation

You can subclass this Store class like any other Ext JS class and add your own custom validation for Dependencies:

    Ext.define('MyDependencyStore', {
        extend              : 'Gnt.data.DependencyStore',

        // Override this method to provide custom logic defining what constitutes a valid dependency
        getDependencyError  : function (from, to) {
            // Support default validation rules
            var error = this.callParent(arguments);
            if (error) return error;

            // Example: Don`t allow links between tasks of type A, to tasks with type B
            var isDepInput = from instanceof Ext.data.Model;
            var sourceTask = isDepInput ? from.getSourceTask() : this.getTaskById(from);
            var targetTask = isDepInput ? from.getTargetTask() : this.getTaskById(to);

            // Let`s return a custom error code -100 for such case (it must be a negative value)
            if (sourceTask.getType() !== 'A' || targetTask.getType() !== 'B') return -100;

            // No errors
            return 0;
        },

        ...
    })

*/
Ext.define('Gnt.data.DependencyStore', {
    extend: 'Sch.data.DependencyStore',
    uses: [
        'Gnt.data.util.TaskDependencyCache'
    ],
    model: 'Gnt.model.Dependency',
    alias: 'store.gantt_dependencystore',
    /**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this dependency store is associated.
     * Usually is configured automatically, by the task store itself.
     *
     * @readonly
     * @deprecated 4.2 Use {@link getTaskStore} instead
     */
    taskStore: null,
    methodsCache: null,
    /**
     * @cfg {Boolean} strictDependencyValidation A boolean flag indicating whether a strict validation of dependencies should be applied.
     * This mode will detect indirect cycles between parent-child relationships.
     * For example, the following cases will be considered as invalid (here `P1`, `P2`, `P3` are parent tasks and `T1`, `T2`, `T3` - their children respectively):

                P1 =========
                T1 ++++++          P2 =========
                                   T2    +++++        P3 ===============
                                                      T3 +++++++++++++++

     * These cases will be considered as cycles:
     *
     * - if we have dependency `P1---->P2` then dependency `T2---->P1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T2---->T1` will be invalid
     * - if we have dependency `P1---->P2` then dependency `T2---->T1` will be invalid
     * - if we have dependencies `P1---->P2---->P3` then dependency `T3---->T1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `P2---->T1` will be invalid
     * - if we have dependencies `P1---->T2` `P2---->T3` then dependency `P3---->T1` will be invalid
     * - if we have dependencies `T1---->P2` `T2---->P3` then dependency `T3---->P1` will be invalid
     *
     * and these cases will be treated as transitivity (or duplicating) dependency when {@link #transitiveDependencyValidation} is set to `True`:
     *
     * - if we have dependency `P1---->P2` then dependency `T1---->P2` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T1---->T2` will be invalid
     * - if we have dependency `P1---->P2` then dependency `T1---->T2` will be invalid
     * - if we have dependencies `P1---->P2---->P3` then dependency `T1---->T3` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T1---->P2` will be invalid
     * - if we have dependencies `P1---->T2` `P2---->T3` then dependency `T1---->P3` will be invalid
     * - if we have dependencies `T1---->P2` `T2---->P3` then dependency `P1---->T3` will be invalid
     */
    strictDependencyValidation: false,
    /**
     * @cfg {Boolean} transitiveDependencyValidation When set to true, alternative routes between tasks are considered invalid.
     * For example if we have dependencies `A---->B---->C` and `D---->C` then dependency `A---->D` will be treated as invalid
     * because it builds an alternative route from task `A` to task `C`.
     *
     * When {@link #strictDependencyValidation} is `True` this setting also enables detecting transitivity between groups of tasks.
     * Please see {@link #strictDependencyValidation} description for examples.
     */
    transitiveDependencyValidation: false,
    /**
     * @cfg {String[]} allowedDependencyTypes
     *
     * Represents a list of the dependency types that are allowed in this store. Any {@link Gnt.panel.Gantt} panel associated with this store
     * will query this store for this information. If set to `null` (the default value) all types of dependencies are allowed.
     * To restrict the allowed dependencies set, provide it as an array of strings, corresponding to the names in the {@link Gnt.model.Dependency#Type} enumerable.
     *
     * For example:
     *
     *          allowedDependencyTypes : [ 'StartToEnd', 'EndToEnd' ]
     *
     */
    allowedDependencyTypes: null,
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `false` to disallow dependencies involving parent tasks.
     */
    allowParentTaskDependencies: true,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.init();
    },
    createEventDependencyCache: function() {
        return new Gnt.data.util.TaskDependencyCache(this);
    },
    init: function() {
        var me = this;
        me.methodsCache = {};
        me.on({
            add: me.onDependencyAdd,
            update: me.onDependencyUpdate,
            // seems we can't use "bulkremove" event, because one can listen to `remove` event on the task store
            // and expect correct state in it
            remove: me.onDependencyRemove,
            priority: 100,
            scope: me
        });
    },
    // Checks if a provided task is fully scheduled and sets its empty start/end/duration fields otherwise.
    scheduleTask: function(task) {
        var taskStore = this.getTaskStore(),
            startDate = task.getStartDate(),
            endDate = task.getEndDate();
        if (!startDate || !endDate) {
            task.beginEdit();
            // if task doesn't have a start date let's set it to the project start date
            if (!startDate) {
                task.setStartDateWithoutPropagation(taskStore.getProjectStartDate(), undefined !== task.getDuration());
            }
            // default duration is gonna be 1 duration unit (day by default)
            if (!endDate) {
                task.setDurationWithoutPropagation(1);
            }
            task.endEdit();
        }
    },
    // Checks tasks linked by dependency if they are fully scheduled
    // and fills their missing start/end/duration values otherwise.
    scheduleLinkedTasks: function(from, to) {
        // schedule predecessor (if required)
        this.scheduleTask(from);
        // if successor has no start date and `cascadeChanges` is disabled we'll try to
        // schedule it by alignByIncomingDependencies() call
        //
        // TODO: I consider it a code smell to check task store property from within a dependency store
        if (!to.getStartDate() && !from.getTaskStore().cascadeChanges) {
            to.alignByIncomingDependencies();
        }
        // schedule successor (if required)
        this.scheduleTask(to);
    },
    onDependencyAdd: function(me, dependencies) {
        // Looping over added dependnecies but
        //     need to ignore the initial "add" events for data provided in the config
        Ext.Array.each(dependencies, function(dependency) {
            var from, to;
            if (!me.isValidDependencyType(dependency.getType())) {
                throw 'This dependency type is invalid. Check Gnt.data.DependencyStore#allowedDependencyTypes value';
            }
            // ensure that tasks being linked are fully scheduled only if we are not currently undoing or redoing
            from = dependency.getSourceTask();
            to = dependency.getTargetTask();
            if (from && to && !me.isUndoingOrRedoing()) {
                me.scheduleLinkedTasks(from, to);
            }
        });
        me.resetMethodsCache();
    },
    onDependencyRemove: function(me, dependencies, index, isMove) {
        var taskStore = this.getTaskStore();
        var tasksToAdjust = [];
        Ext.Array.each(dependencies, function(dependency) {
            // dependencies are already removed from the dependecies store and has no reference to it
            // so `getTaskStore` on the dependency instance won't work, need to provide `taskStore` manually
            var to = dependency.getTargetTask(taskStore);
            // Only tasks which are part of the tree store, i.e. which have parent node should be adjusted,
            // there's no point in adjusting tasks which are removed from the store.
            // Note: it's yet to be investigated why tasks with parentNode == null are returned by
            //       dependency.getSourceTask() / dependency.getTargetTask()
            if (to && !me.isUndoingOrRedoing() && !to.isManuallyScheduled() && to.isTaskStored()) {
                tasksToAdjust.push(to);
            }
        });
        me.resetMethodsCache();
        // Readjust any target tasks only if we are not currently undoing and tasks are contained by a tree store
        if (!me.isUndoingOrRedoing()) {
            Ext.Array.each(tasksToAdjust, function(task) {
                task.adjustToCalendarWithoutPropagation();
            });
        }
    },
    onDependencyUpdate: function(me, dependency, operation) {
        var taskStore, previous, newFromTask, newToTask, fromChanged, toChanged;
        if (operation != Ext.data.Model.COMMIT) {
            taskStore = me.getTaskStore();
            previous = dependency.previous;
            newFromTask = dependency.getSourceTask();
            newToTask = dependency.getTargetTask();
            fromChanged = previous && dependency.fromField in previous;
            toChanged = previous && dependency.toField in previous;
            // Re-scheduling updated tasks only if we are not currently undoing or redoing
            if ((fromChanged || toChanged) && newFromTask && newToTask && !me.isUndoingOrRedoing()) {
                me.scheduleLinkedTasks(newFromTask, newToTask);
            }
            me.resetMethodsCache();
        }
    },
    // TODO: document
    reduceTaskDependencies: function(task, reduceFn, result, flat, depsGetterFn) {
        return this.reduceEventDependencies(task, reduceFn, result, flat, depsGetterFn);
    },
    // TODO: document
    reduceTaskIncomingDependencies: function(task, reduceFn, result, flat) {
        return this.reduceEventIncomingDependencies(task, reduceFn, result, flat);
    },
    // TODO: document
    reduceTaskOutgoingDependencies: function(task, reduceFn, result, flat) {
        return this.reduceEventOutgoingDependencies(task, reduceFn, result, flat);
    },
    // TODO: document
    mapTaskDependencies: function(task, fn, filterFn, flat, depsGetterFn) {
        return this.mapEventDependencies(task, fn, filterFn, flat, depsGetterFn);
    },
    // TODO: document
    mapTaskIncomingDependencies: function(task, fn, filterFn, flat) {
        return this.mapEventIncomingDependencies(task, fn, filterFn, flat);
    },
    // TODO: document
    mapTaskOutgoingDependencies: function(task, fn, filterFn, flat) {
        return this.mapEventOutgoingDependencies(task, fn, filterFn, flat);
    },
    /**
     * Returns all dependencies of for a certain task (both incoming and outgoing)
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     *
     * @deprecated 4.2 Use {@link getTaskDependencies} instead
     */
    getDependenciesForTask: function(task) {
        return this.getEventDependencies(task, true);
    },
    /**
     * Returns all dependencies of for a certain task (both incoming and outgoing)
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     * @return {Gnt.model.Dependency[]}
     */
    getTaskDependencies: function(task, flat) {
        return this.getEventDependencies(task, flat);
    },
    /**
     * Returns all incoming dependencies of the given task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     *
     * @deprecated 4.2 Use {@link getTaskIncomingDependencies} instead
     */
    getIncomingDependenciesForTask: function(task, doNotClone) {
        return this.getEventIncomingDependencies(task, true);
    },
    // TODO: document
    getTaskIncomingDependencies: function(task, flat) {
        return this.getEventIncomingDependencies(task, flat);
    },
    /**
     * Returns all outcoming dependencies of a task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     *
     * @deprecated 4.2 Use {@link getTaskOutgoingDependencies} instead
     */
    getOutgoingDependenciesForTask: function(task, doNotClone) {
        return this.getEventOutgoingDependencies(task, true);
    },
    // TODO: document
    getTaskOutgoingDependencies: function(task, flat) {
        return this.getEventOutgoingDependencies(task, flat);
    },
    // TODO: document
    getTaskPredecessors: function(task, flat) {
        return this.getEventPredecessors(task, flat);
    },
    // TODO: document
    getTaskSuccessors: function(task, flat) {
        return this.getEventSuccessors(task, flat);
    },
    // TODO: document
    removeTaskDependencies: function(task, flat) {
        return this.removeEventDependencies(task, flat);
    },
    // TODO: document
    removeTaskIncomingDependencies: function(task, flat) {
        return this.removeEventIncomingDependencies(task, flat);
    },
    // TODO: document
    removeTaskOutgoingDependencies: function(task, flat) {
        return this.removeEventOutgoingDependencies(task, flat);
    },
    // @private
    // Serializes array of dependencies. Used during cache key calculation.
    getKeyByDeps: function(dependencies, fromField, toField) {
        if (!dependencies || !dependencies.length)  {
            return '';
        }
        
        var key = '';
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
            var dep = dependencies[i];
            key += (dep.getSourceId && dep.getSourceId() || dep[fromField]) + ':' + (dep.getTargetId && dep.getTargetId() || dep[toField]) + ',';
        }
        return key;
    },
    buildCacheKey: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        var fromField = context.fromField || (context.fromField = this.model.prototype.fromField),
            toField = context.toField || (context.toField = this.model.prototype.toField),
            ignoreDepKey = context.ignoreDepKey,
            addDepKey = context.addDepKey;
        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!context.hasOwnProperty('ignoreDepKey')) {
            context.ignoreDepKey = ignoreDepKey = ignoreDepRecords && this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            context.addDepKey = addDepKey = addDepRecords && this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }
        // calculate cache key for provided arguments
        return sourceId + '-' + targetId + '-' + ignoreDepKey + '-' + addDepKey;
    },
    /**
     * Returns `true` if there is a dependency (either direct or "transitive") between tasks
     * with `sourceId` and `targetId`
     *
     * @param {String} sourceId
     * @param {String} targetId
     * @param {Gnt.model.Dependency[]} [ignoreDepRecords] If provided, dependencies in this array will be ignored during transitivity search.
     * @param {Gnt.model.Dependency[]/Object[]} [addDepRecords] If provided, search will be done supposing that specified records exist in the dependency store.
     *
     * @return {Boolean}
     */
    hasTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {
            visitedTasks: {}
        };
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var visitedTasks = context.visitedTasks,
            extraSuccessors = context.extraSuccessors;
        if (this.isCachedResultAvailable('hasTransitiveDependency', cacheKey)) {
            return this.methodsCache.hasTransitiveDependency[cacheKey];
        }
        var me = this,
            fromField = context.fromField,
            toField = context.toField,
            sourceTask = this.getTaskById(sourceId),
            i, l;
        // protection from cycles
        if (visitedTasks[sourceId])  {
            return false;
        }
        
        visitedTasks[sourceId] = true;
        if (sourceTask) {
            // if list of dependencies to be created is provided let's
            // organize it as a hash containing successors list by task ids
            if (addDepRecords && !extraSuccessors) {
                extraSuccessors = context.extraSuccessors = {};
                for (i = 0 , l = addDepRecords.length; i < l; i++) {
                    var dep = addDepRecords[i];
                    var from = dep.getSourceId && dep.getSourceId() || dep[fromField];
                    extraSuccessors[from] = extraSuccessors[from] || [];
                    extraSuccessors[from].push(dep);
                }
            }
            var dependency,
                successors = sourceTask.successors;
            // add successors to be added to existing successors
            if (extraSuccessors && extraSuccessors[sourceId])  {
                successors = successors.concat(extraSuccessors[sourceId]);
            }
            
            for (i = 0 , l = successors.length; i < l; i++) {
                dependency = successors[i];
                var target = dependency.getTargetId && dependency.getTargetId() || dependency[toField];
                if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) && (target === targetId || me.hasTransitiveDependency(target, targetId, ignoreDepRecords, addDepRecords, context))) {
                    return this.setCachedResult('hasTransitiveDependency', cacheKey, true);
                }
            }
        }
        return this.setCachedResult('hasTransitiveDependency', cacheKey, false);
    },
    successorsHaveTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {};
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var task = targetId instanceof Gnt.model.Task ? targetId : this.getTaskById(targetId);
        if (this.isCachedResultAvailable('successorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.successorsHaveTransitiveDependency[cacheKey];
        }
        for (var i = 0,
            l = task.successors.length; i < l; i++) {
            var toId = task.successors[i].getTargetId();
            if (this.hasTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) || this.predecessorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) || this.successorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords, context))  {
                return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, true);
            }
            
        }
        return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, false);
    },
    predecessorsHaveTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {};
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var task = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);
        if (this.isCachedResultAvailable('predecessorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.predecessorsHaveTransitiveDependency[cacheKey];
        }
        for (var i = 0,
            l = task.predecessors.length; i < l; i++) {
            var fromId = task.predecessors[i].getSourceId();
            if (this.hasTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) || this.successorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) || this.predecessorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords, context))  {
                return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, true);
            }
            
        }
        return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, false);
    },
    isPartOfTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords) {
        var task = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);
        if (!task.predecessors.length && !task.successors.length)  {
            return false;
        }
        
        if (task.predecessors.length) {
            return this.predecessorsHaveTransitiveDependency.apply(this, arguments);
        } else {
            return this.successorsHaveTransitiveDependency.apply(this, arguments);
        }
    },
    getCycle: function(context) {
        context = context || {};
        Ext.applyIf(context, {
            ignoreTasks: {},
            visitedTasks: {},
            path: [],
            task: this.getAt(0).getSourceTask()
        });
        var visitedTasks = context.visitedTasks,
            ignoreTasks = context.ignoreTasks,
            path = context.path,
            task = context.task,
            taskId = task.getId();
        if (ignoreTasks[taskId])  {
            return;
        }
        
        path.push(task);
        if (visitedTasks[taskId])  {
            return path;
        }
        
        visitedTasks[taskId] = true;
        var successors = task.successors;
        for (var i = 0,
            l = successors.length; i < l; i++) {
            context.task = successors[i].getTargetTask();
            var cycle = this.getCycle(context);
            if (cycle)  {
                return cycle;
            }
            
        }
        path.pop();
        delete visitedTasks[taskId];
    },
    // TODO improve so it can detect all cycles
    getCycles: function() {
        var me = this,
            result = [],
            ignoreTasks = {};
        this.each(function(dep) {
            var path = me.getCycle({
                    task: dep.getSourceTask(),
                    ignoreTasks: ignoreTasks
                });
            if (path) {
                for (var i = 0,
                    l = path.length; i < l; i++) {
                    ignoreTasks[path[i]] = true;
                }
                result.push(path);
            }
        });
        return result;
    },
    resetMethodsCache: function() {
        this.methodsCache = {};
    },
    isCachedResultAvailable: function(method, key) {
        return this.methodsCache[method] && this.methodsCache[method].hasOwnProperty(key);
    },
    getCachedResult: function(method, key) {
        return this.methodsCache[method][key];
    },
    setCachedResult: function(method, key, value) {
        this.methodsCache[method] = this.methodsCache[method] || {};
        this.methodsCache[method][key] = value;
        return value;
    },
    //@private
    getGroupTopTasks: function(sourceGroup, targetGroup) {
        var sourceGroupLength = sourceGroup.length,
            targetGroupLength = targetGroup.length,
            i = sourceGroupLength,
            j = targetGroupLength,
            sourceTopParent, targetTopParent;
        do {
            sourceTopParent = sourceGroup[i];
            targetTopParent = targetGroup[j];
            i--;
            j--;
        } while (sourceTopParent == targetTopParent && i >= 0 && j >= 0);
        return [
            sourceTopParent,
            targetTopParent
        ];
    },
    groupsHasTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        var ctx = context || {
                targets: null,
                visitedTasks: {}
            };
        var root = this.getTaskStore().getRootNode(),
            result = false,
            me = this,
            source = this.getTaskById(sourceId),
            target = this.getTaskById(targetId),
            visitedTasks = ctx.visitedTasks,
            targets = ctx.targets;
        if (!ctx.targetGroup) {
            ctx.targetGroup = target.getTopParent(true);
        }
        var fromField = ctx.fromField || (ctx.fromField = this.model.prototype.fromField),
            toField = ctx.toField || (ctx.toField = this.model.prototype.toField),
            ignoreDepKey = ctx.ignoreDepKey,
            addDepKey = ctx.addDepKey;
        // get groups top elements based on their intersection
        var groups = this.getGroupTopTasks(source.getTopParent(true), ctx.targetGroup),
            sourceTopParent = groups[0],
            targetTopParent = groups[1];
        if (sourceTopParent === source && targetTopParent === target && source.isLeaf() && target.isLeaf()) {
            return this.hasTransitiveDependency(sourceId, targetId, ignoreDepRecords);
        }
        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!ctx.hasOwnProperty('ignoreDepKey')) {
            ctx.ignoreDepKey = ignoreDepKey = ignoreDepRecords && this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            ctx.addDepKey = addDepKey = addDepRecords && this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }
        // calculate cache key for provided arguments
        var cacheKey = sourceTopParent.getId() + '-' + targetTopParent.getId() + '-' + ignoreDepKey + '-' + addDepKey;
        if (this.isCachedResultAvailable('groupsHasTransitiveDependency', cacheKey)) {
            return this.methodsCache.groupsHasTransitiveDependency[cacheKey];
        }
        // if top target element has changed for this source group
        // then we need to regather "targets" hash
        if (targetTopParent !== ctx.targetTopParent) {
            ctx.targetTopParent = targetTopParent;
            targets = ctx.targets = {};
            // collect children Ids into targets hash
            targetTopParent.cascadeBy(function(task) {
                targets[task.getId()] = true;
            });
        }
        var extraSuccessors = ctx.extraSuccessors;
        // if list of dependencies to be created is provided let's
        // organize it as a hash containing successors list by task ids
        if (addDepRecords && !extraSuccessors) {
            extraSuccessors = ctx.extraSuccessors = {};
            for (var i = 0,
                l = addDepRecords.length; i < l; i++) {
                var dep = addDepRecords[i];
                var from = dep.getSourceId && dep.getSourceId() || dep[fromField];
                extraSuccessors[from] = extraSuccessors[from] || [];
                extraSuccessors[from].push(dep);
            }
        }
        // for each source group task we check if any of its succeeding task is in "targets" hash
        sourceTopParent.cascadeBy(function(task) {
            if (task !== root) {
                var taskId = task.getId();
                // data cycles protection
                if (visitedTasks[taskId])  {
                    return false;
                }
                
                visitedTasks[taskId] = true;
                var successors = task.successors;
                // add successors to be added to existing successors
                if (extraSuccessors && extraSuccessors[taskId])  {
                    successors = successors.concat(extraSuccessors[taskId]);
                }
                
                for (var i = 0,
                    l = successors.length; i < l; i++) {
                    var dependency = successors[i],
                        toId = dependency.getTargetId && dependency.getTargetId() || dependency[toField];
                    // if succeeding task is not in ignore list
                    // and it's in "targets" then we found transitivity
                    // otherwise we go deeper
                    if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) && (targets[toId] || me.groupsHasTransitiveDependency(toId, targetId, ignoreDepRecords, addDepRecords, ctx))) {
                        result = true;
                        return false;
                    }
                }
            }
        });
        // update cache
        return this.setCachedResult('groupsHasTransitiveDependency', cacheKey, result);
    },
    /**
     * Validates a provided dependency and returns a corresponding error code or zero if no error was detected.
     * This method can validate either an existing {@link Gnt.model.Dependency} instance or a proposed (about to be created) link
     * that can be specified as source and target task identifiers plus the dependency type.
     *
     * If you subclass this class, you can provide your own version of this method.
     * Please note that this method is supposed to return a negative integer error code so
     * ensure that you choose some unused values for any new kind of validation.
     * Don't forget to call the parent implementation if you also want to check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies (this check is done only when {@link #transitiveDependencyValidation} is set to `True`), e.g. if A -> B, B -> C, then A -> C is not valid, or if A -> B, A -> C, then B -> C is not valid
     * - cyclic dependencies, e.g. if A -> B, B -> C, then C -> A is not valid
     *
     * **Note:** This method behavior depends on {@link #transitiveDependencyValidation} and {@link #strictDependencyValidation} option.
     * The first config enables so called _transitivity_ validation. And when {@link #strictDependencyValidation} is turned on,
     * the system tries to detect cycles (and transitivity if {@link #transitiveDependencyValidation} enabled) cases between groups of tasks.
     *
     * The method can be used either by providing a dependency as the first argument (then `toId` and `type` should be omitted):
     *
     *      // checking dependency record
     *      switch (dependencyStore.getDependencyError(dependency)) {
     *          case -3: case -8: case -5:
     *              alert('This dependency builds duplicating transitivity');
     *              break;
     *          case -4: case -7:
     *              alert('This is a cyclic dependency');
     *              break;
     *          ...
     *      }
     *
     * or by providing identifiers of the source and target tasks as well as the type of the dependency (if `type` is not provided it defaults to End-To-Start):
     *
     *      // check if 11 --> 15 dependency is between parent & child
     *      if (dependencyStore.getDependencyError(11, 15) == -9) {
     *          alert('This is a dependency between parent and its child');
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done assuming that the specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done assuming that the specified records DO NOT exist in the dependency store.
     * @return {Number} Returns zero if dependency is valid.
     * Full list of possible values is:
     *
     *  - `0`  dependency is valid
     *  - `-1`  other error (wrong input data provided: empty source/target Id(s) or source Id equals target Id)
     *  - `-2`  source (or target) task is not found
     *  - `-3`  transitive dependency (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-4`  cyclic dependency
     *  - `-5`  transitive dependency (dependency being validated is part of larger transitive route) (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-7`  cyclic dependency between groups
     *  - `-8`  transitive dependency between groups (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-9`  dependency between parent and child
     *  - `-10` wrong dependency type
     *  - `-11` dependencies to/from parent tasks not allowed
     *  - `-12` dependencies to projects not allowed
     *  - `-13` dependencies to other project tasks not allowed
     */
    getDependencyError: function(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        // `calledFromThisModel` is used when called from `isValid` method of depedency model
        var fromId, fromTask, toTask;
        var modelInput = dependencyOrFromId instanceof Gnt.model.Dependency;
        // Normalize input
        if (modelInput) {
            fromId = dependencyOrFromId.getSourceId();
            fromTask = this.getTaskById(fromId);
            // if dependency provided then `toId` and `type` arguments can be skipped
            dependenciesToAdd = toId;
            dependenciesToRemove = type;
            // if dependency being validated presented in dependenciesToAdd list
            if (dependenciesToAdd && Ext.Array.contains(dependenciesToAdd, dependencyOrFromId)) {
                // make list copy
                dependenciesToAdd = dependenciesToAdd.slice();
                // and remove dependency from it
                Ext.Array.remove(dependenciesToAdd, dependencyOrFromId);
            }
            type = dependencyOrFromId.getType();
            toId = dependencyOrFromId.getTargetId();
            toTask = this.getTaskById(toId);
            // if we've been called with dependencies model as 1st arg (modelInput) and that dependency
            // is already in the dep store, this case is identical to called "isValid" method on the dependency record
            if (dependencyOrFromId.store)  {
                calledFromThisDepModel = dependencyOrFromId;
            }
            
        } else {
            fromId = dependencyOrFromId;
            fromTask = this.getTaskById(fromId);
            toTask = this.getTaskById(toId);
            if (type === undefined) {
                // get default dependency type from the dependency class
                var defaultType = this.model.getField(this.model.prototype.typeField).defaultValue;
                type = defaultType !== undefined ? defaultType : this.model.Type.EndToStart;
            }
        }
        if (!calledFromThisDepModel && modelInput && !dependencyOrFromId.isValid()) {
            return -1;
        } else if (!fromId || !toId || fromId == toId) {
            return -1;
        }
        // Both tasks need to exist for the link to make sense
        if (!fromTask || !toTask)  {
            return -2;
        }
        
        // check dependency type
        if (!this.isValidDependencyType(type))  {
            return -10;
        }
        
        // Also, not allowed to setup a link between a parent and its child
        if (fromTask.contains(toTask) || toTask.contains(fromTask))  {
            return -9;
        }
        
        var depsToIgnore;
        if (dependenciesToRemove || calledFromThisDepModel) {
            depsToIgnore = [];
            // ignore dependency itself during transitivities/cycles search
            if (calledFromThisDepModel)  {
                depsToIgnore.push(calledFromThisDepModel);
            }
            
            if (dependenciesToRemove)  {
                depsToIgnore = depsToIgnore.concat(dependenciesToRemove);
            }
            
        }
        // checking the presence of transitivity in forward direction (fromId -> toId) - prevents actual transitivity
        if (this.transitiveDependencyValidation) {
            if (this.hasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -3;
            }
            
        } else {
            // check if tasks are already linked directly
            if (this.areTasksLinkedForward(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -3;
            }
            
        }
        // checking the presence of transitivity in backward direction (toId -> fromId) - prevents cycles
        if (this.hasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd))  {
            return -4;
        }
        
        // checking the presence of transitivity between fromId-task and some of toId-task successors
        // or between some of fromId-task predecessors and toId-task
        // it detects cases when we have 1->2, 1->3 dependencies and validating 2->3 dependency
        // and when we have 2->3, 1->3 dependencies and validating 1->2 dependency
        if (this.transitiveDependencyValidation && this.isPartOfTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
            return -5;
        }
        
        // if strict dependencies validation mode enabled
        if (this.strictDependencyValidation) {
            // let's check if there is an opposite relation between the tasks parent-child stacks (to prevent cycle)
            if (this.groupsHasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd))  {
                return -7;
            }
            
            // also check if there is some other relation of the same direction (to prevent transitivity)
            if (this.transitiveDependencyValidation && this.groupsHasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -8;
            }
            
        }
        if (!this.allowParentTaskDependencies && (!fromTask.isLeaf() || !toTask.isLeaf()))  {
            return -11;
        }
        
        // project record itself cannot be linked w/ a dependency
        if (toTask.isProject || fromTask.isProject) {
            return -12;
        }
        // children of a project are connectible depending on "AllowDependencies" flag
        var toProject = toTask.getProject(),
            fromProject = fromTask.getProject();
        if (toProject != fromProject) {
            if (toProject && !toProject.getAllowDependencies() || fromProject && !fromProject.getAllowDependencies()) {
                return -13;
            }
        }
        return 0;
    },
    isValidDependencyType: function(type) {
        if (this.allowedDependencyTypes) {
            var result = false,
                model = this.model;
            Ext.each(this.allowedDependencyTypes, function(name) {
                if (model.Type[name] == type) {
                    result = true;
                    return false;
                }
            });
            return result;
        }
        return true;
    },
    /**
     * Returns `true` if a dependency (or about to be created dependency) between two tasks is valid.
     *
     * **Please note,** If you subclass this class, that this method is just a wrapper over {@link #getDependencyError}
     * method so if you want to implement a custom validation please override {@link #getDependencyError}.
     * And don't forget to call the parent implementation if you also want the check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid, or if A -> B, A -> C, then B -> C is not valid
     * - cyclic dependencies, e.g. if A -> B, B -> C, then C -> A is not valid
     *
     * **Note:** This method behavior depends on {@link #strictDependencyValidation} option.
     * When {@link #strictDependencyValidation} is turned on the system tries to detect cycles and transitivity cases between _groups of tasks_.
     *
     * Method can be used either by providing dependency in first argument (and then `toId` and `type` **should** be omitted):
     *
     *      // validating dependency record
     *      if (!dependencyStore.isValidDependency(dependency)) ...
     *
     * or by providing identifiers of source and target tasks and type of dependency (here `type` can be omitted as well if no further arguments are required):
     *
     *      // if 11 --> 15 dependency is valid
     *      if (dependencyStore.isValidDependency(11, 15)) {
     *          // let`s create it
     *          dependencyStore.add({ From: 11, To: 15 })
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done supposing that specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done supposing that specified records DO NOT exist in the dependency store.
     * @return {Boolean}
     */
    isValidDependency: function(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        return !this.getDependencyError(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel);
    },
    /**
     * Returns true if there is a direct forward dependency between the two tasks.
     * Please see also {@link #areTasksLinked} method to check both forward and backward directions.
     *
     * @param {Mixed/Gnt.model.Task} fromTask The id of source task
     * @param {Mixed/Gnt.model.Task} toTask The id of target task
     *
     * @return {Boolean}
     */
    areTasksLinkedForward: function(fromTaskOrId, toTaskOrId, dependenciesToRemove, dependenciesToAdd) {
        var from = fromTaskOrId instanceof Gnt.model.Task ? fromTaskOrId : this.getTaskById(fromTaskOrId);
        var to = toTaskOrId instanceof Gnt.model.Task ? toTaskOrId : this.getTaskById(toTaskOrId);
        if (!from || !to)  {
            return false;
        }
        
        var model = this.model.prototype,
            fromField = model.fromField,
            toField = model.toField;
        var cacheKey = from.getId() + '-' + to.getId() + '-' + (this.getKeyByDeps(dependenciesToRemove, fromField, toField) || '') + '-' + (this.getKeyByDeps(dependenciesToAdd, fromField, toField) || '');
        if (this.isCachedResultAvailable('areTasksLinkedForward', cacheKey)) {
            return this.methodsCache.areTasksLinkedForward[cacheKey];
        }
        var successors = from.successors,
            predecessors = to.predecessors,
            dep, i, l;
        // loop over source task successors and check if some of them is presented in target tasks predecessors
        for (i = 0 , l = successors.length; i < l; i++) {
            dep = successors[i];
            // ignore dependencies provided in dependenciesToRemove array
            if ((!dependenciesToRemove || !Ext.Array.contains(dependenciesToRemove, dep)) && Ext.Array.contains(predecessors, dep))  {
                return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
            }
            
        }
        // if provided list of dependencies that we must consider as existing in the store
        if (dependenciesToAdd) {
            var sourceId, targetId;
            // let's loop over it and check if link between task is presented there
            for (i = 0 , l = dependenciesToAdd.length; i < l; i++) {
                dep = dependenciesToAdd[i];
                sourceId = dep.getSourceId && dep.getSourceId() || dep[fromField];
                targetId = dep.getTargetId && dep.getTargetId() || dep[toField];
                if (sourceId == from.getId() && targetId == to.getId())  {
                    return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
                }
                
            }
        }
        return this.setCachedResult('areTasksLinkedForward', cacheKey, false);
    },
    /**
     * Returns true if there is a direct dependency between the two tasks. The dependency can be forward (from 1st task to 2nd)
     * or backward (from 2nd to 1st).
     *
     * @param {Mixed/Gnt.model.Task} id1 The id of 1st task
     * @param {Mixed/Gnt.model.Task} id2 The id of 2nd task
     *
     * @return {Boolean}
     */
    areTasksLinked: function(fromTaskOrId, toTaskOrId) {
        var from = fromTaskOrId instanceof Gnt.model.Task ? fromTaskOrId : this.getTaskById(fromTaskOrId);
        var to = toTaskOrId instanceof Gnt.model.Task ? toTaskOrId : this.getTaskById(toTaskOrId);
        if (!from || !to)  {
            return false;
        }
        
        var cacheKey = from.getId() + '-' + to.getId();
        if (this.isCachedResultAvailable('areTasksLinked', cacheKey)) {
            return this.methodsCache.areTasksLinked[cacheKey];
        }
        return this.setCachedResult('areTasksLinked', cacheKey, this.areTasksLinkedForward(from, to) || this.areTasksLinkedForward(to, from));
    },
    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {String} id1 The id of 1st task
     * @param {String} id2 The id of 2nd task
     *
     * @return {Gnt.model.Dependency|undefined}
     * @deprecated 4.2 Use {@link getTasksLinkingDependency} instead
     */
    getByTaskIds: function(id1, id2) {
        return this.getTasksLinkingDependency(id1, id2);
    },
    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Gnt.model.Task|String} sourceTask 1st task
     * @param {Gnt.model.Task|String} targetTask 2nd task
     * @return {Gnt.model.Dependency|Null}
     */
    getDependencyForSourceAndTargetTasks: function(sourceTask, targetTask) {
        return this.getDependencyForSourceAndTargetEvents(sourceTask, targetTask);
    },
    /**
     * Returns a dependency model instance linking given tasks if such dependency exists in the store.
     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Gnt.model.Task|Null} sourceEvent
     * @param {Gnt.model.Task|Null} targetEvent
     * @return {Scm.model.Dependency|Null}
     */
    getTasksLinkingDependency: function(task1, task2) {
        return this.getEventsLinkingDependency(task1, task2);
    },
    getTaskById: function(id) {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getModelById(id) || null;
    },
    /**
     * Returns the source task of the dependency
     *
     * @param {Gnt.model.Dependency} dependency The dependency
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask: function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getSourceId() : dependencyOrId;
        return this.getTaskById(id);
    },
    /**
     * Returns the target task of the dependency
     * @param {Gnt.model.Dependency} dependency The dependency
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask: function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getTargetId() : dependencyOrId;
        return this.getTaskById(id);
    },
    /**
     * Returns the {@link Gnt.data.TaskStore} instance, to which this dependency store is attached.
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.getEventStore();
    },
    /**
     * Sets the associated task store instance.
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        var me = this;
        me.taskStore = store;
        me.setEventStore(store);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/* global Ext */
/**
 * @singleton
 */
Ext.define('Gnt.data.linearizator.CycleResolvers', function(thisClass) {
    /**
     * Doesn't resolve dependency cycle.
     *
     * @method none
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleNone() {
        return false;
    }
    /**
     * Doesn't resolve dependency cycle and throws exception.
     *
     * @method exception
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleByException() {
        Ext.Error.raise("Can't linearize dependent tasks, there's a cycle in the dependency chain!");
    }
    /**
     * Resolve a dependency cycle by cutting (forcefully marking one or more dependencies as resolved ('green')).
     *
     * @method cut
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleByCuttingLinks$(sourceSet, depsData) {
        // The code assuming that nodes in source set form strict upward vertical hierarchy i.e. there can't be child
        // nodes missing parents but the opposite (downward) might be possible, i.e. it is possible for parent node to
        // miss children in the source set, as well as horizontal hierarchy might be lax, i.e. there might be nodes
        // whose siblings are not present in the source set.
        var sourceTree = buildSourceTreeFromSourceSet(sourceSet, depsData),
            cuts = {},
            cutsCollector = function(from, to) {
                (cuts[from] || (cuts[from] = [])).push(to);
            };
        // Folding order is the following:
        //   A
        // +-+-+
        // B C D
        //
        // B - skipped
        // C - folded with B
        // D - folded with C and then folded with A
        traverseSourceTreePostOrder(sourceTree, function foldNode$(node) {
            // First we fold a node with it's previous sibling if one exists
            if (node.prevSibling) {
                // Folding previous sibling with the node, as the result node will represent both
                // folded previous sibling and itself
                node.foldedDeps = foldDepsForNodesHorizontaly(node.prevSibling.foldedDeps, node.foldedDeps, cutsCollector);
            }
            // Next if a node is the last sibling in a parent node then we fold it with parent node
            if (!node.nextSibling && node.parentNode) {
                // Folding node with it's parent, as the result parent node will represent both
                // folded child and itself
                node.parentNode.foldedDeps = foldDepsForNodesVerticaly(node.foldedDeps, node.parentNode.foldedDeps, cutsCollector);
            }
        });
        cutCycles$(depsData.fromById, cuts);
        return true;
    }
    // --- Private functions --------------------------------------------------------------------------------------- //
    // Source set represents a set of colored nodes, which might or might not have vertical links among themselves
    // regardless of that fact we have to build a traversable tree from that linear data structure, so if a task
    // from colored node has some siblings which are not in the sources set then those siblings shouldn't be present
    // in resulting tree, same goes for children and parent nodes. Due to this node skipping we might end with several
    // nodes having no parent nodes, such nodes will be then joined together under common pseudo root node.
    function buildSourceTreeFromSourceSet(sourceSet, depsData) {
        var root,
            roots = [],
            nodes = {},
            internalId, node;
        // In this loop we transform each colored node from a source set into a tree node (an object we use
        // to represent a tree node), and collecting each transformed node for furher realization as well as each
        // root node, i.e. nodes whose parents are not in the source set, for further processing.
        for (internalId in sourceSet) {
            if (sourceSet.hasOwnProperty(internalId)) {
                node = nodes[internalId] = createRawSourceTreeNode(sourceSet[internalId].task, sourceSet, depsData);
                if (!sourceSet.hasOwnProperty(node.parentNode)) {
                    roots.push(node);
                }
            }
        }
        // In this loop we relize collected tree nodes to point to other tree nodes instead of ids.
        for (internalId in nodes) {
            if (nodes.hasOwnProperty(internalId)) {
                nodes[internalId] = realizeRawSourceTreeNode$(nodes[internalId], nodes);
            }
        }
        if (roots.length == 1) {
            root = roots[0];
        } else {
            // The data structure is the same as createRawSourceTreeNode() returns
            root = {
                parentNode: null,
                prevSibling: null,
                nextSibling: null,
                children: roots,
                foldedDeps: {}
            };
        }
        return root;
    }
    function createRawSourceTreeNode(storeNode, sourceSet, depsData) {
        var EO = Ext.Object,
            fromDeps = depsData.fromById,
            foldedDeps = {},
            internalId = storeNode.internalId,
            toIds, parentNode, nextSibling, prevSibling, children, childInternalId, childrenInternalIds, i, len;
        // We count outgoing horizontal (i.e. successors)  dependencies only, this is ok, since if we would count
        // both successors and predecessors then each successor - predecessor pair will create a direct loop
        // NOTE: It is important for following code that folded dependencies map contained node's internal id
        //       even if node has no outgoing dependencies
        toIds = EO.getKeys(fromDeps[internalId]);
        if (toIds.length) {
            foldedDeps[internalId] = toIds;
        } else {
            foldedDeps[internalId] = {};
        }
        // Vertical upward hierarchy might be either present or not, if it's present then it's present up to root
        parentNode = storeNode.parentNode && sourceSet.hasOwnProperty(storeNode.parentNode.internalId) && storeNode.parentNode.internalId;
        // Vertical downward hierarchy might be lax
        children = storeNode.childNodes || [];
        childrenInternalIds = [];
        for (i = 0 , len = children.length; i < len; i++) {
            childInternalId = children[i].internalId;
            if (sourceSet.hasOwnProperty(childInternalId)) {
                childrenInternalIds.push(childInternalId);
            }
        }
        // Horizontal hierarchy might be lax.
        prevSibling = storeNode.previousSibling;
        while (prevSibling && !sourceSet.hasOwnProperty(prevSibling.internalId)) {
            prevSibling = prevSibling.previousSibling;
        }
        prevSibling = prevSibling && prevSibling.internalId;
        nextSibling = storeNode.nextSibling;
        while (nextSibling && !sourceSet.hasOwnProperty(nextSibling.internalId)) {
            nextSibling = nextSibling.nextSibling;
        }
        nextSibling = nextSibling && nextSibling.internalId;
        // That'll be our source node
        // now it references related nodes by ids.
        // Each original node which is referenced by a task but not present in source set has been skipped
        // The resulting data structure will be further realized to reference other tree nodes instances instead of ids.
        return {
            parentNode: parentNode,
            prevSibling: prevSibling,
            nextSibling: nextSibling,
            children: childrenInternalIds,
            foldedDeps: foldedDeps
        };
    }
    function realizeRawSourceTreeNode$(node, nodes) {
        var i, len,
            children = node.children;
        for (i = 0 , len = children.length; i < len; i++) {
            children[i] = nodes[children[i]];
        }
        node.parentNode = (node.parentNode || node.parentNode === 0) && nodes[node.parentNode] || null;
        node.prevSibling = (node.prevSibling || node.prevSibling === 0) && nodes[node.prevSibling] || null;
        node.nextSibling = (node.nextSibling || node.nextSibling === 0) && nodes[node.nextSibling] || null;
        return node;
    }
    function traverseSourceTreePostOrder(branchRoot, stepFn) {
        var children = branchRoot.children,
            i, len;
        for (i = 0 , len = children.length; i < len; i++) {
            traverseSourceTreePostOrder(children[i], stepFn);
        }
        stepFn(branchRoot);
        return branchRoot;
    }
    function foldDepsForNodesHorizontaly(aDeps, bDeps, cutsCollector) {
        var crossDeps = getHorizontalCrossDeps(aDeps, bDeps),
            fromAtoB = crossDeps.fromAtoB,
            fromBtoA = crossDeps.fromBtoA,
            fromAtoBtotal = crossDeps.fromAtoBtotal,
            fromBtoAtotal = crossDeps.fromBtoAtotal,
            cuts = {};
        // A cycle is when A references some ids from B and B references some ids from A simultaneously
        if (fromAtoBtotal > 0 && fromBtoAtotal > 0) {
            cuts = fromAtoBtotal < fromBtoAtotal ? fromAtoB : fromBtoA;
        }
        // Now in cuts we have a minimal map of links to cut, collecting them
        collectCuts(cuts, cutsCollector);
        // Joining two nodes dependencies removing ones which are in cuts
        return joinDeps(aDeps, bDeps, cuts);
    }
    function foldDepsForNodesVerticaly(aDeps, bDeps, cutsCollector) {
        var EO = Ext.Object,
            crossDeps = getHorizontalCrossDeps(aDeps, bDeps),
            fromAtoB = crossDeps.fromAtoB,
            fromBtoA = crossDeps.fromBtoA,
            cuts;
        // During vertical fold all horizontal links from A to B and vise versa should be removed
        cuts = EO.merge({}, fromAtoB, fromBtoA);
        // Collecting cuts
        collectCuts(cuts, cutsCollector);
        // Joining two nodes dependencies removing ones which are in cuts
        return joinDeps(aDeps, bDeps, cuts);
    }
    function getHorizontalCrossDeps(aDeps, bDeps) {
        var EO = Ext.Object,
            EA = Ext.Array,
            aIds = EO.getKeys(aDeps),
            bIds = EO.getKeys(bDeps),
            fromAtoB = {},
            fromBtoA = {},
            fromAtoBtotal = 0,
            fromBtoAtotal = 0,
            i, len, id, toX;
        // Searching for outgoing links from A to B
        for (i = 0 , len = aIds.length; i < len; ++i) {
            id = aIds[i];
            toX = EA.intersect(bIds, aDeps[id]);
            if (toX.length) {
                fromAtoB[id] = toX;
                fromAtoBtotal += toX.length;
            }
        }
        // Searching for outgoing links from B to A
        for (i = 0 , len = bIds.length; i < len; ++i) {
            id = bIds[i];
            toX = EA.intersect(aIds, bDeps[id]);
            if (toX.length) {
                fromBtoA[id] = toX;
                fromBtoAtotal += toX.length;
            }
        }
        return {
            fromAtoB: fromAtoB,
            fromBtoA: fromBtoA,
            fromAtoBtotal: fromAtoBtotal,
            fromBtoAtotal: fromBtoAtotal
        };
    }
    function collectCuts(cuts, cutsCollector) {
        var id, i, len, toX;
        for (id in cuts) {
            if (cuts.hasOwnProperty(id)) {
                toX = cuts[id];
                for (i = 0 , len = toX.length; i < len; ++i) {
                    cutsCollector(id, toX[i]);
                }
            }
        }
    }
    function joinDeps(aDeps, bDeps, cuts) {
        var EO = Ext.Object,
            EA = Ext.Array,
            result, id;
        // Joining two nodes dependencies removing ones which are in cuts
        result = EO.merge({}, aDeps, bDeps);
        for (id in cuts) {
            if (cuts.hasOwnProperty(id) && result.hasOwnProperty(id)) {
                result[id] = EA.difference(result[id], cuts[id]);
            }
        }
        return result;
    }
    function cutCycles$(fromDeps, cuts) {
        var fromId, tos, toId, i, len;
        for (fromId in cuts) {
            if (cuts.hasOwnProperty(fromId)) {
                tos = cuts[fromId];
                for (i = 0 , len = tos.length; i < len; ++i) {
                    toId = tos[i];
                    fromDeps[fromId][toId][0] = 'green';
                }
            }
        }
        return fromDeps;
    }
    // --- Public interface ---------------------------------------------------------------------------------------- //
    return {
        singleton: true,
        'none': resolveCycleNone,
        'exception': resolveCycleByException,
        'cut': resolveCycleByCuttingLinks$
    };
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.data.Linearizator', function(thisClass) {
    var walkingSpecificationsCache = {};
    // {{{ linearWalkBySpecification
    /**
     * Linearly walks source task list and it's members dependent tasks in dependency resolution order.
     *
     * @param {Gnt.model.Task|[Gnt.model.Task]} sourceTasksList
     *  Walking source points
     * @param {Function}       processorFn
     *  Function to call at each walking step
     * @param {Gnt.model.Task} processorFn.task
     *  A task which dependencies are considered to be resolved at the step
     * @param {String}         processorFn.color
     *  Task dependencies resolution state, might be either **'green'** or **'yellow'**. Leaf tasks might be visited
     *  with **'green'** color only, but parent tasks will be visited twice, first with **'yellow'** color and then,
     *  after visiting all node's **'green'** children, the node will be visited again but with **'green'** color.
     *  Parent node **'yellow'** dependencies resolution state means that all it's horizontal dependencies, i.e.
     *  dependencies from node's predecessors, has been visited (and probably processed somehow during the visit),
     *  **'green'** (for any node) means that all node's dependencies, both horizontal and vertical has been visitied
     *  (and processed).
     * @param {Object}         processorFn.sourceSet
     *  Set of all tasks involved into the walking alongside with their dependency resolution state color.
     * @param {Gnt.model.Task} processor.sourceSet.task
     *  Step task
     * @param {String}         processorFn.sourceSet.color
     *  Step color
     * @param {Object}         processorFn.depsMap
     *  **Private**. Dependecies map, this parameter is currently considered to be private.
     * @param {Object}         walkingSpec
     *  Walking specification, contains information describing how to walk and process task dependencies
     * @param {Boolean}        walkingSpec.self
     *  Whether to include tasks from source tasks list into a walking sequence
     * @param {Boolean}        walkingSpec.ancestors
     *  Whether to include tasks' ancestors into a walking sequence
     * @param {Boolean}        walkingSpec.descendants
     *  Whether to include tasks' descendants into a walking sequence
     * @param {Boolean}        walkingSpec.successors
     *  Whether to include tasks's successors into a walking sequece
     * @param {String}         walkingSpec.cycles
     *  Cycles resolution strategy. See {@link Gnt.data.linearizator.CycleResolvers} public method for possible values.
     *
     * @member Gnt.data.Linearizator
     * @method linearWalkBySpecification
     */
    function linearWalkBySpecification(sourceTasksList, processorFn, walkingSpec) {
        Ext.isObject(sourceTasksList) || Ext.isArray(sourceTasksList) || Ext.Error.raise("Invalid arguments, source task list must be either a task or array of tasks!");
        Ext.isFunction(processorFn) || Ext.Error.raise("Invalid arguments, processor function must be a function!");
        Ext.isObject(walkingSpec) || Ext.Error.raise("Invalid arguments, walking specification must be an object!");
        walkingSpec = resolveWalkingSpecification(walkingSpec);
        return linearWalk([].concat(sourceTasksList), processorFn, walkingSpec.tasksDepsCollectingFn, walkingSpec.cycleSolverFn);
    }
    // }}}
    // {{{ linearWalk
    function linearWalk(sourceTasksList, processorFn, tasksDepsCollectingFn, cycleSolverFn) {
        var done = false,
            hadCycle = true,
            tasksColorMap$, depsColorMap$, taskId, task, color;
        tasksColorMap$ = createEmptyTasksColorMap();
        depsColorMap$ = createEmptyDepsColorMap();
        collectTasksAndDepsIntoColorMaps$(sourceTasksList, tasksDepsCollectingFn, tasksColorMap$, depsColorMap$);
        while (hadCycle) {
            done = false;
            while (!done) {
                done = true;
                hadCycle = false;
                for (taskId in tasksColorMap$) {
                    if (tasksColorMap$.hasOwnProperty(taskId) && tasksColorMap$[taskId].color != 'green') {
                        task = tasksColorMap$[taskId].task;
                        color = calculateTaskColor(task, depsColorMap$);
                        if (color != 'red') {
                            setCalculatedTaskColor$(color, task, tasksColorMap$, depsColorMap$);
                            processorFn(task, color, tasksColorMap$, depsColorMap$);
                            done = false;
                        } else {
                            hadCycle = true;
                        }
                    }
                }
            }
            if (hadCycle) {
                hadCycle = cycleSolverFn && cycleSolverFn(tasksColorMap$, depsColorMap$);
            }
        }
    }
    // }}}
    // {{{ resolveWalkingSpecification
    function resolveWalkingSpecification(spec) {
        var walkingSpecificationKey = getWalkingSpecificationKey(spec),
            cycleSolverFn, tasksDepsCollectingFn, result;
        result = walkingSpecificationsCache[walkingSpecificationKey];
        if (!result) {
            cycleSolverFn = Gnt.data.linearizator.CycleResolvers[spec.cycles || 'none'];
            cycleSolverFn || Ext.Error.raise("Can't resolve cycle resolution function, " + spec.cycles + " is unknown!");
            tasksDepsCollectingFn = [];
            spec.self && (tasksDepsCollectingFn.push(selfTasksDepsCollector$));
            spec.ancestors && (tasksDepsCollectingFn.push(ancestorsTasksDepsCollector$));
            spec.descendants && (tasksDepsCollectingFn.push(descendantsTasksDepsCollector$));
            spec.successors && (tasksDepsCollectingFn.push(successorsTasksDepsCollector$));
            tasksDepsCollectingFn = composeTasksDepsCollectors(tasksDepsCollectingFn);
            result = {
                tasksDepsCollectingFn: tasksDepsCollectingFn,
                cycleSolverFn: cycleSolverFn
            };
            walkingSpecificationsCache[walkingSpecificationKey] = result;
        }
        return result;
    }
    // }}}
    // {{{ getWalkingSpecificationKey
    function getWalkingSpecificationKey(spec) {
        var result = [],
            prop;
        for (prop in spec) {
            if (spec.hasOwnProperty(prop)) {
                result.push(prop, '=', String(spec[prop]));
            }
        }
        return result.join(';');
    }
    // }}}
    // {{{ composeTasksDepsCollectors
    function composeTasksDepsCollectors(collectors) {
        return function(task, tasksColorMap$, depsColorMap$) {
            var collectedTasks = [];
            Ext.Array.each(collectors, function(collectorFn) {
                collectedTasks = collectedTasks.concat(collectorFn(task, tasksColorMap$, depsColorMap$));
            });
            return collectedTasks;
        };
    }
    // }}}
    // {{{ collectTasksAndDepsIntoColorMaps$
    function collectTasksAndDepsIntoColorMaps$(tasksList, stepTasksDepsCollectorFn$, tasksMap$, depsMap$) {
        Ext.Array.each(tasksList, function(task) {
            var collectedTasks = stepTasksDepsCollectorFn$(task, tasksMap$, depsMap$);
            if (collectedTasks.length > 0) {
                collectTasksAndDepsIntoColorMaps$(collectedTasks, stepTasksDepsCollectorFn$, tasksMap$, depsMap$);
            }
        });
    }
    // }}}
    // {{{ selfTasksDepsCollector$
    function selfTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            taskId = task.internalId;
        if (!tasksColorMap$.hasOwnProperty(taskId)) {
            // Collecting task
            tasksColorMap$[taskId] = {
                task: task,
                color: 'red'
            };
            collectedTasks = [
                task
            ];
        }
        return collectedTasks;
    }
    // }}}
    // {{{ ancestorsTasksDepsCollector$
    function ancestorsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            downFromByIdMap = depsColorMap$.downFromById,
            downToByIdMap = depsColorMap$.downToById,
            upFromByIdMap = depsColorMap$.upFromById,
            upToByIdMap = depsColorMap$.upToById,
            taskId = task.internalId,
            parentTask = task.parentNode,
            parentId = parentTask && parentTask.internalId,
            downColor, upColor;
        // Collecting task
        if (parentTask && !tasksColorMap$.hasOwnProperty(parentId)) {
            tasksColorMap$[parentId] = {
                task: parentTask,
                color: 'red'
            };
            collectedTasks.push(parentTask);
        }
        // Collecting dependencies
        // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
        if (parentTask) {
            downColor = [
                'red'
            ];
            upColor = [
                'red'
            ];
            !downFromByIdMap[parentId] && (downFromByIdMap[parentId] = {});
            !downFromByIdMap[parentId][taskId] && (downFromByIdMap[parentId][taskId] = downColor);
            !downToByIdMap[taskId] && (downToByIdMap[taskId] = downColor);
            !upToByIdMap[parentId] && (upToByIdMap[parentId] = {});
            !upToByIdMap[parentId][taskId] && (upToByIdMap[parentId][taskId] = upColor);
            !upFromByIdMap[taskId] && (upFromByIdMap[taskId] = upColor);
        }
        return collectedTasks;
    }
    // }}}
    // {{{ descendantsTasksDepsCollector$
    function descendantsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            downFromByIdMap = depsColorMap$.downFromById,
            downToByIdMap = depsColorMap$.downToById,
            upFromByIdMap = depsColorMap$.upFromById,
            upToByIdMap = depsColorMap$.upToById,
            children = !task.isRoot() && task.childNodes,
            taskId = task.internalId;
        children && Ext.Array.each(children, function(childTask) {
            var childId = childTask.internalId,
                downColor, upColor;
            // Collecting tasks
            if (!tasksColorMap$.hasOwnProperty(childId)) {
                tasksColorMap$[childId] = {
                    task: childTask,
                    color: 'red'
                };
                collectedTasks.push(childTask);
            }
            // Collecting dependencies
            // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
            downColor = [
                'red'
            ];
            upColor = [
                'red'
            ];
            !downFromByIdMap[taskId] && (downFromByIdMap[taskId] = {});
            !downFromByIdMap[taskId][childId] && (downFromByIdMap[taskId][childId] = downColor);
            !downToByIdMap[childId] && (downToByIdMap[childId] = downColor);
            !upToByIdMap[taskId] && (upToByIdMap[taskId] = {});
            !upToByIdMap[taskId][childId] && (upToByIdMap[taskId][childId] = upColor);
            !upFromByIdMap[childId] && (upFromByIdMap[childId] = upColor);
        });
        return collectedTasks;
    }
    // }}}
    // {{{ successorsTasksDepsCollector$
    function successorsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            fromByIdMap = depsColorMap$.fromById,
            toByIdMap = depsColorMap$.toById,
            successors = task.getSuccessors(),
            taskId = task.internalId;
        Ext.Array.each(successors, function(successorTask) {
            var successorId = successorTask.internalId,
                color;
            // Collecting tasks
            if (!tasksColorMap$.hasOwnProperty(successorId)) {
                tasksColorMap$[successorId] = {
                    task: successorTask,
                    color: 'red'
                };
                collectedTasks.push(successorTask);
            }
            // Collecting dependencies
            // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
            color = [
                'red'
            ];
            !fromByIdMap[taskId] && (fromByIdMap[taskId] = {});
            !fromByIdMap[taskId][successorId] && (fromByIdMap[taskId][successorId] = color);
            !toByIdMap[successorId] && (toByIdMap[successorId] = {});
            !toByIdMap[successorId][taskId] && (toByIdMap[successorId][taskId] = color);
        });
        return collectedTasks;
    }
    // }}}
    // {{{ createEmptyTasksColorMap
    function createEmptyTasksColorMap() {
        return {};
    }
    // }}}
    // {{{ createEmptyDepsColorMap
    function createEmptyDepsColorMap() {
        return {
            // Horizontal successor dependencies from a task
            // {
            //     taskId : {
            //         successorTaskId : [dependency color]
            //         ...
            //     }
            //     ...
            //     1 : {
            //         2 : ['red'] // the array instance is shared with toById
            //     }
            // }
            fromById: {},
            // Horizontal predecessor dependencies to a task
            // {
            //     taskId : {
            //         predecessorTaskId : [dependency color]
            //         ...
            //     }
            //     ...
            //     2 : {
            //         1 : ['red'] // the array instance is shared with fromById
            //     }
            // }
            toById: {},
            // Vertical (virtual) downward dependencies from a parent task to a children tasks
            // {
            //     parentTaskId : {
            //         childTaskId : [dependency color] // the array instance is shared with downToById
            //         ...
            //     }
            //     ...
            // }
            downFromById: {},
            // Vertical (virtual) downward dependency to a child task from a parent task
            // {
            //    childTaskId : [dependency color] // the array instance is shared with downFromById
            //    ...
            // }
            // The other participant is uniquely identified by child task parent node
            downToById: {},
            // Vertical (virtual) upward dependencies from a child task to a parent task
            // {
            //    childTaskId : [dependency color] // the array instance is shared with upToById
            //    ...
            // }
            // The other participant is uniquely identified by child task parent node
            upFromById: {},
            // Vertical (virtual) upward dependencies to a parent task from a child task
            // {
            //    parentTaskId : {
            //        childTaskId : [dependency color] // the array instance is shared with upFromById
            //        ...
            //    }
            //    ...
            // }
            upToById: {}
        };
    }
    // }}}
    // {{{ hasRedDepsTo
    function hasRedDepsTo(task, depsMap) {
        var toByIdMap = depsMap.toById[task.internalId],
            result = false,
            i;
        for (i in toByIdMap) {
            if (toByIdMap.hasOwnProperty(i) && toByIdMap[i] && toByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsFrom
    function hasRedDepsFrom(task, depsMap) {
        var fromByIdMap = depsMap.fromById[task.internalId],
            result = false,
            i;
        for (i in fromByIdMap) {
            if (fromByIdMap.hasOwnProperty(i) && fromByIdMap[i] && fromByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsDownTo
    function hasRedDepsDownTo(task, depsMap) {
        var downToByIdMap = depsMap.downToById,
            internalId = task.internalId;
        return downToByIdMap[internalId] && downToByIdMap[internalId][0] == 'red';
    }
    // }}}
    // {{{ hasRedDepsDownFrom
    function hasRedDepsDownFrom(task, depsMap) {
        var downFromByIdMap = depsMap.downFromById[task.internalId],
            result = false,
            i;
        for (i in downFromByIdMap) {
            if (downFromByIdMap.hasOwnProperty(i) && downFromByIdMap[i] && downFromByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsUpTo
    function hasRedDepsUpTo(task, depsMap) {
        var upToByIdMap = depsMap.upToById[task.internalId],
            result = false,
            i;
        for (i in upToByIdMap) {
            if (upToByIdMap.hasOwnProperty(i) && upToByIdMap[i] && upToByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsUpFrom
    function hasRedDepsUpFrom(task, depsMap) {
        var internalId = task.internalId,
            upToByIdMap = depsMap.upToById;
        return upToByIdMap[internalId] && upToByIdMap[internalId][0] == 'red';
    }
    // }}}
    // {{{ calculateTaskColor
    function calculateTaskColor(task, depsMap) {
        var color = 'red';
        if (!hasRedDepsTo(task, depsMap) && !hasRedDepsDownTo(task, depsMap) && !hasRedDepsUpTo(task, depsMap)) {
            color = 'green';
        } else if (!hasRedDepsTo(task, depsMap) && !hasRedDepsDownTo(task, depsMap) && hasRedDepsDownFrom(task, depsMap)) {
            color = 'yellow';
        } else {
            color = 'red';
        }
        return color;
    }
    // }}}
    // {{{ setCalculatedTaskColor$
    function setCalculatedTaskColor$(color, task, tasksColorMap$, depsColorMap$) {
        var taskId = task.internalId,
            fromByIdMap = depsColorMap$.fromById[taskId],
            downFromByIdMap = depsColorMap$.downFromById[taskId],
            upFromByIdMap = depsColorMap$.upFromById[taskId],
            i;
        tasksColorMap$[taskId].color = color;
        if (color == 'green') {
            if (fromByIdMap) {
                for (i in fromByIdMap) {
                    if (fromByIdMap.hasOwnProperty(i)) {
                        fromByIdMap[i][0] = color;
                    }
                }
            }
            if (downFromByIdMap) {
                for (i in downFromByIdMap) {
                    if (downFromByIdMap.hasOwnProperty(i)) {
                        downFromByIdMap[i][0] = color;
                    }
                }
            }
            if (upFromByIdMap) {
                upFromByIdMap[0] = color;
            }
        } else if (color == 'yellow') {
            if (downFromByIdMap) {
                for (i in downFromByIdMap) {
                    if (downFromByIdMap.hasOwnProperty(i)) {
                        downFromByIdMap[i][0] = color;
                    }
                }
            }
        }
    }
    // else red and do nothing
    // }}}
    // {{{ Class descriptor
    return {
        // Class behaviour
        singleton: true,
        requires: [
            'Gnt.data.linearizator.CycleResolvers'
        ],
        // Public interface
        linearWalkBySpecification: linearWalkBySpecification
    };
});
// }}}

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.model.Resource
@extends Sch.model.Customizable

This class represent a single Resource in the scheduler chart. It's a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of the resource.

A Resource has only 2 mandatory fields - `Id` and `Name`. If you want to add more fields with meta data describing your resources then you should subclass this class:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],

        getCompany : function () {
            return this.get('Company');
        },
        ...
    });

If you want to use other names for the Id and Name fields you can configure them as seen below:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        nameField   : 'UserName',
        ...
    });

Please refer to {@link Sch.model.Customizable} for details.
*/
Ext.define('Sch.model.Resource', {
    extend: 'Sch.model.Customizable',
    idProperty: 'Id',
    config: Ext.versions.touch ? {
        idProperty: 'Id'
    } : null,
    /**
     * @cfg {String} nameField The name of the field that holds the resource name. Defaults to "Name".
     */
    nameField: 'Name',
    customizableFields: [
        /**
         * @method getName
         *
         * Returns the resource name
         *
         * @return {String} The name of the resource
         */
        /**
         * @method setName
         *
         * Sets the resource name
         *
         * @param {String} name The new name of the resource
         */
        {
            name: 'Name',
            type: 'string'
        }
    ],
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * Returns a resource store this resource is part of. Resource must be part
     * of a resource store to be able to retrieve resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore: function() {
        return this.joined && this.joined[0];
    },
    /**
     * Returns an event store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore: function() {
        var resourceStore = this.getResourceStore();
        return resourceStore && resourceStore.getEventStore() || this.parentNode && this.parentNode.getEventStore();
    },
    /**
     * Returns as assignment store this resources uses as default. Resource must be part
     * of a resource store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },
    /**
     * Returns an array of events, associated with this resource
     *
     * @param {Sch.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
     * @return {Sch.model.Range[]}
     */
    getEvents: function(eventStore) {
        var me = this;
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getEventsForResource(me) || [];
    },
    /**
     * Returns all assignments for the resource. Resource must be part of the store for this method to work.
     *
     * @return {[Sch.model.Assignment]}
     */
    getAssignments: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.getAssignmentsForResource(me);
    },
    /**
     * Returns true if the Resource can be persisted.
     * In a flat store resource is always considered to be persistable, in a tree store resource is considered to
     * be persitable if it's parent node is persistable.
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var parent = this.parentNode;
        return !parent || !parent.phantom || (parent.isRoot && parent.isRoot());
    },
    /**
     * Returns true if this resource model is above the passed resource model
     * @param {Sch.model.Resource} otherResource
     * @return {Boolean}
     */
    isAbove: function(otherResource) {
        var me = this,
            store = me.getResourceStore(),
            result = false,
            current, myAncestors, otherAncestors, commonAncestorsLength, lastCommonAncestor;
        Ext.Assert && Ext.Assert.truthy(store, "Resource must be added to a store to be able to check if it above of an other resource");
        if (me == otherResource) {
            result = false;
        } else if (store instanceof Ext.data.TreeStore) {
            // Getting self ancestors this node including
            current = me;
            myAncestors = [];
            while (current) {
                myAncestors.push(current);
                current = current.parentNode;
            }
            // Getting other ancestors other node including
            current = otherResource;
            otherAncestors = [];
            while (current) {
                otherAncestors.push(current);
                current = current.parentNode;
            }
            // Getting common ancestors sequence length
            commonAncestorsLength = 0;
            while (commonAncestorsLength < myAncestors.length - 1 && commonAncestorsLength < otherAncestors.length - 1 && myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]) {
                ++commonAncestorsLength;
            }
            // Getting last common ancesstor
            lastCommonAncestor = myAncestors[commonAncestorsLength];
            // Here the next ancestor in myAncestors and next ancesstor in otherAncestors are siblings and
            // thus designate which node is above
            me = myAncestors[commonAncestorsLength + 1];
            otherResource = otherAncestors[commonAncestorsLength + 1];
            result = lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
        } else {
            result = store.indexOf(me) < store.indexOf(otherResource);
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.Resource
@extends Sch.model.Resource

This class represents a single Resource in your gantt chart.
The inheritance hierarchy of this class includes {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
Please refer to the documentation of those classes to become familiar with the base interface of this class.

A Resource has the following fields:

- `Id` - holds the resource identifier
- `Name` - holds the resource name
- `CalendarId` - holds the resource calendar identifier

If you want to add some fields, describing resources - subclass this class:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Gnt.model.Resource',

        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],

        getCompany : function () {
            return this.get('Company')
        },
        ...
    })

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

See also: {@link Gnt.model.Assignment}, {@link Gnt.column.ResourceAssignment}

*/
Ext.define('Gnt.model.Resource', {
    extend: 'Sch.model.Resource',
    customizableFields: [
        'CalendarId'
    ],
    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific resource.
     */
    calendarIdField: 'CalendarId',
    normalized: false,
    calendarWaitingListener: null,
    /**
     * Returns a task store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Gnt.data.TaskStore|null}
     */
    getTaskStore: function() {
        if (this.store) {
            return this.store.getTaskStore();
        }
        return null;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Returns an array of tasks associated with this resource
     *
     * @return {Sch.model.Task[]} Associated tasks
     */
    getTasks: function() {
        return this.getEvents();
    },
    /**
     * Returns the calendar, based on which is performed the schedule calculations for associated tasks.
     * It will be either the own calendar of this resource (if any) or the calendar of the whole project.
     *
     * @param {Boolean} ownCalendarOnly Pass `true` to return only own calendar.
     *
     * @return {Gnt.data.Calendar} The instance of calendar
     */
    getCalendar: function(ownCalendarOnly) {
        var me = this;
        return ownCalendarOnly ? me.getOwnCalendar() : me.getOwnCalendar() || me.getProjectCalendar();
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this resource (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar: function() {
        var calendarId = this.getCalendarId();
        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : null;
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this resource (with the TaskStore instance
     * this resource belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar: function() {
        return this.getTaskStore().getCalendar();
    },
    /**
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this resource. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     */
    setCalendar: function(calendar) {
        var isCalendarInstance = calendar instanceof Gnt.data.Calendar;
        if (isCalendarInstance && !calendar.calendarId)  {
            throw new Error("Can't set calendar w/o `calendarId` property");
        }
        
        this.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar);
    },
    setCalendarId: function(calendarId, isInitial) {
        if (calendarId instanceof Gnt.data.Calendar)  {
            calendarId = calendarId.calendarId;
        }
        
        var prevCalendarId = this.getCalendarId();
        if (prevCalendarId != calendarId || isInitial) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }
            var listeners = {
                    calendarchange: this.onCalendarChange,
                    scope: this
                };
            var prevInstance = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);
            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar = null;
            prevInstance && prevInstance.un(listeners);
            this.set(this.calendarIdField, calendarId);
            var calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
            if (calendarInstance) {
                calendarInstance.on(listeners);
                if (!isInitial)  {
                    this.onCalendarChange();
                }
                
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on('add', function(index, item, key) {
                    calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
                    if (calendarInstance) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        calendarInstance.on(listeners);
                        this.onCalendarChange();
                    }
                }, this, {
                    destroyable: true
                });
            }
        }
    },
    onCalendarChange: function() {
        // raise flag that the resource is processing its calendar change
        this.inOnCalendarChange = true;
        this.adjustToCalendar();
        this.inOnCalendarChange = false;
    },
    adjustToCalendar: function() {
        this.getTaskStore() && this.forEachTask(function(task) {
            task.adjustToCalendar();
        });
    },
    // TODO: move it to Scheduler codebase
    /**
     * Assigns this resource to a given task. A new {@link Gnt.model.Assignment assignment} will be created
     * and added to the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     * @param {Number} units The value for the "Units" field
     * @param {Function} [callback] Callback function to call after resource has been assigned and possible changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    assignTo: function(taskOrId, units, callback) {
        var task = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getModelById(taskOrId);
        return task.assign(this, units, callback);
    },
    // TODO: move it to Scheduler code base
    /**
     * Un assigns this resource from the given task. The corresponding {@link Gnt.model.Assignment assignment} record
     * will be removed from the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     * @param {Function} [callback] Callback function to call after resource has been unassigned and possible changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unAssignFrom: function(taskOrId, callback) {
        var task = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getModelById(taskOrId);
        return task.unAssign(this, callback);
    },
    // TODO: move it to Scheduler codebase
    /**
     * Alias to {@link #unAsignFrom}.
     */
    unassignFrom: function() {
        return this.unAssignFrom.apply(this, arguments);
    },
    // TODO: maybe refactor this method using assignment store map* functions
    // TODO: move it to Scheduler's code base
    /**
     * Iterator for each assignment, associated with this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Assignment assignment} instance
     * as the only argument
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachAssignment: function(func, scope) {
        var me = this,
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore && taskStore.getAssignmentStore(),
            assignments = assignmentStore && assignmentStore.getAssignmentsForResource(me) || [],
            i, len, done;
        scope = scope || this;
        for (done = false , i = 0 , len = assignments.length; !done && i < len; ++i) {
            done = (false === func.call(scope, assignments[i]));
        }
    },
    // TODO: maybe refactor this method using assignment store map* methods
    // TODO: move it to Scheduler's codebase with forEachEvent name
    /**
     * Iterator for tasks, assigned to this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Task task} instance
     * as the only argument.
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachTask: function(func, scope) {
        var me = this,
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore && taskStore.getAssignmentStore(),
            assignments = assignmentStore && assignmentStore.getAssignmentsForResource(me) || [],
            i, len, done, task;
        scope = scope || this;
        for (done = false , i = 0 , len = assignments.length; !done && i < len; ++i) {
            task = assignments[i].getTask();
            task && (done = (false === func.call(scope, task)));
        }
    },
    collectAvailabilityIntervalPoints: function(intervals, startPoint, endPoint, pointsByTime, pointTimes) {
        for (var k = 0,
            l = intervals.length; k < l; k++) {
            var interval = intervals[k];
            var intervalStartDate = interval.startDate - 0;
            var intervalEndDate = interval.endDate - 0;
            if (!pointsByTime[intervalStartDate]) {
                pointsByTime[intervalStartDate] = [];
                pointTimes.push(intervalStartDate);
            }
            pointsByTime[intervalStartDate].push(startPoint);
            if (!pointsByTime[intervalEndDate]) {
                pointsByTime[intervalEndDate] = [];
                pointTimes.push(intervalEndDate);
            }
            pointsByTime[intervalEndDate].push(endPoint);
        }
    },
    forEachAvailabilityIntervalWithTasks: function(options, func, scope) {
        scope = scope || this;
        var startDate = options.startDate;
        var endDate = options.endDate;
        var targetTask = options.task;
        if (!startDate || !endDate)  {
            throw "Both `startDate` and `endDate` are required for `forEachAvailabilityIntervalWithTasks`";
        }
        
        var cursorDate = new Date(startDate);
        var includeAllIntervals = options.includeAllIntervals;
        var includeResCalIntervals = options.includeResCalIntervals;
        var resourceCalendar = this.getCalendar();
        var assignments = [];
        var tasks = [];
        var tasksCalendars = [];
        var pointTimes = [
                startDate - 0,
                endDate - 0
            ];
        var pointsByTime = {};
        pointsByTime[startDate - 0] = [
            {
                type: '00-intervalStart'
            }
        ];
        pointsByTime[endDate - 0] = [
            {
                type: '00-intervalEnd'
            }
        ];
        this.forEachAssignment(function(assignment) {
            var task = assignment.getTask();
            // filter out non-existing and irrelevant tasks
            if (!task || (targetTask && task !== targetTask))  {
                return;
            }
            
            var taskStart = task.getStartDate();
            var taskEnd = task.getEndDate();
            var taskId = task.getId();
            // filter out tasks out of provided [ startDate, endDate ) interval
            if (taskStart > endDate || taskEnd < startDate)  {
                return;
            }
            
            tasks.push(task);
            // We use the resource calendar if task has no an assigned calendar
            // Since we have to use resource calendar only in this case (project calendar should not be taken into account)
            tasksCalendars.push(task.getOwnCalendar() || this.getCalendar());
            // if task is segmented then segments start/end dates are points of interest
            if (task.isSegmented()) {
                for (var taskSegments = task.getSegments(),
                    i = 0,
                    l = taskSegments.length; i < l; i++) {
                    var segment = taskSegments[i];
                    this.collectAvailabilityIntervalPoints([
                        {
                            startDate: segment.getStartDate(),
                            endDate: segment.getEndDate()
                        }
                    ], {
                        type: '05-taskStart',
                        assignment: assignment,
                        taskId: taskId,
                        units: assignment.getUnits()
                    }, {
                        type: '04-taskEnd',
                        taskId: taskId
                    }, pointsByTime, pointTimes);
                }
            } else // task start/end dates are points of interest
            {
                this.collectAvailabilityIntervalPoints([
                    {
                        startDate: taskStart,
                        endDate: taskEnd
                    }
                ], {
                    type: '05-taskStart',
                    assignment: assignment,
                    taskId: taskId,
                    units: assignment.getUnits()
                }, {
                    type: '04-taskEnd',
                    taskId: taskId
                }, pointsByTime, pointTimes);
            }
            assignments.push(assignment);
        });
        // if there are no tasks - then there are no common intervals naturally
        if (!tasks.length && !includeAllIntervals && !includeResCalIntervals)  {
            return;
        }
        
        var DATE = Sch.util.Date;
        var i, l, taskId,
            taskCalendarHash = {};
        while (cursorDate < endDate) {
            this.collectAvailabilityIntervalPoints(resourceCalendar.getAvailabilityIntervalsFor(cursorDate), {
                type: '00-resourceAvailabilityStart'
            }, {
                type: '01-resourceAvailabilityEnd'
            }, pointsByTime, pointTimes);
            // using "for" instead of "each" should be blazing fast! :)
            for (i = 0 , l = tasksCalendars.length; i < l; i++) {
                taskId = tasks[i].getId();
                // resource specific calendar point
                this.collectAvailabilityIntervalPoints(tasksCalendars[i].getAvailabilityIntervalsFor(cursorDate), {
                    type: '02-taskAvailabilityStart',
                    taskId: taskId
                }, {
                    type: '03-taskAvailabilityEnd',
                    taskId: taskId
                }, pointsByTime, pointTimes);
            }
            // does not perform cloning internally!
            cursorDate = DATE.getStartOfNextDay(cursorDate);
        }
        // Numerical sort, can't use default JS sort
        // we have to define a sorting function here since there is a bug in Chrome
        // which affects large arrays sorting if you don't provide a sorting function (#1365)
        pointTimes.sort(function(a, b) {
            return a - b;
        });
        var inInterval = false,
            inResource = false,
            currentAssignments = {},
            inTaskCalendar = 0,
            inTask = 0;
        var inTaskCalendarHash = {};
        for (i = 0 , l = pointTimes.length - 1; i < l; i++) {
            var points = pointsByTime[pointTimes[i]];
            points.sort(function(a, b) {
                return a.type < b.type ? 1 : -1;
            });
            for (var k = 0,
                j = points.length; k < j; k++) {
                var point = points[k];
                switch (point.type) {
                    case '00-resourceAvailabilityStart':
                        inResource = true;
                        break;
                    case '01-resourceAvailabilityEnd':
                        inResource = false;
                        break;
                    case '02-taskAvailabilityStart':
                        inTaskCalendar++;
                        inTaskCalendarHash[point.taskId] = true;
                        break;
                    case '03-taskAvailabilityEnd':
                        inTaskCalendar--;
                        delete inTaskCalendarHash[point.taskId];
                        break;
                    case '05-taskStart':
                        currentAssignments[point.taskId] = point;
                        inTask++;
                        break;
                    case '04-taskEnd':
                        delete currentAssignments[point.taskId];
                        inTask--;
                        break;
                    case '00-intervalStart':
                        inInterval = true;
                        break;
                    case '00-intervalEnd':
                        return;
                }
            }
            if (inInterval && (includeAllIntervals || includeResCalIntervals && inResource || inResource && inTaskCalendar && inTask)) {
                var meta = {
                        inResourceCalendar: !!inResource,
                        inTasksCalendar: !!inTaskCalendar,
                        inTask: inTask,
                        inTaskCalendarHash: Ext.apply({}, inTaskCalendarHash)
                    };
                var intervalStartDate = pointTimes[i];
                var intervalEndDate = pointTimes[i + 1];
                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate > endDate || intervalEndDate < startDate)  {
                    
                    continue;
                }
                
                if (intervalStartDate < startDate)  {
                    intervalStartDate = startDate - 0;
                }
                
                if (intervalEndDate > endDate)  {
                    intervalEndDate = endDate - 0;
                }
                
                if (func.call(scope, intervalStartDate, intervalEndDate, currentAssignments, meta) === false)  {
                    return false;
                }
                
            }
        }
    },
    /**
     * This method will generate a report about the resource allocation in the given timeframe.
     * The start and end dates of the timeframe are provided as the "startDate/endDate" properties of the `options` parameter.
     * Options may also contain additional property: `includeAllIntervals` which includes the intervals w/o any
     * assignments in the ouput (see the example below).
     *
     * For example, this resource `R1` has the availability from 10:00 till 17:00 on 2012/06/01 and from 12:00 till 15:00 on 2012/06/02.
     * It is also assigned on 50% to two tasks:
     *
     * - `T1` has availability from 11:00 till 16:00 on 2012/06/01 and from 13:00 till 17:00 on 2012/06/02.
     *   It starts at 11:00 2012/06/01 and ends at 17:00 2012/06/02
     * - `T2` has availability from 15:00 till 19:00 on 2012/06/01 and from 09:00 till 14:00 on 2012/06/02.
     *   It starts at 15:00 2012/06/01 and ends at 14:00 2012/06/02
     *
     * So the allocation information for the period 2012/06/01 - 2012/06/03 (note the 03 in day - it means 2012/06/02 inclusive)
     * will looks like the following (to better understand this example you might want to draw all the information on paper):
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        {
            startDate           : new Date(2012, 5, 1, 15),
            endDate             : new Date(2012, 5, 1, 16),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 1, 16),
            endDate             : new Date(2012, 5, 1, 17),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 12),
            endDate             : new Date(2012, 5, 2, 13),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            assignmentsHash     : { 'T2' : assignmentForTask2 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 13),
            endDate             : new Date(2012, 5, 2, 14),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 14),
            endDate             : new Date(2012, 5, 2, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
    ]

     *
     * As you can see its quite detailed information - every distinct timeframe is included in the report.
     * You can aggregate this information as you need.
     *
     * Setting the `includeAllIntervals` option to true, will include intervals w/o assignments in the report, so the in the
     * example above, the report will start with:
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 00),
            endDate             : new Date(2012, 5, 1, 10),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : false,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 10),
            endDate             : new Date(2012, 5, 1, 11),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : true,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 }
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        ...
    ]


     *
     * @param {Object} options Object with the following properties:
     *
     * - "startDate" - start date for the report timeframe
     * - "endDate" - end date for the report timeframe
     * - "includeAllIntervals" - whether to include the intervals w/o assignments in the report
     * - "includeResCalIntervals" - whether to include the intervals of resource calendar in the report
     * - "task" - (optional) Only return allocation data relating to a certain task
     */
    getAllocationInfo: function(options) {
        var info = [];
        this.forEachAvailabilityIntervalWithTasks(options, function(intervalStartDate, intervalEndDate, intervalAssignments, meta) {
            var effectiveTotalAllocation = 0,
                effectiveAssignments = [],
                effectiveAssignmentsHash = {},
                totalAllocation = 0,
                assignments = [],
                assignmentsHash = {},
                durationMS = intervalEndDate - intervalStartDate,
                allocationMS = 0;
            if (meta.inResourceCalendar && meta.inTasksCalendar && meta.inTask) {
                // loop over all the unfinished (on this period of time) resource assignments
                for (var i in intervalAssignments) {
                    // if this task is running in the interval
                    if (meta.inTaskCalendarHash[i]) {
                        // calculate allocation (in milliseconds)
                        allocationMS += durationMS * intervalAssignments[i].units * 0.01;
                        // calculate "effective" total allocation % (by running tasks only)
                        effectiveTotalAllocation += intervalAssignments[i].units;
                        // put it into array / hash of running tasks
                        effectiveAssignmentsHash[i] = intervalAssignments[i].assignment;
                        effectiveAssignments.push(intervalAssignments[i].assignment);
                    }
                    // keep sum of allocation % for all the not finished tasks
                    // (regardless of which task is been handled in this interval)
                    totalAllocation += intervalAssignments[i].units;
                    // array / hash of ongoing tasks
                    assignmentsHash[i] = intervalAssignments[i].assignment;
                    assignments.push(intervalAssignments[i].assignment);
                }
            }
            info.push(Ext.apply({
                startDate: new Date(intervalStartDate),
                endDate: new Date(intervalEndDate),
                effectiveTotalAllocation: effectiveTotalAllocation,
                effectiveAssignmentsHash: effectiveAssignmentsHash,
                effectiveAssignments: effectiveAssignments,
                totalAllocationMS: allocationMS,
                totalAllocation: totalAllocation,
                assignments: assignments,
                assignmentsHash: assignmentsHash
            }, meta));
        });
        return info;
    },
    /**
     * Returns resource utilization info for the given time span.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Number} underUtilizationThreshold
     * @param {Number} overUtilizationThreshold
     *
     * @return {Object}  info
     * @return {Number}  info.allocationMs
     * @return {Number}  info.allocationDeltaMs,
     * @return {Boolean} info.isOverallocated
     * @return {Boolean} info.isUnderallocated
     * @return {Number}  info.resourceAvailabilityMs,
     * @return {Object}  info.assignmentInfo   Assignment utilization information keyed by assignment id
     * @return {Object}  info.taskInfo         Assignment utilization information keyed by task id
     */
    getUtilizationInfo: function(startDate, endDate, underUtilizationThreshold, overUtilizationThreshold) {
        var me = this,
            amountMs = 0,
            isOverallocated = false,
            isUnderallocated = false,
            assignmentInfo = {},
            taskInfo = {};
        if (arguments.length < 3) {
            underUtilizationThreshold = overUtilizationThreshold = 100;
        }
        // get resource allocation report (array of intervals)
        var allocationIntervals = me.getAllocationInfo({
                // include not only allocated intervals but also availability intervals defined by the resource calendar
                // to be able to detect resource under-allocation properly
                includeResCalIntervals: true,
                startDate: startDate,
                endDate: endDate
            });
        Ext.Array.each(allocationIntervals, function(intervalInfo) {
            amountMs += intervalInfo.totalAllocationMS;
            if (intervalInfo.effectiveTotalAllocation > overUtilizationThreshold) {
                isOverallocated = true;
                isUnderallocated = false;
            } else if (!isOverallocated && intervalInfo.effectiveTotalAllocation < underUtilizationThreshold) {
                isUnderallocated = true;
            }
            // loop over individual assignments to have allocationMs/isOverallocated/isUnderallocated per each assignment
            Ext.Array.each(intervalInfo.effectiveAssignments, function(assignment) {
                var assignmentId = assignment.getId(),
                    taskId = assignment.getTaskId(),
                    assignmentUnits = assignment.getUnits(),
                    allocationMs = Math.floor((intervalInfo.endDate - intervalInfo.startDate) * assignmentUnits / 100),
                    allocationDeltaMs = 0,
                    isOverallocated = assignmentUnits > overUtilizationThreshold,
                    isUnderallocated = assignmentUnits < underUtilizationThreshold,
                    assignmentUtilization;
                // if the assignment counters already started increment them
                if (assignmentInfo[assignmentId]) {
                    assignmentUtilization = assignmentInfo[assignmentId];
                    assignmentUtilization.allocationMs += allocationMs;
                    assignmentUtilization.allocationDeltaMs += allocationDeltaMs;
                    assignmentUtilization.isOverallocated = assignmentUtilization.isOverallocated || isOverallocated;
                    assignmentUtilization.isUnderallocated = assignmentUtilization.isUnderallocated || isUnderallocated;
                } else // init the assignment counters
                {
                    assignmentUtilization = {
                        isUtilized: true,
                        allocationMs: allocationMs,
                        allocationDeltaMs: allocationDeltaMs,
                        isOverallocated: isOverallocated,
                        isUnderallocated: isUnderallocated
                    };
                    assignmentInfo[assignmentId] = assignmentUtilization;
                    taskInfo[taskId] = assignmentUtilization;
                }
            });
        });
        return {
            isUtilized: amountMs > 0,
            allocationMs: amountMs,
            allocationDeltaMs: 0,
            isOverallocated: isOverallocated,
            isUnderallocated: isUnderallocated,
            // individual assignments utilization info
            assignmentInfo: assignmentInfo,
            taskInfo: taskInfo
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.data.mixin.ResourceStore
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Sch.data.ResourceStore} class ("usual" store) and {@link Sch.data.ResourceTreeStore} - tree store.
 *
 */
Ext.define("Sch.data.mixin.ResourceStore", {
    eventStore: null,
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore;
        if (me.eventStore !== eventStore) {
            oldStore = me.eventStore;
            me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.ResourceStore}   this
             * @param {Sch.data.EventStore|null} newEventStore
             * @param {Sch.data.EventStore|null} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    getScheduledEventsInTimeSpan: function(start, end, eventStore) {
        var events = [];
        var DATE = Sch.util.Date;
        eventStore = eventStore || this.getEventStore();
        Ext.Array.each(this.getRange(), function(resource) {
            Ext.Array.each(eventStore.getEventsForResource(resource), function(event) {
                if (event.intersectsRange(start, end)) {
                    events.push(event);
                }
            });
        });
        return events;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.ResourceStore
@extends Ext.data.Store
@mixin Sch.data.mixin.ResourceStore

This is a class holding the collection the {@link Sch.model.Resource resources} to be rendered into a {@link Sch.panel.SchedulerGrid scheduler panel}.
It is a subclass of {@link Ext.data.Store} - a store with linear data presentation.

*/
Ext.define("Sch.data.ResourceStore", {
    extend: 'Ext.data.Store',
    model: 'Sch.model.Resource',
    config: {
        model: 'Sch.model.Resource'
    },
    alias: 'store.resourcestore',
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore',
        'Robo.data.Store'
    ],
    storeId: 'resources',
    constructor: function() {
        this.callParent(arguments);
        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceStore must subclass Sch.model.Resource';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.data.ResourceStore
@extends Sch.data.ResourceStore

A class representing the collection of the resources - {@link Gnt.model.Resource} records.

*/
Ext.define('Gnt.data.ResourceStore', {
    requires: [
        'Gnt.model.Resource'
    ],
    extend: 'Sch.data.ResourceStore',
    storeId: 'resources',
    model: 'Gnt.model.Resource',
    alias: 'store.gantt_resourcestore',
    /**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this resource store is associated.
     * Usually is configured automatically, by the task store itself.
     */
    taskStore: null,
    constructor: function(config) {
        this.callParent([
            config
        ]);
        this.on({
            load: this.normalizeResources,
            remove: this.onResourceRemoved,
            // Our internal listeners should be ran before any client listeners
            priority: 100
        });
    },
    normalizeResources: function() {
        // scan through all resources and re-assign the "calendarId" property to get the listeners in place
        this.each(function(resource) {
            if (!resource.normalized) {
                var calendarId = resource.getCalendarId();
                if (calendarId)  {
                    resource.setCalendarId(calendarId, true);
                }
                
                resource.normalized = true;
            }
        });
    },
    // Performance optimization possibility: Assignment store datachange will cause a full refresh
    // so removing a resource will currently cause 2 refreshes. Not critical since this is not a very common use case
    onResourceRemoved: function(store, resources) {
        var assignmentStore = this.getAssignmentStore();
        Ext.Array.each(resources, function(resource) {
            assignmentStore.removeAssignmentsForResource(resource);
        });
    },
    /**
     * Returns the associated task store instance.
     *
     * @return {Gnt.data.TaskStore|null}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    /**
     * Sets associated task store instance
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        this.taskStore = store;
    },
    /**
     * Returns the associated assignment store instance.
     *
     * @return {Gnt.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getAssignmentStore() || null;
    },
    /**
     * Returns the associated dependency store
     *
     * @return {Gnt.data.DependencyStore|null}
     */
    getDependencyStore: function() {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getDependencyStore() || null;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This class manages id consistency among model stores, it listens to 'idchanged' event on each store and updates
 * referential fields referencing records with changed ids in other model entities.
 *
 * Note on update process:
 *  at the time when 'idchanged' handler is called we can effectively query stores which are using caches for
 *  a data cached under old id, but we cannot update related models with the new id since at the time of
 *  'idchanged' handler is called a record which id has been updated is still marked as phantom, it's
 *  phantom flag will be reset only at 'update' event time (and 'idchanged' event is always followed by 'update'
 *  event) and it's important we start updating related records after primary records are not phantoms
 *  any more since we might rely on this flag (for example a related store sync operation might be blocked
 *  if primary store records it relies on are still phantom).
 *
 * @private
 */
Ext.define('Sch.data.util.IdConsistencyManager', {
    config: {
        eventStore: null,
        resourceStore: null,
        assignmentStore: null,
        dependencyStore: null
    },
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(config) {
        this.initConfig(config);
    },
    // {{{ Event attachers
    updateEventStore: function(newEventStore, oldEventStore) {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher');
        if (newEventStore) {
            me.eventStoreDetacher = newEventStore.on({
                idchanged: me.onEventIdChanged,
                scope: me,
                destroyable: true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new event id already if this priority is lower then the one used in cache
                priority: 200
            });
        }
    },
    updateResourceStore: function(newResourceStore, oldResourceStore) {
        var me = this;
        Ext.destroyMembers(me, 'resourceStoreDetacher');
        if (newResourceStore) {
            me.resourceStoreDetacher = newResourceStore.on({
                idchanged: me.onResourceIdChanged,
                scope: me,
                destroyable: true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new resource id already if this priority is lower then the one used in cache
                priority: 200
            });
        }
    },
    // }}}
    // {{{ Event handlers
    // Please see the note at the class description
    onEventIdChanged: function(eventStore, event, oldId, newId) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            dependencyStore = me.getDependencyStore(),
            assignmentsUpdater, dependenciesUpdater;
        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentEventIdFieldFn(assignmentStore, oldId, newId);
        }
        if (dependencyStore) {
            dependenciesUpdater = me.getUpdateDependencySourceTargedIdFieldFn(dependencyStore, oldId, newId);
        }
        if (assignmentsUpdater || dependenciesUpdater) {
            eventStore.on('update', function() {
                assignmentsUpdater && assignmentsUpdater();
                dependenciesUpdater && dependenciesUpdater();
            }, null, {
                single: true,
                priority: 200
            });
        }
    },
    // Please see the note at the class description
    onResourceIdChanged: function(resourceStore, resource, oldId, newId) {
        var me = this,
            eventStore = me.getEventStore(),
            assignmentStore = me.getAssignmentStore(),
            eventsUpdater, assignmentsUpdater;
        if (eventStore && !assignmentStore) {
            eventsUpdater = me.getUpdateEventResourceIdFieldFn(eventStore, oldId, newId);
        }
        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentResourceIdFieldFn(assignmentStore, oldId, newId);
        }
        if (eventsUpdater || assignmentStore) {
            resourceStore.on('update', function() {
                eventsUpdater && eventsUpdater();
                assignmentsUpdater && assignmentsUpdater();
            }, null, {
                single: true,
                priority: 200
            });
        }
    },
    // }}}
    // {{{ Update rules
    getUpdateEventResourceIdFieldFn: function(eventStore, oldId, newId) {
        var events = eventStore.getRange();
        return function() {
            Ext.Array.each(events, function(event) {
                event.getResourceId() == oldId && event.setResourceId(newId);
            });
        };
    },
    getUpdateAssignmentEventIdFieldFn: function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForEvent(oldId);
        return function() {
            Ext.Array.each(assignments, function(assignment) {
                assignment.getEventId() == oldId && assignment.setEventId(newId);
            });
        };
    },
    getUpdateAssignmentResourceIdFieldFn: function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForResource(oldId);
        return function() {
            Ext.Array.each(assignments, function(assignment) {
                assignment.getResourceId() == oldId && assignment.setResourceId(newId);
            });
        };
    },
    getUpdateDependencySourceTargedIdFieldFn: function(dependencyStore, oldId, newId) {
        var dependencies = dependencyStore.getEventDependencies(oldId);
        return function() {
            Ext.Array.each(dependencies, function(dependency) {
                dependency.getSourceId() == oldId && dependency.setSourceId(newId);
                dependency.getTargetId() == oldId && dependency.setTargetId(newId);
            });
        };
    }
});
// }}}

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable
 * records from sync operation. The logic has meaning only for CRUD-less sync operations.
 *
 * @private
 */
Ext.define('Sch.data.util.ModelPersistencyManager', {
    config: {
        eventStore: null,
        resourceStore: null,
        assignmentStore: null,
        dependencyStore: null
    },
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    assignmentStoreDetacher: null,
    dependencyStoreDetacher: null,
    constructor: function(config) {
        this.initConfig(config);
    },
    // {{{ Event attachers
    updateEventStore: function(newEventStore, oldEventStore) {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher');
        if (newEventStore && newEventStore.autoSync) {
            me.eventStoreDetacher = newEventStore.on({
                beforesync: me.onEventStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateResourceStore: function(newResourceStore, oldResourceStore) {
        var me = this;
        Ext.destroyMembers(me, 'resourceStoreDetacher');
        if (newResourceStore && newResourceStore.autoSync) {
            me.resourceStoreDetacher = newResourceStore.on({
                beforesync: me.onResourceStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateAssignmentStore: function(newAssignmentStore, oldAssignmentStore) {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher');
        if (newAssignmentStore && newAssignmentStore.autoSync) {
            me.assignmentStoreDetacher = newAssignmentStore.on({
                beforesync: me.onAssignmentStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateDependencyStore: function(newDependencyStore, oldDependencyStore) {
        var me = this;
        Ext.destroyMembers(me, 'dependencyStoreDetacher');
        if (newDependencyStore && newDependencyStore.autoSync) {
            me.dependencyStoreDetacher = newDependencyStore.on({
                beforesync: me.onDependencyStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    // }}}
    // {{{ Event handlers
    onEventStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onResourceStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onAssignmentStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onDependencyStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    // }}}
    // {{{ Management rules
    removeNonPersistableRecordsToCreate: function(options) {
        var recordsToCreate = options.create || [],
            r, i;
        // We remove from the array we iterate thus we iterate from end to start
        for (i = recordsToCreate.length - 1; i >= 0; --i) {
            r = recordsToCreate[i];
            if (!r.isPersistable()) {
                Ext.Array.remove(recordsToCreate, r);
            }
        }
        // Prevent empty create request
        if (recordsToCreate.length === 0) {
            delete options.create;
        }
    },
    shallContinueSync: function(options) {
        return Boolean((options.create && options.create.length > 0) || (options.update && options.update.length > 0) || (options.destroy && options.destroy.length > 0));
    }
});
// }}}

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Simple caching utility.
 *
 * Internaly obtains a key value suitable to be used as object property name via {@link Sch.util.Cache#key key()}
 * method and caches a value provided under the key obtained, values with the same key are groupped
 * into single array. Cached values are obtained via {@link Sch.util.Cache#get get()} method and are managed via
 * {@link Sch.util.Cache#add add()}, {@link Sch.util.Cache#remove remove()}, {@link Sch.util.Cache#move move()},
 * {@link Sch.util.Cache#clear clear()}
 * methods.
 */
Ext.define('Sch.util.Cache', {
    cache: null,
    /**
     * @constructor
     */
    constructor: function() {
        this.cache = {};
    },
    /**
     * A function returning a key for given value.
     *
     * @param  {Mixed} v
     * @return {String}
     * @template
     */
    key: function(v) {
        var result;
        if (v instanceof Ext.data.Model) {
            result = v.getId().toString();
        } else if (v === undefined || v === null) {
            result = "[ undefined / null ]";
        } else {
            result = (v).toString();
        }
        return result;
    },
    /**
     * Returns all values cached with a given key, or if key isn't present executes a given function, caches
     * it's result (which should be array) after it's mapped over {@link #map} and returns it.
     *
     * *Warning*: the array returned must not be modified otherwise cache integrity will be violated.
     *
     * @param {Mixed} k
     * @param {Function} [fn]
     * @param {[Mixed]}  [fn.return]
     * @return {[Mixed]}
     */
    get: function(k, fn) {
        var me = this,
            result;
        k = me.key(k);
        result = me.cache.hasOwnProperty(k) && me.cache[k];
        if (!result && fn) {
            result = fn();
        } else if (!result) {
            result = [];
        }
        me.cache[k] = result;
        return result;
    },
    /**
     * Caches a value using either a key provided or a key obtained from {@link #key key()} method.
     *
     * @param {Mixed} k
     * @param {Mixed} v
     * @chainable
     */
    add: function(k, v) {
        var me = this,
            kAdopted = me.key(k);
        if (!me.cache.hasOwnProperty(kAdopted)) {
            me.cache[kAdopted] = me.get(k);
        }
        // initial key cache filling
        Ext.Array.include(me.cache[kAdopted], v);
        return me;
    },
    /**
     * Removes cached value from cache under a given key or under a key obtained from {@link #key key()} method.
     *
     * @param {Mixed} k
     * @param {Mixed} v
     * @chainable
     */
    remove: function(k, v) {
        var me = this;
        k = me.key(k);
        if (me.cache.hasOwnProperty(k)) {
            Ext.Array.remove(me.cache[k], v);
        }
        return me;
    },
    /**
     * Moves all items or a single item under old key to new key
     *
     * @param {Mixed} oldKey
     * @param {Mixed} newKey
     * @chainable
     */
    move: function(oldKey, newKey, v) {
        var me = this;
        oldKey = me.key(oldKey);
        newKey = me.key(newKey);
        if (oldKey != newKey && arguments.length >= 3) {
            me.remove(oldKey, v);
            me.add(newKey, v);
        } else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey) && me.cache.hasOwnProperty(newKey)) {
            me.cache[newKey] = Ext.Array.union(me.cache[newKey], me.cache[oldKey]);
            me.cache[oldKey] = [];
        } else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey)) {
            me.cache[newKey] = me.cache[oldKey];
            me.cache[oldKey] = [];
        }
        return me;
    },
    /**
     * Clears entire cache, or clears cache for a given key.
     *
     * @param {Mixed} [k]
     * @chainable
     */
    clear: function(k) {
        var me = this;
        if (!arguments.length) {
            me.cache = {};
        } else {
            k = me.key(k);
            if (me.cache.hasOwnProperty(k)) {
                delete me.cache[k];
            }
        }
        return me;
    },
    /**
     * Removes value from entire cache (from every key it exists under).
     *
     * @param {Mixed} v
     * @chainable
     */
    uncache: function(v) {
        var me = this,
            k;
        for (k in me.cache) {
            if (me.cache.hasOwnProperty(k)) {
                me.cache[k] = Ext.Array.remove(me.cache[k], v);
            }
        }
        return me;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Event store's resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceEventsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    eventStore: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(eventStore) {
        var me = this,
            resourceStore = eventStore.getResourceStore();
        me.callParent();
        function onEventAdd(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.add(event.getResourceId(), event);
            });
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.remove(event.getResourceId(), event);
            });
        }
        function onEventUpdate(eventStore, event, operation, modifiedFieldNames) {
            var resourceIdField = event.resourceIdField,
                resourceIdChanged = event.previous && resourceIdField in event.previous,
                previousResourceId = resourceIdChanged && event.previous[resourceIdField];
            if (resourceIdChanged) {
                me.move(previousResourceId, event.getResourceId(), event);
            }
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(eventStore, newResourceStore, oldResourceStore) {
            me.clear();
            attachToResourceStore(newResourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.eventStoreDetacher = eventStore.on({
            add: onEventAdd,
            remove: onEventRemove,
            update: onEventUpdate,
            clear: onEventStoreClearOrReset,
            cacheresethint: onEventStoreClearOrReset,
            rootchange: onEventStoreClearOrReset,
            resourcestorechange: onEventStoreResourceStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.eventStoreFiltersDetacher = eventStore.getFilters().on('endupdate', onEventStoreClearOrReset, this, {
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToResourceStore(resourceStore);
        me.eventStore = eventStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher', 'eventStoreFiltersDetacher', 'resourceStoreDetacher');
        me.eventStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.eventStore.getRange(), function(event) {
                return event.getResourceId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This is a mixin, containing functionality related to managing events.
 *
 * It is consumed by the regular {@link Sch.data.EventStore} class and {@link Gnt.data.TaskStore} class
 * to allow data sharing between gantt chart and scheduler. Please note though, that datasharing is still
 * an experimental feature and not all methods of this mixin can be used yet on a TaskStore.
 *
 */
Ext.define("Sch.data.mixin.EventStore", {
    extend: 'Ext.Mixin',
    requires: [
        'Sch.util.Date',
        'Sch.data.util.IdConsistencyManager',
        'Sch.data.util.ModelPersistencyManager',
        'Sch.data.util.ResourceEventsCache'
    ],
    isEventStore: true,
    resourceStore: null,
    resourceStoreDetacher: null,
    /**
     * @cfg {Sch.data.AssignmentStore} assignmentStore Provide assignment store to enable multiple connections between
     * events and resources
     */
    assignmentStore: null,
    resourceEventsCache: null,
    idConsistencyManager: null,
    modelPersistencyManager: null,
    mixinConfig: {
        after: {
            constructor: 'constructor',
            destroy: 'destroy'
        }
    },
    /**
     * @constructor
     */
    constructor: function() {
        var me = this;
        me.resourceEventsCache = me.createResourceEventsCache();
        me.idConsistencyManager = me.createIdConsistencyManager();
        me.modelPersistencyManager = me.createModelPersistencyManager();
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'resourceEventsCache', 'idConsistencyManager', 'modelPersistencyManager');
    },
    /**
     * Creates and returns Resource->Events cache.
     *
     * @return {Sch.data.util.ResourceEventsCache}
     * @template
     * @protected
     */
    createResourceEventsCache: function() {
        return new Sch.data.util.ResourceEventsCache(this);
    },
    /**
     * Creates and returns id consistency manager
     *
     * @return {Sch.data.util.IdConsistencyManager}
     * @tempalte
     * @protected
     */
    createIdConsistencyManager: function() {
        var me = this;
        return new Sch.data.util.IdConsistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    /**
     * Creates and returns model persistency manager
     *
     * @return {Sch.data.util.ModelPersistencyManager}
     * @tempalte
     * @protected
     */
    createModelPersistencyManager: function() {
        var me = this;
        return new Sch.data.util.ModelPersistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    /**
     * Gets the resource store for this store
     *
     * @return {Sch.data.ResourceStore} resourceStore
     */
    getResourceStore: function() {
        return this.resourceStore;
    },
    /**
     * Sets the resource store for this store
     *
     * @param {Sch.data.ResourceStore} resourceStore
     */
    setResourceStore: function(resourceStore) {
        var me = this,
            oldStore = me.resourceStore;
        if (me.resourceStore) {
            me.resourceStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
        }
        me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;
        if (me.resourceStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
            resourceStore.setEventStore(me);
        }
        if ((oldStore || resourceStore) && oldStore !== resourceStore) {
            /**
             * @event resourcestorechange
             * Fires when new resource store is set via {@link #setResourceStore} method.
             * @param {Sch.data.EventStore}         this
             * @param {Sch.data.ResourceStore|null} newResourceStore
             * @param {Sch.data.ResourceStore|null} oldResourceStore
             */
            me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
        }
    },
    /**
     * Returns assignment store this event store is using by default.
     *
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.assignmentStore;
    },
    /**
     * Sets assignment store instance this event store will be using by default.
     *
     * @param {Sch.data.AssignmentStore} store
     */
    setAssignmentStore: function(assignmentStore) {
        var me = this,
            oldStore = me.assignmentStore;
        if (me.assignmentStore) {
            me.assignmentStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
        }
        me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;
        if (me.assignmentStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
            me.assignmentStore.setEventStore(me);
            // If assignment store's set then caching now will be done by it
            // and event store doesn't need to maintain it's own resource-to-events cache.
            Ext.destroy(me.resourceEventsCache);
        } else {
            // If assignment store's reset then caching now should be done by
            // event store again.
            me.resourceEventsCache = me.createResourceEventsCache();
        }
        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * @event assignmentstorechange
             * Fires when new assignment store is set via {@link #setAssignmentStore} method.
             * @param {Sch.data.EventStore}           this
             * @param {Sch.data.AssignmentStore|null} newAssignmentStore
             * @param {Sch.data.AssignmentStore|null} oldAssignmentStore
             */
            me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
        }
    },
    /**
     * Returns a dependecy store instance this event store is associated with. See also {@link #setDependencyStore}.
     *
     * @return {Sch.data.DependencyStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    /**
     * Sets the dependency store for this event store
     *
     * @param {Sch.data.DependencyStore} dependencyStore
     */
    setDependencyStore: function(dependencyStore) {
        var me = this,
            oldStore = me.DependencyStore;
        if (me.dependencyStore) {
            me.dependencyStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(null);
        }
        me.dependencyStore = dependencyStore && Ext.StoreMgr.lookup(dependencyStore) || null;
        if (me.dependencyStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(me.dependencyStore);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(me.dependencyStore);
            me.dependencyStore.setEventStore(me);
        }
        if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
            /**
             * @event dependencystorechange
             * Fires when new dependency store is set via {@link #setDependencyStore} method.
             * @param {Sch.data.EventStore}           this
             * @param {Sch.data.DependencyStore|null} newDependencyStore
             * @param {Sch.data.DependencyStore|null} oldDependencyStore
             */
            me.fireEvent('dependencystorechange', me, dependencyStore, oldStore);
        }
    },
    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function(start, end, excludeEvent, resource) {
        var DATE = Sch.util.Date,
            events = this.getEventsForResource(resource),
            available = true;
        // This can be optimized further if we use simple for() statement (will lead to -1 function call in the loop)
        Ext.each(events, function(ev) {
            available = excludeEvent === ev || !DATE.intersectSpans(start, end, ev.getStartDate(), ev.getEndDate());
            return available;
        });
        // to immediately stop looping if interval is occupied by a non excluding event
        return available;
    },
    /**
    * Returns events between the supplied start and end date
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Boolean} allowPartial false to only include events that start and end inside of the span
    * @return {Ext.util.MixedCollection} the events
    */
    getEventsInTimeSpan: function(start, end, allowPartial) {
        var coll = new Ext.util.MixedCollection();
        var events = [];
        if (allowPartial !== false) {
            var DATE = Sch.util.Date;
            this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
                if (DATE.intersectSpans(eventStart, eventEnd, start, end)) {
                    events.push(event);
                }
            });
        } else {
            this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
                if (eventStart - start >= 0 && end - eventEnd >= 0) {
                    events.push(event);
                }
            });
        }
        coll.addAll(events);
        return coll;
    },
    getEventsByStartDate: function(start) {
        var DATE = Sch.util.Date;
        var events = [];
        this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
            if (DATE.compareWithPrecision(eventStart, start, DATE.DAY) === 0) {
                events.push(event);
            }
        });
        return events;
    },
    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     *      - event : the event record
     *      - startDate : the event start date
     *      - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} scope scope for the function
     */
    forEachScheduledEvent: function(fn, scope) {
        this.each(function(event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();
            if (eventStart && eventEnd) {
                return fn.call(scope || this, event, eventStart, eventEnd);
            }
        }, this);
    },
    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     */
    getTotalTimeSpan: function() {
        var earliest = new Date(9999, 0, 1),
            latest = new Date(0),
            D = Sch.util.Date;
        this.each(function(r) {
            if (r.getStartDate()) {
                earliest = D.min(r.getStartDate(), earliest);
            }
            if (r.getEndDate()) {
                latest = D.max(r.getEndDate(), latest);
            }
        });
        // TODO: this will fail in programs designed to work with events in the past (after Jan 1, 1970)
        earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
        latest = latest > new Date(0) ? latest : null;
        // keep last calculated value to be able to track total timespan changes
        this.lastTotalTimeSpan = {
            start: earliest || null,
            end: latest || earliest || null
        };
        return this.lastTotalTimeSpan;
    },
    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @private {Sch.model.Resource} resource
     * @param {Sch.model.Resource} resource
     * @param {Function} fn The function
     * @param {Object} [scope] The 'this object' for the function
     * @return {Sch.model.Event[]} the events in the time span
     */
    filterEventsForResource: function(resource, fn, scope) {
        // `getEvents` method of the resource will use either `indexByResource` or perform a full scan of the event store
        var events = resource.getEvents(this);
        return Ext.Array.filter(events, fn, scope || this);
    },
    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    append: function(record) {
        throw 'Must be implemented by consuming class';
    },
    // {{{ Entire data model management methods
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Event/Mixed} event
     * @return {Sch.model.Resource[]}
     */
    getResourcesForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore = me.getResourceStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.getResourcesForEvent(event);
        } else if (resourceStore) {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            result = event && resourceStore.getModelById(event.getResourceId());
            result = result && [
                result
            ] || [];
        } else {
            result = [];
        }
        return result;
    },
    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Event[]}
     */
    getEventsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.getEventsForResource(resource);
        }
        // Resource->Events cache is not always accessable, a subclass might override createResourceEventsCache() method
        // returning null
        else if (me.resourceEventsCache) {
            result = me.resourceEventsCache.get(resource);
        } else {
            result = [];
        }
        return result;
    },
    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Event/Mixed} event
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForEvent(event) || [];
    },
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForResource(resource) || [];
    },
    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resource/Mixed/Sch.model.Resource[]/Mixed[]} resource The resource(s) to assign to the event
     */
    assignEventToResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.assignEventToResource(event, resource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            event && event.setResourceId(resource);
        }
    },
    // This will update resource events cache via 'update' event.
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resource/Mixed} resource
     */
    unassignEventFromResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.unassignEventFromResource(event, resource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            if (event && event.getResourceId() == resource) {
                event.setResourceId(null);
            }
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Sch.model.Event}    event    An event or id of the event to reassign
     * @param {Sch.model.Resource/Sch.model.Resource[]} oldResource A resource to unassign from
     * @param {Sch.model.Resource/Sch.model.Resource[]} newResource A resource to assign to
     */
    reassignEventFromResourceToResource: function(event, oldResource, newResource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.unassignEventFromResource(event, oldResource);
            assignmentStore.assignEventToResource(event, newResource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            oldResource = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource;
            // resource id might be 0 thus we use ? operator
            newResource = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource;
            // resource id might be 0 thus we use ? operator
            if (event.getResourceId() == oldResource) {
                event.setResourceId(newResource);
            }
        }
    },
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resouce/Mixed} resource
     * @return {Boolean}
     */
    isEventAssignedToResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.isEventAssignedToResource(event, resource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            result = event && (event.getResourceId() == resource) || false;
        }
        return result;
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Event/Mixed} event
     */
    removeAssignmentsForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.removeAssignmentsForEvent(event);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            event && event.setResourceId(null);
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     */
    removeAssignmentsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore = me.getResourceStore();
        if (assignmentStore) {
            assignmentStore.removeAssignmentsForResource(resource);
        } else if (resourceStore) {
            resource = resource instanceof Sch.model.Resource && resource || resourceStore.getModelById(resource);
            resource && Ext.Array.each(me.resourceEventsCache.get(resource), function(event) {
                event.setResourceId(null);
            });
        } else // This will update resource events cache via 'update' event
        {
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            Ext.Array.each(me.getRange(), function(event) {
                event.getResourceId() == resource && event.setResourceId(null);
            });
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Checks if given event record is persistable.
     * In case assignment store is used to assign events to resources and vise versa event is considered to be always
     * persistable. Otherwise backward compatible logic is used, i.e. event is considered to be persistable when
     * resources it's assigned to are not phantom.
     *
     * @param {Sch.model.Range} event
     * @return {Boolean}
     */
    isEventPersistable: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resources, i, len,
            result = true;
        if (!assignmentStore) {
            resources = event.getResources();
            for (i = 0 , len = resources.length; result && i < len; ++i) {
                result = resources[i].phantom !== true;
            }
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.model.Event
@extends Sch.model.Range

This class represent a single event in your schedule. Its a subclass of the {@link Sch.model.Range}, which is in turn subclass of {@link Sch.model.Customizable} and {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of the task.

The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,
you can do that by subclassing this class (see example below).

Fields
------

- `Id`          - (mandatory) unique identifier of task
- `Name`        - name of the event (task title)
- `StartDate`   - start date of the task in ISO 8601 format
- `EndDate`     - end date of the task in ISO 8601 format,
- `ResourceId`  - The id of the associated resource
- `Resizable`   - A field allowing you to easily control how an event can be resized. You can set it to: true, false, 'start' or 'end' as its value.
- `Draggable`   - A field allowing you to easily control if an event can be dragged. (true or false)
- `Cls`         - A field containing a CSS class to be added to the rendered event element.
- `IconCls`     - A field containing a CSS class to be added as an icon to the event.

Subclassing the Event model class
--------------------

    Ext.define('MyProject.model.Event', {
        extend      : 'Sch.model.Event',

        fields      : [
            // adding new field
            { name: 'MyField', type : 'number', defaultValue : 0 }
        ],

        myCheckMethod : function () {
            return this.get('MyField') > 0
        },
        ...
    });

If you want to use other names for the StartDate, EndDate, ResourceId and Name fields you can configure them as seen below:

    Ext.define('MyProject.model.Event', {
        extend      : 'Sch.model.Event',

        startDateField  : 'taskStart',
        endDateField    : 'taskEnd',

        // just rename the fields
        resourceIdField : 'userId',
        nameField       : 'taskTitle',

        fields      : [
            // completely change the definition of fields
            { name: 'taskStart', type: 'date', dateFormat : 'Y-m-d' },
            { name: 'taskEnd', type: 'date', dateFormat : 'Y-m-d' },
        ]
        ...
    });

Please refer to {@link Sch.model.Customizable} for additional details.

*/
Ext.define('Sch.model.Event', {
    extend: 'Sch.model.Range',
    idProperty: 'Id',
    customizableFields: [
        {
            name: 'IconCls'
        },
        {
            name: 'ResourceId'
        },
        {
            name: 'Draggable',
            type: 'boolean',
            persist: false,
            defaultValue: true
        },
        // true or false
        {
            name: 'Resizable',
            persist: false,
            defaultValue: true
        }
    ],
    // true, false, 'start' or 'end'
    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an event belongs. Defaults to "ResourceId".
     */
    resourceIdField: 'ResourceId',
    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField: 'Draggable',
    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField: 'Resizable',
    /**
     * @cfg {String} iconClsField The name of the field specifying the icon CSS class for an event.
     */
    iconClsField: 'IconCls',
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * Returns an event store this event is part of. Event must be part
     * of an event store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        var me = this,
            result = me.joined && me.joined[0];
        if (result && !result.isEventStore) {
            // sort stores to avoid extra array walks in future
            Ext.Array.sort(me.joined, function(a, b) {
                return (a.isEventStore || false) > (b.isEventStore || false) && -1 || 1;
            });
            result = me.joined[0];
            // record can be joined to several stores none of which is an event store
            // e.g. if record is in viewmodel. test 025_eventstore
            result = result.isEventStore ? result : null;
        }
        return result;
    },
    /**
     * Returns a resource store this event uses as default resource store. Event must be part
     * of an event store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore}
     */
    getResourceStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },
    /**
     * Returns an assigment store this event uses as default assignment store. Event must be part
     * of an event store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },
    /**
     * Returns all resources assigned to an event.
     *
     * @return {Sch.model.Resource[]}
     */
    getResources: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.getResourcesForEvent(me) || [];
    },
    /**
     * @private
     */
    forEachResource: function(fn, scope) {
        var rs = this.getResources();
        for (var i = 0; i < rs.length; i++) {
            if (fn.call(scope || this, rs[i]) === false) {
                return;
            }
        }
    },
    /**
     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
     * with specified id.
     *
     * @param {String} resourceId (optional)
     * @return {Sch.model.Resource}
     */
    getResource: function(resourceId) {
        var me = this,
            result = null,
            eventStore = me.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        // Allow 0 as a valid resource id
        resourceId = resourceId == null ? me.getResourceId() : resourceId;
        if (eventStore && (resourceId === null || resourceId === undefined)) {
            result = eventStore.getResourcesForEvent(me);
            if (result.length == 1) {
                result = result[0];
            } else if (result.length > 1) {
                Ext.Error.raise("Event::getResource() is not applicable for events with multiple assignments, please use Event::getResources() instead.");
            } else {
                result = null;
            }
        } else if (resourceStore) {
            result = resourceStore.getModelById(resourceId);
        }
        return result;
    },
    /**
     * Sets the resource which the event should belong to.
     *
     * @param {Sch.model.Resource/Mixed} resource The new resource
     */
    setResource: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        eventStore && eventStore.removeAssignmentsForEvent(me);
        me.assign(resource);
    },
    /**
     * Assigns this event to the specified resource.
     *
     * @param {Sch.model.Resource/Mixed/Array} resource A new resource for this event, either as a full Resource record or an id (or an array of such).
     */
    assign: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
        // resource id might be 0 thus we use ? operator
        if (eventStore) {
            eventStore.assignEventToResource(me, resource);
        } else {
            me.setResourceId(resource);
        }
    },
    /**
     * Unassigns this event from the specified resource
     *
     * @param {Sch.model.Resource/Mixed/Array} [resource] The resource to unassign from.
     */
    unassign: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
        // resource id might be 0 thus we use ? operator
        if (eventStore) {
            eventStore.unassignEventFromResource(me, resource);
        } else if (me.getResourceId() == resource) {
            me.setResourceId(null);
        }
    },
    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Sch.model.Resource/Mixed} resource A resource to unassign from
     * @param {Sch.model.Resource/Mixed} resource A resource to assign to
     */
    reassign: function(oldResource, newResource) {
        var me = this,
            eventStore = me.getEventStore();
        oldResource = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource;
        // resource id might be 0 thus we use ? operator
        newResource = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource;
        // resource id might be 0 thus we use ? operator
        if (eventStore) {
            eventStore.reassignEventFromResourceToResource(me, oldResource, newResource);
        } else {
            me.setResourceId(newResource);
        }
    },
    /**
     * @method isAssignedTo
     * Returns true if this event is assigned to a certain resource.
     *
     * @param {Sch.model.Resource/Mixed} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo: function(resource) {
        var me = this,
            eventStore = me.getEventStore(),
            result = false;
        resource = resource instanceof Sch.model.Resource && resource.getId() || resource;
        if (eventStore) {
            result = eventStore.isEventAssignedToResource(me, resource);
        } else {
            result = me.getResourceId() == resource;
        }
        return result;
    },
    /**
     * Returns all assignments for the event. Event must be part of the store for this method to work.
     *
     * @return {Sch.model.Assignment[]}
     */
    getAssignments: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.getAssignmentsForEvent(me);
    },
    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */
    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable: function() {
        return this.getDraggable();
    },
    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */
    /**
     * @method getResourceId
     *
     * Returns the resource id of the resource that the event belongs to.
     * @return {Mixed} The resource Id
     */
    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable: function() {
        return this.getResizable();
    },
    /**
     * @method setResourceId
     *
     * Sets the new resource id of the resource that the event belongs to.
     * @param {Mixed} resourceId The resource Id
     */
    /**
     * Returns false if a linked resource is a phantom record, i.e. it's not persisted in the database.
     *
     * @return {Boolean} valid
     */
    isPersistable: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isEventPersistable(me);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.EventStore
@extends Ext.data.Store
@mixins Sch.data.mixin.EventStore

This is a class holding all the {@link Sch.model.Event events} to be rendered into a {@link Sch.SchedulerPanel scheduler panel}.
This class only accepts a model class inheriting from {@link Sch.model.Event}.
*/
Ext.define("Sch.data.EventStore", {
    extend: 'Ext.data.Store',
    alias: 'store.eventstore',
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.EventStore',
        'Robo.data.Store'
    ],
    storeId: 'events',
    model: 'Sch.model.Event',
    config: {
        model: 'Sch.model.Event'
    },
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.resourceStore && me.setResourceStore(me.resourceStore);
        me.assignmentStore && me.setAssignmentStore(me.assignmentStore);
        if (me.getModel() !== Sch.model.Event && !(me.getModel().prototype instanceof Sch.model.Event)) {
            throw 'The model for the EventStore must subclass Sch.model.Event';
        }
    },
    /**
     * Appends a new record to the store
     * @param {Sch.model.Event} record The record to append to the store
     */
    append: function(record) {
        this.add(record);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.utilization.UtilizationNegotiationStrategyMixin', {
    uses: [
        'Gnt.model.utilization.DefaultUtilizationNegotiationStrategy'
    ],
    utilizationNegotiationStrategyClass: 'Gnt.model.utilization.DefaultUtilizationNegotiationStrategy',
    utilizationNegotiationStrategy: null,
    initUtilizationNegotiationStrategyMixin: function(config) {
        var me = this;
        if (config && config.hasOwnProperty('utilizationNegotiationStrategy')) {
            me.utilizationNegotiationStrategy = config.utilizationNegotiationStrategy;
            delete config.utilizationNegotiationStrategy;
        } else {
            me.utilizationNegotiationStrategy = Ext.create(me.utilizationNegotiationStrategyClass);
        }
        return config;
    },
    getUtilizationNegotiationStrategy: function() {
        return this.utilizationNegotiationStrategy;
    },
    setUtilizationNegotiationStrategy: function(strategy) {
        var me = this;
        if (me.utilizationNegotiationStrategy !== strategy && strategy) {
            me.utilizationNegotiationStrategy = strategy;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.UtilizationEvent', {
    extend: 'Sch.model.Event',
    uses: [
        'Ext.Date',
        'Ext.Object',
        'Gnt.model.Resource',
        'Gnt.model.Assignment'
    ],
    mixins: [
        'Gnt.model.utilization.UtilizationNegotiationStrategyMixin'
    ],
    originalResource: null,
    originalAssignment: null,
    customizableFields: [
        {
            name: 'utilizationInfo',
            type: 'auto',
            persist: false,
            defaultValue: null
        }
    ],
    utilizationInfoField: 'utilizationInfo',
    constructor: function(config) {
        var me = this,
            originalResource, originalAssignment;
        config = me.initUtilizationNegotiationStrategyMixin(config);
        if (config.originalResource) {
            originalResource = config.originalResource;
            delete config.originalResource;
        }
        if (config.originalAssignment) {
            originalAssignment = config.originalAssignment;
            delete config.originalAssignment;
        }
        me.callParent(arguments);
        originalResource && me.setOriginalResource(originalResource);
        originalAssignment && me.setOriginalAssignment(originalAssignment);
    },
    /**
     * Returns true if this surrogate event designates an assignment
     *
     * @return {Boolean}
     */
    isSurrogateAssignment: function() {
        return !!this.originalAssignment;
    },
    /**
     * Returns true if this surrogate event designates an assignment summary for a resource
     *
     * @return {Boolean}
     */
    isSurrogateSummary: function() {
        return !!this.originalResource;
    },
    /**
     * Returns original assignment corresponding to this surrogate.
     *
     * @return {Gnt.model.Assignment|null}
     */
    getOriginalAssignment: function() {
        return this.originalAssignment;
    },
    /**
     * Sets original assignment corresponding to this surrogate.
     *
     * @param {Gnt.model.Assignment} assignment
     */
    setOriginalAssignment: function(assignment) {
        var me = this;
        if (me.originalAssignment !== assignment) {
            me.originalAssignment = assignment;
            if (!me.isInSyncWithOriginal()) {
                me.syncFromOriginal();
            }
        }
    },
    /**
     * Returns original resource corresponding to this surrogate.
     *
     * @return {Gnt.model.Resource|null}
     */
    getOriginalResource: function() {
        var me = this,
            resource = me.originalResource,
            assignment = me.originalAssignment;
        return resource || assignment && assignment.getResource() || null;
    },
    /**
     * Sets original resource corresponding to this surrogate.
     *
     * @param {Gnt.model.Resource} resource
     */
    setOriginalResource: function(resource) {
        var me = this;
        if (me.originalResource !== resource) {
            me.originalResource = resource;
            if (!me.isInSyncWithOriginal()) {
                me.syncFromOriginal();
            }
        }
    },
    /**
     * Returns original task corresponding to this surrogate.
     *
     * @return {Gnt.model.Task|null}
     */
    getOriginalTask: function() {
        var me = this,
            assignment = me.originalAssignment;
        return assignment && assignment.getTask() || null;
    },
    /**
     * Checks if this node is properly synchronized with original node.
     *
     * @return {Boolean}
     */
    isInSyncWithOriginal: function() {
        var me = this,
            result = true,
            assignment, resource, task, span, utilizationInfo;
        if (me.isSurrogateAssignment()) {
            assignment = me.getOriginalAssignment() , task = me.getOriginalTask();
            if (assignment) {
                result = result && (me.getId() == me.self.getSurrogateIdFor(assignment));
            }
            if (task && !task.isUnscheduled()) {
                result = result && (me.getStartDate() - me.adjustStartDateToTick(task.getStartDate()) === 0);
                result = result && (me.getEndDate() - me.adjustEndDateToTick(task.getEndDate()) === 0);
            }
        } else if (me.isSurrogateSummary()) {
            resource = me.getOriginalResource();
            span = me.calculateSurrogateSummaryTimeSpan();
            result = result && (me.getId() == me.self.getSurrogateIdFor(resource));
            result = result && (me.getStartDate() - span.startDate === 0);
            result = result && (me.getEndDate() - span.endDate === 0);
        } else {
            Ext.Error.raise('Unknown surrogate type');
            // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
            var foo = false;
        }
        // Utilization info calculation takes considerable amount of time, thus we check it only if previous checks
        // has passed, not some utilization negotiation strategies might cache previously calculated information,
        // thus this code might not be too slow
        if (result) {
            utilizationInfo = me.getUtilizationNegotiationStrategy().getUtilizationInfoForUtilizationEvent(me);
            result = Ext.Object.equals(me.getUtilizationInfo(), utilizationInfo);
        }
        return result;
    },
    /**
     * Updates the record from original record(s)
     */
    syncFromOriginal: function() {
        var me = this,
            assignment, resource, task, span, utilizationInfo;
        me.beginEdit();
        if (me.isSurrogateAssignment()) {
            assignment = me.getOriginalAssignment() , task = me.getOriginalTask();
            if (assignment) {
                me.setId(me.self.getSurrogateIdFor(assignment));
            }
            if (task && !task.isUnscheduled()) {
                me.setStartEndDate(me.adjustStartDateToTick(task.getStartDate()), me.adjustEndDateToTick(task.getEndDate()));
            }
        } else if (me.isSurrogateSummary()) {
            resource = me.getOriginalResource();
            if (resource) {
                me.setId(me.self.getSurrogateIdFor(resource));
            }
            span = me.calculateSurrogateSummaryTimeSpan();
            me.setStartEndDate(span.startDate, span.endDate);
        }
        // Some strategies might cache the utilization information, thus this might not take too much time.
        utilizationInfo = me.getUtilizationNegotiationStrategy().getUtilizationInfoForUtilizationEvent(me);
        if (!Ext.Object.equals(me.getUtilizationInfo(), utilizationInfo)) {
            me.setUtilizationInfo(utilizationInfo);
        }
        me.endEdit();
    },
    getUtilizationInfo: function() {
        var me = this,
            info = me.get(me.utilizationInfoField);
        if (!info) {
            info = me.getUtilizationNegotiationStrategy().getUtilizationInfoForUtilizationEvent(me);
            me.set(me.utilizationInfoField, info);
        }
        return info;
    },
    /**
     * Updates original record with values from surrogate
     */
    syncToOriginal: function() {
        var me = this,
            task;
        if (me.isSurrogateAssignment()) {
            task = me.getOriginalTask();
            if (task) {
                task.setStartEndDate(me.getStartDate(), me.getEndDate(), true);
            }
        }
    },
    /**
     * Checks if this node is properly synchronized with similar surrogate node.
     *
     * @param {MyApp.model.UtilizationEvent} surrogateEvent
     * @return {Boolean}
     */
    isInSyncWithSurrogate: function(surrogateEvent) {
        var me = this;
        return me.getOriginalResource() === surrogateEvent.getOriginalResource() && me.getOriginalAssignment() === surrogateEvent.getOriginalAssignment() && me.getId() === surrogateEvent.getId() && me.getStartDate() - surrogateEvent.getStartDate() === 0 && me.getEndDate() - surrogateEvent.getEndDate() === 0 && Ext.Object.equals(me.getUtilizationInfo(), surrogateEvent.getUtilizationInfo());
    },
    /**
     * Updates the record from similar surrogate record
     *
     * @param {MyApp.model.UtilizationEvent} surrogateEvent
     */
    syncFromSurrogate: function(surrogateEvent) {
        var me = this;
        me.originalResource = surrogateEvent.originalResource;
        // direct property access is intentional here
        me.originalAssignment = surrogateEvent.originalAssignment;
        // direct property access is intentional here
        me.beginEdit();
        me.setId(surrogateEvent.getId());
        me.setStartEndDate(surrogateEvent.getStartDate(), surrogateEvent.getEndDate());
        // Objects are compared by reference by default, so we can't rely on default set() method logic to check
        // if the value is the same.
        if (!Ext.Object.equals(me.getUtilizationInfo(), surrogateEvent.getUtilizationInfo())) {
            me.setUtilizationInfo(surrogateEvent.getUtilizationInfo());
        }
        me.endEdit();
    },
    /**
     * Returns an utilization info for this surrogate event for particular interval during which the event designating
     * an assignment or assignment summary lasts. Which intervals are defined for the event depend on event start/end
     * dates and ticks which are used by event's utilization info calculation strategy. Default strategy
     * {@link MyApp.model.UtilizationRecord.DefaultUtilizationNegotiationStrategy} uses daily intervals
     * (which start at the beginning of a day), other strategies might use different ticks. Programmer must know
     * the context, i.e. strategy, in which the particular surrogate event record is used to properly use this method.
     *
     * @param {Date} intervalStartDate
     * @return {Object}  info
     * @return {Boolean} info.isUtilized
     * @return {Number}  info.allocationMs
     * @return {Number}  info.allocationDeltaMs
     * @return {Boolean} info.isOverallocated
     * @return {Boolean} info.isUnderallocated
     */
    getUtilizationInfoForInterval: function(intervalStartDate) {
        var me = this;
        return me.getUtilizationNegotiationStrategy().getUtilizationInfoForAssignmentEventInterval(me, intervalStartDate);
    },
    /**
     * Iterates over intervals defined for this surrogate event calling callback for each
     *
     * @param {Function} callback
     * @param {Date} callback.intervalStartDate
     * @param {Date} callback.intervalEndDate
     */
    forEachInterval: function(callback) {
        var me = this;
        return me.getUtilizationNegotiationStrategy().forEachTimeSpanInterval(me, callback);
    },
    calculateSurrogateSummaryTimeSpan: function() {
        var me = this;
        return me.getUtilizationNegotiationStrategy().calculateResourceAssignmentsTimespan(me.getOriginalResource());
    },
    adjustStartDateToTick: function(date) {
        var me = this;
        return me.getUtilizationNegotiationStrategy().adjustStartDateToTick(date);
    },
    adjustEndDateToTick: function(date) {
        var me = this;
        return me.getUtilizationNegotiationStrategy().adjustEndDateToTick(date);
    },
    clone: function(session) {
        var me = this,
            clone = me.callParent([
                session
            ]);
        clone.setUtilizationNegotiationStrategy(me.getUtilizationNegotiationStrategy());
        return clone;
    },
    inheritableStatics: {
        /**
         * Returns id for a surrogate record corresponding to original assignment or resource record
         *
         * @return {String}
         */
        getSurrogateIdFor: function(record) {
            var id = record.getId();
            if (record instanceof Gnt.model.Resource) {
                id = 'resource-' + id;
            } else if (record instanceof Gnt.model.Assignment) {
                id = 'assignment-' + id;
            } else {
                Ext.Error.raise('Wrong original record type');
                // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
                var foo = false;
            }
            return id;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.data.ResourceUtilizationEventStore', {
    extend: 'Sch.data.EventStore',
    model: 'Gnt.model.UtilizationEvent',
    storeId: null,
    /**
     * Returns this store (utilization information) model which corresponding to particular original model a resource or
     * an assignment.
     *
     * @param {Gnt.model.Resource|Gnt.model.Assignment} originalModel
     * @return {Gnt.model.UtilizationResource}
     */
    getModelByOriginal: function(originalModel) {
        var me = this;
        return me.getModelById(me.model.getSurrogateIdFor(originalModel));
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// TreeStore doesn't support rejectChanges very well
// https://www.sencha.com/forum/showthread.php?300339-rejectChanges-doesn-t-work-for-TreeStore-added-removed-records&p=1097116#post1097116
Ext.define('Sch.patches.TreeStore', {
    extend: 'Sch.util.Patch',
    target: 'Ext.data.TreeStore',
    minVersion: '5.1.0',
    overrides: {
        getRejectRecords: function() {
            return this.getModifiedRecords();
        },
        rejectChanges: function() {
            this.removed = this.removedNodes;
            this.callParent(arguments);
        },
        remove: function(node) {
            if (node.isModel) {
                node.remove();
            } else if (node instanceof Array && node[0].isModel) {
                for (var i = 0; i < node.length; i++) node[i].remove();
            } else {
                this.callParent(arguments);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// byInternalIdMap is removed from 5.1.1 and it is widely used in projection mechanism
Ext.define('Sch.patches.TreeStoreInternalIdMap', {
    extend: 'Sch.util.Patch',
    target: 'Ext.data.TreeStore',
    minVersion: '5.1.1',
    overrides: {
        registerNode: function(node, includeChildren) {
            var me = this;
            if (!me.byInternalIdMap) {
                me.byInternalIdMap = {};
            }
            me.byInternalIdMap[node.internalId] = node;
            me.callParent(arguments);
        },
        unregisterNode: function(node, includeChildren) {
            var me = this;
            if (me.byInternalIdMap) {
                delete me.byInternalIdMap[node.internalId];
            }
            me.callParent(arguments);
        },
        updateRoot: function() {
            this.byInternalIdMap = {};
            this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.mixin.FilterableTreeStore

This is a mixin for the Ext.data.TreeStore providing filtering functionality.

The functionality of this class can be divided into two sections:

Filtering
=========

Filtering of a tree store is different from filtering flat stores. In a flat store, all nodes (items)
are of the same type and on the same hierarchical level. Filtering can hide any nodes that not matching some criteria.

On the other hand, in tree stores some of the nodes represent parent nodes with child nodes
("parent", "folder", "group" etc) and other nodes are "leaves". And usually a "leaf" node can't be
sufficiently identified w/o its parents - i.e. it is important to know all the parents that
a particular leaf node belongs to. So when filtering tree stores, we need to show all parent nodes of the filtered nodes.

Moreover, filtering is usually being used for searching and thus should ignore the "expanded/collapsed"
state of tree nodes (we need to search among all nodes, including collapsed ones).

Filtering can be activated with the {@link #filterTreeBy} method and cleared with {@link #clearTreeFilter}.

Hiding/Showing nodes
====================

Sometimes we want to keep some nodes in the tree, but remove them from the visual presentation and hide them.
This can be done with {@link #hideNodesBy} method and {@link #showAllNodes} can be used to restore the previous state.
When a node is hidden, all its child nodes are hidden too.

"Hidden" nodes will never appear in filtered results - consider them removed from the tree store completely.
They will, however, appear in a data package for a `store.sync()` operation (you can override the the "filterUpdated" method to exclude them from there if needed).

Note, that it is possible to filter a store with hidden nodes, but not the other way around (hide some nodes of a filtered store).

*/
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    isFilteredFlag: false,
    isHiddenFlag: false,
    treeFilter: null,
    // ref to the last filter applied
    lastTreeFilter: null,
    lastTreeHiding: null,
    /**
     * @cfg {Boolean} allowExpandCollapseWhileFiltered When enabled (by default), tree store allows user to expand/collapse nodes while it is
     * filtered with the {@link #filterTreeBy} method. Please set it explicitly to `false` to restore the previous behavior,
     * where collapse/expand operations were disabled.
     */
    allowExpandCollapseWhileFiltered: true,
    /**
     * @cfg {Boolean} reApplyFilterOnDataChange When enabled (by default), tree store will update the filtering (both {@link #filterTreeBy}
     * and {@link #hideNodesBy}) after new data is added to the tree or removed from it. Please set it explicitly to `false` to restore the previous behavior,
     * where this feature did not exist.
     */
    reApplyFilterOnDataChange: true,
    suspendIncrementalFilterRefresh: 0,
    filterGeneration: 0,
    currentFilterGeneration: null,
    dataChangeListeners: null,
    monitoringDataChange: false,
    filterUpdateSuspended: false,
    onClassMixedIn: function(cls) {
        cls.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {});
    },
    // Events (private)
    //    'filter-set',
    //    'filter-clear',
    //    'nodestore-datachange-start',
    //    'nodestore-datachange-end'
    /**
     * Should be called in the constructor of the consuming class, to activate the filtering functionality.
     */
    initTreeFiltering: function() {
        this.treeFilter = new Ext.util.Filter({
            filterFn: this.isNodeFilteredIn,
            scope: this
        });
        this.dataChangeListeners = {
            nodeappend: this.onNeedToUpdateFilter,
            nodeinsert: this.onNeedToUpdateFilter,
            scope: this
        };
        // in Ext 5.1.1 sencha apparently fixed some issue and now each 'endupdate' on filters
        // lead to view refresh. When store is loading, filter is applied to each record and each time view is refreshed.
        // This code suspend filters until 'load' event is fired
        Ext.apply(this.dataChangeListeners, {
            beforeload: this.onStoreBeforeLoad,
            load: this.onStoreLoad
        });
    },
    onStoreBeforeLoad: function() {
        this.filterUpdateSuspended = true;
    },
    onStoreLoad: function() {
        this.filterUpdateSuspended = false;
        this.onNeedToUpdateFilter();
    },
    startDataChangeMonitoring: function() {
        if (this.monitoringDataChange)  {
            return;
        }
        
        this.monitoringDataChange = true;
        this.on(this.dataChangeListeners);
    },
    stopDataChangeMonitoring: function() {
        if (!this.monitoringDataChange)  {
            return;
        }
        
        this.monitoringDataChange = false;
        this.un(this.dataChangeListeners);
    },
    onNeedToUpdateFilter: function() {
        if (this.reApplyFilterOnDataChange && !this.filterUpdateSuspended && !this.suspendIncrementalFilterRefresh)  {
            this.reApplyFilter();
        }
        
    },
    /**
     * Clears the current filter (if any).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    clearTreeFilter: function() {
        if (!this.isTreeFiltered())  {
            return;
        }
        
        this.currentFilterGeneration = null;
        this.isFilteredFlag = false;
        this.lastTreeFilter = null;
        if (!this.isTreeFiltered(true))  {
            this.stopDataChangeMonitoring();
        }
        
        this.refreshNodeStoreContent();
        this.fireEvent('filter-clear', this);
    },
    reApplyFilter: function() {
        // bypass the nodeStore content refresh if store has both hiding and filtering
        if (this.isHiddenFlag)  {
            this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag));
        }
        
        if (this.isFilteredFlag)  {
            this.filterTreeBy(this.lastTreeFilter);
        }
        
    },
    refreshNodeStoreContent: function() {
        var me = this,
            filters = me.getFilters();
        if (filters.indexOf(me.treeFilter) < 0) {
            me.addFilter(me.treeFilter);
        } else {
            this.getFilters().fireEvent('endupdate', this.getFilters());
        }
    },
    getIndexInTotalDataset: function(record) {
        var root = this.getRootNode(),
            index = -1;
        var rootVisible = this.rootVisible;
        if (!rootVisible && record == root)  {
            return -1;
        }
        
        var isFiltered = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;
        var collectNodes = function(node) {
                if (isFiltered && node.__filterGen != currentFilterGeneration || node.hidden)  {
                    // stop scanning if record we are looking for is hidden
                    if (node == record)  {
                        return false;
                    }
                    ;
                }
                
                if (rootVisible || node != root)  {
                    index++;
                }
                
                // stop scanning if we found the record
                if (node == record)  {
                    return false;
                }
                
                if (!node.isLeaf() && node.isExpanded()) {
                    var childNodes = node.childNodes,
                        length = childNodes.length;
                    for (var k = 0; k < length; k++) if (collectNodes(childNodes[k]) === false)  {
                        return false;
                    }
                    ;
                }
            };
        collectNodes(root);
        return index;
    },
    /**
     * Returns true if this store is currently filtered
     *
     * @return {Boolean}
     */
    isTreeFiltered: function(orHasHiddenNodes) {
        return this.isFilteredFlag || orHasHiddenNodes && this.isHiddenFlag;
    },
    markFilteredNodes: function(top, params) {
        var me = this;
        var filterGen = this.currentFilterGeneration;
        var visibleNodes = {};
        var root = this.getRootNode(),
            rootVisible = this.rootVisible;
        var includeParentNodesInResults = function(node) {
                var parent = node.parentNode;
                while (parent && !visibleNodes[parent.internalId]) {
                    visibleNodes[parent.internalId] = true;
                    parent = parent.parentNode;
                }
            };
        var filter = params.filter;
        var scope = params.scope || this;
        var shallowScan = params.shallow;
        var checkParents = params.checkParents || shallowScan;
        var fullMatchingParents = params.fullMatchingParents;
        var onlyParents = params.onlyParents || fullMatchingParents;
        var isNewFilter = !params.isOldFilter;
        //  If this filter is a reapplied filter or a brand new
        if (onlyParents && checkParents)  {
            throw new Error("Can't combine `onlyParents` and `checkParents` options");
        }
        
        if (rootVisible)  {
            visibleNodes[root.internalId] = true;
        }
        
        var collectNodes = function(node) {
                if (node.hidden)  {
                    return;
                }
                
                var nodeMatches, childNodes, length, k;
                // `collectNodes` should not be called for leafs at all
                if (node.isLeaf()) {
                    if (filter.call(scope, node, visibleNodes)) {
                        visibleNodes[node.internalId] = true;
                        includeParentNodesInResults(node);
                    }
                } else {
                    if (onlyParents) {
                        nodeMatches = filter.call(scope, node);
                        childNodes = node.childNodes;
                        length = childNodes.length;
                        if (nodeMatches) {
                            visibleNodes[node.internalId] = true;
                            includeParentNodesInResults(node);
                            // if "fullMatchingParents" option enabled we gather all matched parent's sub-tree
                            if (fullMatchingParents) {
                                node.cascadeBy(function(currentNode) {
                                    visibleNodes[currentNode.internalId] = true;
                                });
                                return;
                            }
                        }
                        // at this point nodeMatches and fullMatchingParents can't be both true
                        for (k = 0; k < length; k++) if (nodeMatches && childNodes[k].isLeaf())  {
                            visibleNodes[childNodes[k].internalId] = true;
                        }
                        else if (!childNodes[k].isLeaf())  {
                            collectNodes(childNodes[k]);
                        }
                        ;
                    } else {
                        // mark matching nodes to be kept in results
                        if (checkParents) {
                            nodeMatches = filter.call(scope, node, visibleNodes);
                            if (nodeMatches) {
                                visibleNodes[node.internalId] = true;
                                includeParentNodesInResults(node);
                            }
                        }
                        // recurse if
                        // - we don't check parents
                        // - shallow scan is not enabled
                        // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                        if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                            childNodes = node.childNodes;
                            length = childNodes.length;
                            for (k = 0; k < length; k++) collectNodes(childNodes[k]);
                        }
                    }
                }
            };
        collectNodes(top);
        // additional filtering of the result set
        // removes parent nodes which do not match filter themselves and have no matching children
        root.cascadeBy(function(node) {
            if (isNewFilter) {
                node.addedWhileFiltered = false;
            }
            if (visibleNodes[node.internalId]) {
                node.__filterGen = filterGen;
                if (me.allowExpandCollapseWhileFiltered && !node.isLeaf())  {
                    node.expand();
                }
                
            }
        });
    },
    /**
     * This method filters the tree store. It accepts an object with the following properties:
     *
     * - `filter` - a function to check if a node should be included in the result. It will be called for each **leaf** node in the tree and will receive the current node as the first argument.
     * It should return `true` if the node should remain visible, `false` otherwise. The result will also contain all parents nodes of all matching leafs. Results will not include
     * parent nodes, which do not have at least one matching child.
     * To call this method for parent nodes too, pass an additional parameter - `checkParents` (see below).
     * - `scope` - a scope to call the filter with (optional)
     * - `checkParents` - when set to `true` will also call the `filter` function for each parent node. If the function returns `false` for some parent node,
     * it could still be included in the filtered result if some of its children match the `filter` (see also "shallow" option below). If the function returns `true` for a parent node, it will be
     * included in the filtering results even if it does not have any matching child nodes.
     * - `shallow` - implies `checkParents`. When set to `true`, it will stop checking child nodes if the `filter` function return `false` for a parent node. The whole sub-tree, starting
     * from a non-matching parent, will be excluded from the result in such case.
     * - `onlyParents` - alternative to `checkParents`. When set to `true` it will only call the provided `filter` function for parent tasks. If
     * the filter returns `true`, the parent and all its direct child leaf nodes will be included in the results. If the `filter` returns `false`, a parent node still can
     * be included in the results (w/o direct children leafs), if some of its child nodes matches the filter.
     * - `fullMatchingParents` - implies `onlyParents`. In this mode, if a parent node matches the filter, then not only its direct children
     * will be included in the results, but the whole sub-tree, starting from the matching node.
     *
     * Repeated calls to this method will clear previous filters.
     *
     * This function can be also called with 2 arguments, which should be the `filter` function and `scope` in such case.
     *
     * For example:

    treeStore.filterTreeBy({
        filter          : function (node) { return node.get('name').match(/some regexp/) },
        checkParents    : true
    })

    // or, if you don't need to set any options:
    treeStore.filterTreeBy(function (node) { return node.get('name').match(/some regexp/) })

     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Object} params
     */
    filterTreeBy: function(params, scope) {
        this.currentFilterGeneration = this.filterGeneration++;
        var filter;
        if (arguments.length == 1 && Ext.isObject(arguments[0])) {
            scope = params.scope;
            filter = params.filter;
        } else {
            filter = params;
            params = {
                filter: filter,
                scope: scope
            };
        }
        this.fireEvent('nodestore-datachange-start', this);
        params = params || {};
        this.markFilteredNodes(this.getRootNode(), params);
        params.isOldFilter = true;
        this.startDataChangeMonitoring();
        this.isFilteredFlag = true;
        this.lastTreeFilter = params;
        //this.fireEvent('clear', this);
        this.fireEvent('nodestore-datachange-end', this);
        this.fireEvent('filter-set', this);
        this.refreshNodeStoreContent();
    },
    isNodeFilteredIn: function(node) {
        var isFiltered = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;
        return this.loading || // If node was added with active filter, it should always be shown if (reApplyFilterOnDataChange) until
        // the next call to filterTreeBy
        (node.addedWhileFiltered && node.isVisible()) || !Boolean(isFiltered && node.__filterGen != currentFilterGeneration || node.hidden);
    },
    hasNativeFilters: function() {
        var me = this,
            filters = me.getFilters(),
            count = filters.getCount();
        return (count && count > 1) || filters.indexOf(me.treeFilter) < 0;
    },
    /**
     * Hide nodes from the visual presentation of tree store (they still remain in the store).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Function} filter - A filtering function. Will be called for each node in the tree store and receive
     * the current node as the 1st argument. Should return `true` to **hide** the node
     * and `false`, to **keep it visible**.
     * @param {Object} scope (optional).
     */
    hideNodesBy: function(filter, scope, skipNodeStoreRefresh) {
        var me = this;
        if (me.isFiltered() && me.hasNativeFilters())  {
            throw new Error("Can't hide nodes of a filtered tree store");
        }
        
        scope = scope || me;
        me.getRootNode().cascadeBy(function(node) {
            node.hidden = Boolean(filter.call(scope, node, me));
        });
        me.startDataChangeMonitoring();
        me.isHiddenFlag = true;
        me.lastTreeHiding = [
            filter,
            scope
        ];
        if (!skipNodeStoreRefresh)  {
            me.refreshNodeStoreContent();
        }
        
    },
    /**
     * Shows all nodes that was previously hidden with {@link #hideNodesBy}
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    showAllNodes: function(skipNodeStoreRefresh) {
        this.getRootNode().cascadeBy(function(node) {
            node.hidden = false;
        });
        this.isHiddenFlag = false;
        this.lastTreeHiding = null;
        if (!this.isTreeFiltered(true))  {
            this.stopDataChangeMonitoring();
        }
        
        if (!skipNodeStoreRefresh)  {
            this.refreshNodeStoreContent();
        }
        
    },
    inheritables: function() {
        return {
            // @OVERRIDE
            onNodeExpand: function(parent) {
                if (this.isTreeFiltered(true) && parent == this.getRoot()) {
                    this.callParent(arguments);
                    // the expand of the root node - most probably its the data loading
                    this.reApplyFilter();
                } else  {
                    return this.callParent(arguments);
                }
                
            },
            // @OVERRIDE
            onNodeCollapse: function(parent, records) {
                var me = this;
                var data = me.data;
                var prevContains = data.contains;
                var isFiltered = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;
                // the default implementation of `onNodeCollapse` only checks if the 1st record from collapsed nodes
                // exists in the node store. Meanwhile, that 1st node can be hidden, so we need to check all of them
                // thats what we do in the `for` loop below
                // then, if we found a node, we want to do actual removing of nodes and we override the original code from NodeStore
                // by always returning `false` from our `data.contains` override
                data.contains = function() {
                    var node, sibling, lastNodeIndexPlus;
                    var collapseIndex = me.indexOf(parent) + 1;
                    var found = false;
                    for (var i = 0; i < records.length; i++) if (!(records[i].hidden || isFiltered && records[i].__filterGen != currentFilterGeneration) && prevContains.call(this, records[i])) {
                        // this is our override for internal part of `onNodeCollapse` method
                        // Calculate the index *one beyond* the last node we are going to remove
                        // Need to loop up the tree to find the nearest view sibling, since it could
                        // exist at some level above the current node.
                        node = parent;
                        while (node.parentNode) {
                            sibling = node;
                            do {
                                sibling = sibling.nextSibling;
                            } while (sibling && (sibling.hidden || isFiltered && sibling.__filterGen != currentFilterGeneration));
                            if (sibling) {
                                found = true;
                                lastNodeIndexPlus = me.indexOf(sibling);
                                break;
                            } else {
                                node = node.parentNode;
                            }
                        }
                        if (!found) {
                            lastNodeIndexPlus = me.getCount();
                        }
                        // Remove the whole collapsed node set.
                        me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
                        break;
                    };
                    // always return `false`, so original NodeStore code won't execute
                    return false;
                };
                this.callParent(arguments);
                /* HACK in case no records are deemed visible we need to handle things ourselves */
                if (this.isTreeFiltered()) {
                    if (me.needsLocalFilter()) {
                        records = Ext.Array.filter(records, me.filterVisible);
                    }
                    // 'parent' can be filtered out, in such case we don't need to remove anything
                    // covered by 124_tree_filter
                    if (!records.length && me.indexOf(parent) !== -1) {
                        var collapseIndex = me.indexOf(parent) + 1;
                        var lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);
                        me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
                    }
                }
                data.contains = prevContains;
            },
            // @OVERRIDE
            handleNodeExpand: function(parent, records, toAdd) {
                var me = this;
                var visibleRecords = [];
                var isFiltered = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    if (!(isFiltered && record.__filterGen != currentFilterGeneration || record.hidden)) {
                        visibleRecords[visibleRecords.length] = record;
                    }
                }
                return this.callParent([
                    parent,
                    visibleRecords,
                    toAdd
                ]);
            },
            // @OVERRIDE
            onNodeInsert: function(parent, node, index) {
                var me = this,
                    refNode, sibling, storeReader, nodeProxy, nodeReader, reader,
                    data = node.raw || node.data,
                    removed = me.removedNodes,
                    dataRoot, isVisible, childType,
                    isTreeFiltered = this.isTreeFiltered();
                if (me.filterFn) {
                    isVisible = me.filterFn(node);
                    node.set('visible', isVisible);
                    // If a node which passes the filter is added to a parent node
                    if (isVisible) {
                        parent.set('visible', me.filterFn(parent));
                    }
                }
                if (!this.reApplyFilterOnDataChange && isTreeFiltered) {
                    node.addedWhileFiltered = true;
                }
                // Register node by its IDs
                me.registerNode(node, true);
                me.beginUpdate();
                // Only react to a node append if it is to a node which is expanded.
                if (me.isVisible(node) || (isTreeFiltered && node.addedWhileFiltered)) {
                    if (index === 0 || !node.previousSibling) {
                        refNode = parent;
                    } else {
                        // Find the previous visible sibling (filtering may have knocked out intervening nodes)
                        for (sibling = node.previousSibling; sibling && !sibling.addedWhileFiltered && !sibling.get('visible'); sibling = sibling.previousSibling){}
                        if (!sibling) {
                            refNode = parent;
                        } else {
                            while (sibling.isExpanded() && sibling.lastChild) {
                                sibling = sibling.lastChild;
                            }
                            // The chosen sibling here might be filtered out too
                            for (; sibling && !sibling.addedWhileFiltered && !sibling.get('visible'); sibling = sibling.previousSibling){}
                            refNode = sibling;
                        }
                    }
                    // The reaction to collection add joins the node to this Store
                    me.insert(me.indexOf(refNode) + 1, node);
                    if (!node.isLeaf() && node.isExpanded()) {
                        if (node.isLoaded()) {
                            // Take a shortcut
                            me.onNodeExpand(node, node.childNodes);
                        } else if (!me.fillCount) {
                            // If the node has been marked as expanded, it means the children
                            // should be provided as part of the raw data. If we're filling the nodes,
                            // the children may not have been loaded yet, so only do this if we're
                            // not in the middle of populating the nodes.
                            node.set('expanded', false);
                            node.expand();
                        }
                    }
                }
                // Set sync flag if the record needs syncing.
                //else {
                //    me.needsSync = me.needsSync || node.phantom || node.dirty;
                //}
                // In case the node was removed and added to the removed nodes list.
                Ext.Array.remove(removed, node);
                // New nodes mean we need a sync if those nodes are phantom or dirty (have client-side only information)
                me.needsSync = me.needsSync || node.phantom || node.dirty;
                if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
                    // With heterogeneous nodes, different levels may require differently configured readers to extract children.
                    // For example a "Disk" node type may configure it's proxy reader with root: 'folders', while a "Folder" node type
                    // might configure its proxy reader with root: 'files'. Or the root property could be a configured-in accessor.
                    storeReader = me.getProxy().getReader();
                    nodeProxy = node.getProxy();
                    nodeReader = nodeProxy ? nodeProxy.getReader() : null;
                    // If the node's reader was configured with a special root (property name which defines the children array) use that.
                    reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
                    dataRoot = reader.getRoot(data);
                    if (dataRoot) {
                        childType = node.childType;
                        me.fillNode(node, reader.extractData(dataRoot, childType ? {
                            model: childType
                        } : undefined));
                    }
                }
                me.endUpdate();
            },
            isFiltered: function() {
                return this.callParent(arguments) || this.isTreeFiltered();
            },
            afterEdit: function(node, modifiedFieldNames) {
                var me = this;
                // In Ext 6.0.2 sencha decided that tree should be filtered again after data is changed
                // Prior to 6.0.2 they used to apply filter only to new node
                if (Ext.getVersion().isGreaterThan('6.0.2')) {
                    if (me.needsLocalFilter()) {
                        me.doFilter(node);
                    }
                    me.superclass.superclass.afterEdit.apply(me, [
                        node,
                        modifiedFieldNames
                    ]);
                } else {
                    return me.callParent([
                        node,
                        modifiedFieldNames
                    ]);
                }
            }
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.data.ResourceTreeStore
 * @extends Ext.data.TreeStore
 * @mixin Sch.data.mixin.FilterableTreeStore
 *
 * This is a class holding all the resources to be rendered into a {@link Sch.panel.SchedulerTree}. It is a subclass of "Ext.data.TreeStore" - a store containing hierarchical data.
 *
 * Filtering capabilities are provided by {@link Sch.data.mixin.FilterableTreeStore}, please refer to its documentation for additional information.
 */
Ext.define("Sch.data.ResourceTreeStore", {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Sch.patches.TreeStore',
        'Sch.patches.TreeStoreInternalIdMap'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore',
        'Sch.data.mixin.FilterableTreeStore',
        'Robo.data.Store'
    ],
    alias: 'store.resourcetreestore',
    model: 'Sch.model.Resource',
    storeId: 'resources',
    constructor: function() {
        this.callParent(arguments);
        this.initTreeFiltering();
        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceTreeStore must subclass Sch.model.Resource';
        }
    },
    setRootNode: function() {
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        this.isSettingRoot = true;
        var res = this.callParent(arguments);
        this.isSettingRoot = false;
        return res;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.UtilizationResource', {
    extend: 'Sch.model.Resource',
    requires: [
        'Ext.data.NodeInterface'
    ],
    uses: [
        'Gnt.model.Resource',
        'Gnt.model.Assignment'
    ],
    customizableFields: [
        {
            name: 'TaskName'
        },
        {
            name: 'TaskSequenceNumber'
        }
    ],
    taskNameField: 'TaskName',
    taskSequenceNumberField: 'TaskSequenceNumber',
    originalResource: null,
    originalAssignment: null,
    /**
     * @constructor
     */
    constructor: function(cfg) {
        var me = this,
            originalResource, originalAssignment;
        if (cfg.originalResource) {
            originalResource = cfg.originalResource;
            delete cfg.originalResource;
        }
        if (cfg.originalAssignment) {
            originalAssignment = cfg.originalAssignment;
            delete cfg.originalAssignment;
        }
        me.callParent(arguments);
        originalResource && me.setOriginalResource(originalResource);
        originalAssignment && me.setOriginalAssignment(originalAssignment);
    },
    /**
     * Returns original resource corresponding to this surrogate.
     *
     * @return {Gnt.model.Resource|null}
     */
    getOriginalResource: function() {
        return this.originalResource || this.originalAssignment && this.originalAssignment.getResource();
    },
    /**
     * Sets original resource corresponding to this surrogate.
     *
     * @param {Gnt.model.Resource} resource
     */
    setOriginalResource: function(resource) {
        var me = this;
        if (me.originalResource !== resource) {
            me.originalResource = resource;
            if (!me.isInSyncWithOriginal()) {
                me.syncFromOriginal();
            }
        }
    },
    /**
     * Returns original assignment corresponding to this surrogate.
     *
     * @return {Gnt.model.Assignment|null}
     */
    getOriginalAssignment: function() {
        return this.originalAssignment;
    },
    /**
     * Sets original assignment corresponding to this surrogate.
     *
     * @param {Gnt.model.Assignment} resource
     */
    setOriginalAssignment: function(assignment) {
        var me = this;
        if (me.originalAssignment !== assignment) {
            me.originalAssignment = assignment;
            if (!me.isInSyncWithOriginal()) {
                me.syncFromOriginal();
            }
        }
    },
    /**
     * Returns original task corresponding to this surrogate.
     *
     * @return {Gnt.model.Task|null}
     */
    getOriginalTask: function() {
        var assignment = this.getOriginalAssignment();
        return assignment && assignment.getTask() || null;
    },
    /**
     * Checks whether this node represents a surrogate resource
     *
     * @return {Boolean}
     */
    isSurrogateResource: function() {
        return !this.getOriginalAssignment();
    },
    /**
     * Checks whether this node represents a surrogate assignment
     *
     * @return {Boolean}
     */
    isSurrogateAssignment: function() {
        return !!this.getOriginalAssignment();
    },
    /**
     * Checks if this node is properly synchronized with original node.
     *
     * @return {Boolean}
     */
    isInSyncWithOriginal: function() {
        var me = this,
            resource = me.getOriginalResource(),
            // Name, Id
            assignment = me.getOriginalAssignment(),
            // Id
            task = me.getOriginalTask(),
            // Name, Sequence number
            result = true;
        if (assignment) {
            result = result && (me.getId() == me.self.getSurrogateIdFor(assignment));
            if (task) {
                result = result && (me.getTaskName() == task.getName());
                result = result && (me.getTaskSequenceNumber() == task.getSequenceNumber());
            }
        } else if (resource) {
            result = result && (me.getId() == me.self.getSurrogateIdFor(resource));
            result = result && (me.getName() == resource.getName());
        }
        return result;
    },
    /**
     * Updates the record from original record(s)
     */
    syncFromOriginal: function() {
        var me = this,
            resource = me.getOriginalResource(),
            assignment = me.getOriginalAssignment(),
            task = me.getOriginalTask();
        me.beginEdit();
        if (resource && !assignment) {
            me.setId(me.self.getSurrogateIdFor(resource));
        }
        if (assignment && !resource) {
            me.setId(me.self.getSurrogateIdFor(assignment));
        }
        if (resource) {
            me.setName(resource.getName());
        }
        if (task) {
            me.setTaskName(task.getName());
            me.setTaskSequenceNumber(task.getSequenceNumber());
        }
        me.endEdit();
    },
    /**
     * Updates original record with values from surrogate
     */
    syncToOriginal: function() {
        Ext.Error.raise('Not implemented');
        // @TODO #2773 - Rhyno parse error - Syntax error while building the app
        var foo = false;
    },
    /**
     * Checks if this node is properly synchronized with similar surrogate node.
     *
     * @param {Gnt.model.UtilizationResource} surrogateRecord
     * @return {Boolean}
     */
    isInSyncWithSurrogate: function(surrogateRecord) {
        var me = this;
        return me.originalResource === surrogateRecord.originalResource && me.originalAssignment === surrogateRecord.originalAssignment && me.getName() === surrogateRecord.getName() && me.getTaskName() === surrogateRecord.getTaskName() && me.getTaskSequenceNumber() === surrogateRecord.getTaskSequenceNumber();
    },
    /**
     * Updates the record from similar surrogate record
     *
     * @param {MyApp.model.UtilizationResoure} surrogateRecord
     */
    syncFromSurrogate: function(surrogateRecord) {
        var me = this;
        me.originalResource = surrogateRecord.originalResource;
        // direct property access is intentional here
        me.originalAssignment = surrogateRecord.originalAssignment;
        // direct property access is intentional here
        me.beginEdit();
        me.setId(surrogateRecord.getId());
        me.setName(surrogateRecord.getName());
        me.setTaskName(surrogateRecord.getTaskName());
        me.setTaskSequenceNumber(surrogateRecord.getTaskSequenceNumber());
        me.endEdit();
    },
    inheritableStatics: {
        /**
         * Returns id for a surrogate record corresponding to original resource or assignment record
         *
         * @return {String}
         */
        getSurrogateIdFor: function(record) {
            var id = record.getId();
            if (record instanceof Gnt.model.Resource) {
                id = 'resource-' + id;
            } else if (record instanceof Gnt.model.Assignment) {
                id = 'assignment-' + id;
            } else {
                Ext.Error.raise('Wrong original record type');
                // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
                var foo = false;
            }
            return id;
        }
    },
    /**
     * TODO: remove this override when it's fixed in Sch.model.Resource
     */
    getResourceStore: function() {
        return this.store;
    }
}, function() {
    Ext.data.NodeInterface.decorate(this);
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.data.ResourceUtilizationStore', {
    extend: 'Sch.data.ResourceTreeStore',
    uses: [
        'Gnt.data.ResourceUtilizationEventStore',
        'Gnt.model.Resource',
        'Gnt.model.Assignment',
        'Gnt.model.UtilizationEvent',
        'Gnt.model.utilization.ResourceStoreUtilizationNegotiationStrategy'
    ],
    mixins: [
        'Gnt.model.utilization.UtilizationNegotiationStrategyMixin'
    ],
    model: 'Gnt.model.UtilizationResource',
    eventModel: 'Gnt.model.UtilizationEvent',
    autoDestroy: true,
    storeId: null,
    root: {
        expanded: true
    },
    proxy: 'memory',
    config: {
        defaultResourceExpandedState: false,
        taskStore: null,
        resourceStore: null,
        assignmentStore: null,
        timeAxis: null,
        underUtilizationThreshold: null,
        overUtilizationThreshold: null
    },
    // Can't make eventStore to be a configuration property since parent class has similar property defined
    //eventStore                 : null
    folderSort: false,
    taskStoreDetacher: null,
    resourceStoreDetacher: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    timeAxisDetacher: null,
    utilizationInfoCache: null,
    syncingWithOriginal: false,
    utilizationNegotiationStrategyClass: 'Gnt.model.utilization.ResourceStoreUtilizationNegotiationStrategy',
    /**
     * @constructor
     */
    constructor: function(config) {
        var me = this;
        me.eventModel = Ext.ClassManager.get(this.eventModel);
        me.utilizationInfoCache = {};
        me.callParent([
            config
        ]);
        me.initUtilizationNegotiationStrategyMixin({
            utilizationNegotiationStrategy: Ext.create(me.utilizationNegotiationStrategyClass, {
                underUtilizationThreshold: me.getUnderUtilizationThreshold(),
                overUtilizationThreshold: me.getOverUtilizationThreshold(),
                resourceUtilizationStore: me
            })
        });
        if (!me.getEventStore()) {
            me.setEventStore(new Gnt.data.ResourceUtilizationEventStore({
                model: me.eventModel,
                resourceStore: me
            }));
        }
        me.setupSorters();
    },
    destroy: function() {
        var me = this;
        me.callParent(arguments);
        clearTimeout(me.fireReassignTimer);
        Ext.destroy(me.getEventStore());
        me.setEventStore(null);
    },
    setupSorters: function() {
        var me = this;
        me.setSorters([
            {
                sorterFn: function(a, b) {
                    var result;
                    // Sorting resources alphanumerically
                    if (a.isSurrogateResource() && b.isSurrogateResource() && a.getName() > b.getName()) {
                        result = 1;
                    } else if (a.isSurrogateResource() && b.isSurrogateResource() && a.getName() < b.getName()) {
                        result = -1;
                    } else if (a.isSurrogateResource() && b.isSurrogateResource()) {
                        result = 0;
                    }
                    // Placing resources before assignments
                    else if (a.isSurrogateResource() && b.isSurrogateAssignment()) {
                        result = 1;
                    } else if (a.isSurrogateAssignment() && b.isSurrogateResource()) {
                        result = -1;
                    }
                    // Assignments are compared according to strategy
                    else if (a.isSurrogateAssignment() && b.isSurrogateAssignment()) {
                        result = me.getUtilizationNegotiationStrategy().assignmentsComparator(a.getOriginalAssignment(), b.getOriginalAssignment());
                    } else {
                        result = 0;
                    }
                    return result;
                }
            }
        ]);
    },
    updateTaskStore: function(newStore, oldStore) {
        var me = this;
        oldStore && Ext.destroy(me.taskStoreDetacher);
        if (newStore) {
            me.setResourceStore(newStore.getResourceStore() || me.setResourceStore());
            me.setAssignmentStore(newStore.getAssignmentStore() || me.getAssignmentStore());
            me.taskStoreDetacher = me.mon(newStore, {
                load: me.onSourceDataTouch,
                refresh: me.onSourceDataTouch,
                clear: me.onSourceDataTouch,
                add: me.onSourceDataTouch,
                append: me.onSourceDataTouch,
                update: me.onSourceDataTouch,
                remove: me.onSourceDataTouch,
                bulkremove: me.onSourceDataTouch,
                move: me.onSourceDataTouch,
                scope: me,
                destroyable: true
            });
        }
    },
    updateResourceStore: function(newStore, oldStore) {
        var me = this;
        oldStore && Ext.destroy(me.resourceStoreDetacher);
        if (newStore) {
            me.resourceStoreDetacher = me.mon(newStore, {
                load: me.onSourceDataTouch,
                refresh: me.onSourceDataTouch,
                clear: me.onSourceDataTouch,
                add: me.onSourceDataTouch,
                update: me.onSourceDataTouch,
                remove: me.onSourceDataTouch,
                bulkremove: me.onSourceDataTouch,
                scope: me,
                destroyable: true
            });
        }
    },
    updateAssignmentStore: function(newStore, oldStore) {
        var me = this;
        oldStore && Ext.destroy(me.assignmentStoreDetacher);
        if (newStore) {
            me.assignmentStoreDetacher = me.mon(newStore, {
                load: me.onSourceDataTouch,
                refresh: me.onSourceDataTouch,
                clear: me.onSourceDataTouch,
                add: me.onSourceDataTouch,
                update: me.onSourceDataTouch,
                remove: me.onSourceDataTouch,
                bulkremove: me.onSourceDataTouch,
                scope: me,
                destroyable: true
            });
        }
    },
    setEventStore: function(newStore) {
        var me = this,
            oldStore = me.eventStore;
        me.callParent([
            newStore
        ]);
        if (oldStore != newStore) {
            oldStore && Ext.destroy(me.eventStoreDetacher);
            if (newStore) {
                me.utilizationEventStoreDetacher = me.mon(newStore, {
                    update: me.onUtilizationEventStoreUpdate,
                    scope: me
                });
            }
        }
    },
    updateTimeAxis: function(newTimeAxis, oldTimeAxis) {
        var me = this;
        oldTimeAxis && Ext.destroy(me.timeAxisDetacher);
        if (newTimeAxis) {
            me.timeAxisDetacher = me.mon(newTimeAxis, {
                reconfigure: me.onSourceDataTouch,
                scope: me,
                destroyable: true
            });
        }
    },
    makeSurrogateResource: function(resource) {
        var me = this,
            model = me.model;
        return new me.model({
            Id: model.getSurrogateIdFor(resource),
            originalResource: resource,
            expanded: me.getDefaultResourceExpandedState()
        });
    },
    makeSurrogateAssignment: function(assignment) {
        var model = this.model;
        return new model({
            Id: model.getSurrogateIdFor(assignment),
            originalAssignment: assignment,
            leaf: true
        });
    },
    makeSurrogateAssignmentEvent: function(resourceOrAssignment) {
        var me = this,
            eventModel = me.eventModel,
            id = eventModel.getSurrogateIdFor(resourceOrAssignment);
        return new eventModel({
            Id: id,
            ResourceId: id,
            originalResource: resourceOrAssignment instanceof Gnt.model.Resource && resourceOrAssignment || null,
            originalAssignment: resourceOrAssignment instanceof Gnt.model.Assignment && resourceOrAssignment || null,
            utilizationNegotiationStrategy: me.getUtilizationNegotiationStrategy()
        });
    },
    makeSurrogateResourceBranch: function(resource) {
        var me = this,
            surrogateResource = me.makeSurrogateResource(resource),
            surrogateAssignmentEvents = [],
            surrogateSummaryEvent;
        // Surrogate assignments
        resource.forEachAssignment(function(assignment) {
            var task = assignment.getTask();
            if (task && !task.isUnscheduled()) {
                surrogateResource.appendChild(me.makeSurrogateAssignment(assignment));
                surrogateAssignmentEvents.push(me.makeSurrogateAssignmentEvent(assignment));
            }
        });
        // Surrogate summary (only if there are any assignments)
        if (surrogateAssignmentEvents.length > 0) {
            surrogateSummaryEvent = me.makeSurrogateAssignmentEvent(resource);
            surrogateAssignmentEvents.push(surrogateSummaryEvent);
        }
        return {
            resource: surrogateResource,
            events: surrogateAssignmentEvents
        };
    },
    /**
     * Fills in the resource utilization store from primary (Task/Resource/Assignment) stores.
     */
    fillStore: function() {
        var me = this,
            root = me.getRoot(),
            resourceStore = me.getResourceStore(),
            utilizationEventStore = me.getEventStore(),
            resources = resourceStore && resourceStore.getRange(),
            resourcesToAdd = [],
            eventsToAdd = [];
        me.syncingWithOriginal = true;
        root.removeAll();
        utilizationEventStore.removeAll();
        resources && Ext.Array.each(resources, function(resource) {
            var branch = me.makeSurrogateResourceBranch(resource);
            resourcesToAdd.push(branch.resource);
            eventsToAdd = eventsToAdd.concat(branch.events);
        });
        utilizationEventStore.add(eventsToAdd);
        root.appendChild(resourcesToAdd);
        me.sorters && me.sorters.getCount() && root.sort();
        me.syncingWithOriginal = false;
    },
    /**
     * The task is to effectively synchronize two data structures.
     * First (Current) is a pair of:
     *  - resource tree store with nodes designating resources
     *    and leafs designating resource assignments;
     *  - flat event store, where each event designates a task assignment.
     * Second (Correct) is a triplet of:
     *  - resource store;
     *  - task store;
     *  - assignment store.
     *
     * Synchronization is one way, from second triplet to first pair of stores.
     *
     * How do I synchronize? The primary assumption here is that touching DOM is expensive.
     *
     * I have current structure in this store and it's event store
     * I might build correct structure in a separate store with events suspended,
     * sort it accordingly (store's sort method support external sorters collection).
     * Then I shall compare and build a list of actions executing which, one by one, I will
     * make current data structure to be correct.
     *
     * Synchronization steps:
     * ----------------------
     * 1. Create and fill correct store (with events suspended).
     * 2. Sort correct store using sorters collection from current store.
     * 3. Walk through the current store and remove all assignments from this store and events store
     *    which are not present in the correct store.
     * 4. Walk through the current store and remove all resource from this store which are not
     *    present in the correct store.
     * 5. Walk through the current store:
     *    - for surrogate resource node check if it's referencing the same original resource record
     *      as the one present in correct store for the surrogate resource with the same id, if objects
     *      are different then setup the current surrogate resource node to use new original record
     *      - otherwise just sync the node from original;
     *    - for surrogate assignment node check if it's referencing the same original assignment record
     *      as the one present in correct store for the surrogate assignment with the same id, if objects
     *      are different then setup the current surrogate assignment node to use new original record,
     *      the same do for the surrogate assignment event in current event store
     *      - otherwise just sync the node from original;
     * 6. Walk through the correct store and for each surrogate resource which is not present in the current store
     *    insert it into current store under the same index it's present in the correct store.
     * 7. Walk through the correct store and for each surrogate assignment which is not present in the current store
     *    insert it into current store under the same index it's present in the correct store. Do the same for
     *    the surrogate assignment event.
     * 8. Walk through the correct store and check if corresponding records in current store are under the same index
     *    if not, then rearrange them according to correct store.
     *
     * After actions are executed the correct store should be destroyed, just to clean up some memory, as well
     * for surrogate events were not shared by two event stores.
     *
     * @private
     */
    diffSyncStore: function() {
        var me = this,
            correctStore;
        me.syncingWithOriginal = true;
        /**
         * @event sync-start
         *
         * Fired when store starts synchronization with original (Task/Resource/Assignment) stores
         *
         * @param {Gnt.data.ResourceUtilizationStore} me
         */
        me.fireEvent('sync-start', me);
        // Temporary solution until since buffered renderer sometimes skips fine grained store events and
        // doesn't updates corresponding grid rows. For now we're forced to fire 'refresh' at the end of synchronization
        me.suspendEvents();
        // Creating and filling correct store
        correctStore = new me.self({
            underUtilizationThreshold: me.getUnderUtilizationThreshold(),
            overUtilizationThreshold: me.getOverUtilizationThreshold()
        });
        correctStore.suspendEvents();
        correctStore.setTimeAxis(me.getTimeAxis());
        correctStore.setTaskStore(me.getTaskStore());
        correctStore.fillStore();
        // Remove outdated surrogate assingments
        me.removeOutdatedSurrogateAssignments(me, correctStore);
        // Remove outdated surrogate resources
        me.removeOutdatedSurrogateResources(me, correctStore);
        // Add new surrogate resources
        me.addNewSurrogateResources(me, correctStore);
        // Add new surrogate assignments
        me.addNewSurrogateAssignments(me, correctStore);
        // Sync present surrogate assingments
        me.updatePresentSurrogates(me, correctStore);
        // Rearrange present surrogate records
        me.rearrangePresentSurrogates(me, correctStore);
        me.utilizationInfoCache = correctStore.utilizationInfoCache;
        // Clean up
        Ext.destroy(correctStore);
        // Temporary solution until I understand why buffered renderer sometimes skips fine grained sotre events and
        // doesn't updates corresponding grid rows. For now I'm forced to fire 'refresh' at the and of synchronization
        me.resumeEvents();
        /**
         * @event sync-end
         *
         * Fired when store completes synchronization with original (Task/Resource/Assignment) stores
         *
         * @param {Gnt.data.ResourceUtilizationStore} me
         */
        me.fireEvent('sync-complete', me);
        me.fireEvent('refresh', me);
        me.syncingWithOriginal = false;
    },
    removeOutdatedSurrogateAssignments: function(currentStore, correctStore) {
        var currentRoot = currentStore.getRoot(),
            nodesToDelete = [],
            eventsToDelete = [];
        currentRoot.cascadeBy(function(currentNode) {
            var correctNode = correctStore.getModelById(currentNode.getId());
            if (!currentNode.isRoot() && currentNode.isSurrogateAssignment()) {
                if (!correctNode || (correctNode.parentNode.getId() != currentNode.parentNode.getId())) {
                    nodesToDelete.push(currentNode);
                    eventsToDelete = eventsToDelete.concat(currentNode.getEvents());
                }
            } else if (!currentNode.isRoot() && currentNode.isSurrogateResource()) {
                // Remove events from the eventStore bound to the Panel which:
                // 1. Are parent nodes in the 'true' store with 0 children (meaning a resource is unassigned)
                // or
                // 2. Are surrogate assignments that ended up on a summary row due to reassign (drag drop etc)
                eventsToDelete = eventsToDelete.concat(Ext.Array.filter(currentNode.getEvents(), function(event) {
                    return event.isSurrogateAssignment() || (correctNode && correctNode.childNodes.length === 0);
                }));
            }
        });
        currentStore.getEventStore().remove(eventsToDelete);
        Ext.Array.each(nodesToDelete, function(currentNode) {
            currentNode.remove();
        });
    },
    removeOutdatedSurrogateResources: function(currentStore, correctStore) {
        var currentRoot = currentStore.getRoot(),
            nodesToDelete = [],
            eventsToDelete = [];
        currentRoot.cascadeBy(function(currentNode) {
            var correctNode;
            if (!currentNode.isRoot() && currentNode.isSurrogateResource()) {
                correctNode = correctStore.getModelById(currentNode.getId());
                if (!correctNode) {
                    nodesToDelete.push(currentNode);
                    eventsToDelete = eventsToDelete.concat(currentNode.getEvents());
                }
            }
        });
        currentStore.getEventStore().remove(eventsToDelete);
        Ext.Array.each(nodesToDelete, function(currentNode) {
            currentNode.remove();
        });
    },
    addNewSurrogateResources: function(currentStore, correctStore) {
        var correctRoot = correctStore.getRoot(),
            currentRoot = currentStore.getRoot(),
            eventStore = currentStore.getEventStore(),
            eventsToAdd = [];
        correctRoot.cascadeBy(function(correctNode) {
            var currentNode;
            if (!correctNode.isRoot() && correctNode.isSurrogateResource()) {
                currentNode = currentStore.getModelById(correctNode.getId());
                if (!currentNode) {
                    currentRoot.insertChild(correctNode.get('index'), currentStore.makeSurrogateResource(correctNode.getOriginalResource()));
                    eventsToAdd.push(currentStore.makeSurrogateAssignmentEvent(correctNode.getOriginalResource()));
                } else {
                    //#2762 - ResourceUtilizationStore should update resource summaries 
                    if (currentNode.getEvents().length === 0) {
                        eventsToAdd = eventsToAdd.concat(Ext.Array.map(correctNode.getEvents(), function(ev) {
                            return ev.clone();
                        }));
                    }
                }
            }
        });
        eventStore.add(eventsToAdd);
    },
    addNewSurrogateAssignments: function(currentStore, correctStore) {
        var correctRoot = correctStore.getRoot(),
            currentEventStore = currentStore.getEventStore(),
            toAdd = [];
        correctRoot.cascadeBy(function(correctNode) {
            var currentNode, correctParent, currentParent;
            if (!correctNode.isRoot() && correctNode.isSurrogateAssignment()) {
                currentNode = currentStore.getModelById(correctNode.getId());
                if (!currentNode) {
                    correctParent = correctNode.parentNode;
                    currentParent = currentStore.getModelById(correctParent.getId());
                    if (currentParent) {
                        currentParent.insertChild(correctNode.get('index'), currentStore.makeSurrogateAssignment(correctNode.getOriginalAssignment()));
                        toAdd = toAdd.concat(Ext.Array.map(correctNode.getEvents(), function(ev) {
                            return ev.clone();
                        }));
                    }
                }
            }
        });
        currentEventStore.add(toAdd);
    },
    updatePresentSurrogates: function(currentStore, correctStore) {
        var currentRoot = currentStore.getRoot();
        currentRoot.cascadeBy(function(currentNode) {
            var correctNode, correctEvent, currentEvent;
            if (!currentNode.isRoot()) {
                correctNode = correctStore.getModelById(currentNode.getId());
                if (correctNode) {
                    if (!currentNode.isInSyncWithSurrogate(correctNode)) {
                        currentNode.syncFromSurrogate(correctNode);
                    }
                    correctEvent = correctNode.getEvents()[0];
                    // We always have 1 to [0,1] relation between assignment and event
                    if (correctEvent) {
                        currentEvent = currentStore.getEventStore().getModelById(correctEvent.getId());
                        // Event might be moved by drag & drop to another resource and removed at assignments remove step
                        if (currentEvent && !currentEvent.isInSyncWithSurrogate(correctEvent)) {
                            currentEvent.syncFromSurrogate(correctEvent);
                        }
                    } else {
                        currentNode.syncFromOriginal(correctNode);
                    }
                }
            }
        });
    },
    rearrangePresentSurrogates: function(currentStore, correctStore) {
        var correctRoot = correctStore.getRoot();
        correctRoot.cascadeBy(function(correctNode) {
            var currentNode;
            if (!correctNode.isRoot()) {
                currentNode = currentStore.getModelById(correctNode.getId());
                if (currentNode && currentNode.get('index') != correctNode.get('index')) {
                    currentNode.parentNode.insertChild(correctNode.get('index'), currentNode);
                }
            }
        });
    },
    clearUtilizationInfoCache: function() {
        this.utilizationInfoCache = {};
    },
    /**
     * Returns this store (utilization information) model which corresponding to particular original model a resource or
     * an assignment.
     *
     * @param {Gnt.model.Resource|Gnt.model.Assignment} originalModel
     * @return {Gnt.model.UtilizationResource}
     */
    getModelByOriginal: function(originalModel) {
        var me = this;
        return me.getModelById(me.model.getSurrogateIdFor(originalModel));
    },
    onSourceDataTouch: Ext.Function.createBuffered(function() {
        var me = this;
        if (!me.isDestroyed) {
            me.clearUtilizationInfoCache();
            me.diffSyncStore();
        }
    }, 10),
    onUtilizationEventStoreUpdate: function(utilizationEventStore, surrogateEvent, operation, modifiedFieldNames) {
        var me = this;
        if (!me.syncingWithOriginal) {
            if (!surrogateEvent.isInSyncWithOriginal()) {
                surrogateEvent.syncToOriginal();
            }
            if (Ext.Array.contains(modifiedFieldNames, surrogateEvent.resourceIdField)) {
                var surrogateResource = surrogateEvent.getResource();
                // TODO REMOVE
                me.fireReassignTimer = Ext.Function.defer(function() {
                    me.fireEvent('reassign', me, surrogateResource.getOriginalResource(), surrogateResource.getOriginalTask(), // might be null
                    surrogateEvent.getOriginalResource(), surrogateEvent.getOriginalTask(), surrogateEvent.getOriginalAssignment());
                }, 1);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin adds transaction alike functionality into a model and works in pair with {@link Gnt.data.mixin.ProjectableStore}.
 * If you mix-in this class into a model, make sure you also mix-in {@link Gnt.model.mixin.ProjectableStore} into the store(s)
 * which will work with this model class.
 *
 * Make sure you call the {@link #initProjection} method in your model class constructor, otherwise mixing in this mixin
 * won't have any effect.
 */
Ext.define('Gnt.model.mixin.ProjectableModel', function() {
    var overridables = {};
    /**
     * Initializes record's projectable mechanics.
     * @protected
     * @method initProjectable
     * @member Gnt.model.mixin.ProjectableModel
     */
    function initProjectable() {
        Ext.override(this, overridables);
    }
    // Private
    function getUnprojected(fieldName) {
        return this.data[fieldName];
    }
    /**
     * Checks whether the record is projected, i.e. a projection has changed values for this record.
     *
     * @return {Boolean}
     */
    function isProjected() {
        var me = this,
            store = me.getTreeStore && me.getTreeStore() || me.store,
            projection = store && store.getProjection && store.getProjection();
        return projection && projection.hasOwnProperty(me.internalId) ? true : false;
    }
    overridables.get = function get(fieldName) {
        var me = this,
            store = me.getTreeStore && me.getTreeStore() || me.store,
            projection = store && store.getProjection && store.getProjection(),
            internalId = me.internalId,
            data, value;
        if (projection && projection.hasOwnProperty(internalId)) {
            data = projection[internalId];
            if (fieldName in data) {
                value = data[fieldName];
            } else {
                value = me.callParent([
                    fieldName
                ]);
            }
        } else {
            value = me.callParent([
                fieldName
            ]);
        }
        return value;
    };
    // TODO we should probably handle 'options' object as well
    overridables.set = function set(fieldName, value, options) {
        var me = this,
            store = me.getTreeStore && me.getTreeStore() || me.store,
            projection = store && store.getProjection && store.getProjection(),
            internalId = me.internalId,
            data, prop, result, currentValue, currentValueAdopted, valueAdopted;
        if (projection) {
            result = [];
            if (typeof arguments[0] === 'object') {
                for (prop in fieldName) {
                    if (fieldName.hasOwnProperty(prop)) {
                        value = fieldName[prop];
                        currentValue = me.get(prop);
                        //me.getUnprojected(prop);
                        valueAdopted = (value !== undefined && value !== null) ? (value).valueOf() : value;
                        currentValueAdopted = (currentValue !== undefined && currentValue !== null) ? (currentValue).valueOf() : currentValue;
                        if (((valueAdopted === undefined || valueAdopted === null) && valueAdopted !== currentValueAdopted) || valueAdopted != currentValueAdopted) {
                            data = projection[internalId] = projection.hasOwnProperty(internalId) && projection[internalId] || {};
                            data[prop] = value;
                            result.push(prop);
                        }
                    }
                }
            } else // method called with a field name
            {
                currentValue = me.get(fieldName);
                //me.getUnprojected(fieldName);
                valueAdopted = (value !== undefined && value !== null) ? (value).valueOf() : value;
                currentValueAdopted = (currentValue !== undefined && currentValue !== null) ? (currentValue).valueOf() : currentValue;
                if (((valueAdopted === undefined || valueAdopted === null) && valueAdopted !== currentValueAdopted) || valueAdopted != currentValueAdopted) {
                    data = projection[internalId] = projection.hasOwnProperty(internalId) && projection[internalId] || {};
                    data[fieldName] = value;
                    result.push(fieldName);
                }
            }
        } else {
            result = me.callParent(arguments);
        }
        return result;
    };
    return {
        initProjectable: initProjectable,
        getUnprojected: getUnprojected,
        isProjected: isProjected
    };
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.task.More
@mixin
@protected

Internal mixin class providing additional logic and functionality belonging to the Task model class.

*/
Ext.define('Gnt.model.task.More', {
    propagating: false,
    /**
     * Increases the indentation level of this task in the tree
     *
     * @param {Function} [callback] Callback function to call after task has been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    indent: function(callback) {
        var me = this,
            previousSibling = me.previousSibling,
            cancelFn;
        if (previousSibling) {
            var taskStore = me.getTaskStore();
            taskStore.beginIndent();
            me.propagateChanges(function() {
                return me.indentWithoutPropagation(function(fn) {
                    cancelFn = fn;
                });
            }, function(cancelChanges, affectedTasks) {
                if (cancelChanges) {
                    cancelFn && cancelFn();
                } else {
                    previousSibling.expand();
                }
                taskStore.endIndent();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            // TODO: actually an exception should be thrown here, but BC is such BC
            callback && callback(false, {});
        }
    },
    indentWithoutPropagation: function(cancelFeedback) {
        var me = this,
            previousSibling = me.previousSibling,
            originalParent, originalIndex, wasLeaf, segments, removeContext;
        removeContext = {
            parentNode: me.parentNode,
            previousSibling: me.previousSibling,
            nextSibling: me.nextSibling
        };
        // This data we need for canceling
        originalParent = me.parentNode;
        originalIndex = originalParent.indexOf(me);
        wasLeaf = previousSibling.get('leaf');
        if (wasLeaf) {
            segments = previousSibling.getSegments();
            previousSibling.markAsParent();
        }
        // This clears the removeContext object, put it back below
        previousSibling.appendChild(me);
        // if new ancestors of the task have incoming dependencies
        // we need to re-align the task to take them into account
        if (me.getParentsIncomingDependencies().length) {
            me.alignByIncomingDependenciesWithoutPropagation();
        }
        // http://www.sencha.com/forum/showthread.php?270802-4.2.1-NodeInterface-removeContext-needs-to-be-passed-as-an-arg
        me.removeContext = removeContext;
        cancelFeedback && cancelFeedback(function() {
            originalParent.insertChild(originalIndex, me);
            if (wasLeaf) {
                // turn previous sibling back to leaf
                previousSibling.set('leaf', true);
                // and if it was segmented restore segments
                segments && previousSibling.setSegmentsWithoutPropagation(segments);
            }
        });
        return me;
    },
    /**
     * Decreases the indentation level of this task in the tree
     * @param {Function} [callback] Callback function to call after task has been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    outdent: function(callback) {
        var me = this,
            parentNode = me.parentNode,
            cancelFn;
        if (parentNode && !parentNode.isRoot()) {
            var taskStore = me.getTaskStore();
            // need to do view refresh after indent to sync scroll between locked/normal view
            // and get rid of extra nodes
            taskStore.beginIndent();
            me.propagateChanges(function() {
                return me.outdentWithoutPropagation(function(fn) {
                    cancelFn = fn;
                });
            }, function(cancelChanges, affectedTasks) {
                cancelChanges && cancelFn && cancelFn();
                taskStore.endIndent();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            // TODO: actually an exception should be thrown here, but BC is such BC
            callback && callback(false, {});
        }
    },
    outdentWithoutPropagation: function(cancelFeedback) {
        var me = this,
            originalParent, originalIndex, removeContext;
        removeContext = {
            parentNode: me.parentNode,
            previousSibling: me.previousSibling,
            nextSibling: me.nextSibling
        };
        // This data we need for canceling
        originalParent = me.parentNode;
        originalIndex = originalParent.indexOf(me);
        // This clears the removeContext object, put it back below
        if (originalParent.nextSibling) {
            originalParent.parentNode.insertBefore(me, originalParent.nextSibling);
        } else {
            originalParent.parentNode.appendChild(me);
        }
        // http://www.sencha.com/forum/showthread.php?270802-4.2.1-NodeInterface-removeContext-needs-to-be-passed-as-an-arg
        me.removeContext = removeContext;
        cancelFeedback && cancelFeedback(function() {
            originalParent.insertChild(originalIndex, me);
        });
        // Changes propagation will be collected using original parent as the source point
        return originalParent;
    },
    removeInvalidDependencies: function() {
        var depStore = this.getDependencyStore(),
            deps = this.getAllDependencies();
        for (var i = 0; i < deps.length; i++) {
            if (!deps[i].isValid()) {
                depStore.remove(deps[i]);
            }
        }
    },
    removeDependenciesToParents: function(newParentNode) {
        var me = this,
            linkedTasks = me.getSuccessors().concat(me.getPredecessors());
        newParentNode.bubble(function(parent) {
            if (Ext.Array.indexOf(linkedTasks, parent) >= 0) {
                me.removeLinkToTask(parent);
            }
        });
    },
    /**
     * Returns true if the task has at least one dependency
     *
     * @return {Boolean}
     */
    hasDependencies: function() {
        return this.hasIncomingDependencies() || this.hasOutgoingDependencies();
    },
    /**
     * Returns all dependencies of this task (both incoming and outgoing)
     *
     * @return {Gnt.model.Dependency[]}
     */
    getAllDependencies: function() {
        return this.predecessors.concat(this.successors);
    },
    /**
     * Returns true if this task has at least one incoming dependency
     *
     * @return {Boolean}
     */
    hasIncomingDependencies: function() {
        return this.predecessors.length > 0;
    },
    /**
     * Returns true if this task has at least one outgoing dependency
     *
     * @return {Boolean}
     */
    hasOutgoingDependencies: function() {
        return this.successors.length > 0;
    },
    /**
     * Returns all incoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#predecessors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case.
     *
     * @return {Gnt.model.Dependency[]}
     */
    getIncomingDependencies: function(doNotClone) {
        return doNotClone ? this.predecessors : this.predecessors.slice();
    },
    getParentsIncomingDependencies: function(parentNode) {
        var parent = this.parentNode,
            result = [],
            toAppend;
        while (parent) {
            // provided parentNode restricts to take into account dependencies from only its descendants
            if (parentNode) {
                toAppend = Ext.Array.filter(parent.getIncomingDependencies(), function(dependency) {
                    var sourceTask = dependency.getSourceTask();
                    return sourceTask && sourceTask.isAncestor(parentNode);
                });
            } else {
                toAppend = parent.getIncomingDependencies();
            }
            result = result.concat(toAppend);
            parent = parent.parentNode;
        }
        return result;
    },
    /**
     * Returns all outcoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#successors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case.
     *
     * @return {Gnt.model.Dependency[]}
     */
    getOutgoingDependencies: function(doNotClone) {
        return doNotClone ? this.successors : this.successors.slice();
    },
    // TODO: see if this is needed or can be removed or substituted by another method
    // NOTE: return value is never used anywhere in our code base
    /**
     * @private
     * Internal method, constrains the task according to its incoming dependencies
     * @param {Gnt.data.TaskStore} taskStore The task store
     * @return {Boolean} true if the task was updated as a result.
     */
    alignByIncomingDependencies: function(taskStore, currentCascadeBatch, callback) {
        var result = this.alignByIncomingDependenciesWithoutPropagation(taskStore, currentCascadeBatch);
        this.propagateChanges(null, callback, true);
        return result;
    },
    alignByIncomingDependenciesWithoutPropagation: function(taskStore, currentCascadeBatch, parentNode) {
        // we don't affect the task by incoming dependencies if it's either:
        //  - a manually scheduled task
        //  - a readonly task
        if (this.isManuallyScheduled() || this.isReadOnly()) {
            return false;
        }
        var changed = false;
        taskStore = taskStore || this.getTaskStore();
        var constrainContext = this.getIncomingDependenciesConstraintContext(taskStore, parentNode);
        if (constrainContext) {
            var startDate = constrainContext.startDate;
            var endDate = constrainContext.endDate;
            if (startDate && startDate - this.getStartDate() !== 0) {
                currentCascadeBatch && currentCascadeBatch.addAffected(this);
                this.setStartDateWithoutPropagation(startDate, true, taskStore.skipWeekendsDuringDragDrop);
                changed = true;
            } else if (endDate && endDate - this.getEndDate() !== 0) {
                currentCascadeBatch && currentCascadeBatch.addAffected(this);
                this.setEndDateWithoutPropagation(endDate, true, taskStore.skipWeekendsDuringDragDrop);
                changed = true;
            }
        }
        return changed;
    },
    getDependencyCalendar: function(dependency, dependenciesCalendar, taskStore) {
        if (!dependenciesCalendar) {
            dependenciesCalendar = (taskStore || this.getTaskStore()).dependenciesCalendar;
        }
        var projectCalendar = this.getProjectCalendar(),
            fromTask = dependency.getSourceTask(taskStore),
            targetTask = dependency.getTargetTask(taskStore),
            calendar;
        switch (dependenciesCalendar) {
            case 'project':
                calendar = projectCalendar;
                break;
            case 'source':
                calendar = fromTask.getCalendar();
                break;
            case 'target':
                calendar = targetTask.getCalendar();
                break;
            default:
                throw "Unsupported value for `dependenciesCalendar` config option";
        }
        return calendar;
    },
    getIncomingDependenciesConstraintContext: function(providedTaskStore, parentNode) {
        var me = this,
            // the task incoming dependencies plus the ones inherited from its ancestors
            incomingDependencies = this.getIncomingDependencies(true).concat(this.getParentsIncomingDependencies(parentNode));
        if (!incomingDependencies.length || this.isUnscheduled()) {
            return null;
        }
        var DepType = Gnt.model.Dependency.Type,
            earliestStartDate = new Date(0),
            // This will break for tasks later then 01.01.1970
            earliestEndDate = new Date(0),
            // This will break for tasks later then 01.01.1970
            constrainingStartTask, constrainingEndTask;
        var dependenciesCalendar = (providedTaskStore || this.getTaskStore()).dependenciesCalendar;
        Ext.Array.each(incomingDependencies, function(dependency) {
            var fromTask = dependency.getSourceTask(providedTaskStore);
            if (fromTask && (!parentNode || fromTask.isAncestor(parentNode))) {
                // get calendar instance to use for lag calculations
                var calendar = me.getDependencyCalendar(dependency, dependenciesCalendar, providedTaskStore);
                var lag = dependency.getLag() || 0,
                    lagUnit = dependency.getLagUnit(),
                    start = fromTask.getStartDate(),
                    end = fromTask.getEndDate();
                switch (dependency.getType()) {
                    case DepType.StartToEnd:
                        if (start) {
                            start = calendar.skipWorkingTime(start, lag, lagUnit);
                            if (earliestEndDate < start) {
                                earliestEndDate = start;
                                constrainingEndTask = fromTask;
                            }
                        };
                        break;
                    case DepType.StartToStart:
                        if (start) {
                            start = calendar.skipWorkingTime(start, lag, lagUnit);
                            if (earliestStartDate < start) {
                                earliestStartDate = start;
                                constrainingStartTask = fromTask;
                            }
                        };
                        break;
                    case DepType.EndToStart:
                        if (end) {
                            end = calendar.skipWorkingTime(end, lag, lagUnit);
                            if (earliestStartDate < end) {
                                earliestStartDate = end;
                                constrainingStartTask = fromTask;
                            }
                        };
                        break;
                    case DepType.EndToEnd:
                        if (end) {
                            end = calendar.skipWorkingTime(end, lag, lagUnit);
                            if (earliestEndDate < end) {
                                earliestEndDate = end;
                                constrainingEndTask = fromTask;
                            }
                        };
                        break;
                    default:
                        throw 'Invalid dependency type: ' + dependency.getType();
                }
            }
        });
        var result = {
                startDate: earliestStartDate > 0 ? earliestStartDate : null,
                endDate: earliestEndDate > 0 ? earliestEndDate : null,
                constrainingTask: constrainingStartTask || constrainingEndTask
            };
        // if we have both start & end constrained ...
        if (result.startDate && result.endDate) {
            // we need to compare them to get effective constraint value (and task)
            // so we convert earliestEndDate constraint to task start date and compare it with earliestStartDate
            var start = this.calculateStartDate(result.endDate, this.getDuration());
            if (start > earliestStartDate) {
                result.startDate = start;
                result.constrainingTask = constrainingEndTask;
            }
            // get rid of endDate constraint since we just processed it
            result.endDate = null;
        }
        // Skip non-working time
        if (result.startDate) {
            result.startDate = this.skipNonWorkingTime(result.startDate);
        }
        // for EndDate we skip it backward
        if (result.endDate) {
            result.endDate = this.skipNonWorkingTime(result.endDate, false);
        }
        return result.constrainingTask && result;
    },
    /**
     * @private
     * Internal method, called recursively to query for the longest duration of the chain structure
     * @return {Gnt.model.Task[]} chain An array forming a chain of linked tasks
     */
    getCriticalPaths: function() {
        var cPath = [
                this
            ],
            ctx = this.getIncomingDependenciesConstraintContext(),
            task = this;
        // if there is a constraining
        while (ctx) {
            var startDate = ctx.startDate;
            var endDate = ctx.endDate;
            // If the task being constrained has not distance between its constraining limit and real start(end) date
            // we consider it a part of the critical path
            if ((startDate && startDate - task.getStartDate() >= 0) || (endDate && endDate - task.getEndDate() >= 0)) {
                task = ctx.constrainingTask;
                cPath.push(task);
                ctx = task.getIncomingDependenciesConstraintContext();
            } else {
                ctx = null;
            }
        }
        return cPath;
    },
    /**
     * @removed Please use {@link Gnt.data.TaskStore#cascadeChangesForTask} method instead.
     * @method cascadeChanges
     */
    /**
     * Adds the passed task to the collection of child tasks.
     * @param {Gnt.model.Task} subtask The new subtask
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} The added subtask task
     */
    addSubtask: function(subtask, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.addSubtaskWithoutPropagation(subtask, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    addSubtaskWithoutPropagation: function(subtask, cancelAndResultFeedback) {
        var me = this,
            originalParent, originalIndex, propagationSources, wasLeaf, segments;
        originalParent = subtask.parentNode;
        originalIndex = originalParent && originalParent.indexOf(me);
        wasLeaf = me.get('leaf');
        if (wasLeaf) {
            me.markAsParent();
            segments = me.getSegments();
        }
        subtask = me.appendChild(subtask);
        me.expand();
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            if (originalParent) {
                originalParent.insertChild(originalIndex, subtask);
            } else {
                me.removeChild(subtask);
            }
            wasLeaf && me.set('leaf', true);
            wasLeaf && segments && me.setSegmentsWithoutPropagation(segments);
        }, subtask);
        // Changes propagation will be collected using affected parents as the source points
        if (!originalParent) {
            propagationSources = subtask;
        } else if (me !== originalParent && me.getTaskStore(true) === originalParent.getTaskStore(true)) {
            propagationSources = [
                subtask,
                originalParent
            ];
        }
        return propagationSources;
    },
    /**
     * Inserts the passed task to the collection of child tasks at the given index.
     * @param {Integer} index Tne new subtask index
     * @param {Gnt.model.Task} subtask The new subtask
     * @param {Function} [callback] Callback function to call after task has been inserted and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} The inserted subtask
     */
    insertSubtask: function(index, subtask, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.insertSubtaskWithoutPropagation(index, subtask, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    insertSubtaskWithoutPropagation: function(index, subtask, cancelAndResultFeedback) {
        var me = this,
            originalParent, originalIndex, propagationSources, wasLeaf, segments;
        originalParent = subtask.parentNode;
        originalIndex = originalParent && originalParent.indexOf(me);
        wasLeaf = me.get('leaf');
        if (wasLeaf) {
            me.markAsParent();
            segments = me.getSegments();
        }
        subtask = me.insertChild(index, subtask);
        me.expand();
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            if (originalParent) {
                originalParent.insertChild(originalIndex, subtask);
            } else {
                me.removeChild(subtask);
            }
            wasLeaf && me.set('leaf', true);
            wasLeaf && segments && me.setSegmentsWithoutPropagation(segments);
        }, subtask);
        // Changes propagation will be collected using affected parents as the source points
        if (!originalParent) {
            propagationSources = subtask;
        } else if (me !== originalParent && me.getTaskStore(true) === originalParent.getTaskStore(true)) {
            propagationSources = [
                subtask,
                originalParent
            ];
        }
        return propagationSources;
    },
    /**
     * Constraints aware removes the passed subtask from this task child nodes.
     *
     * @param {Gnt.model.Task} [subtask] The subtask to remove
     * @param {Function} [callback] Callback function to call after the subtask has been removed and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    removeSubtask: function(subtask, callback) {
        var me = this,
            cancelFn;
        // if the subtask is already removed then we have nothing to do
        if (me.indexOf(subtask) !== -1) {
            me.propagateChanges(function() {
                return me.removeSubtaskWithoutPropagation(subtask, function cancelFeedback(fn) {
                    cancelFn = fn;
                });
            }, function onPropagationComplete(cancelChanges, affectedTasks) {
                cancelChanges && cancelFn && cancelFn();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            callback && callback(false, {});
        }
    },
    removeSubtaskWithoutPropagation: function(subtask, cancelFeedback) {
        var me = this,
            indexOfSubtask = me.indexOf(subtask),
            subtree, dependencyStore, assignmentStore, dependencies, assignments, dependenciesIndices, assignmentsIndices, i, len, r;
        indexOfSubtask != -1 || Ext.Error.raise("Can't remove subtask `" + subtask.getId() + "` from task `" + me.getId() + "` subtask is not a child of the task!");
        dependencyStore = me.getDependencyStore();
        assignmentStore = me.getAssignmentStore();
        dependencies = dependencyStore && dependencyStore.getDependenciesForTask(subtask);
        assignments = assignmentStore && subtask.getAssignments();
        subtree = [];
        dependenciesIndices = [];
        assignmentsIndices = [];
        // Collecting all the descendants of the subtask.
        subtask.cascadeBy(function(node) {
            subtree.push(node);
        });
        // Collecting dependencies and assignments of the subtree
        for (i = 0 , len = subtree.length; (dependencyStore || assignmentStore) && i < len; i++) {
            r = subtree[i];
            dependencyStore && (dependencies = dependencies.concat(dependencyStore.getDependenciesForTask(r)));
            assignmentStore && (assignments = assignments.concat(r.getAssignments()));
        }
        // Sorting dependencies in index order for future restoration
        dependencies = dependencyStore && Ext.Array.unique(dependencies);
        dependencies = dependencyStore && Ext.Array.sort(dependencies, function(a, b) {
            return dependencyStore.indexOf(a) < dependencyStore.indexOf(b) ? -1 : 1;
        });
        // 0 is not an option here
        // Collecting dependencies indices
        for (i = 0 , len = dependencies && dependencies.length; dependencyStore && i < len; i++) {
            dependenciesIndices.push(dependencyStore.indexOf(dependencies[i]));
        }
        // Sorting assignments in index order for future restoration
        assignments = assignmentStore && Ext.Array.sort(assignments, function(a, b) {
            return assignmentStore.indexOf(a) < assignmentStore.indexOf(b) ? -1 : 1;
        });
        // 0 is not an option here
        // Collecting assignments indicies
        for (i = 0 , len = assignments && assignments.length; assignmentStore && i < len; i++) {
            assignmentsIndices.push(assignmentStore.indexOf(assignments[i]));
        }
        // It's important to remove subtask/subtree first. If we will remove assignments/dependencies first then
        // subtree tasks might be adjusted and such adjustments might envolve pricy calculations which then will be
        // made void by removing a task they affecting.
        // Removing subtask (which will remove subtree as well)
        subtask = me.removeChild(subtask);
        // Removing all assignments
        assignmentStore && assignmentStore.remove(assignments);
        // Removing all dependencies
        dependencyStore && dependencyStore.remove(dependencies);
        // Converting self to leaf if required
        if (me.childNodes.length === 0 && me.convertEmptyParentToLeaf) {
            me.set('leaf', true);
        }
        cancelFeedback && cancelFeedback(function() {
            // Restoring everything back
            me.insertChild(indexOfSubtask, subtask);
            for (i = 0 , len = assignments && assignments.length; assignmentStore && i < len; i++) {
                assignmentStore.insert(assignmentsIndices[i], assignments[i]);
            }
            for (i = 0 , len = dependencies && dependencies.length; dependencyStore && i < len; i++) {
                dependencyStore.insert(dependenciesIndices[i], dependencies[i]);
            }
        });
        return me;
    },
    /**
     * Adds the passed task as a successor and creates a new dependency between the two tasks.
     * @param {Gnt.model.Task} [successor] The new successor
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the successor task
     */
    addSuccessor: function(successor, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.addSuccessorWithoutPropagation(successor, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    addSuccessorWithoutPropagation: function(successor, cancelAndResultFeedback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            insertCancelFn, linkCancelFn;
        successor = successor || new me.self();
        // we set a calendar to the task being added to be able to call calculateEndDate() for it
        // since we do it before the task gets into the task store and the project calendar is not reachable
        successor.calendar = successor.calendar || me.getCalendar();
        successor.taskStore = successor.taskStore || me.getTaskStore(true);
        if (me.getEndDate()) {
            successor.beginEdit();
            successor.set(me.startDateField, me.getEndDate());
            successor.set(me.endDateField, successor.calculateEndDate(me.getEndDate(), 1, Sch.util.Date.DAY));
            successor.set(me.durationField, 1);
            successor.set(me.durationUnitField, Sch.util.Date.DAY);
            successor.endEdit();
        }
        // adding successor below
        parentNode.insertSubtaskWithoutPropagation(index + 1, successor, function(fn, result) {
            insertCancelFn = fn;
            successor = result;
        });
        me.linkToWithoutPropagation(successor, Gnt.model.Dependency.Type.EndToStart, function(fn) {
            linkCancelFn = fn;
        });
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            linkCancelFn();
            insertCancelFn();
        }, successor);
        return me;
    },
    /**
     * Adds the passed task as a milestone below this task.
     * @param {Gnt.model.Task} milestone (optional) The milestone
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the new milestone.
     */
    addMilestone: function(milestone, callback) {
        var me = this,
            date = me.getEndDate();
        if (!milestone) {
            milestone = new me.self();
        } else if (Ext.isObject(milestone) && !(milestone instanceof Gnt.model.Task)) {
            milestone = new me.self(milestone);
        }
        if (date && !milestone.isMilestone()) {
            milestone.calendar = milestone.calendar || me.getCalendar();
            milestone.setStartEndDate(date, date);
        }
        return me.addTaskBelow(milestone, callback);
    },
    /**
     * Adds the passed task as a predecessor and creates a new dependency between the two tasks.
     * @param {Gnt.model.Task} [predecessor] The new predecessor
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the new predecessor
     */
    addPredecessor: function(predecessor, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.addPredecessorWithoutPropagation(predecessor, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    addPredecessorWithoutPropagation: function(predecessor, cancelAndResultFeedback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            insertCancelFn, linkCancelFn;
        predecessor = predecessor || new me.self();
        predecessor.calendar = predecessor.calendar || me.getCalendar();
        // WTF, why so?
        predecessor.taskStore = predecessor.taskStore || me.getTaskStore(true);
        if (me.getStartDate()) {
            predecessor.beginEdit();
            predecessor.set(me.startDateField, predecessor.calculateStartDate(me.getStartDate(), 1, Sch.util.Date.DAY));
            predecessor.set(me.endDateField, me.getStartDate());
            predecessor.set(me.durationField, 1);
            predecessor.set(me.durationUnitField, Sch.util.Date.DAY);
            predecessor.endEdit();
        }
        parentNode.insertSubtaskWithoutPropagation(index, predecessor, function(fn, result) {
            insertCancelFn = fn;
            predecessor = result;
        });
        predecessor.linkToWithoutPropagation(me, Gnt.model.Dependency.Type.EndToStart, function(fn) {
            linkCancelFn = fn;
        });
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            linkCancelFn();
            insertCancelFn();
        }, predecessor);
        return predecessor;
    },
    /**
     * Returns all the successor tasks of this task
     *
     * @return {Gnt.model.Task[]}
     */
    getSuccessors: function() {
        var deps = this.successors,
            res = [];
        for (var i = 0,
            len = deps.length; i < len; i++) {
            var task = deps[i].getTargetTask();
            if (task)  {
                res.push(task);
            }
            
        }
        return res;
    },
    /**
     * Returns all the predecessor tasks of a this task.
     *
     * @return {Gnt.model.Task[]}
     */
    getPredecessors: function() {
        var deps = this.predecessors,
            res = [];
        for (var i = 0,
            len = deps.length; i < len; i++) {
            var task = deps[i].getSourceTask();
            if (task)  {
                res.push(task);
            }
            
        }
        return res;
    },
    /**
     * Adds the passed task (or creates a new task) before itself
     * @param {Gnt.model.Task} addTaskAbove (optional) The task to add
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskAbove: function(task, callback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            compatResult, cancelFn;
        task = task || new me.self();
        me.propagateChanges(function() {
            return parentNode.insertSubtaskWithoutPropagation(index, task, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    /**
     * Adds the passed task (or creates a new task) after itself
     * @param {Gnt.model.Task} task (optional) The task to add
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskBelow: function(task, callback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me) + 1,
            compatResult, cancelFn;
        task = task || new me.self();
        me.propagateChanges(function() {
            return parentNode.insertSubtaskWithoutPropagation(index, task, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    // Returns true if this task model is 'above' the passed task model
    isAbove: function(otherTask) {
        var me = this,
            minDepth = Math.min(me.data.depth, otherTask.data.depth);
        var current = this;
        // Walk upwards until tasks are on the same level
        while (current.data.depth > minDepth) {
            current = current.parentNode;
            if (current == otherTask)  {
                return false;
            }
            
        }
        while (otherTask.data.depth > minDepth) {
            otherTask = otherTask.parentNode;
            if (otherTask == me)  {
                return true;
            }
            
        }
        // At this point, depth of both tasks should be identical.
        // Walk up to find common parent, to be able to compare indexes
        while (otherTask.parentNode !== current.parentNode) {
            otherTask = otherTask.parentNode;
            current = current.parentNode;
        }
        return otherTask.data.index > current.data.index;
    },
    /**
     * Cascades the children of a task. The given function is not called for this node itself.
     * @param {Function} fn The function to call for each child
     * @param {Object} scope The 'this' object to use for the function, defaults to the current node.
     */
    cascadeChildren: function(fn, scope) {
        var me = this;
        if (me.isLeaf())  {
            return;
        }
        
        var childNodes = this.childNodes;
        for (var i = 0,
            len = childNodes.length; i < len; i++) childNodes[i].cascadeBy(fn, scope);
    },
    /**
     * Returns the _slack_ (or _float_) of this task.
     * The _slack_ is the amount of time that this task can be delayed without causing a delay
     * to any of its successors.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _slack_ of this task.
     */
    getSlack: function(unit) {
        unit = unit || Sch.util.Date.DAY;
        var earlyStart = this.getEarlyStartDate(),
            lateStart = this.getLateStartDate();
        if (!earlyStart || !lateStart)  {
            return null;
        }
        
        // slack taking into account only working period of time
        return this.getCalendar().calculateDuration(earlyStart, lateStart, unit);
    },
    /**
     * Returns the _early start date_ of this task.
     * The _early start date_ is the earliest possible start date of a task.
     * This value is calculated based on the earliest end dates of the task predecessors.
     * If the task has no predecessors, its start date is the early start date.
     *
     * @return {Date} The early start date.
     */
    getEarlyStartDate: function() {
        var store = this.getTaskStore(true);
        if (!store)  {
            return this.getStartDate();
        }
        
        var internalId = this.internalId;
        if (store.earlyStartDates[internalId])  {
            return store.earlyStartDates[internalId];
        }
        
        var dt,
            result = 0,
            i, l;
        // for a parent task we take the minimum Early Start from its children
        if (this.childNodes.length) {
            for (i = 0 , l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getEarlyStartDate();
                if (dt < result || !result)  {
                    result = dt;
                }
                
            }
            store.earlyStartDates[internalId] = result;
            return result;
        }
        // for manually scheduled task we simply return its start date
        if (this.isManuallyScheduled()) {
            result = store.earlyStartDates[internalId] = this.getStartDate();
            return result;
        }
        var deps = this.getIncomingDependencies(true);
        if (!deps.length) {
            result = store.earlyStartDates[internalId] = this.getStartDate();
            return result;
        }
        var depType = Gnt.model.Dependency.Type,
            ownCalendar = this.getCalendar();
        // Early Start Date is the largest of Early Finish Dates of the preceding tasks
        for (i = 0 , l = deps.length; i < l; i++) {
            var dependency = deps[i],
                fromTask = dependency.getSourceTask(),
                // get calendar instance to use for lag calculations
                dependencyCalendar = this.getDependencyCalendar(dependency);
            if (fromTask) {
                switch (dependency.getType()) {
                    case depType.StartToStart:
                        dt = fromTask.getEarlyStartDate();
                        break;
                    case depType.StartToEnd:
                        dt = fromTask.getEarlyStartDate();
                        // minus duration to get start
                        dt = ownCalendar.calculateStartDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.EndToStart:
                        dt = fromTask.getEarlyEndDate();
                        break;
                    case depType.EndToEnd:
                        dt = fromTask.getEarlyEndDate();
                        // minus duration to get start
                        dt = ownCalendar.calculateStartDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                }
                // plus dependency Lag
                var lag = dependency.getLag();
                if (dt && lag)  {
                    dt = dependencyCalendar.skipWorkingTime(dt, lag, dependency.getLagUnit());
                }
                
                if (dt) {
                    dt = ownCalendar.skipNonWorkingTime(dt, true);
                }
            }
            if (dt > result)  {
                result = dt;
            }
            
        }
        // store found value into the cache
        store.earlyStartDates[internalId] = result;
        return result;
    },
    /**
     * Returns the _early end date_ of the task.
     * The _early end date_ is the earliest possible end date of the task.
     * This value is calculated based on the earliest end dates of predecessors.
     * If the task has no predecessors then its end date is used as its earliest end date.
     *
     * @return {Date} The early end date.
     */
    getEarlyEndDate: function() {
        var store = this.getTaskStore(true);
        if (!store)  {
            return this.getEndDate();
        }
        
        var internalId = this.internalId;
        if (store.earlyEndDates[internalId])  {
            return store.earlyEndDates[internalId];
        }
        
        var result = 0;
        // for parent task we take maximum Early Finish from its children
        if (this.childNodes.length) {
            var dt, i, l;
            for (i = 0 , l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getEarlyEndDate();
                if (dt > result)  {
                    result = dt;
                }
                
            }
            store.earlyEndDates[internalId] = result;
            return result;
        }
        // for manually scheduled task we simply return its end date
        if (this.isManuallyScheduled()) {
            result = store.earlyEndDates[internalId] = this.getEndDate();
            return result;
        }
        // Early Finish Date is Early Start Date plus duration
        var value = this.getEarlyStartDate();
        if (!value)  {
            return null;
        }
        
        result = store.earlyEndDates[internalId] = this.getCalendar().calculateEndDate(value, this.getDuration(), this.getDurationUnit());
        return result;
    },
    /**
     * Returns the _late end date_ of the task.
     * The _late end date_ is the latest possible end date of the task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, the project end date is used as its latest end date.
     *
     * @return {Date} The late end date.
     */
    getLateEndDate: function() {
        var store = this.getTaskStore(true);
        if (!store)  {
            return this.getEndDate();
        }
        
        var internalId = this.internalId;
        if (store.lateEndDates[internalId])  {
            return store.lateEndDates[internalId];
        }
        
        var dt,
            result = 0,
            i, l;
        // for parent task we take maximum Late Finish from its children
        if (this.childNodes.length) {
            for (i = 0 , l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getLateEndDate();
                if (dt > result)  {
                    result = dt;
                }
                
            }
            store.lateEndDates[internalId] = result;
            return result;
        }
        // for manually scheduled task we simply return its end date
        if (this.isManuallyScheduled()) {
            result = store.lateEndDates[internalId] = this.getEndDate();
            return result;
        }
        var deps = this.getOutgoingDependencies(true);
        if (!deps.length) {
            result = store.lateEndDates[internalId] = store.getProjectEndDate();
            return result;
        }
        var depType = Gnt.model.Dependency.Type,
            ownCalendar = this.getCalendar();
        // Late Finish Date is the smallest of Late Start Dates of succeeding tasks
        for (i = 0 , l = deps.length; i < l; i++) {
            var dependency = deps[i],
                toTask = dependency.getTargetTask(),
                // get calendar instance to use for lag calculations
                dependencyCalendar = this.getDependencyCalendar(dependency);
            if (toTask) {
                switch (dependency.getType()) {
                    case depType.StartToStart:
                        // start-to-start
                        dt = toTask.getLateStartDate();
                        // plus duration to get end
                        dt = ownCalendar.calculateEndDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.StartToEnd:
                        // start-to-end
                        dt = toTask.getLateEndDate();
                        // plus duration to get end
                        dt = ownCalendar.calculateEndDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.EndToStart:
                        // end-to-start
                        dt = toTask.getLateStartDate();
                        break;
                    case depType.EndToEnd:
                        // end-to-end
                        dt = toTask.getLateEndDate();
                        break;
                }
                // minus dependency Lag
                var lag = dependency.getLag();
                if (lag)  {
                    dt = dependencyCalendar.skipWorkingTime(dt, -lag, dependency.getLagUnit());
                }
                
                dt = ownCalendar.skipNonWorkingTime(dt, false);
                if (dt < result || !result)  {
                    result = dt;
                }
                
            }
        }
        // cache found value
        store.lateEndDates[internalId] = result || store.getProjectEndDate();
        return store.lateEndDates[internalId];
    },
    /**
     * Returns the _late start date_ of the task.
     * The _late start date_ is the latest possible start date of this task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, this value is calculated as the _project end date_ minus the task duration
     * (_project end date_ is the latest end date of all the tasks in the taskStore).
     *
     * @return {Date} The late start date.
     */
    getLateStartDate: function() {
        var store = this.getTaskStore(true);
        if (!store)  {
            return this.getStartDate();
        }
        
        var internalId = this.internalId;
        if (store.lateStartDates[internalId])  {
            return store.lateStartDates[internalId];
        }
        
        var result;
        // for parent task we take minimum Late Start from its children
        if (this.childNodes.length) {
            var dt, i, l;
            for (i = 0 , l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getLateStartDate();
                if (dt < result || !result)  {
                    result = dt;
                }
                
            }
            store.lateStartDates[internalId] = result;
            return result;
        }
        // for manually scheduled task we simply return its start date
        if (this.isManuallyScheduled()) {
            result = store.lateStartDates[internalId] = this.getStartDate();
            return result;
        }
        // Late Start Date is Late Finish Date minus duration
        var value = this.getLateEndDate();
        if (!value)  {
            return null;
        }
        
        result = store.lateStartDates[internalId] = this.getCalendar().calculateStartDate(value, this.getDuration(), this.getDurationUnit());
        return result;
    },
    getTopParent: function(all) {
        var root = this.getTaskStore().getRoot(),
            p = this,
            path = [
                this
            ],
            result;
        while (p) {
            if (p === root)  {
                return all ? path : result;
            }
            
            path.push(p);
            result = p;
            p = p.parentNode;
        }
    },
    // TODO: use for something - as a fast way of iterating over all children of some parent in depth
    getInDepthWalker: function(includeThisNode) {
        var current = includeThisNode ? this : this.childNodes && this.childNodes[0];
        var stopAt = this;
        var visitedParents = {};
        var next = function(from) {
                var current = from;
                var internalId = current.internalId;
                if (current.isLeaf() || !current.childNodes.length)  {
                    current = current.nextSibling;
                }
                else {
                    if (visitedParents[internalId] === true) {
                        visitedParents[internalId] = false;
                        current = current.nextSibling;
                    } else {
                        visitedParents[internalId] = true;
                        current = current.childNodes[0];
                    }
                }
                if (!current) {
                    current = from;
                    do {
                        if (current === stopAt)  {
                            return null;
                        }
                        
                        current = current.parentNode;
                        if (current === stopAt)  {
                            return null;
                        }
                        
                    } while (visitedParents[current.internalId] === false);
                    return next(current);
                }
                return current;
            };
        return function() {
            var task = current;
            if (current)  {
                current = next(current);
            }
            
            return task;
        };
    },
    /**
     * Propagates changes done in `changer` function to the task to all dependent tasks. The action is asynchronous
     * since changes propagation might violate some constraints applied, which in it's turn might require user
     * interaction.
     *
     * @param {Function} [changer] A function which should apply changes to the task
     *  A changer might return:
     *  - true - in this case the task will be considered as propagation source and propagation will be done only
     *    if the task has outstanding changes to propagate;
     *  - false or nothing - to cancel changes and skip propagation entirely;
     *  - a task instance, or array of task instances - to considered given instances as propagation source(s) and do
     *    the propagation
     *  If changer is not given or it's equal to Ext.emptyFn then propagation will be forcefully executed and tasks
     *  will be aligned/constrained according to their dependencies and/or constraints.
     * @param {Gnt.model.Task} changer.task The task
     * @param {Function} [callback] A callback function which will be called after changes propagation.
     * @param {Boolean}  callback.cancel Flag showing whether entire changes transaction has been canceled
     *  and nothing is changed.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @param {Boolean}  [forceCascadeChanges=task's task store `cascadeChanges` option] Flag indicating whether to propagate changes to dependent tasks.
     */
    propagateChanges: function(changer, callback, forceCascadeChanges) {
        var me = this,
            propagationSources, affectedTasks, taskStore, cascadeBatch;
        !changer || Ext.isFunction(changer) || Ext.Error.raise("Can't propagate changes to a task, invalid changer function given");
        !callback || Ext.isFunction(callback) || Ext.Error.raise("Can't propagate changes to a task, invalid callback function given");
        taskStore = me.getTaskStore(true);
        forceCascadeChanges = arguments.length == 3 ? forceCascadeChanges : taskStore && taskStore.cascadeChanges;
        if (!me.propagating && taskStore) {
            me.propagating = true;
            affectedTasks = {};
            taskStore.suspendAutoSync();
            cascadeBatch = taskStore.startBatchCascade();
            taskStore.startProjection();
            try {
                propagationSources = (changer && changer !== Ext.emptyFn) ? changer(me) : [
                    me
                ];
            } catch (e) {
                taskStore.rejectProjection();
                taskStore.endBatchCascade();
                taskStore.resumeAutoSync(taskStore.autoSync);
                me.propagating = false;
                throw e;
            }
            if (propagationSources === true) {
                propagationSources = me.isProjected() && [
                    me
                ] || false;
            } else if (propagationSources) {
                propagationSources = [].concat(propagationSources);
            }
            // Propagating
            if (propagationSources) {
                me.propagateChangesThroughDependentTasks(taskStore.getLinearWalkingSequenceForDependentTasks(propagationSources, {
                    self: true,
                    ancestors: taskStore.recalculateParents,
                    descendants: taskStore.moveParentAsGroup,
                    successors: forceCascadeChanges,
                    cycles: taskStore.cycleResolutionStrategy
                }), taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, function propagateChangesThroughDependentTasksCallback(cancelChanges, affectedTasks) {
                    if (cancelChanges) {
                        taskStore.rejectProjection();
                        affectedTasks = {};
                    } else {
                        taskStore.commitProjection();
                    }
                    taskStore.endBatchCascade();
                    me.propagating = false;
                    callback && callback(cancelChanges, affectedTasks);
                    taskStore.resumeAutoSync(taskStore.autoSync && !cancelChanges && !Ext.Object.isEmpty(affectedTasks));
                });
            } else {
                taskStore.rejectProjection();
                taskStore.endBatchCascade();
                me.propagating = false;
                callback && callback(false, {});
                taskStore.resumeAutoSync(taskStore.autoSync);
            }
        }
        // No task store
        else if (!me.propagating) {
            me.propagating = true;
            try {
                changer && changer(me);
            } catch (e) {
                me.propagating = false;
                throw e;
            }
            me.verifyConstraint(function(constraintSatisfied, cancelChanges) {
                affectedTasks = {};
                cancelChanges = !!cancelChanges;
                if (!cancelChanges) {
                    affectedTasks[me.getId()] = me;
                }
                me.propagating = false;
                callback && callback(cancelChanges, affectedTasks);
            });
        } else // We are currently propagating
        {
            callback && callback(true, {});
        }
    },
    /**
     * @private
     *
     * @param {Array} linearWalkingSequence
     * @param {Gnt.model.Task} linearWalkingSequence[0] Step task
     * @param {String}         linearWalkingSequence[1] Color of the visiting step
     *  - 'green'  - Task is ready to be processed
     *  - 'yellow' - Branch task is ready to process it's children
     * @param {Object}         linearWalkingSequence[2] Set of all collected dependent tasks
     * @param {Object}         linearWalkingSequence[3] Dependency data
     * @param {Gnt.data.TaskStore} taskStore
     * @param {Object}             cascadeBatch
     * @param {Gnt.model.Task[]}   propagationSources
     * @param {Boolean}            forceCascadeChanges
     * @param {Object}             affectedTasks
     * @param {Function}           callback
     * @param {Integer}            startAt
     */
    propagateChangesThroughDependentTasks: function(linearWalkingSequence, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback, startAt) {
        var me = this,
            i, len, constraintSatisfied;
        startAt = startAt || 0;
        constraintSatisfied = true;
        for (i = startAt , len = linearWalkingSequence.length; constraintSatisfied && i < len; ++i) {
            constraintSatisfied = me.processTaskConstraints(linearWalkingSequence, i, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, function(linearWalkingIndex, constraintSatisfied, propagationCanceled, affectedTasks) {
                // This callback might be called either synchronously or asynchronously thus we can't rely on
                // `i` variable here. That's because if it is called synchronously then `i` will not yet be
                // incremented by the for loop counter incrementing part, and if it's called asynchronously
                // then `i` will be already incremented by the for loop directive. Thus we got the index
                // for which this callback is called for as a parameter
                // Stop condition
                if (propagationCanceled || (linearWalkingIndex == len - 1)) {
                    callback(propagationCanceled, affectedTasks);
                }
                // Continue by recursion condition
                else if (!constraintSatisfied) {
                    me.propagateChangesThroughDependentTasks(linearWalkingSequence, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback, linearWalkingIndex + 1);
                }
            });
        }
    },
    // Else constraint is satisfied and we will continue by the for loop
    /**
     * @private
     *
     * Will return `false` if a constraint conflict has been detected and awaiting for resolution, once resolved
     * the callback method will be called.
     */
    processTaskConstraints: function(linearWalkingSequence, linearWalkingIndex, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback) {
        var me = this,
            step = linearWalkingSequence[linearWalkingIndex],
            task = step[0],
            color = step[1],
            isParent = task.hasChildNodes(),
            isLeaf = !isParent,
            autoScheduled = !(task.isManuallyScheduled() || task.isReadOnly() || Ext.Array.contains(propagationSources, task)),
            cascadeChanges = forceCascadeChanges || taskStore.cascadeChanges,
            recalculateParents = taskStore.recalculateParents,
            moveParentAsGroup = taskStore.moveParentAsGroup,
            parentNode = task.parentNode,
            parentNodeStartDate = parentNode && (parentNode.getStartDate()),
            parentNodeUnprojectedStartDate = parentNode && (parentNode.getUnprojected(parentNode.startDateField)),
            parentNodeDateOffset = parentNode && (parentNodeStartDate - parentNodeUnprojectedStartDate),
            offsetFromParent;
        function areIncomingDependenciesAffectedOrPropagationSourcesIncoming(task, affectedTasks, propagationSources) {
            var incomingDeps = task.getIncomingDependencies(true),
                result = false,
                i, len, dep, fromTask;
            for (i = 0 , len = incomingDeps.length; !result && i < len; ++i) {
                dep = incomingDeps[i];
                fromTask = dep.getSourceTask();
                result = fromTask && affectedTasks.hasOwnProperty(fromTask.getId()) || Ext.Array.contains(propagationSources, fromTask);
            }
            return result;
        }
        switch (true) {
            case autoScheduled && isLeaf && color == 'green' && parentNodeDateOffset && moveParentAsGroup:
            case autoScheduled && isParent && color == 'yellow' && parentNodeDateOffset && moveParentAsGroup:
                // TODO: we ignore case when parent StartDate set to NULL
                // since we cannot calculate proper dates to shift child tasks at
                if (parentNodeStartDate) {
                    var startDate = task.getStartDate();
                    if (startDate >= parentNodeUnprojectedStartDate) {
                        offsetFromParent = task.calculateDuration(parentNodeUnprojectedStartDate, startDate, null, {
                            segments: false
                        });
                        task.setStartDateWithoutPropagation(task.calculateEndDate(parentNodeStartDate, offsetFromParent, null, {
                            segments: false
                        }), true, taskStore.skipWeekendsDuringDragDrop);
                    } else // if the summary task starts after this one
                    {
                        // force to not take segments into account during new start date calculating
                        offsetFromParent = task.calculateDuration(startDate, parentNodeUnprojectedStartDate, null, {
                            segments: false
                        });
                        task.setStartDateWithoutPropagation(task.calculateStartDate(parentNodeStartDate, offsetFromParent, null, {
                            segments: false
                        }), true, taskStore.skipWeekendsDuringDragDrop);
                    }
                    // Passing a parent node here limits the constraining to incoming dependencies incoming from
                    // that parent node descendants only, outer nodes are not taken into account
                    areIncomingDependenciesAffectedOrPropagationSourcesIncoming(task, affectedTasks, propagationSources) && task.alignByIncomingDependenciesWithoutPropagation(taskStore, null, parentNode);
                };
                break;
            case autoScheduled && isLeaf && color == 'green' && cascadeChanges:
            case autoScheduled && isParent && color == 'yellow' && cascadeChanges:
                areIncomingDependenciesAffectedOrPropagationSourcesIncoming(task, affectedTasks, propagationSources) && task.alignByIncomingDependenciesWithoutPropagation(taskStore, null);
                break;
            case isParent && color == 'green' && recalculateParents:
                task.refreshCalculatedParentNodeData();
                break;
        }
        if (task.isProjected()) {
            cascadeBatch.addAffected(task);
            affectedTasks[task.getId()] = task;
        }
        return task.verifyConstraint(function(constraintSatisfied, propagationCanceled) {
            var yellowStep, yellowStepIdx;
            // In case a parent node is adjusted according to it's children and such an adjustment violates
            // the parent node constraint then we rewind back to the same parent node yellow step to readjust
            // it and it's children once again allowing a user to reconsider (by showing him constraint violation
            // dialog, for example). We rewince by calling a callback with ajusted step index.
            if (!constraintSatisfied && isParent && autoScheduled && taskStore.recalculateParents && color == 'green') {
                yellowStep = Ext.Array.findBy(linearWalkingSequence, function(step, index) {
                    var stepTask = step[0],
                        stepColor = step[1];
                    yellowStepIdx = index;
                    return task === stepTask && stepColor == 'yellow';
                });
                // yellowStep must always be present in the linear walking sequence.
                callback(yellowStepIdx, constraintSatisfied, !!propagationCanceled, affectedTasks);
            } else {
                callback(linearWalkingIndex, constraintSatisfied, !!propagationCanceled, affectedTasks);
            }
        });
    },
    removeLinkToTask: function(task) {
        var depStore = this.getDependencyStore();
        var task1Id = this.getId();
        var task2Id = task.getId();
        Ext.Array.each(this.getAllDependencies(), function(dep) {
            if ((dep.getSourceId() === task1Id && dep.getTargetId() === task2Id) || (dep.getSourceId() === task2Id && dep.getTargetId() === task1Id)) {
                depStore.remove(dep);
                return false;
            }
        });
    },
    convertEmptyParentToLeafTask: function() {
        this.beginEdit();
        this.set('leaf', true);
        this.setDurationWithoutPropagation(1, Sch.util.Date.DAY);
        this.endEdit();
    },
    hasEndPredecessorsButNoStartPredecessors: function() {
        var incoming = this.getIncomingDependencies();
        var result = incoming.length > 0;
        var Type = Gnt.model.Dependency.Type;
        Ext.Array.each(incoming, function(dep) {
            if (dep.getType() === Type.StartToStart || dep.getType() === Type.EndToStart) {
                return result = false;
            }
        });
        return result;
    },
    isCompleted: function() {
        return this.getPercentDone() >= 100;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.task.Constraints
@mixin
@protected

Internal mixin class providing additional logic and functionality related to task constraints.

*/
Ext.define('Gnt.model.task.Constraints', {
    requires: [
        'Gnt.constraint.Base',
        'Gnt.constraint.StartNoEarlierThan',
        'Gnt.constraint.StartNoLaterThan',
        'Gnt.constraint.FinishNoEarlierThan',
        'Gnt.constraint.FinishNoLaterThan',
        'Gnt.constraint.MustStartOn',
        'Gnt.constraint.MustFinishOn'
    ],
    /**
     * Sets the constraint type and constraining date (if applicable) to the task.
     *
     * @param {String} type
     *  Constraint type, see {@link #setConstraintType} for further description.
     * @param {Date}   date
     *  Constraint date
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for cancelling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraint: function(type, date, callback) {
        var me = this;
        function changer() {
            return me.setConstraintWithoutPropagation(type, date);
        }
        if (type) {
            me.propagateChanges(changer, callback);
        } else {
            changer();
            callback && callback(false, {});
        }
    },
    setConstraintWithoutPropagation: function(type, date) {
        var me = this,
            constraint;
        if (type) {
            constraint = Gnt.constraint.Base.getConstraintClass(type);
        }
        if (!date && constraint) {
            date = constraint.getInitialConstraintDate(me);
        }
        me.beginEdit();
        me.set(me.constraintTypeField, type || '');
        me.set(me.constraintDateField, date);
        me.endEdit();
        return true;
    },
    /**
     * Sets the constraint type of the task. The type string can be one of the following values:
     *
     *  - finishnoearlierthan
     *  - finishnolaterthan
     *  - mustfinishon
     *  - muststarton
     *  - startnoearlierthan
     *  - startnolaterthan
     *
     * @param {String} type
     *  Constraint type
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraintType: function(type, callback) {
        this.setConstraint(type, this.getConstraintDate(), callback);
    },
    setConstraintTypeWithoutPropagation: function(type, callback) {
        this.setConstraintWithoutPropagation(type, this.getConstraintDate(), callback);
    },
    /**
     * Sets the constraint date of the task.
     *
     * @param {Date}   date
     *  Constraint date
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraintDate: function(date, callback) {
        this.setConstraint(this.getConstraintType(), date, callback);
    },
    setConstraintDateWithoutPropagation: function(date) {
        this.setConstraintWithoutPropagation(this.getConstraintType(), date);
    },
    /**
     * Checks whether a constraint is set for the task.
     *
     * @return {Boolean}
     */
    hasConstraint: function() {
        return !!this.getConstraintType();
    },
    /**
     * Returns a constraint singleton class corresponding to the constraint type currently set for the task.
     *
     * @return {Gnt.constraint.Base} subclass of
     */
    getConstraintClass: function() {
        return Gnt.constraint.Base.getConstraintClass(this.getConstraintType());
    },
    /**
     * Returns true if task has no constraint set or if a constraint set is satisfied by the task.
     *
     * @return {Boolean}
     */
    isConstraintSatisfied: function() {
        var me = this;
        return !me.hasConstraint() || me.getConstraintClass().isSatisfied(me, me.getConstraintDate());
    },
    /**
     * Verifies the constraint of the task.
     *
     * @param {Function} [onceResolvedContinueHere] Callback function to be called after constraint conflict resolution.
     * @param {Boolean}  onceResolvedContinueHere.constraintSatisfied Flag showing whether constraint has been satisfied or violated.
     * @param {Boolean}  onceResolvedContinueHere.cancelChanges Flag showing whether a user has opted for changes to be canceled.
     * @return {Boolean} True if no constraint conflict has been found, false otherwise
     *
     * @private
     */
    verifyConstraint: function(onceResolvedContinueHere) {
        var me = this,
            taskStore, precision, constraintResolutionContext, constraintSatisfied, hasConflictListener;
        !onceResolvedContinueHere || Ext.isFunction(onceResolvedContinueHere) || Ext.Error.raise("Can't verify task's constraint, resultion callback is invalid!");
        constraintSatisfied = me.isConstraintSatisfied();
        onceResolvedContinueHere = onceResolvedContinueHere && Ext.Function.pass(onceResolvedContinueHere, [
            constraintSatisfied
        ]);
        taskStore = me.getTaskStore(true);
        hasConflictListener = taskStore && taskStore.hasListener('constraintconflict');
        precision = taskStore && taskStore.constraintDatePrecision || Sch.util.Date.DAY;
        constraintResolutionContext = !constraintSatisfied && me.getConstraintClass().getResolution(onceResolvedContinueHere, me, null, precision);
        if (!constraintSatisfied && hasConflictListener) {
            /**
             * @event constraintconflict
             *
             * Fires when task constraint conflict has been found and requires a resolution.
             *
             * @param {Gnt.model.Task} task The task whose constraint is violated
             * @param {Object} context Constraint resolution context
             * @param {String} context.title The description of the
             *
             * @member Gnt.data.TaskStore
             */
            taskStore.fireEvent('constraintconflict', me, constraintResolutionContext);
        } else if (!constraintSatisfied) {
            constraintResolutionContext.cancelAction();
        } else if (onceResolvedContinueHere) {
            onceResolvedContinueHere(false);
        }
        return constraintSatisfied;
    },
    /**
     * Returns working time start for the given date, task's calendar and calendars the task assigned resources
     * calendars are taken into account.
     *
     * If there's no working time present at the given date then returns false.
     *
     * @param {Date} date
     * @return {Date|false}
     */
    getWorkingTimeStartForDate: function(date) {
        var me = this,
            result = false,
            startDate, endDate;
        date instanceof Date || Ext.Error.raise('Can\'t get working time start for a date, invalid date given!');
        startDate = Ext.Date.clearTime(date, true);
        endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, 1);
        me.forEachAvailabilityInterval({
            isForward: true,
            startDate: startDate,
            endDate: endDate,
            segments: false,
            resources: true,
            fn: function(from, to) {
                result = new Date(from);
                return false;
            }
        });
        return result;
    },
    /**
     * Returns working time end for the given date, task's calendar and calendars the task assigned resources
     * calendars are taken into account.
     *
     * If there's no working time present at the given date then returns false.
     *
     * @param {Date} date
     * @return {Date|false}
     */
    getWorkingTimeEndForDate: function(date) {
        var me = this,
            result = false,
            startDate, endDate;
        date instanceof Date || Ext.Error.raise('Can\'t get working time end for a date, invalid date given!');
        startDate = Ext.Date.clearTime(date, true);
        endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, 1);
        me.forEachAvailabilityInterval({
            isForward: false,
            startDate: startDate,
            endDate: endDate,
            segments: false,
            resources: true,
            fn: function(from, to) {
                result = new Date(to);
                return false;
            }
        });
        return result;
    },
    /**
     * Returns nearest working time start (earliest for the day) in the given search direction up to given search limit
     *
     * @param {Date} date Date to start searching from.
     * @param {Boolean} searchBackward Search direction flag.
     * @param {Integer} searchLimit Amount of days to search in.
     *
     * @return {Date|false}
     */
    getNearestWorkingTimeStartForDate: function(date, searchBackward, searchLimit) {
        var me = this,
            step, result;
        date instanceof Date || Ext.Error.raise('Can\'t get nearest working time start for a date, invalid date given!');
        searchBackward = searchBackward || false;
        searchLimit = searchLimit || 365;
        step = searchBackward ? -1 : 1;
        result = me.getWorkingTimeStartForDate(date);
        while (!result && searchLimit--) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, step);
            result = me.getWorkingTimeStartForDate(date);
        }
        return result;
    },
    /**
     * Returns nearest working time end (latest for the day) in the given search direction up to given search limit
     *
     * @param {Date} date Date to start searching from.
     * @param {Boolean} searchBackward Search direction flag.
     * @param {Integer} searchLimit Amount of days to search in.
     *
     * @return {Date|false}
     */
    getNearestWorkingTimeEndForDate: function(date, searchBackward, searchLimit) {
        var me = this,
            step, result;
        date instanceof Date || Ext.Error.raise('Can\'t get nearest working time end for a date, invalid date given!');
        searchBackward = searchBackward || false;
        searchLimit = searchLimit || 365;
        step = searchBackward ? -1 : 1;
        result = me.getWorkingTimeEndForDate(date);
        while (!result && searchLimit--) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, step);
            result = me.getWorkingTimeEndForDate(date);
        }
        return result;
    },
    /**
     * Returns working time interval for the given datetime, if datetime is not withing working time interval,
     * then returns false, task's calendar and calendars the task assigned resources calendars are taken into account.
     *
     * @param {Date} dateTime
     * @return {Object|false} Object containing _startDate_, _endDate_ properties or false.
     */
    getWorkingTimeIntervalForDateTime: function(dateTime) {
        var me = this,
            result = false,
            startDate, endDate;
        dateTime instanceof Date || Ext.Error.raise('Can\'t get task\'s working time intarval for a datetime, invalid datetime given!');
        startDate = Ext.Date.clearTime(dateTime, true);
        endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, 1);
        dateTime = dateTime.valueOf();
        me.forEachAvailabilityInterval({
            isForward: true,
            startDate: startDate,
            endDate: endDate,
            segments: false,
            resources: true,
            fn: function(from, to) {
                if (from <= dateTime && dateTime <= to) {
                    result = {
                        startDate: new Date(from),
                        endDate: new Date(to)
                    };
                }
                return !result;
            }
        });
        return result;
    },
    /**
     * Checks whether the given time is within working time interval for the task, task's calendar and calendars
     * the task assigned resources calendars are taken into account.
     *
     * @param {Date} dateTime
     * @return {Boolean}
     */
    isDateTimeWithinWorkingTimeInterval: function(dateTime) {
        var me = this;
        dateTime instanceof Date || Ext.Error.raise('Can\'t check if datetime is within working time intarval for a task, invalid datetime given!');
        return me.getWorkingTimeIntervalForDateTime(dateTime) !== false;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.task.Splittable
@mixin
@protected

Internal mixin class providing task splitting logic and functionality belonging to the Task model class.

*/
Ext.define('Gnt.model.task.Splittable', {
    uses: [
        'Gnt.model.TaskSegment'
    ],
    segmentsTrackingSuspended: 0,
    changingTaskBySegments: false,
    segmentsSnapshot: null,
    segmentsProjection: null,
    getFirstSegment: function() {
        var segments = this.getSegments();
        return segments && segments[0];
    },
    getLastSegment: function() {
        var segments = this.getSegments();
        return segments && segments[segments.length - 1];
    },
    normalizeSegments: function() {
        var segments = this.getSegments();
        // we don't wanna hear any response from segments during their normalization
        this.suspendSegmentsTracking();
        // first let sort intervals by its start dates ascending
        segments.sort(function(a, b) {
            if (!a.normalized)  {
                a.normalize();
            }
            
            if (!b.normalized)  {
                b.normalize();
            }
            
            return a.getStartDate() > b.getStartDate() ? 1 : -1;
        });
        // merge overlapped segments if any
        this.mergeOverlappedSegments();
        // if we still have segmentation after merging
        if (this.getSegments()) {
            this.data[this.durationField] = this.getSegmentsDuration();
        }
        this.resumeSegmentsTracking();
    },
    // Refreshes the task segments dates. We have to call this after the task time span change.
    updateSegmentsDates: function(options) {
        options = options || {};
        if (!this.isSegmented())  {
            return;
        }
        
        // we don't want to catch response from segments
        this.suspendSegmentsTracking();
        options = Ext.apply({
            useAbsoluteOffset: false
        }, options);
        options.isForward = options.isForward !== false;
        var segmentsModified = false;
        this.forEachSegment(function(segment) {
            segment.updateDatesByOffsets(options);
            // remember any segment was actually modified
            segmentsModified = segmentsModified || Boolean(segment.modified);
        }, options.isForward);
        // need to set Segments field dirty
        if (segmentsModified) {
            this.set(this.segmentsField, this.getSegments().slice());
        }
        this.resumeSegmentsTracking();
    },
    getSegmentIntervalsForRange: function(from, till, segments) {
        segments = segments || this.getSegments();
        if (!segments)  {
            return;
        }
        
        var DATE = Sch.util.Date,
            result = [];
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var part = segments[i],
                segmentStart = part.getStartDate(),
                segmentEnd = part.getEndDate();
            if (DATE.intersectSpans(from, till, segmentStart, segmentEnd)) {
                result.push([
                    DATE.constrain(segmentStart, from, till) - 0,
                    DATE.constrain(segmentEnd, from, till) - 0
                ]);
            }
        }
        return result.length && result || null;
    },
    /**
     * Returns a segment that is ongoing on the provided date.
     * @param  {Date} date Date to find an ongoing segment on
     * @param  {Gnt.model.TaskSegment[]} [segments] List of segments to check. When not provided the task segments is used
     * @return {Gnt.model.TaskSegment} Ongoing segment
     */
    getSegmentByDate: function(date, segments) {
        segments = segments || this.getSegments();
        if (!segments)  {
            return;
        }
        
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var part = segments[i];
            if (date >= part.getStartDate() && date < part.getEndDate())  {
                return part;
            }
            
        }
    },
    // Truncates segments that don't fit into task time span (this can be detected either based on the task start/end dates or by comparing with the task duration).
    // @private
    constrainSegments: function(options) {
        // should be called only for the task driven changes, and `this.changingTaskBySegments` means that change initiated by a segment
        if (this.changingTaskBySegments)  {
            return;
        }
        
        options = options || {};
        var segments = this.getSegments();
        if (!segments)  {
            return;
        }
        
        var taskDuration = this.getDuration('MILLI'),
            durationUnit = options.unit || this.getDurationUnit(),
            durationLimit = options.duration,
            startDate = this.getStartDate(),
            endDate = this.getEndDate(),
            converter = this.getUnitConverter();
        if (!startDate || (!endDate && !taskDuration && !durationLimit)) {
            this.set(this.segmentsField, null);
            return;
        }
        if (durationLimit) {
            durationLimit = converter.convertDurationToMs(durationLimit, durationUnit);
        } else if (!endDate) {
            durationLimit = taskDuration;
        }
        // we don't want to catch response from segments
        this.suspendSegmentsTracking();
        segments[0].setStartDateWithoutPropagation(this.getStartDate(), false);
        // now let's loop over array and merge overlapping intervals
        var toRemove = [],
            durationLeft = durationLimit,
            current, previous;
        var toRemoveChecker;
        // we check if segment fits into task timespan using either task end date or task duration depending on options provided
        if (durationLimit) {
            toRemoveChecker = function() {
                return durationLeft <= 0;
            };
        } else {
            toRemoveChecker = function(segment) {
                return segment.getStartDate() >= endDate;
            };
        }
        for (var i = 0,
            l = segments.length; i < l; i++) {
            current = segments[i];
            // we get rid of segments that do not fit into task timespan
            if (toRemoveChecker(current)) {
                toRemove.push.apply(toRemove, segments.slice(i));
                break;
            }
            durationLeft -= current.getDuration('MILLI');
            previous = current;
        }
        // remove segments swallowed during merge
        this.removeSegments(toRemove);
        if (segments.length < 2) {
            this.set(this.segmentsField, null);
        } else {
            var last = this.getLastSegment();
            var lastAdjusted = false;
            // if we constrain using duration
            if (durationLimit) {
                if (durationLeft) {
                    last.setDurationWithoutPropagation(converter.convertMSDurationToUnit(last.getEndOffset() - last.getStartOffset() + durationLeft, last.getDurationUnit()));
                    lastAdjusted = true;
                }
            } else {
                if (last.getEndDate() - endDate) {
                    last.setEndDateWithoutPropagation(endDate, false);
                    lastAdjusted = true;
                }
            }
            // if we modified segments and field is not marked as modified yet
            var taskStore = this.getTaskStore(true),
                isProjecting = taskStore && taskStore.isProjecting();
            if ((toRemove.length || lastAdjusted) && (isProjecting || !this.modified || !this.modified[this.segmentsField])) {
                this.set(this.segmentsField, this.getSegments().slice());
            }
        }
        this.resumeSegmentsTracking();
    },
    forEachSegment: function(fn, isForward, startSegment, scope) {
        if (!fn)  {
            return;
        }
        
        scope = scope || this;
        var method, segment;
        if (isForward !== false) {
            // method to walk down the segments available
            method = 'getNextSegment';
            // initial segment
            segment = startSegment || this.getFirstSegment();
        } else {
            method = 'getPrevSegment';
            segment = startSegment || this.getLastSegment();
        }
        while (segment) {
            if (fn.call(scope, segment) === false)  {
                return;
            }
            
            segment = segment[method].call(segment);
        }
    },
    /**
     * Splits a task.
     * @param {Date} from The date to split this task at.
     * @param {Number} [duration=1] Split duration.
     * @param {String} [unit=d] Split duration unit.
     * @param {Boolean} [skipNonWorkingTime] Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     * Default is `false`
     * @param {Function} [callback] Callback function to call after task has been split and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    split: function(from, duration, unit, skipNonWorkingTime, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.splitWithoutPropagation(from, duration, unit, skipNonWorkingTime, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    splitWithoutPropagation: function(from, duration, unit, skipNonWorkingTime, cancelFeedback) {
        var me = this;
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            var taskStore = me.getTaskStore(true);
            skipNonWorkingTime = taskStore ? taskStore.skipWeekendsDuringDragDrop : false;
        }
        // cannot split:
        // - if no split date specified
        // - a summary task
        // - a milestone
        if (!from || !me.isLeaf() || me.isMilestone())  {
            return;
        }
        
        var startDate = me.getStartDate(),
            endDate = me.getEndDate();
        // - not scheduled task
        // - provided date violates task interval
        if (!startDate || !endDate || (startDate >= from) || (from >= endDate))  {
            return;
        }
        
        var segments = me.getSegments(),
            segmentToSplit;
        // let's make a snapshot to rollback in case of some constraint violation
        var snapshot = me.buildSegmentsSnapshot(segments);
        if (segments) {
            segmentToSplit = me.getSegmentByDate(from);
            if (!segmentToSplit)  {
                return;
            }
            
        } else {
            segments = [];
        }
        duration = duration || 1;
        unit = unit || this.getDurationUnit();
        var date = new Date(from),
            splitStart = date,
            splitEnd = date,
            durationMS = me.getUnitConverter().convertDurationToMs(duration, unit);
        if (skipNonWorkingTime) {
            splitEnd = me.skipNonWorkingTime(splitEnd, true, true);
            splitStart = me.skipNonWorkingTime(splitStart, false, true);
        }
        // exit if split date is in a large gap between working periods of time
        // if (splitEnd - splitStart  > durationMS) return;
        var taskDurationUnit = me.getDurationUnit(),
            segmentPrototype = Ext.ClassManager.get(me.segmentClassName).prototype,
            firstPieceDuration, secondPieceDuration, segmentData;
        // suspend to not call onSegmentsChanged on every segment modification
        // we call it one time on the last step
        me.suspendSegmentsTracking();
        var addSegment = true;
        // split not segmented task
        if (!segmentToSplit) {
            firstPieceDuration = me.calculateDuration(startDate, splitStart);
            secondPieceDuration = me.getDuration() - firstPieceDuration;
            segmentData = {
                task: me
            };
            segmentData[segmentPrototype.startDateField] = startDate;
            segmentData[segmentPrototype.durationField] = firstPieceDuration;
            segmentData[segmentPrototype.durationUnitField] = taskDurationUnit;
            segments.push(Ext.create(me.segmentClassName, segmentData));
        } else // split existing segment
        {
            firstPieceDuration = me.calculateDuration(segmentToSplit.getStartDate(), splitStart, taskDurationUnit);
            secondPieceDuration = segmentToSplit.getDuration(taskDurationUnit) - firstPieceDuration;
            // we don't create a new segment if split date falls on a segment start
            // in this case we just push the segment further by split duration length
            addSegment = !!firstPieceDuration;
            var pushFrom;
            if (addSegment) {
                segmentToSplit.setEndDateWithoutPropagation(splitStart, false, skipNonWorkingTime);
                // push segments starting from the next after the clicked one
                pushFrom = segmentToSplit.getNextSegment();
            } else // if we don't split the clicked segment
            // we push segments starting from it
            {
                pushFrom = segmentToSplit;
            }
            // shift all further segments by provided duration
            if (pushFrom) {
                me.forEachSegment(function(s) {
                    s.setStartEndOffset(s.getStartOffset() + durationMS, s.getEndOffset() + durationMS);
                    s.updateDatesByOffsets();
                }, true, pushFrom);
            }
        }
        // if we need to create a new segment
        if (addSegment) {
            // take split duration into account
            splitEnd = me.skipWorkingTime(splitEnd, durationMS);
            if (skipNonWorkingTime) {
                // adjust to calendar if required
                splitEnd = me.skipNonWorkingTime(splitEnd);
            }
            segmentData = {
                prevSegment: segmentToSplit || segments[0],
                task: me
            };
            segmentData[segmentPrototype.startDateField] = splitEnd;
            segmentData[segmentPrototype.durationField] = secondPieceDuration;
            segmentData[segmentPrototype.durationUnitField] = taskDurationUnit;
            var newSegment = Ext.create(me.segmentClassName, segmentData);
            if (segmentToSplit) {
                Ext.Array.insert(segments, Ext.Array.indexOf(segments, segmentToSplit) + 1, [
                    newSegment
                ]);
            } else {
                segments.push(newSegment);
            }
        }
        me.resumeSegmentsTracking();
        cancelFeedback && cancelFeedback(function() {
            me.rollbackSegmentsToSnapshot(snapshot);
        });
        if (!segmentToSplit) {
            me.setSegmentsWithoutPropagation(segments);
        } else {
            me.onSegmentsChanged(null, null);
        }
        return true;
    },
    /**
     * Merges two segments of a task.
     * @param {Gnt.model.TaskSegment} segment1 First segment to merge.
     * @param {Gnt.model.TaskSegment} segment2 Second segment to merge.
     * @param {Function} [callback] Callback function to call after task has been merged and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    merge: function(segment1, segment2, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.mergeWithoutPropagation(segment1, segment2);
        }, callback);
    },
    mergeWithoutPropagation: function(segment1, segment2) {
        if (!this.isSegmented() || !segment1 || !segment2)  {
            return;
        }
        
        var first, second;
        if (segment1.getStartOffset() > segment2.getStartOffset()) {
            first = segment2;
            second = segment1;
        } else {
            first = segment1;
            second = segment2;
        }
        // merging itself will be done automatically inside of `onSegmentsChanged`
        first.setEndDateWithoutPropagation(second.getEndDate(), false);
        return true;
    },
    suspendSegmentsTracking: function() {
        this.segmentsTrackingSuspended++;
    },
    resumeSegmentsTracking: function() {
        this.segmentsTrackingSuspended--;
    },
    // Returns the sum of segments durations.
    getSegmentsDuration: function(unit) {
        unit = unit || this.getDurationUnit();
        var segments = this.getSegments();
        var duration = 0;
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var s = segments[i];
            duration += s.getEndOffset() - s.getStartOffset();
        }
        return this.getUnitConverter().convertMSDurationToUnit(duration, unit);
    },
    mergeOverlappedSegments: function(doNotTruncate) {
        var segments = this.getSegments();
        if (segments) {
            var toRemove = [],
                previous = segments[0],
                current;
            // Check if we should merge segments
            for (var i = 1,
                l = segments.length; i < l; i++) {
                current = segments[i];
                // if `current` segment intersects `previous` segment
                if (current.getStartOffset() <= previous.getEndOffset()) {
                    // we skip the current
                    toRemove.push(current);
                    // if `current` end date is greater than `previous` one we elapse previous segment
                    if (current.getEndOffset() > previous.getEndOffset()) {
                        previous.setEndDateWithoutPropagation(current.getEndDate(), false);
                    }
                } else {
                    // `previous` keeps the last not skipped segment
                    previous = current;
                }
            }
            this.removeSegments(toRemove);
            if (segments.length < 2 && !doNotTruncate) {
                this.setSegmentsWithoutPropagation(null);
            }
        }
    },
    onSegmentEditBegin: function(segment) {
        this.getTreeStore().onSegmentEditBegin(this, segment);
        this.snapshotSegments();
    },
    onSegmentEditEnd: function(segment) {
        this.getTreeStore().onSegmentEditEnd(this, segment);
    },
    onSegmentsChanged: function(segment, modified) {
        if (this.segmentsTrackingSuspended)  {
            return;
        }
        
        this.changingTaskBySegments = true;
        // we don't want to escalate chain of calls
        this.suspendSegmentsTracking();
        // Check if we should merge segments
        // we pass `true` to not truncate segments array if we have 1 element in it (we need this to get duration from it)
        // The array will be completely reset inside of this.set() call
        this.mergeOverlappedSegments(true);
        // segments has been changed so we need re-adjust task to take them into account
        // if segment duration has been changed - task duration has to be updated
        if (segment && modified && segment.durationField in modified) {
            // even after merge here we have at least 1 segment to be able to get duration from it
            this.setDurationWithoutPropagation(this.getSegmentsDuration());
        }
        // for effort driven tasks we use setStartEndDateWithoutPropagation
        // since we might need to recalculate both EndDate and Duration
        else if (this.getSchedulingMode() == 'EffortDriven') {
            this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate());
        } else {
            this.setStartDateWithoutPropagation(this.getStartDate());
        }
        // re-get segments list since it could've been rolled back because of failed propagation
        // inside of setDuration/setStartDate call
        var segments = this.getSegments();
        // set field state to dirty
        this.set(this.segmentsField, segments && segments.slice() || null);
        this.resumeSegmentsTracking();
        this.changingTaskBySegments = false;
    },
    //this.getTreeStore().onSegmentsChanged(segment, modified);
    removeSegments: function(toRemove) {
        var segments = this.getSegments();
        if (!segments || !toRemove || !toRemove.length)  {
            return;
        }
        
        if (!Ext.isArray(toRemove))  {
            toRemove = [
                toRemove
            ];
        }
        
        for (var i = 0,
            l = toRemove.length; i < l; i++) {
            Ext.Array.remove(segments, toRemove[i]);
        }
        this.onSegmentsChanged();
    },
    /**
     * Sets list of segments of the split task.
     * @param {Gnt.model.TaskSegment[]/Object[]} value List of segments.
     * @param {Function} [callback] Callback function to call after task end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setSegments: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setSegmentsWithoutPropagation(value);
        }, callback);
    },
    setSegmentsWithoutPropagation: function(value) {
        this.onSegmentEditBegin();
        this.suspendSegmentsTracking();
        // We call processSegmentsValue(value) here explicitly regardless "Segment" field also does this in its "convert" method.
        // The reason is we might be in the middle of projection and then "model.set()" method is overridden
        // and "converter" is not really called (until projection gets committed).
        this.set(this.segmentsField, this.processSegmentsValue(value));
        this.resumeSegmentsTracking();
        this.onSegmentsChanged();
        this.onSegmentEditEnd();
        return true;
    },
    processSegmentsValue: function(value) {
        var segments, currentSegment, prevSegment;
        // if segments are specified for the task
        if (value) {
            value = [].concat(value);
            segments = [];
            for (var i = 0,
                l = value.length; i < l; i++) {
                currentSegment = value[i];
                if (!(currentSegment instanceof Gnt.model.TaskSegment)) {
                    currentSegment = Ext.create(this.segmentClassName, Ext.apply(currentSegment, {
                        task: this
                    }));
                }
                segments.push(currentSegment);
                prevSegment = currentSegment;
            }
            value = segments && segments.length > 1 && segments || null;
        }
        return value;
    },
    /**
     * Returns `true` if task is segmented and `false` otherwise.
     * @return {Boolean} `true` if task is segmented and `false` otherwise.
     */
    isSegmented: function() {
        return Boolean(this.getSegments());
    },
    /**
     * Gets segment by its index.
     * @param {Number} index Segment index to retrieve (zero based value).
     * @return {Gnt.model.TaskSegment}
     */
    getSegment: function(index) {
        return this.getSegments()[index];
    },
    rejectSegmentsProjection: function() {
        var projectionLevel = this.getTaskStore(true).getProjectionLevel();
        var snapshot, i;
        if (this.segmentsProjection) {
            var snapshotLevel;
            for (i = projectionLevel; i >= 0; i--) {
                if (snapshot = this.segmentsProjection[i]) {
                    snapshotLevel = i;
                    break;
                }
            }
            if (snapshotLevel === projectionLevel) {
                delete this.segmentsProjection[snapshotLevel];
            }
        }
        if (snapshot) {
            this.rollbackSegmentsToSnapshot(snapshot);
        }
    },
    commitSegmentsProjection: function() {
        var taskStore = this.getTaskStore(true),
            projectionLevel = taskStore && taskStore.getProjectionLevel();
        if (this.segmentsProjection) {
            delete this.segmentsProjection[projectionLevel];
        }
    },
    rollbackSegmentsToSnapshot: function(snapshot) {
        this.data[this.segmentsField] = snapshot && Ext.Array.map(snapshot, function(segment) {
            return segment && segment[0].readSnapshot(segment);
        });
    },
    buildSegmentsSnapshot: function(segments) {
        segments = segments || this.getSegments();
        return segments && Ext.Array.map(segments, function(segment) {
            return segment && segment.buildSnapshot();
        });
    },
    snapshotSegments: function() {
        var taskStore = this.getTaskStore(true),
            segments = this.getSegments(),
            projectionLevel = taskStore && taskStore.getProjectionLevel(),
            snapshot;
        // if taskStore is in the middle of projection let's try to follow it
        // and bind snapshot to previous projection level, to be able to rollback segments
        // after projection rollback
        if (projectionLevel) {
            this.segmentsProjection = this.segmentsProjection || {};
            snapshot = this.segmentsProjection[projectionLevel - 1];
            if (!snapshot) {
                snapshot = this.buildSegmentsSnapshot(segments);
                this.segmentsProjection[projectionLevel - 1] = snapshot;
            }
        }
        // this is a zero level snapshot that is used for task.reject() support
        if (!this.segmentsSnapshot) {
            this.segmentsSnapshot = snapshot || this.buildSegmentsSnapshot(segments);
        }
    },
    commitSegments: function() {
        // EtxJS5 calls `commit` during `reject` call. o_O
        if (this.rejecting)  {
            return;
        }
        
        // let's reset snapshot, we will fill it during first attempt to edit this task segments
        this.segmentsSnapshot = null;
        var segments = this.getSegments();
        if (segments) {
            for (var i = 0,
                l = segments.length; i < l; i++) {
                segments[i].commit();
            }
        }
    },
    rejectSegments: function() {
        // get kept previous segments data
        this.rollbackSegmentsToSnapshot(this.segmentsSnapshot);
        this.segmentsSnapshot = null;
        var segments = this.getSegments();
        if (segments) {
            for (var i = 0,
                l = segments.length; i < l; i++) {
                segments[i].reject();
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.Task
@extends Sch.model.Range

This class represents a single task in your Gantt chart.

The inheritance hierarchy of this class includes the {@link Sch.model.Customizable} and {@link Ext.data.Model} classes. Fields that begin
 with a capital letter come from this class directly, and lowercase field names are inherited from {@link Ext.data.NodeInterface}.
This class will not only inherit fields but also a set of methods that stem from the {@link Ext.data.NodeInterface}.
Please refer to the documentation of those classes to become familiar with the base interface of this class.

By default, a Task has the following fields as seen below.

Task Fields
------

- `Id` - (mandatory) a unique identifier of the task
- `Name` - the name of the task (task title)
- `StartDate` - the start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
- `EndDate` - the end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
- `Duration` - the numeric part of the task duration (the number of units)
- `DurationUnit` - the unit part of the task duration (corresponds to units defined in `Sch.util.Date`), defaults to "d" (days). Valid values are:
     - "ms" (milliseconds)
     - "s" (seconds)
     - "mi" (minutes)
     - "h" (hours)
     - "d" (days)
     - "w" (weeks)
     - "mo" (months)
     - "q" (quarters)
     - "y" (years)
- `Effort` - the numeric part of the task effort (the number of units). The effort of the "parent" tasks will be automatically set to the sum
of efforts of their "child" tasks
- `EffortUnit` - the unit part of the task effort (corresponds to units defined in `Sch.util.Date`), defaults to "h" (hours). Valid values are:
     - "ms" (milliseconds)
     - "s" (seconds)
     - "mi" (minutes)
     - "h" (hours)
     - "d" (days)
     - "w" (weeks)
     - "mo" (months)
     - "q" (quarters)
     - "y" (years)
- `PercentDone` - the current status of a task, expressed as the percentage completed (integer from 0 to 100)
- `Cls` - A CSS class that will be applied to each rendered task DOM element
- `BaselineStartDate` - the baseline start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
- `BaselineEndDate` - the baseline end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
- `BaselinePercentDone` - the baseline status of a task, expressed as the percentage completed (integer from 0 to 100)
- `CalendarId` - the id of the calendar, assigned to task. Allows you to set the time when task can be performed.
Should be only provided for specific tasks - all tasks by default are assigned to the project calendar, provided as the
{@link Gnt.data.TaskStore#calendar} option.
- `SchedulingMode` - the field, defining the scheduling mode for the task. Based on this field some fields of the task
will be "fixed" (should be provided) and some - computed. See {@link #getSchedulingMode} for details.
- `ManuallyScheduled` - When set to `true`, the `StartDate` of the task will not be changed by any of its incoming dependencies
or constraints. Also, a manually scheduled parent task is not affected by its child tasks and behaves like any other normal task.
- `ConstraintType` - A string containing the alias for a constraint class (w/o the `gntconstraint` prefix). Valid values are:

  - "finishnoearlierthan"
  - "finishnolaterthan"
  - "mustfinishon"
  - "muststarton"
  - "startnoearlierthan"
  - "startnolaterthan"

If you want to define your own custom constraint class, you need to alias it:

        Ext.define('MyConstraint', {
            extend      : 'Gnt.constraint.Base',

            alias       : 'gntconstraint.myconstraint',
            ...
        });

- `ConstraintDate` - A date, defining the constraint boundary date, if applicable.
- `Note` A freetext note about the task.
- `Rollup` Set this to 'true' if the task should rollup to its parent task.
- `ShowInTimeline` Set this to true if this task should be shown in the Timeline widget
- `DeadlineDate` A deadline date for this task
- `ReadOnly` 'true' to indicate that a task cannot be modified.

If you want to add new fields or change the name/options for the existing fields,
you can do that by subclassing this class (see example below).

Subclassing the Task class
--------------------

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

    Ext.define('MyProject.model.Task', {
        extend              : 'Gnt.model.Task',

        nameField           : 'myName',
        percentDoneField    : 'percentComplete',

        isAlmostDone : function () {
            return this.get('percentComplete') > 80;
        },
        ...
    });

Creating a new Task instance programmatically
--------------------

To create a new task programmatically, simply call the Gnt.model.Task constructor and pass in any default field values.

    var newTask = new Gnt.model.Task({
        Name            : 'An awesome task',
        PercentDone     : 80, // So awesome it's almost done
        ...
    });

    // To take weekends and non-working time into account, the new task needs a reference to the task store (which has access to the global calendar)
    newTask.taskStore = taskStore;

    // Initialize new task to today
    newTask.setStartDate(new Date());

    // This is a leaf task
    newTask.set('leaf', true);

    // Now it will appear in the UI if the Gantt panel is rendered
    taskStore.getRootNode().appendChild(newTask);


Start and End dates
-------------------

For all tasks, the range between start date and end date is supposed to be not-inclusive on the right side: StartDate <= date < EndDate.
So, for example, the task which starts at 2011/07/18 and has 2 days duration, should have the end date: 2011/07/20, **not** 2011/07/19 23:59:59.

Also, both start and end dates of tasks in our components are *points* on time axis. For example, if user specifies that some task starts
01/01/2013 and has 1 day duration, that means the start point is 01/01/2013 00:00 and end point is 02/01/2013 00:00.
However, its a common requirement, to *display* such task as task with both start and end date as 01/01/2013. Because of that,
during rendering the end date is adjusted so for such task user will see a 01/01/2013 end date. In the model layer however, the precise point is stored.

Conversion to "days" duration unit
-----------------------------------

Some duration units cannot be converted to "days" consistently. For example a month may have 28, 29, 30 or 31 days. The year may have 365 or 366 days and so on.
So in such conversion operations, we will always assume that a task with a duration of 1 month will have a duration of 30 days.
This is {@link Gnt.data.Calendar#daysPerMonth a configuration option} of the calendar class.

Task API
-------

One important thing to consider is that, if you are using the availability/scheduling modes feature, then you need to use the task API call to update the fields like `StartDate / EndDate / Duration`.
Those calls will calculate the correct value of each the field, taking into account the information from calendar/assigned resources.

Server-side integration
-----------------------

Also, at least for now you should not use the "save" method of the model available in Ext 4:

    task.save() // WON'T WORK

This is because there are some quirks in using CRUD for Ext tree stores. These quirks are fixed in the TaskStore. To save the changes in task to server
use the "sync" method of the task store:

    taskStore.sync() // OK

*/
Ext.define('Gnt.model.Task', {
    extend: 'Sch.model.Range',
    alias: 'gntmodel.event',
    requires: [
        'Sch.util.Date',
        'Ext.data.NodeInterface'
    ],
    uses: [
        'Gnt.model.TaskSegment'
    ],
    mixins: [
        'Gnt.model.mixin.ProjectableModel',
        'Gnt.model.task.More',
        'Gnt.model.task.Constraints',
        'Gnt.model.task.Splittable'
    ],
    segmentClassName: 'Gnt.model.TaskSegment',
    /**
     * @cfg {String} idProperty The name of the field treated as this Model's unique id.
     */
    idProperty: "Id",
    customizableFields: [
        {
            name: 'Duration',
            type: 'number',
            allowNull: true
        },
        {
            name: 'Effort',
            type: 'number',
            allowNull: true
        },
        {
            name: 'EffortUnit',
            type: 'string',
            defaultValue: 'h'
        },
        {
            name: 'CalendarId',
            type: 'string'
        },
        {
            name: 'Note',
            type: 'string'
        },
        {
            name: 'DurationUnit',
            type: 'string',
            defaultValue: "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert: function(value) {
                return value || "d";
            }
        },
        {
            name: 'PercentDone',
            type: 'number',
            defaultValue: 0
        },
        {
            name: 'ConstraintType',
            type: 'string',
            defaultValue: ''
        },
        {
            name: 'ConstraintDate',
            type: 'date',
            dateFormat: 'c'
        },
        {
            name: 'ManuallyScheduled',
            type: 'boolean',
            defaultValue: false
        },
        {
            name: 'SchedulingMode',
            type: 'string',
            defaultValue: 'Normal'
        },
        {
            name: 'BaselineStartDate',
            type: 'date',
            dateFormat: 'c'
        },
        {
            name: 'BaselineEndDate',
            type: 'date',
            dateFormat: 'c'
        },
        {
            name: 'BaselinePercentDone',
            type: 'int',
            defaultValue: 0
        },
        {
            name: 'Draggable',
            type: 'boolean',
            persist: false,
            defaultValue: true
        },
        // true or false
        {
            name: 'Resizable',
            persist: false,
            defaultValue: ''
        },
        // true, false, 'start' or 'end'
        {
            name: 'ReadOnly',
            persist: false,
            type: 'bool',
            defaultValue: false
        },
        {
            name: 'Rollup',
            type: 'boolean',
            defaultValue: false
        },
        {
            name: 'Segments',
            persist: true,
            convert: function(value, record) {
                return record.processSegmentsValue(value, record);
            },
            serialize: function(value) {
                if (!value)  {
                    return null;
                }
                
                return Ext.Array.map([].concat(value), function(segment) {
                    return segment.serialize();
                });
            }
        },
        // Two fields which specify the relations between "phantom" tasks when they are
        // being sent to the server to be created (e.g. when you create a new task containing a new child task).
        {
            name: 'PhantomId',
            type: 'string'
        },
        {
            name: 'PhantomParentId',
            type: 'string'
        },
        {
            name: 'ShowInTimeline',
            type: 'bool'
        },
        {
            name: 'DeadlineDate',
            type: 'date',
            dateFormat: 'c'
        },
        // Override NodeInterface defaults
        {
            name: 'index',
            type: 'int',
            persist: true
        }
    ],
    /**
     * @cfg {String} constraintTypeField The name of the field specifying the constraint type of this task.
     */
    constraintTypeField: 'ConstraintType',
    /**
     * @cfg {String} constraintDateField The name of the field specifying the constraint date for this task.
     */
    constraintDateField: 'ConstraintDate',
    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField: 'Draggable',
    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField: 'Resizable',
    /**
     * @cfg {String} nameField The name of the field that holds the task name. Defaults to "Name".
     */
    nameField: 'Name',
    /**
     * @cfg {String} durationField The name of the field holding the task duration.
     */
    durationField: 'Duration',
    /**
     * @cfg {String} durationUnitField The name of the field holding the task duration unit.
     */
    durationUnitField: 'DurationUnit',
    /**
     * @cfg {String} effortField The name of the field holding the value of task effort.
     */
    effortField: 'Effort',
    /**
     * @cfg {String} effortUnitField The name of the field holding the task effort unit.
     */
    effortUnitField: 'EffortUnit',
    /**
     * @cfg {String} percentDoneField The name of the field specifying the level of completion.
     */
    percentDoneField: 'PercentDone',
    /**
     * @cfg {String} manuallyScheduledField The name of the field defining if a task is manually scheduled or not.
     */
    manuallyScheduledField: 'ManuallyScheduled',
    /**
     * @cfg {String} schedulingModeField The name of the field defining the scheduling mode of the task.
     */
    schedulingModeField: 'SchedulingMode',
    /**
     * @cfg {String} rollupField The name of the field specifying if the task should rollup to its parent task.
     */
    rollupField: 'Rollup',
    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific task. Task calendar has the highest priority.
     */
    calendarIdField: 'CalendarId',
    /**
     * @cfg {String} baselineStartDateField The name of the field that holds the task baseline start date.
     */
    baselineStartDateField: 'BaselineStartDate',
    /**
     * @cfg {String} baselineEndDateField The name of the field that holds the task baseline end date.
     */
    baselineEndDateField: 'BaselineEndDate',
    /**
     * @cfg {String} baselinePercentDoneField The name of the field specifying the baseline level of completion.
     */
    baselinePercentDoneField: 'BaselinePercentDone',
    /**
     * @cfg {String} noteField The name of the field specifying the task note.
     */
    noteField: 'Note',
    /**
     * @cfg {String} segmentsField The name of the field specifying the task segments.
     */
    segmentsField: 'Segments',
    /*
     * @cfg {Boolean} readOnlyField The name of the field specifying if the task is read only. When set to true, a task
     * is not draggable, resizable and for all its fields {@link #isEditable} returns `false`
     */
    readOnlyField: 'ReadOnly',
    /**
     * @cfg {Gnt.data.Calendar} calendar
     * Optional. An explicitly provided {@link Gnt.data.Calendar calendar} instance. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore
     * Optional. An explicitly provided {@link Gnt.data.DependencyStore} with dependencies information. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore
     * Optional. An explicitly provided Gnt.data.TaskStore with tasks information. Usually will be set by the {@link Gnt.data.TaskStore task store}.
     */
    taskStore: null,
    /**
     * @cfg {String} phantomIdField The name of the field specifying the phantom id when this task is being 'realized' by the server.
     */
    phantomIdField: 'PhantomId',
    /**
     * @cfg {String} phantomParentIdField The name of the field specifying the parent task phantom id when this task is being 'realized' by the server.
     */
    phantomParentIdField: 'PhantomParentId',
    /**
     * @cfg {String} showInTimelineField The name of the field saying if the task has to be displayed in a project timeline view.
     */
    showInTimelineField: 'ShowInTimeline',
    /**
     * @cfg {String} deadlineDateField The name of the field that holds the task deadline date.
     */
    deadlineDateField: 'DeadlineDate',
    normalized: false,
    recognizedSchedulingModes: [
        'Normal',
        'FixedDuration',
        'EffortDriven',
        'DynamicAssignment'
    ],
    /**
     * Returns the constraint type of the task.
     * @method getConstraintType
     * @return {String} Constraint type. The type string might be one of the following values:
     *
     *  - `finishnoearlierthan`
     *  - `finishnolaterthan`
     *  - `mustfinishon`
     *  - `muststarton`
     *  - `startnoearlierthan`
     *  - `startnolaterthan`
     */
    /**
     * Returns the constraint date of the task.
     * @method getConstraintDate
     * @return {Date} Constraint date
     */
    /**
     * @cfg {Boolean} convertEmptyParentToLeaf
     *
     * This configuration option allows you to control whether an empty parent task should be converted into a leaf. Note, that
     * it's not a new field, but a regular configuration property of this class.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                      : 'Gnt.model.Task',

        convertEmptyParentToLeaf    : false
    })

     */
    convertEmptyParentToLeaf: true,
    /**
     * @cfg {Boolean} autoCalculateEffortForParentTask
     *
     * This configuration option enables auto-calculation of the effort value for the parent task. When this option is enabled,
     * effort value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                              : 'Gnt.model.Task',

        autoCalculateEffortForParentTask    : false
    })

     *
     */
    autoCalculateEffortForParentTask: true,
    /**
     * @cfg {Boolean} autoCalculatePercentDoneForParentTask
     *
     * This configuration option enables auto-calculation of the percent done value for the parent task. When this option is enabled,
     * percent done value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                                  : 'Gnt.model.Task',

        autoCalculatePercentDoneForParentTask   : false
    })

     *
     */
    autoCalculatePercentDoneForParentTask: true,
    isHighlighted: false,
    calendarWaitingListener: null,
    childTasksDuration: null,
    completedChildTasksDuration: null,
    totalCount: null,
    /**
     * @property {Gnt.model.Dependency[]} predecessors An array of dependencies, which are predecessors for this task.
     * To access this property safely you can use {@link #getIncomingDependencies} method.
     *
     * @deprecated 4.2 Use {@link getIncomingDependencies} method instead
     *
     * NOTE: The property is managed by Gnt.data.util.TaskDependencyCache class
     */
    predecessors: null,
    /**
     * @property {Gnt.model.Dependency[]} successors An array of dependencies, which are successors for this task.
     * To access this property safely you can use {@link #getOutgoingDependencies} method.
     *
     * @deprecated 4.2 Use {@link getOutgoingDependencies} method instead
     *
     * NOTE: The property is managed by Gnt.data.util.TaskDependencyCache class
     */
    successors: null,
    /**
     * @private
     * @deprecated Please use {@link #getAssignments} method.
     * @property {Gnt.model.Assignment[]} assignments An array of assignments for this task.
     * To access this property safely you can use {@link #getAssignments} method.
     */
    // special flag, that prevents parent from being converted into leafs when using "replaceChild" method
    // see `data_components/077_task_replace_child.t.js`
    removeChildIsCalledFromReplaceChild: false,
    // see comments in `endEdit` override
    savedDirty: null,
    useOwnCalendarAsConverter: false,
    constructor: function() {
        this._singleProp = {};
        this.initProjectable();
        this.callParent(arguments);
        if (this.phantom) {
            this.data[this.phantomIdField] = this.getId();
        }
        if (this.id === 'root') {
            this.convertEmptyParentToLeaf = false;
        }
        // NOTE: The properties are managed by Gnt.data.util.TaskDependencyCache class
        // TODO: Remove this code when those properties are remove from Task interface
        this.predecessors = [];
        this.successors = [];
    },
    // should be called once after initial loading - will convert the "EndDate" field to "Duration"
    // the model should have the link to calendar
    normalize: function() {
        var durationUnit = this.getDurationUnit(),
            startDate = this.getStartDate(),
            endDate = this.getEndDate(),
            data = this.data,
            taskStore = this.getTaskStore(true),
            schedulingMode = this.getSchedulingMode();
        if (schedulingMode == 'Manual') {
            schedulingMode = data[this.schedulingModeField] = 'Normal';
            data[this.manuallyScheduledField] = true;
        }
        var endDateField = this.endDateField;
        // normalize segments if required
        if (taskStore && this.isSegmented()) {
            this.normalizeSegments();
            var last;
            // if task is still segmented after segments normalization
            // let's set the task end to the last segment finish
            if (last = this.getLastSegment()) {
                endDate = data[endDateField] = last.getEndDate();
            }
        }
        var duration = this.getDuration();
        var effortField = this.effortField;
        if (endDate && this.inclusiveEndDate) {
            // End date supplied, if end dates are inclusive we need to adjust them -
            // but only IF:
            //      * The end-date dateFormat does not contain any hour info, OR
            //      * The end-date dateFormat does contain any hour info AND it has no hours/minutes/seconds/ms
            var format = this.getField(endDateField).dateFormat;
            var doAdjust = (format && !Ext.Date.formatContainsHourInfo(format)) || (endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.getSeconds() === 0 && endDate.getMilliseconds() === 0);
            if (doAdjust) {
                if (Ext.isNumber(duration)) {
                    // Recalculate end date based on duration
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                } else {
                    // Simply add 1 day to end date
                    endDate = data[endDateField] = Ext.Date.add(endDate, Ext.Date.DAY, 1);
                }
            }
        }
        // for all scheduling modes
        if (duration == null && startDate && endDate) {
            duration = data[this.durationField] = this.calculateDuration(startDate, endDate, durationUnit);
        }
        if ((schedulingMode == 'Normal' || this.isManuallyScheduled()) && endDate == null && startDate && Ext.isNumber(duration)) {
            endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
        }
        // accessing the field value directly here, since we are interested in "raw" value
        // `getEffort` now returns 0 for empty effort values
        var effort = this.get(effortField),
            effortUnit = this.getEffortUnit();
        switch (schedulingMode) {
            case 'FixedDuration':
                if (endDate == null && startDate && Ext.isNumber(duration)) {
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                };
                if (effort == null && startDate && endDate) {
                    data[effortField] = this.calculateEffort(startDate, endDate, effortUnit);
                };
                break;
            case 'EffortDriven':
                if (effort == null && startDate && endDate) {
                    data[effortField] = this.calculateEffort(startDate, endDate, effortUnit);
                };
                if (endDate == null && startDate && effort) {
                    data[endDateField] = this.calculateEffortDrivenEndDate(startDate, effort, effortUnit);
                    // for "effortDriven" task, user can only provide StartDate and Effort - that's all we need
                    if (duration == null) {
                        data[this.durationField] = this.calculateDuration(startDate, data[endDateField], durationUnit);
                    }
                };
                break;
            default:
                if (endDate == null && startDate && Ext.isNumber(duration)) {
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                };
                break;
        }
        var calendarId = this.getCalendarId();
        if (calendarId)  {
            this.setCalendarId(calendarId, true);
        }
        
        this.normalized = true;
    },
    getUnitConverter: function() {
        return this.useOwnCalendarAsConverter && this.getCalendar() || this.getProjectCalendar();
    },
    // recursive task
    normalizeParent: function() {
        var childNodes = this.childNodes;
        var totalEffortInMS = 0;
        var totalDurationInMS = 0;
        var completedDurationInMS = 0;
        var autoCalculatePercentDoneForParentTask = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask = this.autoCalculateEffortForParentTask;
        for (var i = 0; i < childNodes.length; i++) {
            var child = childNodes[i];
            var isLeaf = child.isLeaf();
            if (!isLeaf)  {
                child.normalizeParent();
            }
            
            if (autoCalculateEffortForParentTask) {
                totalEffortInMS += child.getEffort('MILLI');
            }
            if (autoCalculatePercentDoneForParentTask) {
                var durationInMS = isLeaf ? child.getDuration('MILLI') || 0 : child.childTasksDuration;
                totalDurationInMS += durationInMS;
                completedDurationInMS += isLeaf ? durationInMS * (child.getPercentDone() || 0) : child.completedChildTasksDuration;
            }
        }
        if (autoCalculatePercentDoneForParentTask) {
            this.childTasksDuration = totalDurationInMS;
            this.completedChildTasksDuration = completedDurationInMS;
            var newPercentDone = totalDurationInMS ? completedDurationInMS / totalDurationInMS : 0;
            if (this.getPercentDone() != newPercentDone)  {
                this.data[this.percentDoneField] = newPercentDone;
            }
            
        }
        if (autoCalculateEffortForParentTask) {
            if (this.getEffort('MILLI') != totalEffortInMS)  {
                this.data[this.effortField] = this.getUnitConverter().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit());
            }
            
        }
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task. If task has no own calendar, it will be recursively looked up
     * starting from task's parent. If no one from parents have own calendar then project calendar will be returned.
     * See also `ownCalendarOnly` parameter and {@link #getOwnCalendar}, {@link #getProjectCalendar} methods.
     *
     * @param {Boolean} ownCalendarOnly (optional) When set to true, return only own calendar of this task and `null` if task has no calendar
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getCalendar: function(ownCalendarOnly) {
        return ownCalendarOnly ? this.getOwnCalendar() : this.getOwnCalendar() || this.parentNode && this.parentNode.getCalendar() || this.getProjectCalendar();
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar: function() {
        var calendarId = this.get(this.calendarIdField);
        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : this.calendar;
    },
    // TODO: cache project
    /**
     * Returns the {@link Gnt.model.Project project} instance, associated with this task if this task belongs to a project
     *
     * @return {Gnt.model.Project} project
     */
    getProject: function() {
        var me = this,
            project = null;
        this.bubble(function(task) {
            if (me !== task && task.isProject) {
                project = task;
                return false;
            }
        }, this);
        return project;
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this task (with the TaskStore instance
     * this task belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar: function() {
        var store = this.getTaskStore(true);
        var calendar = store && store.getCalendar() || this.parentNode && this.parentNode.getProjectCalendar() || this.isRoot() && this.calendar;
        if (!calendar) {
            Ext.Error.raise("Can't find a project calendar in `getProjectCalendar`");
        }
        return calendar;
    },
    /**
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this task. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     * @param {Function} [callback] Callback function to call after task calendar has been changed and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setCalendar: function(calendar, callback) {
        var me = this,
            isCalendarInstance = calendar instanceof Gnt.data.Calendar;
        if (isCalendarInstance && !calendar.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property");
        }
        return me.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar, false, callback);
    },
    setCalendarId: function(calendarId, isInitial, callback) {
        var me = this;
        if (!isInitial) {
            me.propagateChanges(function() {
                return me.setCalendarIdWithoutPropagation(calendarId, isInitial);
            }, callback);
        } else {
            me.setCalendarIdWithoutPropagation(calendarId, isInitial);
        }
    },
    onCalendarChange: function(calendar) {
        if (!this.isReadOnly()) {
            this.adjustToCalendarWithoutPropagation();
        }
    },
    setCalendarIdWithoutPropagation: function(calendarId, isInitial) {
        var propagate = false;
        if (calendarId instanceof Gnt.data.Calendar)  {
            calendarId = calendarId.calendarId;
        }
        
        var prevCalendarId = this.getCalendarId();
        if (prevCalendarId != calendarId || isInitial) {
            propagate = true;
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }
            var listeners = {
                    calendarchange: this.onCalendarChange,
                    scope: this
                };
            var prevInstance = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);
            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar = null;
            prevInstance && prevInstance.un(listeners);
            this.set(this.calendarIdField, calendarId);
            var calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
            if (calendarInstance) {
                calendarInstance.on(listeners);
                if (!isInitial)  {
                    this.onCalendarChange();
                }
                
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on('add', function() {
                    calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
                    if (calendarInstance) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        calendarInstance.on(listeners);
                        this.onCalendarChange();
                    }
                }, this, {
                    destroyable: true
                });
            }
        }
        return propagate;
    },
    /**
     * Returns the dependency store, associated with this task.
     *
     * @return {Gnt.data.DependencyStore} The dependency store instance
     */
    getDependencyStore: function() {
        var taskStore = this.getTaskStore(true),
            dependencyStore = taskStore && taskStore.getDependencyStore();
        return dependencyStore;
    },
    /**
     * Returns the resource store, associated with this task.
     *
     * @return {Gnt.data.Resource} The resource store instance
     */
    getResourceStore: function() {
        var taskStore = this.getTaskStore(true);
        return taskStore && taskStore.getResourceStore();
    },
    /**
     * Returns the assignment store, associated with this task.
     *
     * @return {Gnt.data.AssignmentStore} The assignment store instance
     */
    getAssignmentStore: function() {
        var taskStore = this.getTaskStore(true);
        return taskStore && taskStore.getAssignmentStore();
    },
    /**
     * Returns the {@link Gnt.data.TaskStore task store} instance, associated with this task
     *
     * @return {Gnt.data.TaskStore} task store
     */
    getTaskStore: function(ignoreAbsense) {
        var me = this;
        if (!me.taskStore) {
            me.taskStore = me.getTreeStore() || me.parentNode && me.parentNode.getTaskStore(ignoreAbsense);
        }
        if (!me.taskStore && !ignoreAbsense) {
            Ext.Error.raise("Can't find a taskStore in `getTaskStore`");
        }
        return me.taskStore;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Provides a reference to a {@link Gnt.data.TaskStore task store} instance, which the task will use to access the global
     * {@link Gnt.data.Calendar calendar}. Calling this does *not* add the model to the task store. Call this method if you want to use
     * methods like {@link #setStartDate} or {@link #setEndDate} that should take the store calendar into account.
     *
     * @param {Gnt.data.TaskStore} taskStore The task store
     */
    setTaskStore: function(taskStore) {
        this.taskStore = taskStore;
    },
    /**
     * Returns true if the task is manually scheduled or if it is completed. Manually scheduled task is not affected by incoming dependencies or
     * constraints. Also, the manually scheduled parent task is not affected by its child tasks positions and behaves like any other normal task.
     *
     * @return {Boolean} The value of the ManuallyScheduled field
     */
    isManuallyScheduled: function() {
        return this.get(this.schedulingModeField) === 'Manual' || this.get(this.manuallyScheduledField) || this.isCompleted();
    },
    isShowInTimeline: function() {
        return Boolean(this.getShowInTimeline());
    },
    /*
     * Sets the task manually scheduled status.
     * If that field was set to "Manual", calling this method with false value will set the scheduling mode to "Normal".
     *
     * @param {Boolean} value The new value of the SchedulingMode field
     * @param {Function} [callback] Callback function to call after effort has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setManuallyScheduled: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setManuallyScheduledWithoutPropagation(value);
        }, callback);
    },
    setManuallyScheduledWithoutPropagation: function(value) {
        var me = this,
            propagationSource;
        if (me.isManuallyScheduled() != value) {
            this.set(me.manuallyScheduledField, value);
            // if the task is no longer manually scheduled we align it by incoming dependencies
            if (!value)  {
                propagationSource = me.getPredecessors()[0];
            }
            
            propagationSource = propagationSource || me;
        }
        return propagationSource;
    },
    /**
     * @method getSchedulingMode
     *
     * Returns the scheduling mode of this task. May be one of the
     * following strings:
     *
     * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based on information
     * about its start/end dates, task own calendar (project calendar if there's no one) and calendars of the assigned resources.
     *
     * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed dynamically,
     * based on the assigned resources information. Typical example of such task is - meeting. Meetings typically have
     * pre-defined start and end dates and the more people are participating in the meeting, the more effort is spent on the task.
     * When duration of such task increases, its effort is increased too (and vice-versa). Note: fixed start and end dates
     * here doesn't mean that a user can't update them via GUI, the only field which won't be editable in GUI is the effort field,
     * it will be calculated according to duration and resources assigned to the task.
     *
     * - `EffortDriven` mode means, that task has fixed effort and computed duration. The more resources will be assigned
     * to this task, the less the duration will be. The typical example will be a "paint the walls" task -
     * several painters will complete it faster.
     *
     * - `DynamicAssignment` mode can be used when both duration and effort of the task are fixed. The computed value in this
     * case will be - the assignment units of the resources assigned. In this mode, the assignment level of all assigned resources
     * will be updated to evenly distribute the task's workload among them.
     *
     * @return {String} scheduling mode string
     */
    /**
     * Sets the scheduling mode for this task.
     *
     * @param {String} value Name of the scheduling mode. Should be one of the
     * following strings:
     *
     * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based on information
     * about its start/end dates, task own calendar (project calendar if there's no one) and calendars of the assigned resources.
     *
     * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed dynamically,
     * based on the assigned resources information. Typical example of such task is - meeting. Meetings typically have
     * pre-defined start and end dates and the more people are participating in the meeting, the more effort is spent on the task.
     * When duration of such task increases, its effort is increased too (and vice-versa). Note: fixed start and end dates
     * here doesn't mean that a user can't update them via GUI, the only field which won't be editable in GUI is the effort field,
     * it will be calculated according to duration and resources assigned to the task.
     *
     * - `EffortDriven` mode means, that task has fixed effort and computed duration. The more resources will be assigned
     * to this task, the less the duration will be. The typical example will be a "paint the walls" task -
     * several painters will complete it faster.
     *
     * - `DynamicAssignment` mode can be used when both duration and effort of the task are fixed. The computed value in this
     * case will be - the assignment units of the resources assigned. In this mode, the assignment level of all assigned resources
     * will be updated to evenly distribute the task's workload among them.
     *
     * - `Manual` **this mode is deprecated. Please set "ManuallyScheduled" field to `true` instead.**
     *
     * @param {Function} [callback] Callback function to call after task's scheduling mode has been changed and possible
     *  changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for cancelling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setSchedulingMode: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setSchedulingModeWithoutPropagation(value);
        }, callback);
    },
    setSchedulingModeWithoutPropagation: function(value) {
        var me = this,
            propagationSource;
        Ext.Array.contains(me.recognizedSchedulingModes, value) || Ext.Error.raise("Unrecognized scheduling mode: " + value);
        if (me.getSchedulingMode() != value) {
            me.set(this.schedulingModeField, value);
            switch (value) {
                case 'FixedDuration':
                    me.updateEffortBasedOnDuration();
                    break;
                case 'EffortDriven':
                    me.updateSpanBasedOnEffort();
                    break;
            }
            var predecessors = me.getPredecessors();
            if (predecessors.length) {
                propagationSource = predecessors[0];
            } else {
                propagationSource = me;
            }
        }
        return propagationSource;
    },
    /**
     * @method getSegments
     * Gets segments of the task
     * @returns {Gnt.model.TaskSegment[]} Task segments
     */
    skipWorkingTime: function(date, duration, isForward, segments) {
        var result;
        var durationLeft;
        isForward = isForward !== false;
        var cfg = {
                isForward: isForward,
                segments: segments || false,
                // take resources into account if any
                resources: this.hasResources(),
                fn: function(from, to) {
                    var diff = to - from,
                        dstDiff = new Date(from).getTimezoneOffset() - new Date(to).getTimezoneOffset();
                    if (diff >= durationLeft) {
                        result = new Date((isForward ? from : to) - 0 + (isForward ? 1 : -1) * durationLeft);
                        return false;
                    } else {
                        durationLeft -= diff + dstDiff * 60 * 1000;
                    }
                }
            };
        if (Ext.isObject(date)) {
            Ext.apply(cfg, date);
        } else {
            if (isForward) {
                cfg.startDate = date;
            } else {
                cfg.endDate = date;
            }
        }
        durationLeft = duration || cfg.duration;
        if (!durationLeft)  {
            return date;
        }
        
        this.forEachAvailabilityInterval(cfg);
        return result;
    },
    /**
     * @ignore
     */
    skipNonWorkingTime: function(date, isForward, segments) {
        var skipped = false;
        isForward = isForward !== false;
        var cfg = {
                isForward: isForward,
                segments: segments || false,
                // take resources into account if any
                resources: this.hasResources(),
                fn: function(from, to) {
                    // if found interval has zero time length then nothing to skip so we just ignore it.
                    // TODO: need to review a possibility to move this condition right into forEachAvailabilityInterval() body
                    if (from !== to) {
                        date = isForward ? from : to;
                        skipped = true;
                        return false;
                    }
                }
            };
        if (Ext.isObject(date)) {
            Ext.apply(cfg, date);
        } else {
            if (isForward) {
                cfg.startDate = date;
            } else {
                cfg.endDate = date;
            }
        }
        // resetting the date to the earliest availability interval
        this.forEachAvailabilityInterval(cfg);
        return skipped ? new Date(date) : this.getCalendar().skipNonWorkingTime(date, isForward);
    },
    /**
     * @method getStartDate
     *
     * Returns the start date of this task
     *
     * @return {Date} start date
     */
    /**
     * Depending from the arguments, set either `StartDate + EndDate` fields of this task, or `StartDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date Start date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     * @param {Function} [callback] Callback function to call after start date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setStartDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setStartDateWithoutPropagation(date, keepDuration, skipNonWorkingTime);
        }, callback);
    },
    // TODO: refactor this
    setStartDateWithoutPropagation: function(date, keepDuration, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true),
            duration, endDate;
        // {{{ Parameters normalization
        keepDuration = keepDuration !== false;
        if (taskStore && skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = taskStore.skipWeekendsDuringDragDrop;
        } else if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = false;
        }
        // }}}
        me.beginEdit();
        if (!date) {
            me.set(me.durationField, null);
            me.set(me.startDateField, null);
            me.setSegmentsWithoutPropagation(null);
        } else {
            if (skipNonWorkingTime) {
                // for milestones we skip non-working backwards, for normal tasks - forward
                date = me.skipNonWorkingTime(date, !me.isMilestone());
            }
            me.set(me.startDateField, date);
            // recalculate split dates
            if (taskStore && me.isSegmented()) {
                me.updateSegmentsDates();
            }
            if (keepDuration !== false) {
                me.set(me.endDateField, me.recalculateEndDate(date));
            } else {
                endDate = this.getEndDate();
                if (endDate) {
                    // truncate segments that don't fit into master task range and shrink/expand last segment
                    this.constrainSegments();
                    me.set(me.durationField, me.calculateDuration(date, endDate, me.getDurationUnit()));
                }
            }
        }
        // eof "has `date`" branch
        duration = me.getDuration();
        endDate = me.getEndDate();
        if (date && endDate && (duration === undefined || duration === null)) {
            me.set(me.durationField, me.calculateDuration(date, endDate, me.getDurationUnit()));
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * @method getEndDate
     *
     * Returns the end date of this task
     *
     * @return {Date} end date
     */
    /**
     * Depending from the arguments, set either `StartDate + EndDate` fields of this task, or `EndDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date End date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the end date to the previous working day (if it falls on weekend/holiday).
     * @param {Function} [callback] Callback function to call after end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setEndDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setEndDateWithoutPropagation(date, keepDuration, skipNonWorkingTime);
        }, callback);
    },
    // TODO: refactor this
    setEndDateWithoutPropagation: function(date, keepDuration, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true),
            duration, startDate;
        // {{{ Parameters normalization
        keepDuration = keepDuration !== false;
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false && taskStore) {
            skipNonWorkingTime = taskStore.skipWeekendsDuringDragDrop;
        } else if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = false;
        }
        // }}}
        me.beginEdit();
        var currentEndDate = me.getEndDate();
        if (!date) {
            me.set(me.durationField, null);
            me.set(me.endDateField, null);
            me.setSegments(null);
        } else {
            startDate = me.getStartDate();
            // task end date cannot be less than its start date
            if (date < startDate && keepDuration === false) {
                date = startDate;
            }
            if (skipNonWorkingTime) {
                date = me.skipNonWorkingTime(date, false);
            }
            if (keepDuration !== false) {
                duration = me.getDuration();
                if (Ext.isNumber(duration)) {
                    // recalculate segments dates (we need this to calculate the task start date properly)
                    if (taskStore && me.isSegmented() && (date - currentEndDate)) {
                        me.updateSegmentsDates({
                            isForward: false,
                            endDate: date
                        });
                    }
                    me.set(me.startDateField, me.calculateStartDate(date, duration, me.getDurationUnit()));
                    me.set(me.endDateField, date);
                } else {
                    me.set(me.endDateField, date);
                }
            } else {
                var wasMilestone = me.isMilestone();
                // if end date after adjusting to calendar is less than start date
                // then it's going to be a milestone and we set start date equal to adjusted end date
                if (date < startDate) {
                    me.set(me.startDateField, date);
                }
                me.set(me.endDateField, date);
                me.constrainSegments();
                if (startDate) {
                    me.set(me.durationField, me.calculateDuration(startDate, date, me.getDurationUnit()));
                    // if we converted to regular task from milestone
                    // let's make sure that task start is adjusted to the calendar
                    if (wasMilestone && !me.isMilestone()) {
                        var properStartDate = me.skipNonWorkingTime(startDate, true);
                        if (properStartDate - startDate !== 0) {
                            // set start date adjusted to the calendar
                            me.set(me.startDateField, properStartDate);
                        }
                    }
                }
            }
        }
        duration = me.getDuration();
        startDate = me.getStartDate();
        if (date && startDate && (duration === undefined || duration === null)) {
            me.set(me.durationField, me.calculateDuration(startDate, date, me.getDurationUnit()));
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * Sets the `StartDate / EndDate / Duration` fields of this task, considering the availability/holidays information.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} startDate Start date to set
     * @param {Date} endDate End date to set
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start/end dates to the next/previous working day (if they falls on weekend/holiday).
     * @param {Function} [callback] Callback function to call after start/end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setStartEndDate: function(startDate, endDate, skipNonWorkingTime, callback) {
        var me = this;
        // This is required to have Data components tests green
        skipNonWorkingTime = skipNonWorkingTime || false;
        me.propagateChanges(function() {
            return me.setStartEndDateWithoutPropagation(startDate, endDate, skipNonWorkingTime);
        }, callback);
    },
    setStartEndDateWithoutPropagation: function(startDate, endDate, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true);
        // {{{ Parameters normalization
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false && taskStore) {
            skipNonWorkingTime = taskStore.skipWeekendsDuringDragDrop;
        } else if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = false;
        }
        // }}}
        if (skipNonWorkingTime) {
            startDate = startDate && me.skipNonWorkingTime(startDate, true);
            endDate = endDate && me.skipNonWorkingTime(endDate, false);
            if (endDate < startDate) {
                startDate = endDate;
            }
        }
        var currentStartDate = me.getStartDate(),
            currentEndDate = me.getEndDate();
        me.beginEdit();
        me.set(me.startDateField, startDate);
        me.set(me.endDateField, endDate);
        // recalculate split dates
        if (me.getTaskStore(true) && me.isSegmented() && ((startDate - currentStartDate) || (endDate - currentEndDate))) {
            me.updateSegmentsDates();
        }
        if (endDate - currentEndDate) {
            me.constrainSegments();
        }
        me.set(me.durationField, me.calculateDuration(startDate, endDate, me.getDurationUnit()));
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * Shift the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
     * @param {Number} amount The amount to shift
     * @param {Function} [callback] Callback function to call after task has been shifted and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    shift: function(unit, amount, callback) {
        var me = this,
            startDate = me.getStartDate(),
            endDate = me.getEndDate();
        me.setStartEndDate(startDate && Sch.util.Date.add(startDate, unit, amount), endDate && Sch.util.Date.add(endDate, unit, amount), undefined, callback);
    },
    /**
     * Returns the duration of the task expressed in the unit passed as the only parameter (or as specified by the DurationUnit for the task).
     *
     * @param {String} unit (optional) Unit to return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getDuration: function(unit) {
        if (!unit)  {
            return this.get(this.durationField);
        }
        
        var converter = this.getUnitConverter(),
            durationInMS = converter.convertDurationToMs(this.get(this.durationField), this.get(this.durationUnitField));
        return converter.convertMSDurationToUnit(durationInMS, unit);
    },
    /**
     * Returns the effort of the task expressed in the unit passed as the only parameter (or as specified by the EffortUnit for the task).
     *
     * @param {String} unit Unit to return the effort in. Defaults to the `EffortUnit` field of this task
     *
     * @return {Number} effort
     */
    getEffort: function(unit) {
        var fieldValue = this.get(this.effortField) || 0;
        if (!unit)  {
            return fieldValue;
        }
        
        var converter = this.getUnitConverter(),
            durationInMS = converter.convertDurationToMs(fieldValue, this.getEffortUnit());
        return converter.convertMSDurationToUnit(durationInMS, unit);
    },
    /**
     * Sets the `Effort + EffortUnit` fields of this task. In case the task has the `EffortDriven`
     * scheduling mode will also update the duration of the task accordingly.
     * In case of `DynamicAssignment` mode - will update the assignments.
     *
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getEffortUnit()] The unit of the effort.
     * @param {Function} [callback] Callback function to call after effort has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setEffort: function(number, unit, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setEffortWithoutPropagation(number, unit);
        }, callback);
    },
    setEffortWithoutPropagation: function(number, unit) {
        var me = this;
        // {{{ Parameters normalization
        unit = unit || me.getEffortUnit();
        // }}}
        me.beginEdit();
        me.set(me.effortField, number);
        me.set(me.effortUnitField, unit);
        switch (me.getSchedulingMode()) {
            case 'EffortDriven':
                me.updateSpanBasedOnEffort();
                break;
            case 'DynamicAssignment':
                me.updateAssignments();
                break;
        }
        me.endEdit();
        return true;
    },
    /**
     * Returns the "raw" calendar duration (difference between end and start date) of this task in the given units.
     *
     * Please refer to the "Task durations" section for additional important details about duration units.
     *
     * @param {String} unit Unit to return return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getCalendarDuration: function(unit) {
        return this.getUnitConverter().convertMSDurationToUnit(this.getEndDate() - this.getStartDate(), unit || this.get(this.durationUnitField));
    },
    /**
     * Sets the `Duration + DurationUnit + EndDate` fields of this task, considering the weekends/holidays rules.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * May also update additional fields, depending from the scheduling mode.
     *
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getDurationUnit()] The unit of the duration.
     * @param {Function} [callback] Callback function to call after duration has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setDuration: function(number, unit, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setDurationWithoutPropagation(number, unit);
        }, callback);
    },
    setDurationWithoutPropagation: function(number, unit) {
        var me = this;
        // If a task has end predecessors, and no start predecessors we update the start date instead of the end date
        var updateStartDate = !me.isManuallyScheduled() && me.hasEndPredecessorsButNoStartPredecessors();
        var newEndDate = null;
        var newStartDate = null;
        var endDate = me.getEndDate();
        // {{{ Parameters normalization
        unit = unit || me.getDurationUnit();
        // }}}
        var wasMilestone = me.isMilestone();
        me.beginEdit();
        // Provide project start date (if any) or now as start date if it isn't already set
        if (Ext.isNumber(number) && !me.getStartDate()) {
            if (endDate) {
                // If task has end date but no start date and we're setting the duration, modify start date (handled below)
                updateStartDate = true;
            } else {
                var taskStore = me.getTaskStore(true);
                newStartDate = (taskStore && taskStore.getProjectStartDate()) || Ext.Date.clearTime(new Date());
                me.setStartDateWithoutPropagation(newStartDate);
            }
        }
        this.constrainSegments({
            duration: number,
            unit: unit
        });
        if (Ext.isNumber(number)) {
            if (updateStartDate && me.getEndDate()) {
                newStartDate = me.calculateStartDate(me.getEndDate(), number, unit);
            } else {
                newEndDate = me.calculateEndDate(me.getStartDate(), number, unit);
            }
        }
        // Don't clear the end date if task isn't properly scheduled
        if (!updateStartDate && (newEndDate || this.getStartDate())) {
            me.set(me.endDateField, newEndDate);
        }
        if (updateStartDate && (newStartDate || this.getEndDate())) {
            me.set(me.startDateField, newStartDate);
        }
        me.set(me.durationField, number);
        me.set(me.durationUnitField, unit);
        // if task is switched to/from milestone then we also need
        // to check if start/end dates are adjusted to the calendar
        if (me.isMilestone() != wasMilestone) {
            // if it's not a milestone now
            if (wasMilestone) {
                // check if start date is adjusted to calendar
                var startDate = me.getStartDate();
                if (startDate) {
                    var properStartDate = me.skipNonWorkingTime(startDate, true);
                    if (properStartDate - startDate !== 0) {
                        // set start date adjusted to the calendar
                        me.set(me.startDateField, properStartDate);
                    }
                }
            }
            // if it's a milestone
            else if (newEndDate) {
                // skip non-working time backward
                var properEndDate = me.skipNonWorkingTime(newEndDate, false);
                if (properEndDate - newEndDate !== 0) {
                    // set start/end dates adjusted to the calendar
                    me.set(me.startDateField, properEndDate);
                    me.set(me.endDateField, properEndDate);
                }
            }
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    calculateStartDate: function(endDate, duration, unit, options) {
        if (!duration)  {
            return endDate;
        }
        
        unit = unit || this.getDurationUnit();
        var schedulingMode = this.getSchedulingMode(),
            isStartDateCalculationRequiresAssignments = schedulingMode != 'FixedDuration' && schedulingMode != 'DynamicAssignment' && schedulingMode != 'EffortDriven';
        options = Ext.apply({
            endDate: endDate,
            isForward: false,
            // if there are any assignments, need to take them into account when calculating the duration
            // but only for "normal" scheduling mode
            // for "EffortDriven" one should use "calculateEffortDrivenEndDate"
            // for "FixedDuration/DynamicAssignment" assignments should not affect the end date of the task
            resources: isStartDateCalculationRequiresAssignments && this.hasResources()
        }, options);
        if (this.getTaskStore(true) && (this.isSegmented() || isStartDateCalculationRequiresAssignments)) {
            var leftDuration = this.getUnitConverter().convertDurationToMs(duration, unit);
            var startDate;
            this.forEachAvailabilityInterval(options, function(intervalStart, intervalEnd) {
                var intervalDuration = intervalEnd - intervalStart;
                if (intervalDuration >= leftDuration) {
                    startDate = new Date(intervalEnd - leftDuration);
                    return false;
                } else {
                    var dstDiff = new Date(intervalEnd).getTimezoneOffset() - new Date(intervalStart).getTimezoneOffset();
                    leftDuration -= intervalDuration + dstDiff * 60 * 1000;
                }
            });
            return startDate;
        } else {
            // otherwise just consult the calendar
            return this.getCalendar().calculateStartDate(endDate, duration, unit);
        }
    },
    //Recalculates a task end date based on a new startdate (use task start date if omitted)
    recalculateEndDate: function(startDate) {
        var me = this,
            result, duration;
        startDate = startDate || me.getStartDate();
        if (startDate && me.getSchedulingMode() == 'EffortDriven') {
            result = me.calculateEffortDrivenEndDate(startDate, me.getEffort());
        } else {
            duration = me.getDuration();
            if (startDate && Ext.isNumber(duration)) {
                result = me.calculateEndDate(startDate, duration, me.getDurationUnit());
            } else {
                result = me.getEndDate();
            }
        }
        return result;
    },
    calculateEndDate: function(startDate, duration, unit, options) {
        unit = unit || this.getDurationUnit();
        if (!duration)  {
            return startDate;
        }
        
        options = Ext.apply({
            startDate: startDate
        }, options);
        var schedulingMode = this.getSchedulingMode(),
            endDate;
        // if there are any assignments, need to take them into account when calculating the duration
        // but only for "normal" scheduling mode
        // for "FixedDuration/DynamicAssignment" assignments should not affect the end date of the task
        // and for "EffortDriven" mode one should use "calculateEffortDrivenEndDate"
        var isEndDateCalculationRequiresAssignments = schedulingMode != 'FixedDuration' && schedulingMode != 'DynamicAssignment' && schedulingMode != 'EffortDriven';
        if (this.getTaskStore(true) && (this.isSegmented() || isEndDateCalculationRequiresAssignments)) {
            var leftDuration = this.getUnitConverter().convertDurationToMs(duration, unit);
            options.resources = isEndDateCalculationRequiresAssignments && this.hasResources();
            this.forEachAvailabilityInterval(options, function(from, till) {
                var intervalDuration = till - from;
                if (intervalDuration >= leftDuration) {
                    endDate = new Date(from + leftDuration);
                    return false;
                } else {
                    var dstDiff = new Date(from).getTimezoneOffset() - new Date(till).getTimezoneOffset();
                    leftDuration -= intervalDuration + dstDiff * 60 * 1000;
                }
            });
        } else {
            // otherwise just consult the calendar
            return this.getCalendar().calculateEndDate(startDate, duration, unit);
        }
        return endDate;
    },
    calculateDuration: function(startDate, endDate, unit, options) {
        unit = unit || this.getDurationUnit();
        if (!startDate || !endDate) {
            return 0;
        }
        // if there are any assignments, need to take them into account when calculating the duration
        if (this.getTaskStore(true)) {
            var durationInMS = 0;
            this.forEachAvailabilityInterval(Ext.apply({
                startDate: startDate,
                endDate: endDate,
                resources: this.hasResources()
            }, options), function(from, till) {
                var dstDiff = new Date(from).getTimezoneOffset() - new Date(till).getTimezoneOffset();
                durationInMS += till - from + dstDiff * 60 * 1000;
            });
            return this.getUnitConverter().convertMSDurationToUnit(durationInMS, unit);
        } else {
            // otherwise just consult the calendar
            return this.getCalendar().calculateDuration(startDate, endDate, unit);
        }
    },
    isCalendarApplicable: function(calendarId) {
        var startDate = this.getStartDate();
        if (!startDate)  {
            return true;
        }
        
        var taskStore = this.getTaskStore(true);
        if (!taskStore)  {
            return true;
        }
        
        var endDate = Sch.util.Date.add(startDate, 'd', (taskStore && taskStore.availabilitySearchLimit) || 5 * 365);
        var assignments = this.getAssignments();
        var resourcesCalendars = [];
        Ext.Array.each(assignments, function(assignment) {
            var resource = assignment.getResource();
            if (resource) {
                resourcesCalendars.push(resource.getCalendar());
            }
        });
        if (!resourcesCalendars.length)  {
            return true;
        }
        
        var calendar = Gnt.data.Calendar.getCalendar(calendarId);
        for (var i = 0,
            l = resourcesCalendars.length; i < l; i++) {
            if (calendar.isAvailabilityIntersected(resourcesCalendars[i], startDate, endDate))  {
                return true;
            }
            
        }
        return false;
    },
    forEachAvailabilityInterval: function(options, func, scope) {
        func = func || options.fn;
        scope = scope || options.scope || this;
        var me = this,
            startDate = options.startDate,
            endDate = options.endDate,
            includeEmptyIntervals = options.includeEmptyIntervals,
            needResources = options.resources,
            useSegments = options.segments || (options.segments !== false),
            // isForward enabled by default
            isForward = options.isForward !== false,
            DATE = Sch.util.Date,
            cursorDate, segments;
        // need taskStore to get default `availabilitySearchLimit` value
        var store = this.getTaskStore(true);
        var i, k, l, interval, intervalStart, intervalEnd;
        if (isForward) {
            if (!startDate)  {
                throw new Error("forEachAvailabilityInterval: `startDate` is required when `isForward` is true");
            }
            
            // if no boundary we still have to specify some limit
            if (!endDate)  {
                endDate = DATE.add(startDate, 'd', options.availabilitySearchLimit || (store && store.availabilitySearchLimit) || 5 * 365);
            }
            
            cursorDate = new Date(startDate);
        } else {
            if (!endDate)  {
                throw new Error("forEachAvailabilityInterval: `endDate` is required when `isForward` is false");
            }
            
            // if no boundary we still have to specify some limit
            if (!startDate)  {
                startDate = DATE.add(endDate, 'd', -(options.availabilitySearchLimit || (store && store.availabilitySearchLimit) || 5 * 365));
            }
            
            cursorDate = new Date(endDate);
        }
        var taskCalendar = this.getOwnCalendar(),
            projectCalendar = this.getProjectCalendar(),
            resourceByCalendar = {},
            calendars = [];
        // if we take resources into account
        if (needResources) {
            var resourceFound = false;
            // we can provide list of assignments as well
            var assignments = options.assignments;
            // helper function to prepare resources data
            var handleResource = function(resource) {
                    var resourceId = resource.getId(),
                        assignment = assignments && Ext.Array.findBy(assignments, function(a) {
                            return a.getResourceId() == resourceId;
                        }) || me.getAssignmentFor(resource),
                        calendar = resource.getCalendar(),
                        id = calendar.getCalendarId();
                    if (!resourceByCalendar[id]) {
                        resourceByCalendar[id] = [];
                        calendars.push(calendar);
                    }
                    resourceByCalendar[id].push({
                        assignment: assignment,
                        resourceId: resourceId,
                        units: assignment && assignment.getUnits()
                    });
                    resourceFound = true;
                };
            // user has provided the resources to use for iteration
            if (needResources !== true) {
                Ext.each(needResources, handleResource);
            } else // otherwise retrieve all assigned resources
            {
                Ext.Array.each(this.getAssignments(), function(assignment) {
                    var resource = assignment.getResource();
                    if (resource)  {
                        handleResource(resource);
                    }
                    
                });
            }
            // if there are no resources - then iterator should not be called by contract, just return
            if (!resourceFound)  {
                return;
            }
            
        } else // if we don't use resource calendars for calculation then we gonna use the task/project calendar
        {
            taskCalendar = taskCalendar || projectCalendar;
        }
        var splits, splitStart, splitEnd;
        if (useSegments) {
            if (!Ext.isArray(useSegments)) {
                segments = this.getSegments();
            } else {
                segments = useSegments;
            }
            if (segments) {
                splits = [];
                // Let's walk over the segment and "invert" them.
                // We need to operate non working intervals (splits) instead of StartDate-EndDate pairs.
                for (i = 0 , l = segments.length; i < l - 1; i++) {
                    // split start is the current segment EndDate and split end is the next segment StartDate
                    splitStart = segments[i].getEndDate() - 0;
                    splitEnd = segments[i + 1].getStartDate() - 0;
                    // we use the split only if it intersects w/ the requested timespan
                    if (splitStart > startDate || splitEnd < endDate) {
                        splits.push([
                            segments[i].getEndDate() - 0,
                            segments[i + 1].getStartDate() - 0
                        ]);
                    }
                }
                if (!splits.length) {
                    splits = null;
                }
            }
        }
        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            var pointsByTime = {};
            var pointTimes = [];
            var cursorDT = cursorDate - (isForward ? 0 : 1);
            // if a task has a custom calendar
            if (taskCalendar) {
                var taskIntervals = taskCalendar.getAvailabilityIntervalsFor(cursorDT);
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0 , l = taskIntervals.length; k < l; k++) {
                    interval = taskIntervals[k];
                    intervalStart = interval.startDate - 0;
                    intervalEnd = interval.endDate - 0;
                    if (!pointsByTime[intervalStart]) {
                        pointsByTime[intervalStart] = [];
                        pointTimes.push(intervalStart);
                    }
                    pointsByTime[intervalStart].push({
                        type: '00-taskAvailailabilityStart',
                        typeBackward: '01-taskAvailailabilityStart'
                    });
                    pointTimes.push(intervalEnd);
                    pointsByTime[intervalEnd] = pointsByTime[intervalEnd] || [];
                    pointsByTime[intervalEnd].push({
                        type: '01-taskAvailailabilityEnd',
                        typeBackward: '00-taskAvailailabilityEnd'
                    });
                }
            }
            // If we take the task segmentation into account
            if (splits) {
                var from, till;
                if (isForward) {
                    from = cursorDate;
                    till = DATE.getStartOfNextDay(cursorDate);
                } else {
                    from = DATE.getEndOfPreviousDay(cursorDate);
                    till = cursorDate;
                }
                for (i = 0 , l = splits.length; i < l; i++) {
                    splitStart = splits[i][0];
                    splitEnd = splits[i][1];
                    if (splitStart < till && splitEnd > from) {
                        splitStart = DATE.constrain(splitStart, from, till) - 0;
                        splitEnd = DATE.constrain(splitEnd, from, till) - 0;
                        if (!pointsByTime[splitStart]) {
                            pointsByTime[splitStart] = [];
                            pointTimes.push(splitStart);
                        }
                        pointsByTime[splitStart].push({
                            type: '05-taskSegmentEnd',
                            typeBackward: '04-taskSegmentEnd'
                        });
                        if (!pointsByTime[splitEnd]) {
                            pointsByTime[splitEnd] = [];
                            pointTimes.push(splitEnd);
                        }
                        pointsByTime[splitEnd].push({
                            type: '04-taskSegmentStart',
                            typeBackward: '05-taskSegmentStart'
                        });
                        // Since segments cannot overlap by contract we can break the loop here
                        break;
                    }
                }
            }
            var resourceList;
            // loop over resources having custom calendars
            for (i = 0 , l = calendars.length; i < l; i++) {
                var cal = calendars[i],
                    resourceIntervals = cal.getAvailabilityIntervalsFor(cursorDT);
                resourceList = resourceByCalendar[cal.getCalendarId()];
                // using "for" instead of "each" should be blazing fast! :)
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0; k < resourceIntervals.length; k++) {
                    interval = resourceIntervals[k];
                    intervalStart = interval.startDate - 0;
                    intervalEnd = interval.endDate - 0;
                    if (!pointsByTime[intervalStart]) {
                        pointsByTime[intervalStart] = [];
                        pointTimes.push(intervalStart);
                    }
                    pointsByTime[intervalStart].push({
                        type: '02-resourceAvailailabilityStart',
                        typeBackward: '03-resourceAvailailabilityStart',
                        resources: resourceList
                    });
                    if (!pointsByTime[intervalEnd]) {
                        pointsByTime[intervalEnd] = [];
                        pointTimes.push(intervalEnd);
                    }
                    pointsByTime[intervalEnd].push({
                        type: '03-resourceAvailailabilityEnd',
                        typeBackward: '02-resourceAvailailabilityEnd',
                        resources: resourceList
                    });
                }
            }
            pointTimes.sort(function(a, b) {
                return a - b;
            });
            var inTaskCalendar = false,
                inSegment = true,
                currentResources = {},
                resourceCounter = 0,
                points, point, m, n;
            if (isForward) {
                for (i = 0 , l = pointTimes.length; i < l; i++) {
                    points = pointsByTime[pointTimes[i]];
                    points.sort(function(a, b) {
                        return a.type < b.type ? 1 : -1;
                    });
                    for (k = 0; k < points.length; k++) {
                        point = points[k];
                        switch (point.type) {
                            case '00-taskAvailailabilityStart':
                                inTaskCalendar = true;
                                break;
                            case '01-taskAvailailabilityEnd':
                                inTaskCalendar = false;
                                break;
                            case '02-resourceAvailailabilityStart':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    currentResources[resourceList[m].resourceId] = resourceList[m];
                                    resourceCounter++;
                                };
                                break;
                            case '03-resourceAvailailabilityEnd':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    delete currentResources[resourceList[m].resourceId];
                                    resourceCounter--;
                                };
                                break;
                            case '04-taskSegmentStart':
                                inSegment = true;
                                break;
                            case '05-taskSegmentEnd':
                                inSegment = false;
                                break;
                        }
                    }
                    if ((inTaskCalendar || !taskCalendar) && (!splits || inSegment) && (!needResources || resourceCounter || includeEmptyIntervals)) {
                        intervalStart = pointTimes[i];
                        intervalEnd = pointTimes[i + 1];
                        // availability interval is out of [ startDate, endDate )
                        if (intervalStart >= endDate || intervalEnd <= startDate)  {
                            
                            continue;
                        }
                        
                        if (intervalStart < startDate)  {
                            intervalStart = startDate - 0;
                        }
                        
                        if (intervalEnd > endDate)  {
                            intervalEnd = endDate - 0;
                        }
                        
                        if (func.call(scope, intervalStart, intervalEnd, currentResources) === false)  {
                            return false;
                        }
                        
                    }
                }
            } else {
                for (i = pointTimes.length - 1; i >= 0; i--) {
                    points = pointsByTime[pointTimes[i]];
                    points.sort(function(a, b) {
                        return a.typeBackward < b.typeBackward ? 1 : -1;
                    });
                    for (k = 0; k < points.length; k++) {
                        point = points[k];
                        switch (point.typeBackward) {
                            case '00-taskAvailailabilityEnd':
                                inTaskCalendar = true;
                                break;
                            case '01-taskAvailailabilityStart':
                                inTaskCalendar = false;
                                break;
                            case '02-resourceAvailailabilityEnd':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    currentResources[resourceList[m].resourceId] = resourceList[m];
                                    resourceCounter++;
                                };
                                break;
                            case '03-resourceAvailailabilityStart':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    delete currentResources[resourceList[m].resourceId];
                                    resourceCounter--;
                                };
                                break;
                            case '04-taskSegmentEnd':
                                inSegment = true;
                                break;
                            case '05-taskSegmentStart':
                                inSegment = false;
                                break;
                        }
                    }
                    if ((inTaskCalendar || !taskCalendar) && (!splits || inSegment) && (!needResources || resourceCounter || includeEmptyIntervals)) {
                        intervalStart = pointTimes[i - 1];
                        intervalEnd = pointTimes[i];
                        // availability interval is out of [ startDate, endDate )
                        if (intervalStart > endDate || intervalEnd <= startDate)  {
                            
                            continue;
                        }
                        
                        if (intervalStart < startDate)  {
                            intervalStart = startDate - 0;
                        }
                        
                        if (intervalEnd > endDate)  {
                            intervalEnd = endDate - 0;
                        }
                        
                        if (func.call(scope, intervalStart, intervalEnd, currentResources) === false)  {
                            return false;
                        }
                        
                    }
                }
            }
            // eof backward branch
            // does not perform cloning internally!
            cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate) : DATE.getEndOfPreviousDay(cursorDate);
        }
    },
    // eof while
    // iterates over the common availability intervals for tasks and resources in between `startDate/endDate`
    // note, that function will receive start/end dates as number, not dates (for optimization purposes)
    // this method is not "normalized" intentionally because of performance considerations
    forEachAvailabilityIntervalWithResources: function(options, func, scope) {
        if (!options.resources)  {
            options.resources = true;
        }
        
        this.forEachAvailabilityInterval.apply(this, arguments);
    },
    calculateEffortDrivenEndDate: function(startDate, effort, unit) {
        if (!effort)  {
            return startDate;
        }
        
        var effortInMS = this.getUnitConverter().convertDurationToMs(effort, unit || this.getEffortUnit());
        var endDate = new Date(startDate);
        this.forEachAvailabilityIntervalWithResources({
            startDate: startDate
        }, function(intervalStartDate, intervalEndDate, currentResources) {
            var totalUnits = 0;
            for (var i in currentResources) totalUnits += currentResources[i].units;
            var intervalDuration = intervalEndDate - intervalStartDate;
            var availableEffort = totalUnits * intervalDuration / 100;
            if (availableEffort >= effortInMS) {
                endDate = new Date(intervalStartDate + effortInMS / availableEffort * intervalDuration);
                return false;
            } else {
                effortInMS -= availableEffort;
            }
        });
        return endDate;
    },
    // this method has a contract that all child parents should already have refreshed data, so it should be called
    // in the "bubbling" order - starting from deeper nodes to closer to root
    refreshCalculatedParentNodeData: function() {
        var autoCalculatePercentDoneForParentTask = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask = this.autoCalculateEffortForParentTask;
        var childNodes = this.childNodes;
        var length = childNodes.length;
        var changedFields = {};
        if (length > 0 && (autoCalculateEffortForParentTask || autoCalculatePercentDoneForParentTask)) {
            var totalEffortInMS = 0;
            var totalDurationInMS = 0;
            var completedDurationInMS = 0;
            for (var k = 0; k < length; k++) {
                var childNode = childNodes[k];
                // We could end up here as a result of taskStore#removeAll which means some of the child nodes could already
                // be removed
                if (childNode.parentNode) {
                    var isLeaf = childNode.isLeaf();
                    if (autoCalculateEffortForParentTask)  {
                        totalEffortInMS += childNode.getEffort('MILLI');
                    }
                    
                    if (autoCalculatePercentDoneForParentTask) {
                        var durationInMS = isLeaf ? childNode.getDuration('MILLI') || 0 : childNode.childTasksDuration;
                        totalDurationInMS += durationInMS;
                        completedDurationInMS += isLeaf ? durationInMS * (childNode.getPercentDone() || 0) : childNode.completedChildTasksDuration;
                    }
                }
            }
            if (autoCalculateEffortForParentTask && this.getEffort('MILLI') != totalEffortInMS) {
                changedFields.Effort = true;
                this.setEffortWithoutPropagation(this.getUnitConverter().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit()));
            }
            if (autoCalculatePercentDoneForParentTask) {
                this.childTasksDuration = totalDurationInMS;
                this.completedChildTasksDuration = completedDurationInMS;
                var newPercentDone = totalDurationInMS ? completedDurationInMS / totalDurationInMS : 0;
                if (this.getPercentDone() != newPercentDone) {
                    changedFields.PercentDone = true;
                    this.setPercentDone(newPercentDone);
                }
            }
        }
        var startChanged, endChanged;
        if (!this.isRoot() && length > 0 && !this.isManuallyScheduled() && !this.isReadOnly()) {
            var minDate = new Date(-8.64E15),
                maxDate = new Date(+8.64E15),
                earliest = new Date(+8.64E15),
                //new Date(maxDate)
                latest = new Date(-8.64E15);
            //new Date(minDate) - this works incorrect in FF
            for (var i = 0; i < length; i++) {
                var r = childNodes[i];
                earliest = Sch.util.Date.min(earliest, r.getStartDate() || earliest);
                latest = Sch.util.Date.max(latest, r.getEndDate() || latest);
            }
            // This could happen if a parent task has two children, one having just start date and another having just an end date
            if (latest < earliest && earliest < maxDate && latest > minDate) {
                var tmp;
                tmp = latest;
                latest = earliest;
                earliest = tmp;
            }
            startChanged = changedFields.StartDate = earliest - maxDate !== 0 && this.getStartDate() - earliest !== 0;
            endChanged = changedFields.EndDate = latest - minDate !== 0 && this.getEndDate() - latest !== 0;
            // special case to only trigger 1 update event and avoid extra "recalculateParents" calls
            // wrapping with `beginEdit / endEdit` is not an option, because they do not nest (one "endEdit" will "finalize" all previous "beginEdit")
            if (startChanged && endChanged) {
                this.setStartEndDateWithoutPropagation(earliest, latest, false);
            } else if (startChanged) {
                this.setStartDateWithoutPropagation(earliest, false, false);
            } else if (endChanged) {
                this.setEndDateWithoutPropagation(latest, false, false);
            }
        }
        return changedFields;
    },
    // This function is mostly used for backward compatibility as it does not trigger the changes propagation
    recalculateParents: function() {
        var parent = this.parentNode;
        parent && (parent.refreshCalculatedParentNodeData() , !this.getTaskStore().cascading && parent.recalculateParents());
    },
    /*
        var parent = this.parentNode;

        if (parent) {
            var changedFields   = parent.refreshCalculatedParentNodeData();
            var startChanged    = changedFields.StartDate;
            var endChanged      = changedFields.EndDate;

            // if `startChanged` or `endChanged` is true, then propagation to parent task has alreday happened in the
            // `onTaskUpdated` method of the TaskStore (during setStart/EndDate call), otherwise need to propagate it manually
            //
            // In the case of cascading, the store listeners are temporarily disabled so we should bubble up if there's a change
            if ((this.getTaskStore().cascading && (startChanged || endChanged)) || (!startChanged && !endChanged)) {
                if (!parent.isRoot()) parent.recalculateParents();
            }
        }
        */
    /**
     * Returns true if this task is a milestone (has the same start and end dates).
     *
     * @param {Boolean} isBaseline Whether to check for baseline dates instead of "normal" dates. If this argument is provided with
     * "true" value, this method returns the result from the {@link #isBaselineMilestone} method.
     *
     * @return {Boolean}
     */
    isMilestone: function(isBaseline) {
        if (isBaseline)  {
            return this.isBaselineMilestone();
        }
        
        // a summary task may have zero duration when "recalculateParents" is on
        // and a child task has working time on the summary task non-working time
        // so we operate start and end date pair here
        if (!this.get('leaf')) {
            var startDate = this.getStartDate(),
                endDate = this.getEndDate();
            if (startDate && endDate) {
                return endDate - startDate === 0;
            }
        }
        return this.getDuration() === 0;
    },
    /**
     * Converts this task to a milestone (start date will match the end date).
     *
     * @param {Function} [callback] Callback function to call after task has been converted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    convertToMilestone: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.convertToMilestoneWithoutPropagation();
        }, callback);
    },
    convertToMilestoneWithoutPropagation: function() {
        var me = this,
            propagate = false;
        if (!me.isMilestone()) {
            propagate = me.setStartDateWithoutPropagation(me.getEndDate(), false);
            propagate = propagate && me.setDurationWithoutPropagation(0);
        }
        return propagate;
    },
    /**
     * Converts a milestone task to a regular task with a duration of 1 [durationUnit].
     *
     * @param {Function} [callback] Callback function to call after task has been converted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    convertToRegular: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.convertToRegularWithoutPropagation();
        }, callback);
    },
    convertToRegularWithoutPropagation: function() {
        var me = this,
            propagate = false,
            unit, newStart;
        if (me.isMilestone()) {
            unit = me.get(me.durationUnitField);
            newStart = me.calculateStartDate(me.getStartDate(), 1, unit);
            propagate = me.setDurationWithoutPropagation(1, unit);
            // we set the `moveParentAsGroup` flag to false, because in this case we don't want/need to
            // change any of child tasks
            propagate = propagate && me.setStartDateWithoutPropagation(newStart, true, false, false);
        }
        return propagate;
    },
    /**
     * Returns true if this task is a "baseline" milestone (has the same start and end baseline dates) or false if it's not or the dates are wrong.
     *
     * @return {Boolean}
     */
    isBaselineMilestone: function() {
        var baseStart = this.getBaselineStartDate(),
            baseEnd = this.getBaselineEndDate();
        if (baseStart && baseEnd) {
            return baseEnd - baseStart === 0;
        }
        return false;
    },
    // Sets the task "leaf" attribute to `false` and resets `Segments` field
    // since a parent task cannot be split
    markAsParent: function() {
        var me = this;
        me.isSegmented() && me.setSegmentsWithoutPropagation(null);
        // Parent task should never be split
        me.set('leaf', false);
    },
    /**
     * Returns the duration unit of the task.
     * @return {String} the duration unit
     */
    getDurationUnit: function() {
        return this.get(this.durationUnitField) || 'd';
    },
    /**
     * @method setDurationUnit
     *
     * Updates the duration unit of the task.
     *
     * @param {String} unit New duration unit
     * @return {String} the duration unit
     */
    /**
     * Returns the effort unit of the task.
     * @return {String} the effort unit
     */
    getEffortUnit: function() {
        return this.get(this.effortUnitField) || 'h';
    },
    /**
     * @method setEffortUnit
     *
     * Updates the effort unit of the task.
     *
     * @param {String} unit New effort unit
     * @return {String} the effort unit
     */
    /**
     * @method setDeadlineDate
     *
     * Sets the deadline date for this task
     *
     * @param {Date} date
     */
    /**
     * @method getDeadlineDate
     *
     * Returns the task deadline date
     *
     * @return {Date} date
     */
    /**
     * @method setRollup
     *
     * Controls if this task should roll up to its parent
     *
     * @param {Boolean} rollup
     */
    /**
     * @method getRollup
     *
     * Gets the rollup value for this task
     *
     * @return {Boolean} value
     */
    /**
     * @method setPercentDone
     *
     * Sets the percent complete value of the task
     *
     * @param {Number} value The new value
     */
    /**
     * @method getPercentDone
     *
     * Gets the percent complete value of the task
     * @return {Number} The percent complete value of the task
     */
    /**
     * @method getCls
     *
     * Returns the name of field holding the CSS class for each rendered task element
     *
     * @return {String} cls The cls field
     */
    /**
     * @method getBaselineStartDate
     *
     * Returns the baseline start date of this task
     *
     * @return {Date} The baseline start date
     */
    /**
     * @method setBaselineStartDate
     *
     * Sets the baseline start date of this task
     *
     * @param {Date} date
     */
    /**
     * @method getBaselineEndDate
     *
     * Returns the baseline end date of this task
     *
     * @return {Date} The baseline end date
     */
    /**
     * @method setBaselineEndDate
     *
     * Sets the baseline end date of this task
     *
     * @param {Date} date
     */
    /**
     * @method setBaselinePercentDone
     *
     * Sets the baseline percent complete value
     *
     * @param {Number} value The new value
     */
    /**
     * Gets the baseline percent complete value
     * @return {Number} The percent done level of the task
     */
    getBaselinePercentDone: function() {
        return this.get(this.baselinePercentDoneField) || 0;
    },
    /**
     * Returns true if the Task can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var parent = this.parentNode;
        return !parent || !parent.phantom || parent.isRoot();
    },
    /**
     * Returns an array of Gnt.model.Resource instances assigned to this Task.
     *
     * @return {Gnt.model.Resource[]} resources
     */
    getResources: function() {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getResourcesForEvent(me) || [];
    },
    /**
     * Returns an array of Gnt.model.Assignment instances associated with this Task.
     *
     * @return {Gnt.model.Assignment[]} resources
     */
    getAssignments: function() {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForTask(me) || [];
    },
    /**
     * Returns true if this task has any assignments. **Note**, that this function returns `true` even if all assignment records are invalid
     * (ie pointing to non-existing resource in the resource store).
     *
     * @return {Boolean}
     */
    hasAssignments: function() {
        return this.getAssignments().length > 0;
    },
    /**
     * Returns true if this task has any assignments with valid resources. Returns `true` only if at least one assignment record is valid -
     * pointing to existed resource record in the resource store.
     *
     * @return {Boolean}
     */
    hasResources: function() {
        var assignments = this.getAssignments(),
            result = false,
            i, len;
        for (i = 0 , len = assignments.length; !result && i < len; i++) {
            result = !!assignments[i].getResource();
        }
        return result;
    },
    /**
     * If given resource is assigned to this task, returns a Gnt.model.Assignment record.
     * Otherwise returns `null`
     *
     * @param {Gnt.model.Resource/Mixid} resourceOrId The instance of {@link Gnt.model.Resource} or resource id
     *
     * @return {Gnt.model.Assignment|null}
     */
    getAssignmentFor: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentForEventAndResource(me, resource) || null;
    },
    /**
     * @method isAssignedTo
     * Returns true if the task is assigned to a certain resource.
     *
     * @param {Sch.model.Resource} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.isTaskAssignedToResource(me, resource) || false;
    },
    /**
     * Assigns this task to the passed Resource or Resource Id.
     *
     * @param {Gnt.model.Resource/Mixed} resource The instance of a {@link Gnt.model.Resource resource} or its id.
     * @param {Number} units The integer value for the {@link Gnt.model.Assignment#unitsField Units field} of the assignment record.
     * @param {Function} [callback] Callback function to call after resource has been assigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    assign: function(resource, units, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.assignWithoutPropagation(resource, units, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    assignWithoutPropagation: function(resource, units, cancelAndResultFeedback) {
        var me = this,
            cancelActions = [],
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore.getAssignmentStore(),
            resourceStore = taskStore.getResourceStore(),
            assignment, resourceId;
        // {{{ Parameter normalization
        units = units || 100;
        // }}}
        // Preconditions:
        // TODO: wrap it into debug tags when our build system will support debug builds
        !me.getAssignmentFor(resource) || Ext.Error.raise("Resource can't be assigned twice to the same task");
        // If we have a resource model instance but it's not in the resource store then adding it,
        // the resource is proably a phantom record
        if (resource instanceof Gnt.model.Resource && resourceStore.indexOf(resource) == -1) {
            resourceId = resource.getId();
            resourceStore.add(resource);
            cancelActions.push(function() {
                resourceStore.remove(resource);
            });
        }
        // If we have a resource model already in the store then just getting it's id
        else if (resource instanceof Gnt.model.Resource) {
            resourceId = resource.getId();
        }
        // If we don't have a resource model then we must have a resource id, and if a resource with the given id
        // is present in the store then we can proceed
        else if (resourceStore.indexOfId(resource) >= 0) {
            resourceId = resource;
        } else // Otherwise we have nothing to assign to the task, raising an error
        {
            Ext.Error.raise("Can't assign resource to a task, task's resource store doesn't contain resource id given");
            // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
            var foo = false;
        }
        assignment = assignmentStore.assignTaskToResource(me, resourceId, units);
        cancelActions.push(function() {
            assignmentStore.unassignTaskFromResource(me, resourceId);
        });
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            Ext.Array.each(cancelActions, function(action) {
                action();
            });
        }, assignment[0]);
        return true;
    },
    /**
     * Un-assign a resource from this task
     *
     * @param {Gnt.model.Resource/Number} resource An instance of the {@link Gnt.model.Resource} class or a resource id
     * @param {Function} [callback] Callback function to call after resource has been unassigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unassign: function() {
        return this.unAssign.apply(this, arguments);
    },
    unAssign: function(resource, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.unassignWithoutPropagation(resource, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    unassignWithoutPropagation: function(resource, cancelFeedback) {
        var me = this,
            resourceId = resource instanceof Gnt.model.Resource ? resource.getId() : resource,
            assignmentStore = me.getAssignmentStore(),
            assignment = me.getAssignmentFor(resourceId),
            indexOfAssignment;
        assignment || Ext.Error.raise("Can't unassign resource `" + resourceId + "` from task `" + me.getId() + "` resource is not assigned to the task!");
        indexOfAssignment = assignmentStore.indexOf(assignment);
        assignmentStore.unassignTaskFromResource(me, resource);
        cancelFeedback && cancelFeedback(function() {
            assignmentStore.insert(indexOfAssignment, assignment);
        });
        return true;
    },
    /**
     * Reassigns a task from old resource to a new one.
     *
     * @param {Gnt.model.Resource/Mixed} oldResource A resource to unassign from
     * @param {Gnt.model.Resource/Mixed} newResource A resource to assign to
     * @param {Function} [callback] Callback function to call after resource has been reassigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    reassign: function(oldResource, newResource, callback) {
        var me = this,
            unassignCancelFn, assignCancelFn;
        me.propagateChanges(function() {
            var units = me.getAssignmentFor(oldResource).getUnits();
            var propagate = false;
            propagate = me.unassignWithoutPropagation(oldResource, function unassignCancelFeedback(fn) {
                unassignCancelFn = fn;
            });
            propagate = propagate && me.assignWithoutPropagation(newResource, units, function assignCancelFeedback(fn) {
                assignCancelFn = fn;
            });
            return propagate;
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            if (cancelChanges) {
                assignCancelFn && assignCancelFn();
                unassignCancelFn && unassignCancelFn();
            }
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    // TODO: interceptor is needed only for Gnt.view.Dependency, ask Nick if it can be removed
    /**
     * Links a task to another one given in `toId` with typed dependency given in `type`.
     *
     * @param {Gnt.model.Task|Number} toId
     * @param {Integer} [type=Gnt.model.Dependency.Type.EndToStart] dependency type see {@link Gnt.model.Dependency#Type}.
     * @param {Function} [callback] Callback function to call after tasks has been linked and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    linkTo: function(toId, type, callback, /* private */
    interceptor) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.linkToWithoutPropagation(toId, type, function cancelFeedback(fn) {
                cancelFn = fn;
            }, interceptor);
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    linkToWithoutPropagation: function(toId, type, cancelFeedback, /* deprecated */
    interceptor) {
        var me = this,
            fromId = me.getId(),
            taskStore = me.getTaskStore(),
            dependencyStore = me.getDependencyStore(),
            newDependency;
        // {{{ Parameters normalization
        toId = toId instanceof Gnt.model.Task ? toId.getId() : toId;
        type = ((type === null || type === undefined) && Gnt.model.Dependency.Type.EndToStart) || type;
        // }}}
        // Preconditions:
        taskStore.getModelById(toId instanceof Gnt.model.Task ? toId.getId() : toId) != -1 || Ext.Error.raise("Can't link task `" + fromId + "` to task with id `" + toId + "` the task is not present in the task store!");
        newDependency = new dependencyStore.model();
        newDependency.setSourceId(fromId);
        newDependency.setTargetId(toId);
        newDependency.setType(type);
        if (dependencyStore.isValidDependency(newDependency) && (!interceptor || interceptor(newDependency) !== false)) {
            dependencyStore.add(newDependency);
        }
        cancelFeedback && cancelFeedback(function() {
            dependencyStore.remove(newDependency);
        });
        return me;
    },
    /**
     * Unlinks a task from another one given in `fromId`.
     *
     * @param {Gnt.model.Task|Number} fromId
     * @param {Function} [callback] Callback function to call after tasks has been unlinked and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unlinkFrom: function(fromId, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.unlinkFromWithoutPropagation(fromId, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    unlinkFromWithoutPropagation: function(fromId, cancelFeedback) {
        var me = this,
            toId = me.getId(),
            dependencyStore = me.getDependencyStore(),
            dependency, indexOfDependency;
        // {{{ Parameters normalization
        fromId = fromId instanceof Gnt.model.Task ? fromId.getId() : fromId;
        // }}}
        dependency = dependencyStore.getByTaskIds(fromId, toId);
        // Preconditions:
        dependency || Ext.Error.raise("Can't unlink task '" + toId + "' from task '" + fromId + ", tasks are not linked!");
        indexOfDependency = dependencyStore.indexOf(dependency);
        dependencyStore.remove(dependency);
        cancelFeedback && cancelFeedback(function() {
            dependencyStore.insert(indexOfDependency, dependency);
        });
        return me;
    },
    // side-effects free method - suitable for use in "normalization" stage
    // calculates the effort based on the assignments information
    calculateEffort: function(startDate, endDate, unit) {
        // effort calculation requires both dates
        if (!startDate || !endDate)  {
            return 0;
        }
        
        var totalEffort = 0;
        this.forEachAvailabilityIntervalWithResources({
            startDate: startDate,
            endDate: endDate
        }, function(intervalStartDate, intervalEndDate, currentAssignments) {
            var totalUnits = 0;
            for (var i in currentAssignments) totalUnits += currentAssignments[i].units;
            totalEffort += (intervalEndDate - intervalStartDate) * totalUnits / 100;
        });
        return this.getUnitConverter().convertMSDurationToUnit(totalEffort, unit || this.getEffortUnit());
    },
    updateAssignments: function() {
        var startDate = this.getStartDate();
        var endDate = this.getEndDate();
        // do nothing if task is not scheduled
        if (!startDate || !endDate)  {
            return;
        }
        
        var totalTime = 0;
        this.forEachAvailabilityIntervalWithResources({
            startDate: startDate,
            endDate: endDate
        }, function(intervalStartDate, intervalEndDate, currentAssignments) {
            for (var resourceId in currentAssignments) {
                totalTime += intervalEndDate - intervalStartDate;
            }
        });
        // no available resources?
        if (!totalTime) {
            return;
        }
        var effortInMS = this.getEffort(Sch.util.Date.MILLI);
        Ext.Array.each(this.getAssignments(), function(assignment) {
            assignment.setUnits(effortInMS / totalTime * 100);
        });
    },
    updateEffortBasedOnDuration: function() {
        this.setEffortWithoutPropagation(this.calculateEffort(this.getStartDate(), this.getEndDate()));
    },
    // Alias for updateEffortBasedOnDuration(). Added to have symmetry with updateSpanBasedOnEffort.
    updateEffortBasedOnSpan: function() {
        this.updateEffortBasedOnDuration();
    },
    updateSpanBasedOnEffort: function() {
        // we have to update startDate because duration change can turn the task into a milestone
        // and for milestones we should set startDate to the end of last working period
        this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate());
    },
    onPotentialEffortChange: function() {
        var me = this,
            taskStore = me.getTaskStore(true);
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (me.getSchedulingMode()) {
                case 'FixedDuration':
                    me.updateEffortBasedOnDuration();
                    break;
                case 'DynamicAssignment':
                    me.updateAssignments();
                    break;
            }
        }
    },
    onAssignmentMutation: function() {
        var me = this,
            taskStore = me.getTaskStore(true);
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (this.getSchedulingMode()) {
                case 'FixedDuration':
                    this.updateEffortBasedOnDuration();
                    break;
                case 'EffortDriven':
                    this.updateSpanBasedOnEffort();
                    break;
                case 'DynamicAssignment':
                    this.updateAssignments();
                    break;
            }
        }
    },
    onAssignmentStructureMutation: function() {
        var me = this,
            taskStore = me.getTaskStore(true);
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (this.getSchedulingMode()) {
                case 'FixedDuration':
                    this.updateEffortBasedOnDuration();
                    break;
                case 'EffortDriven':
                    this.updateSpanBasedOnEffort();
                    break;
                case 'DynamicAssignment':
                    this.updateAssignments();
                    break;
            }
        }
    },
    /**
     * Adjusts the task start/end properly according to the calendar dates.
     * @param {Function} [callback] Callback function to call after the task has been adjusted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    adjustToCalendar: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.adjustToCalendarWithoutPropagation();
        }, callback);
    },
    adjustToCalendarWithoutPropagation: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            propagate = false;
        if (taskStore) {
            if (me.get('leaf')) {
                me.setStartDateWithoutPropagation(me.getStartDate(), true, taskStore.skipWeekendsDuringDragDrop);
                me.alignByIncomingDependenciesWithoutPropagation(taskStore, null);
                propagate = me;
            } else if (me.getStartDate() && me.getEndDate()) {
                me.set(me.durationField, me.calculateDuration(me.getStartDate(), me.getEndDate(), me.getDurationUnit()));
                propagate = me;
            }
        }
        return propagate;
    },
    /**
     Returns if the task is readonly. When readonly is `true` the task {@link #isEditable} returns `false` for all its fields.
     @return {Boolean} Boolean value, indicating whether the model is readonly
     */
    isReadOnly: function() {
        var result = false;
        this.bubble(function(task) {
            if (task.getReadOnly()) {
                result = true;
                return false;
            }
        }, this);
        return result;
    },
    /*
     * @method setReadOnly
     * Sets if the given task is readonly. You can subclass this class and override this method to provide your own logic.
     *
     * When the task is readonly {@link #isEditable} returns `false` for all fields except the readonly field.
     * A task in readonly state will not allow dependency creation.
     *
     * @param {String} value indicating if the task is readonly
     */
    /**
     * Checks if the given task field is editable. You can subclass this class and override this method to provide your own logic.
     *
     * It takes the scheduling mode of the task into account. For example for "FixedDuration" mode, the "Effort"
     * field is calculated and should not be updated by user directly.
     *
     * @param {String} fieldName Name of the field
     * @return {Boolean} Boolean value, indicating whether the given field is editable
     */
    isEditable: function(fieldName) {
        // if some parent is readonly
        if (!this.getReadOnly() && this.isReadOnly()) {
            return false;
        }
        if (fieldName === this.readOnlyField)  {
            return true;
        }
        
        // check if the task is readonly
        if (this.getReadOnly())  {
            return false;
        }
        
        if (!this.isLeaf()) {
            if (fieldName === this.effortField && this.autoCalculateEffortForParentTask)  {
                return false;
            }
            
            if (fieldName === this.percentDoneField && this.autoCalculatePercentDoneForParentTask)  {
                return false;
            }
            
        }
        if ((fieldName === this.durationField || fieldName === this.endDateField) && this.getSchedulingMode() === 'EffortDriven') {
            return false;
        }
        if (fieldName === this.effortField && this.getSchedulingMode() === 'FixedDuration') {
            return false;
        }
        return true;
    },
    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable: function() {
        return this.getDraggable();
    },
    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */
    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable: function() {
        return this.getResizable();
    },
    /**
     * @method getWBSCode
     *
     * Returns WBS code of task.
     * @return {String} The WBS code string
     */
    getWBSCode: function() {
        var indexes = [],
            task = this;
        while (task.parentNode) {
            indexes.push(task.data.index + 1);
            task = task.parentNode;
        }
        return indexes.reverse().join('.');
    },
    resetTotalCount: function(preventCaching) {
        var task = this;
        while (task) {
            task.totalCount = preventCaching ? -1 : null;
            task = task.parentNode;
        }
    },
    /**
     * Returns total count of child nodes and their children.
     *
     * @return {Number} Total count of child nodes
     */
    getTotalCount: function() {
        var totalCount = this.totalCount;
        var cachingPrevented = totalCount == -1;
        // `cachingPrevented` (totalCount == -1) will cause the value to be always recalculated
        if (totalCount == null || cachingPrevented) {
            var childNodes = this.childNodes;
            totalCount = childNodes.length;
            for (var i = 0,
                l = childNodes.length; i < l; i++) {
                totalCount += childNodes[i].getTotalCount();
            }
            if (cachingPrevented)  {
                return totalCount;
            }
            else  {
                this.totalCount = totalCount;
            }
            
        }
        return totalCount;
    },
    /**
     * @method getPreviousSiblingsTotalCount
     * Returns count of all sibling nodes (including their children).
     *
     * @return {Number}
     */
    getPreviousSiblingsTotalCount: function() {
        var task = this.previousSibling,
            count = this.data.index;
        while (task) {
            count += task.getTotalCount();
            task = task.previousSibling;
        }
        return count;
    },
    /**
     * Returns count of all predecessors nodes (including their children).
     * @return {Number}
     * @deprecated Was renamed to {@link #getPreviousSiblingsTotalCount} since `predecessor` term has another meaning in the gantt context.
     */
    getPredecessorsCount: function() {
        return this.getPreviousSiblingsTotalCount.apply(this, arguments);
    },
    /**
     * @method getSequenceNumber
     *
     * Returns the sequential number of the task. A sequential number means the ordinal position of the task in the total dataset, regardless
     * of its nesting level and collapse/expand state of any parent tasks. The root node has a sequential number equal to 0.
     *
     * For example, in the following tree data sample sequential numbers are specified in the comments:

        root : {
            children : [
                {   // 1
                    leaf : true
                },
                {       // 2
                    children : [
                        {   // 3
                            children : [
                                {   // 4
                                    leaf : true
                                },
                                {   // 5
                                    leaf : true
                                }
                            ]
                        }]
                },
                {   // 6
                    leaf : true
                }
            ]
        }

     * If we will collapse some of the parent tasks, sequential number of collapsed tasks won't change.
     *
     * See also {@link Gnt.data.TaskStore#getBySequenceNumber}.
     *
     * @return {Number} The code
     */
    getSequenceNumber: function() {
        var code = 0,
            task = this;
        while (task.parentNode) {
            code += task.getPredecessorsCount() + 1;
            task = task.parentNode;
        }
        return code;
    },
    // generally should be called on root node only
    getBySequenceNumber: function(number) {
        var resultNode = null,
            childNode, totalCount;
        if (number === 0) {
            resultNode = this;
        } else if (number > 0 && number <= this.getTotalCount()) {
            number--;
            for (var i = 0,
                l = this.childNodes.length; i < l; i++) {
                childNode = this.childNodes[i];
                totalCount = childNode.getTotalCount();
                if (number > totalCount)  {
                    number -= totalCount + 1;
                }
                else {
                    childNode = this.childNodes[i];
                    resultNode = childNode.getBySequenceNumber(number);
                    break;
                }
            }
        }
        return resultNode;
    },
    /**
     * @method getDisplayStartDate
     *
     * Returns the formatted start date value to be used in the UI.
     * @param {String} format Date format.
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getStartDate()] Start date value. If not specified, the Task start date will be used.
     * @return {String} Formatted start date value.
     */
    getDisplayStartDate: function(format, adjustMilestones, value, returnDate, isBaseline) {
        format = format || Ext.Date.defaultFormat;
        // if no value specified then we'll take task start date
        if (arguments.length < 3) {
            value = this.getStartDate();
            // by default we consider adjustMilestones enabled
            if (arguments.length < 2)  {
                adjustMilestones = true;
            }
            
        }
        if (value && adjustMilestones && this.isMilestone(isBaseline) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }
        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    },
    /**
     * @method getDisplayEndDate
     *
     * Returns the formatted end date value to be used in the UI.
     * **Note** that the end date of tasks in the Gantt chart is not inclusive, however this method will compensate the value.
     * For example, if you have a 1 day task which starts at **2011-07-20T00:00:00** and ends at **2011-07-21T00:00:00** (remember the end date is not inclusive),
     * this method will return **2011-07-20** if called with 'Y-m-d'.

            var task = new Gnt.model.Task({
                StartDate : new Date(2011, 6, 20),
                EndDate   : new Date(2011, 6, 21)
            });

            // below code will display "2011/07/20"
            alert(task.getDisplayEndDate("Y/m/d"));

     * @param {String} format Date format (required).
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getEndDate()] End date value. If not specified, the Task end date will be used.
     * @return {String} The formatted end date value.
     */
    getDisplayEndDate: function(format, adjustMilestones, value, returnDate, isBaseline) {
        format = format || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            value = this.getEndDate();
            if (arguments.length < 2)  {
                adjustMilestones = true;
            }
            
        }
        if (value && (!this.isMilestone(isBaseline) || adjustMilestones) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }
        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    },
    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */
    copy: function() {
        var result = this.callParent(arguments),
            segments = result.getSegments();
        // for a segmented task we also make a copy of each segment
        if (segments) {
            for (var i = 0; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = segment.copy(segment.getId(), false);
            }
        }
        return result;
    },
    // Does a regular copy but also copies references to the model taskStore etc
    // Intended to be used when copying a task that will be added to the same taskStore
    fullCopy: function(model) {
        var cp = this.callParent(arguments);
        cp.taskStore = this.getTaskStore();
        return cp;
    },
    commit: function() {
        this.callParent(arguments);
        this.commitSegments();
    },
    reject: function() {
        this.callParent(arguments);
        this.rejectSegments();
    },
    isUnscheduled: function() {
        return !this.getStartDate() || !this.getEndDate();
    },
    isTaskStored: function() {
        // We can't rely on this.taskStore here only, it's value is managed in setRoot/onTaskRemoved method of the task store
        // and there's a time when task is removed already but onTaskRemoved() handle hasn't completed yet
        return !!this.getTreeStore();
    }
}, /*
        var root = this;
        while (!root.isRoot()) {
            root = root.parentNode;
        }
        return this.taskStore && this.taskStore.getRoot() === root;
        */
function() {
    // Do this first to be able to override NodeInterface methods
    Ext.data.NodeInterface.decorate(this);
    this.override({
        // @OVERRIDE
        insertBefore: function(node, refNode) {
            node = this.createNode(node);
            if (!node)  {
                return;
            }
            
            var store = this.getTaskStore(true),
                root = store && store.getRoot(),
                phantomParentIdField = this.phantomParentIdField,
                phantom = this !== root && this.phantom,
                isMove = !!node.parentNode,
                internalId = this.getId();
            if (phantom) {
                this.data[this.phantomIdField] = internalId;
            }
            if (internalId !== node.data[phantomParentIdField]) {
                var newPhantomParentIdValue = phantom ? internalId : null;
                if (!node.phantom && node.data[phantomParentIdField] !== newPhantomParentIdValue) {
                    node.modified = node.modified || {};
                    node.modified[phantomParentIdField] = node.data[phantomParentIdField];
                }
                node.data[phantomParentIdField] = newPhantomParentIdValue;
            }
            var refNodeIndex = refNode && refNode.get('index');
            this.resetTotalCount(isMove);
            // Scan for and remove invalid dependencies since a parent task may not have dependencies to its children etc.
            // Has to be done before callParent where the node move happens
            if (isMove && node.hasDependencies() && !store.isUndoingOrRedoing()) {
                node.removeDependenciesToParents(this);
            }
            var res = this.callParent(arguments);
            // Scan for and remove invalid dependencies since a parent task may not have dependencies to its children etc.
            if (isMove) {
                // if the task has dependencies
                if (this.hasDependencies()) {
                    // we just potentially changed dependencies setup so need to reset the dependency store cache
                    store.getDependencyStore().resetMethodsCache();
                    // Scan for and remove invalid dependencies.
                    if (!store.isUndoingOrRedoing()) {
                        this.removeInvalidDependencies();
                    }
                }
                this.resetTotalCount();
            }
            // fix for ExtJS 5.1.0 bug:
            // https://www.sencha.com/forum/showthread.php?300695-getChanges-doesn-t-include-quot-index-quot-after-insertBefore-call&p=1098694#post1098694
            if (refNode && refNode.get('index') != refNodeIndex) {
                refNode.modified = refNode.modified || {};
                refNode.modified.index = refNodeIndex;
            }
            return res;
        },
        // @OVERRIDE
        appendChild: function(nodes, suppressEvents, commit) {
            nodes = nodes instanceof Array ? nodes : [
                nodes
            ];
            var store = this.getTaskStore(true),
                root = store && store.getRoot(),
                isMove = false,
                phantomParentIdField = this.phantomParentIdField,
                phantom = this !== root && this.phantom,
                internalId = this.getId(),
                nodesCreated = 0;
            if (store && nodes.length > 1) {
                store.suspendAutoRecalculateParents++;
            }
            for (var i = 0; i < nodes.length; i++) {
                var node = this.createNode(nodes[i]);
                if (!node)  {
                    
                    continue;
                }
                
                nodesCreated++;
                nodes[i] = node;
                // appending child that is already in the same tree, will first remove it from previous parent.
                // Removing is hidden inside of the `appendChild` implementation and causes various side effects
                // which re-fills the `totalCount` cache with wrong value. Need to suspend caching during parent
                // "appendChild" implementation
                if (node.parentNode) {
                    isMove = true;
                    // Has to be done before callParent where the node move happens
                    if (node.hasDependencies() && store && !store.isUndoingOrRedoing()) {
                        node.removeDependenciesToParents(this);
                    }
                }
                if (internalId !== node.data[phantomParentIdField]) {
                    var newPhantomParentIdValue = phantom ? internalId : null;
                    if (!node.phantom && node.data[phantomParentIdField] !== newPhantomParentIdValue) {
                        node.modified = node.modified || {};
                        node.modified[phantomParentIdField] = node.data[phantomParentIdField];
                    }
                    node.data[phantomParentIdField] = newPhantomParentIdValue;
                }
            }
            if (!nodesCreated)  {
                return;
            }
            
            if (phantom) {
                this.data[this.phantomIdField] = internalId;
            }
            this.resetTotalCount(isMove);
            // convert a single element array back to just element, to avoid extra function call
            var res = this.callParent([
                    nodes.length > 1 ? nodes : nodes[0],
                    suppressEvents,
                    commit
                ]);
            if (isMove) {
                // if the task has dependencies
                if (this.hasDependencies()) {
                    // we just potentially changed dependencies setup so need to reset the dependency store cache
                    store.getDependencyStore().resetMethodsCache();
                    // Scan for and remove invalid dependencies.
                    if (store && !store.isUndoingOrRedoing()) {
                        this.removeInvalidDependencies();
                    }
                }
                this.resetTotalCount();
            }
            if (store && !store.isUndoingOrRedoing()) {
                this.beginEdit();
                // Bugfix ticket #1401
                this.markAsParent();
                // since the task became a parent we switch its scheduling mode to 'Normal' (ticket #1441)
                this.set(this.schedulingModeField, 'Normal');
                if (store && nodes.length > 1) {
                    store.suspendAutoRecalculateParents--;
                }
                this.endEdit();
            }
            if (store && store.recalculateParents && !store.suspendAutoRecalculateParents && !this.isRoot() && !store.cascading && !store.isUndoingOrRedoing()) {
                nodes[0].recalculateParents();
            }
            return res;
        },
        // @OVERRIDE
        removeChild: function(node, destroy, suppressEvents, isMove) {
            var me = this,
                needToConvertToLeaf = !me.removeChildIsCalledFromReplaceChild && me.convertEmptyParentToLeaf && me.childNodes.length == 1,
                taskStore = me.getTaskStore(true),
                result;
            me.resetTotalCount();
            // need to reset the flag early, because the removal operation may cause some side effects (event listeners)
            // flag should be already reset in those listeners
            me.removeChildIsCalledFromReplaceChild = false;
            // Calling parent
            result = me.callParent(arguments);
            // In case of node move we need to reset the total count cache one more time here.
            // This is for the case, when we append/insert some existing node to a different position
            // in its parent node. In this case, the total count cache will be originally reset in our
            // overrides for `insertBefore` or `appendChild`. This is supposed to be enough, but its not,
            // because before doing actuall append, not first will be removed from the parent ("removeChild" call
            // is part of the `appendChild/insertBefore` methods. The listeners of `remove` event may call
            // `getTotalCount` and fill the cache. Then, we continue to actual node insertion, but cache is already filled
            // with wrong data.
            if (isMove) {
                me.resetTotalCount();
            }
            // If this parent has children left, recalculate it's start/end dates if required
            if (me.childNodes.length > 0 && taskStore && taskStore.recalculateParents && !taskStore.suspendAutoRecalculateParents && !taskStore.isUndoingOrRedoing()) {
                // If the parent has some children left then recalculate it's start/end dates if required
                //me.refreshCalculatedParentNodeData();
                me.childNodes[0].recalculateParents();
            }
            // If the parent has no other children, change it to a leaf task
            if (needToConvertToLeaf && !me.isRoot() && taskStore && !taskStore.isUndoingOrRedoing()) {
                me.convertEmptyParentToLeafTask();
            }
            return result;
        },
        replaceChild: function() {
            // flag will be reset in the `removeChild` override
            this.removeChildIsCalledFromReplaceChild = true;
            this.callParent(arguments);
        },
        removeAll: function() {
            var isLeaf = this.isLeaf(),
                taskStore = this.getTaskStore(true);
            this.resetTotalCount();
            this.callParent(arguments);
            // if we don't know the task taskStore we cannot set its duration to 1 day (which happens in convertEmptyParentToLeafTask())
            if (!isLeaf && this.convertEmptyParentToLeaf && taskStore) {
                this.convertEmptyParentToLeafTask();
            }
        },
        // @OVERRIDE
        createNode: function(node) {
            var me = this,
                store = me.getTaskStore(true),
                root = store && store.getRoot(),
                reader;
            if (store) {
                reader = store.getProxy().getReader();
                var originalGetChildType = reader.getChildType;
                // TODO: check this in ext5.1.2+
                // parent "createNode" doesnot fallback to the reader model
                // and raises exception because of that (in ext5.1.0/ext5.1.1)
                reader.getChildType = function() {
                    return originalGetChildType.apply(this, arguments) || this.getModel();
                };
            }
            node = this.callParent(arguments);
            // restore original reader.getChildType
            if (store && reader)  {
                delete reader.getChildType;
            }
            
            // project nodes under the root allowed only
            if (store && root !== this && node.isProject) {
                return;
            }
            var needsNormalization = store && store.autoNormalizeNodes && !node.normalized && !node.normalizeScheduled;
            node = this.callParent(arguments);
            if (needsNormalization) {
                var prevUpdateInfo = node.updateInfo;
                node.updateInfo = function() {
                    prevUpdateInfo.apply(this, arguments);
                    delete node.updateInfo;
                    // normalization needs to fully set up node, this happens after 1) createNode 2) updateNodeInfo
                    node.normalize();
                };
                //createNode is called multiple times before the node is normalized.
                //For preventing a chain of calls to updateInfo and normalize is created we set a property to schedule normalization only once
                node.normalizeScheduled = true;
            }
            return node;
        }
    });
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.model.Project
@extends Gnt.model.Task

This class represents a single Project in your Gantt chart.

The inheritance hierarchy of this class includes {@link Gnt.model.Task}, {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
This class will also receive a set of methods and additional fields that stem from the {@link Ext.data.NodeInterface}.
Please refer to the documentation of those classes to become familiar with the base interface of this class.

By default, a Project has the following fields as seen below.

# Project Fields

- `Description` - the description of the project, this field maps to the task `Note` field
- `AllowDependencies` - this field indicates if the project tasks allowed to have dependencies with tasks external to the project

*/
Ext.define('Gnt.model.Project', {
    extend: 'Gnt.model.Task',
    alias: 'gntmodel.project',
    /**
     * @property {Boolean} isProject Indicates that this is a project.
     * Can be used in heterogeneous stores to distinguish project records from task ones.
     */
    isProject: true,
    /**
     * @cfg {String} descriptionField The description of the project.
     */
    descriptionField: 'Note',
    /**
     * @cfg {Boolean} allowDependenciesField The name of the field specifying if the task allows dependencies.
     */
    allowDependenciesField: 'AllowDependencies',
    customizableFields: [
        {
            name: 'Description',
            type: 'string'
        },
        {
            name: 'AllowDependencies',
            persist: false,
            type: 'bool',
            defaultValue: false
        }
    ],
    recognizedSchedulingModes: [
        'Normal'
    ],
    convertEmptyParentToLeaf: false,
    isEditable: function(fieldName) {
        // some fields doesn't make sense to edit for a project
        switch (fieldName) {
            case this.nameField:
            case this.startDateField:
            case this.endDateField:
            case this.readOnlyField:
            case this.durationField:
            case this.durationUnitField:
            case this.descriptionField:
            case this.allowDependenciesField:
                return this.callParent(arguments);
            default:
                return false;
        }
    }
});
/*
     * @method setReadOnly
     * Sets if the given project is read only. All underlying tasks will be considered as read only as well.
     *
     * @param {String} value `True` to mark the project as read only.
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?301768-Tree-view-is-rendered-before-load-event-is-thrown
// In Ext 5.1.1 tree view is refreshed before its store throw 'load' event.
// Only reliable way to process loaded data before that refresh is to listen 'refresh' event after store.load method in called
// This patch requires to be a mixin, to be required correctly in the task store
Ext.define('Gnt.patches.TaskStore', {
    extend: 'Ext.Mixin',
    onClassMixedIn: function(targetClass) {
        Ext.override(targetClass, {
            // This is new handler for 'load' event that will check if caching procedures were performed before
            // and also it will remove extra listener
            onTasksLoad: function() {
                if (!this._refreshCalled) {
                    this.onTasksLoaded();
                }
                this.un('refresh', this.onTaskStoreRefresh, this);
            },
            onTasksBeforeLoad: function() {
                // if this is a reload operation, view will be refreshed before 'load' event is fired
                // we need to recalculate cache on 'refresh' event then
                this._refreshCalled = false;
                // There's a sencha listener to refresh view, with priority of 1000, we need to prepare data before that
                // so we make priority a little bit more. Covered by 200_view
                this.on('refresh', this.onTaskStoreRefresh, this, {
                    priority: 1001
                });
            },
            // Fill cache, rise a flag about this
            onTaskStoreRefresh: function() {
                // Refresh can be called twice (6.0.2), we need to restore listeners only once
                // https://www.sencha.com/forum/showthread.php?310964-TreeStore-fires-refresh-twice-during-load
                if (!this._refreshCalled) {
                    this._refreshCalled = true;
                    this.onTasksLoaded();
                }
            },
            setupListeners: function() {
                this.callParent(arguments);
                this.on('beforeload', this.onTasksBeforeLoad, this, {
                    priority: 100
                });
                // these events need advanced listener that will check if cache has to be recalculated
                this.un({
                    load: this.onTasksLoaded,
                    rootchanged: this.onTasksLoaded,
                    scope: this
                });
                this.on({
                    load: this.onTasksLoad,
                    rootchanged: this.onTasksLoad,
                    scope: this
                });
            }
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*

 Overrides to detect and save task segments state before any editing takes place
 The flow is as follows:

 1. taskStore.onSegmentEditBegin() is called
 2. We serialize and save current segments on the Task
 3. Any following change to segments from here on
 4. At some point later 'processSavingOldValue' is called as a result of the 'update' event fired
 5. The Undo action now has a reliable before-edit copy of all segment data for the Task
 6a. If no undo manager active: State cache cleared in onSegmentEditEnd
 6b. If undo manager active : State cache cleared in onUndoRedoTransactionEnd
 */
Ext.define('Gnt.data.undoredo.mixin.TaskStoreHint', {
    extend: 'Robo.data.Store',
    segmentsStateByTaskId: null,
    onSegmentEditBegin: function(task, segment) {
        var me = this;
        this.segmentsStateByTaskId = this.segmentsStateByTaskId || {};
        // Before any editing takes place of a segment, store the original
        if (!this.segmentsStateByTaskId.hasOwnProperty(task.internalId)) {
            this.segmentsStateByTaskId[task.internalId] = task.buildSegmentsSnapshot();
        }
    },
    onSegmentEditEnd: function(task, segment) {
        var me = this;
        if (!me.isInUndoRedoTransaction()) {
            delete this.segmentsStateByTaskId[task.internalId];
        }
    },
    onUndoRedoTransactionEnd: function(manager, transaction) {
        var me = this;
        // After a transaction is completed, clear the cached data
        this.segmentsStateByTaskId = null;
        me.callParent([
            manager,
            transaction
        ]);
    },
    getOriginalSegmentsState: function(task) {
        // We get previous segments value either from "segmentsStateByTaskId" hash
        var segmentsSnapshot = this.segmentsStateByTaskId && this.segmentsStateByTaskId[task.internalId];
        // ..or from standard "previous"/"previousValues" hashes (this might happen when generic model.set("Segments", ...) was used
        // instead of higher level methods like "split", "setSegments" etc
        if (!segmentsSnapshot) {
            var previousSegments = (task.previous || task.previousValues)[task.segmentsField];
            if (previousSegments) {
                segmentsSnapshot = task.buildSegmentsSnapshot(previousSegments);
            }
        }
        return segmentsSnapshot;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * The mixin adds transaction alike functionality into a store, works in pair with {@link Gnt.model.mixin.ProjectableModel}
 * if you mix-in this one into a store make sure you mixin in {@link Gnt.model.mixin.ProjectableModel} into store's
 * model class as well.
 *
 * NOTE: only model updates are included into a transaction, record adding/removing are not taken into account,
 * that's why it's called "projection".
 */
Ext.define('Gnt.data.mixin.ProjectableStore', function() {
    function getByInternalId(store, id) {
        return store.byInternalIdMap && store.byInternalIdMap[id] || store.getByInternalId(id);
    }
    /**
     * @private
     * @method getProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjection() {
        var me = this,
            projectionStack = me.projectionStack;
        return projectionStack && projectionStack[projectionStack.length - 1];
    }
    /**
     * @private
     * @method getProjectionLevel
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjectionLevel() {
        var me = this,
            projectionStack = me.projectionStack;
        return projectionStack && projectionStack.length || 0;
    }
    /**
     * Checks if a store is currently projecting
     *
     * @return {Boolean}
     * @method isProjecting
     * @member Gnt.data.mixin.ProjectableStore
     */
    function isProjecting() {
        return this.getProjectionLevel() > 0;
    }
    /**
     * Checks whether any of given records are projected currently, i.e. any of given records has changes in current
     * projection.
     *
     * @param {Ext.data.Model/[Ext.data.Model]} records
     * @return boolean
     */
    function areProjected(records) {
        var i, len, are;
        records = [].concat(records);
        for (are = false , i = 0 , len = records.length; !are && i < len; i++) {
            are = records[i].isProjected();
        }
        return are;
    }
    /**
      * Starts store's projection, any updates to any records during projection period will be put into a projection
      * storage and might be committed into record's data by calling {@link Gnt.data.mixin.ProjectableStore#commitProjection} or
      * canceled by calling {@link Gnt.data.mixin.ProjectableStore#rejectProjection}. The primary condition for this
      * to work is that store's records must use {#link Gnt.model.mixin.ProjectableModel} mixin. Projections
      * might be nested.
      *
      * @method startProjection
      * @member Gnt.data.mixin.ProjectableStore
      */
    function startProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            newProjection, prevProjection;
        if (!projectionStack) {
            me.projectionStack = [
                {}
            ];
        } else {
            prevProjection = projectionStack[projectionStack.length - 1];
            newProjection = {};
            Ext.Object.each(prevProjection, function(id, data) {
                var dataConstructor = function() {};
                dataConstructor.prototype = data;
                newProjection[id] = new dataConstructor();
            });
            projectionStack.push(newProjection);
        }
        me.fireEvent('projectionstart', me, me.getProjectionLevel());
    }
    /**
     * Commits all the changes recorded since last call to {@link #startProjection}..
     *
     * @method commitProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function commitProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            projectionData, committingData, prop, data, hasUpdates, internalId, record;
        // If projection level is 0 then committing recorded updates into corresponding store's records.
        if (projectionStack.length === 1) {
            committingData = projectionStack[0];
            me.projectionStack = null;
            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {
                    record = getByInternalId(me, internalId);
                    // Record might have been deleted from the store during projection time
                    if (record) {
                        data = committingData[internalId];
                        hasUpdates = false;
                        for (prop in data) {
                            if (data.hasOwnProperty(prop)) {
                                hasUpdates = true;
                                break;
                            }
                        }
                        hasUpdates && record.set(data);
                    }
                }
            }
        } else // If projection level is higher then copying current projection into lower level (previous) projection
        {
            committingData = projectionStack.pop();
            projectionData = projectionStack[projectionStack.length - 1];
            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {
                    if (!projectionData.hasOwnProperty(internalId)) {
                        projectionData[internalId] = committingData[internalId];
                    } else {
                        projectionData[internalId] = Ext.apply(projectionData[internalId], committingData[internalId]);
                    }
                }
            }
        }
        me.fireEvent('projectioncommit', me, projectionStack && projectionStack[projectionStack.length - 1], committingData, me.getProjectionLevel());
    }
    /**
     * Rejects all the changes to store's records recorded since projection last call to {@link #startProjection}.
     *
     * @method rejectProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function rejectProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            projectionData = projectionStack.pop();
        // If projection level was 1 (and now 0) then simply getting rid of projection stack
        if (projectionStack.length === 0) {
            me.projectionStack = null;
        }
        // If projection level is higher then we've got rid of changes recorded since last startProjection() call
        // by simply popping the last projection state from the projection stack.
        me.fireEvent('projectionreject', me, projectionStack && projectionStack[projectionStack.length - 1], projectionData, me.getProjectionLevel());
    }
    return {
        projectionStack: null,
        getProjection: getProjection,
        isProjecting: isProjecting,
        areProjected: areProjected,
        getProjectionLevel: getProjectionLevel,
        startProjection: startProjection,
        commitProjection: commitProjection,
        rejectProjection: rejectProjection
    };
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.data.TaskStore
 @extends Ext.data.TreeStore

 A class representing the tree of tasks in the gantt chart. An individual task is represented as an instance of the {@link Gnt.model.Task} class. The store
 expects the data loaded to be hierarchical. Each parent node should contain its children in a property called 'children' (please note that this is different from the old 1.x
 version where the task store expected a flat data structure)

 Parent tasks
 ------------

 By default, when the start or end date of a task gets changed, its parent task(s) will optionally also be updated. Parent tasks always start at it earliest child and ends
 at the end date of its latest child. So be prepared to see several updates and possibly several requests to server. You can batch them with the {@link Ext.data.proxy.Proxy#batchActions} configuration
 option.

 Overall, this behavior can be controlled with the {@link #recalculateParents} configuration option (defaults to true).

 Cascading
 ---------

 In the similar way, when the start/end date of the task gets changed, gantt *can* update any dependent tasks, so they will start on the earliest date possible.
 This behavior is called "cascading" and is enabled or disabled using the {@link #cascadeChanges} configuration option.

 Integration notes
 ---------

 For details on data integration - please see [this guide](../#!/guide/gantt_data_integration).

 */
Ext.define('Gnt.data.TaskStore', {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Sch.util.Date',
        'Sch.patches.TreeStore',
        'Sch.patches.TreeStoreInternalIdMap',
        'Gnt.data.Linearizator',
        'Gnt.model.Task',
        'Gnt.model.Project',
        'Gnt.data.Calendar',
        'Gnt.data.DependencyStore',
        'Gnt.data.ResourceStore',
        'Gnt.data.AssignmentStore'
    ],
    mixins: [
        'Gnt.patches.TaskStore',
        'Sch.data.mixin.FilterableTreeStore',
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.EventStore',
        'Gnt.data.undoredo.mixin.TaskStoreHint',
        'Gnt.data.mixin.ProjectableStore'
    ],
    model: 'Gnt.model.Task',
    alias: 'store.gantt_taskstore',
    storeId: 'tasks',
    /**
     * @cfg {String} typeProperty
     * The name of the property in a raw task data block which indicates the type of the task to be created from that raw data.
     * This is used for heterogeneous trees containing both task and project models (the value is set on the `typeProperty` of the DataReader).
     * For example, the data may look like this:
     *
     *      [{
     *          // TaskType provided so Gnt.model.Project instance will be created for the node
     *          TaskType    : 'Gnt.model.Project',
     *          Name        : 'Main Project',
     *          StartDate   : '2015-06-01',
     *          Duration    : 100,
     *          children    : [{
     *              // since TaskType is omitted the store model will be used for the node
     *              Name        : 'Task 1',
     *              StartDate   : '2015-06-01',
     *              Duration    : 10
     *              children    : [{
     *                  // since TaskType is omitted the store model will be used for the node
     *                  Name        : 'Sub-task 1'
     *                  StartDate   : '2015-06-01',
     *                  Duration    : 10,
     *                  leaf        : true
     *              }]
     *          }]
     *      }]
     *
     * The values should correspond to a valid {@link Gnt.model.Task Task} model class.
     */
    typeProperty: 'TaskType',
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager A calendar manager instance.
     * If specified then the task store will use its {@link Gnt.data.Calendar project calendar}.
     */
    calendarManager: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance to use for this task store. **Should be loaded prior the task store**.
     * This option can be also specified as the configuration option for the gantt panel. If not provided, a default calendar, containig the weekends
     * only (no holidays) will be created.
     *
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A `Gnt.data.DependencyStore` instance with dependencies information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A `Gnt.data.ResourceStore` instance with resources information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A `Gnt.data.AssignmentStore` instance with assignments information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    assignmentStore: null,
    /**
     * @cfg {Boolean} weekendsAreWorkdays This option will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar.
     *
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Boolean} cascadeChanges A boolean flag indicating whether a change in some task should be propagated to its depended tasks.
     * This option can be also specified as the configuration option for the gantt panel.
     */
    cascadeChanges: true,
    /**
     * @cfg {Boolean} batchSync true to batch sync request for 500ms allowing cascade operations, or any other task change with side effects to be batched into one sync call.
     */
    batchSync: true,
    /**
     * @cfg {Boolean} recalculateParents A boolean flag indicating whether a change in some task should update its parent task.
     * This option can be also specified as the configuration option for the gantt panel.
     */
    recalculateParents: true,
    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop A boolean flag indicating whether a task should be moved to the next earliest available time if it falls on non-working time,
     * during move/resize/create operations.
     * This option can be also specified as a configuration option for the Gantt panel.
     */
    skipWeekendsDuringDragDrop: true,
    /**
     * @cfg {Number} cascadeDelay If you usually have deeply nested dependencies, it might be a good idea to add a small delay
     * to allow the modified record to be refreshed in the UI right away and then handle the cascading
     */
    cascadeDelay: 0,
    /**
     * @cfg {Boolean} moveParentAsGroup Set to `true` to move parent task together with its children, as a group. Set to `false`
     * to move only parent task itself. Note, that to enable drag and drop for parent tasks, one need to use the
     * {@link Gnt.panel.Gantt#allowParentTaskMove} option.
     */
    moveParentAsGroup: true,
    /**
     * @cfg {Boolean} enableDependenciesForParentTasks Set to `true` to process the dependencies from/to parent tasks as any other dependency.
     * Set to `false` to ignore such dependencies and not cascade changes by them.
     *
     * Currently, support for dependencies from/to parent task is limited. Only the "start-to-end" and "start-to-start" dependencies
     * are supported. Also, if some task has incoming dependency from usual task and parent task, sometimes the dependency from
     * parent task can be ignored.
     *
     * Note, that when enabling this option requires the {@link Gnt.data.DependencyStore#strictDependencyValidation} to be set to `true` as well.
     * Otherwise it will be possible to create indirect cyclic dependencies, which will cause an infinite recursion exception.
     */
    enableDependenciesForParentTasks: true,
    /**
     * @cfg {Number} availabilitySearchLimit Maximum number of days to search for calendars common availability.
     * Used in various task calculations requiring to respect working time.
     * In these cases system tries to account working time as intersection of assigned resources calendars and task calendar.
     * This config determine a range intersectin will be searched in.
     * For example in case of task end date calculation system will try to find calendars intersection between task start date
     * and task start date plus `availabilitySearchLimit` days.
     */
    availabilitySearchLimit: 1825,
    //5*365
    /**
     * @cfg {String} [cycleResolutionStrategy='cut'] Strategy to use to resolve cycles in dependent node sets.
     * Possible values are:
     *
     *  - "none"
     *  - "exception"
     *  - "cut"
     *
     * Each value corresponds to a public function from {@link Gnt.data.linearizator.CycleResolvers}.
     */
    cycleResolutionStrategy: 'cut',
    /**
     * @cfg {Boolean} [autoNormalizeNodes=true] Flag defining whether to automaticaly normalize nodes by calculating
     *  derivative data fields.
     */
    autoNormalizeNodes: true,
    /**
     * @event filter
     * Will be fired on the call to `filter` method
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `filter` method
     */
    /**
     * @event clearfilter
     * Will be fired on the call to `clearFilter` method
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `clearFilter` method
     */
    /**
    * @event beforecascade
    * Fires before a cascade operation is initiated
    * @param {Gnt.data.TaskStore} store The task store
    */
    /**
    * @event cascade
    * Fires when after a cascade operation has completed
    * @param {Gnt.data.TaskStore} store The task store
    * @param {Object} context A context object revealing details of the cascade operation, such as 'nbrAffected' - how many tasks were affected.
    */
    cascading: false,
    isFillingRoot: false,
    isSettingRoot: false,
    earlyStartDates: null,
    earlyEndDates: null,
    lateStartDates: null,
    lateEndDates: null,
    lastTotalTimeSpan: null,
    suspendAutoRecalculateParents: 0,
    suspendAutoCascade: 0,
    currentCascadeBatch: null,
    batchCascadeLevel: 0,
    /**
     * @cfg {String} dependenciesCalendar A string, defining the calendar, that will be used when calculating the working time, skipped
     * by the dependencies {@link Gnt.model.Dependency#lagField lag}. Default value is `project` meaning main project calendar is used.
     * Other recognized values are: `source` - the calendar of dependency's source task is used, `target` - the calendar of target task.
     */
    dependenciesCalendar: 'project',
    pendingDataUpdates: null,
    // Counter for the number of store.load() calls. It's used to track nested calls.
    tasksLoadStarted: 0,
    /**
     * Will be fired on the call to `filter` method
     * @event filter
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `filter` method
     */
    /**
     * Will be fired on the call to `clearFilter` method
     * @event clearfilter
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `clearFilter` method
     */
    /**
     * @event beforecascade
     * Fires before a cascade operation is initiated
     * @param {Gnt.data.TaskStore} store The task store
     */
    /**
     * @event cascade
     * Fires when after a cascade operation has completed
     * @param {Gnt.data.TaskStore} store The task store
     * @param {Object} context A context object revealing details of the cascade operation, such as 'nbrAffected' - how many tasks were affected.
     */
    constructor: function(config) {
        config = config || {};
        // calendar manager on the config has the highest prio
        var calendarManager = 'calendarManager' in config ? config.calendarManager : this.calendarManager;
        delete config.calendarManager;
        this.setCalendarManager(calendarManager);
        var calendar = config.calendar || this.calendar;
        if (!calendar) {
            var calendarConfig = {};
            if (config.hasOwnProperty('weekendsAreWorkdays')) {
                calendarConfig.weekendsAreWorkdays = config.weekendsAreWorkdays;
            } else {
                if (this.self.prototype.hasOwnProperty('weekendsAreWorkdays') && this.self != Gnt.data.TaskStore) {
                    calendarConfig.weekendsAreWorkdays = this.weekendsAreWorkdays;
                }
            }
            // if we have calendarManager
            if (this.calendarManager) {
                calendar = this.calendarManager.getProjectCalendar();
            }
            calendar = calendar && Ext.data.StoreManager.lookup(calendar) || new Gnt.data.Calendar(calendarConfig);
        }
        // If not provided, create default stores (which will be overridden by GanttPanel during instantiation
        var dependencyStore = config.dependencyStore || this.dependencyStore;
        dependencyStore = dependencyStore && Ext.data.StoreManager.lookup(dependencyStore) || Ext.create("Gnt.data.DependencyStore");
        delete config.dependencyStore;
        var resourceStore = config.resourceStore || this.resourceStore;
        resourceStore = resourceStore && Ext.data.StoreManager.lookup(resourceStore) || Ext.create("Gnt.data.ResourceStore");
        delete config.resourceStore;
        var assignmentStore = config.assignmentStore || this.assignmentStore;
        assignmentStore = assignmentStore && Ext.data.StoreManager.lookup(assignmentStore) || Ext.create("Gnt.data.AssignmentStore", {
            resourceStore: resourceStore
        });
        delete config.assignmentStore;
        if (calendar) {
            // remove config to not overwrite this.calendar after setCalendar() call
            delete config.calendar;
            this.setCalendar(calendar, true, true);
        }
        // init cache for early/late dates
        this.resetEarlyDates(true);
        this.resetLateDates(true);
        this.pendingDataUpdates = {
            recalculateParents: {}
        };
        // Nodes should not be loaded before related stores are set, thus we postpone root loading
        // to the time when class is constructed and related stores are set
        // {{{ Initial root loading and superclass construction
        var configuredRoot = config.root || this.root;
        this.root = null;
        delete config.root;
        this.callParent([
            config
        ]);
        this.setResourceStore(resourceStore);
        this.setAssignmentStore(assignmentStore);
        this.setDependencyStore(dependencyStore);
        configuredRoot && this.setRoot(configuredRoot);
        // }}}
        this.setupListeners();
        var root = this.getRoot();
        if (root && this.autoNormalizeNodes) {
            root.normalizeParent();
        }
        if (this.autoSync && this.batchSync) {
            // Prevent operations with side effects to create lots of individual server requests
            this.sync = Ext.Function.createBuffered(this.sync, 500);
        }
        this.initTreeFiltering();
    },
    setCalendarManager: function(calendarManager) {
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy();
        }
        calendarManager = calendarManager && Ext.data.StoreManager.lookup(calendarManager);
        this.calendarManager = calendarManager;
        if (calendarManager) {
            this.projectCalendarSet = Boolean(calendarManager.getProjectCalendar());
            // wait till calendar manager set a project calendar and then use it
            this.calendarManagerListeners = calendarManager.on({
                projectcalendarset: function(manager, calendar) {
                    // we don't recalculate tasks after the first project calendar set
                    // further calendarManager.setProjectCalendar() calls will cause tasks adjustment
                    if (!this.settingCalendar) {
                        this.setCalendar(calendar, !this.projectCalendarSet);
                        this.projectCalendarSet = true;
                    }
                },
                scope: this,
                destroyable: true
            });
        }
        return calendarManager;
    },
    onProjectionCommit: function(me, lastChanges, committedChanges) {
        // loop over committed tasks and commit segments changes as well
        for (var internalId in committedChanges) {
            if (committedChanges.hasOwnProperty(internalId)) {
                var task = this.getModelByInternalId(internalId);
                task && task.commitSegmentsProjection();
            }
        }
    },
    onProjectionReject: function(me, lastChanges, rejectedChanges) {
        // loop over committed tasks and revert segments changes as well
        for (var internalId in rejectedChanges) {
            if (rejectedChanges.hasOwnProperty(internalId)) {
                var task = this.getModelByInternalId(internalId);
                task && task.rejectSegmentsProjection();
            }
        }
    },
    setupListeners: function() {
        this.on({
            nodeappend: this.onMyNodeAdded,
            nodeinsert: this.onMyNodeAdded,
            update: this.onTaskUpdated,
            // track projection commit/reject
            projectioncommit: this.onProjectionCommit,
            projectionreject: this.onProjectionReject,
            scope: this
        });
        this.on({
            noderemove: this.onTaskRemoved,
            nodemove: this.onTaskMoved,
            write: this.onTaskStoreWrite,
            sort: this.onTasksSorted,
            load: this.onTasksLoaded,
            rootchange: this.onTasksRootChange,
            scope: this,
            // This should guarantee that our listeners are run first since view should
            // only refresh after we've updated cached dependencies for each task (on store load, root change etc)
            priority: 100
        });
    },
    // Overridden from EventStore mixin to turn off EventStore mixin's logic related to resource->events caching
    // which comes into play in absence of assignment store
    createResourceEventsCache: Ext.emptyFn,
    // Overridden from EventStore mixin to provide id consistency manager with task store insteadof event store
    createIdConsistencyManager: function() {
        var me = this;
        return new Sch.data.util.IdConsistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    // Overridden from EventStore mixin to provide id consistency manager with task store insteadof event store
    createModelPersistencyManager: function() {
        var me = this;
        return new Sch.data.util.ModelPersistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    fillNode: function(node, newNodes) {
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        if (node.isRoot()) {
            this.isSettingRoot = true;
        }
        this.callParent(arguments);
        if (node.isRoot()) {
            this.isSettingRoot = false;
        }
    },
    onTasksRootChange: function() {
        var root = this.getRoot();
        if (root && this.autoNormalizeNodes) {
            root.normalizeParent();
        }
    },
    onTasksLoaded: function() {
        this.onTasksRootChange();
        // restore back CRUD listeners to support cascading and parent recalculations
        this.onTasksLoadEnd();
    },
    onTasksLoadStart: function() {
        // store.load() might be called recursively in a tree store
        // so we keep number of invokes to restore listeners back only when the last call is done
        this.tasksLoadStarted++;
        // we don't want to recalculate parent nodes an load stage
        this.suspendAutoRecalculateParents++;
        // Overridden to avoid reacting to the removing of all the records in the store
        this.un("noderemove", this.onTaskRemoved, this);
        // 5.0.1 Seems Ext is using regular "appendChild" method during store load, which triggers all the corresponding events
        // we don't want to react on those events during loading (recalculate parents, etc)
        this.un("nodeappend", this.onMyNodeAdded, this);
        this.un("update", this.onTaskUpdated, this);
    },
    onTasksLoadEnd: function() {
        // reset total timespan cache to force its recalculating
        this.lastTotalTimeSpan = null;
        (this.tasksLoadStarted > 0) || Ext.Error.raise("Invalid tasksLoadStarted flag state, should be greater than zero at this point");
        this.tasksLoadStarted--;
        // if no more nested load() calls
        // let's restore CRUD listeners
        if (!this.tasksLoadStarted) {
            this.on("noderemove", this.onTaskRemoved, this);
            this.on("nodeappend", this.onMyNodeAdded, this);
            this.on("update", this.onTaskUpdated, this);
        }
        // enable parent nodes recaulcalating back
        this.suspendAutoRecalculateParents--;
    },
    load: function(options) {
        // suspend CRUD listeners to skip cascading and parent recalculations (we restore it back by calling onTasksLoadEnd() in a "load" event listener)
        this.on('beforeload', this.onTasksLoadStart, this, {
            // we want it to run as late as possible to make sure some other listener hadn't returned false before it
            priority: -999,
            single: true
        });
        // Note, that gantt uses additional important override for `load` method for ExtJS 4.2.1 and below, inherited from
        // Sch.data.mixin.FilterableTreeStore
        this.callParent(arguments);
    },
    // After the task store proxy is set we map provided "typeProperty"
    // to the reader being used
    setProxy: function() {
        this.callParent(arguments);
        if (this.typeProperty) {
            var me = this,
                reader = me.getProxy() && me.getProxy().getReader();
            // if user has not provided "typeProperty" directly to the reader
            if (reader && !reader.getTypeProperty()) {
                reader.setTypeProperty(me.typeProperty);
            }
        }
    },
    setRoot: function(rootNode) {
        var me = this;
        // Ext5 NOTE: we check this.count() since it might break loading of data from "root" config if we call getRoot() too early
        var oldRoot = this.count() && this.getRoot();
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        this.isSettingRoot = true;
        Ext.apply(rootNode, {
            calendar: me.calendar,
            taskStore: me,
            // TODO: this is probably not needed anymore
            dependencyStore: me.dependencyStore,
            // TODO: this is probably not needed anymore
            // TODO: this is probably not working because phantom is set to true directly in superclass' setRoot() implementation
            // HACK Prevent tree store from trying to 'create' the root node
            phantom: false,
            dirty: false
        });
        var res = this.callParent(arguments);
        this.isSettingRoot = false;
        // we reset taskStore property on the tasks of the old root when we set the new root
        oldRoot && oldRoot.cascadeBy(function(node) {
            node.setTaskStore(null);
        });
        return res;
    },
    /**
     * Sets the dependency store for this task store
     *
     * @param {Gnt.data.DependencyStore} dependencyStore
     */
    setDependencyStore: function(dependencyStore) {
        var me = this,
            oldStore = me.dependencyStore,
            listeners = {
                add: me.onDependencyAdd,
                update: me.onDependencyUpdate,
                remove: me.onDependencyDelete,
                scope: me
            };
        if (oldStore && oldStore.isStore) {
            oldStore.un(listeners);
            oldStore.setTaskStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(null);
        }
        me.dependencyStore = dependencyStore && Ext.StoreMgr.lookup(dependencyStore) || null;
        if (me.dependencyStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(me.dependencyStore);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(me.dependencyStore);
            me.dependencyStore.setTaskStore(me);
            me.dependencyStore.on(listeners);
        }
        if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
            /**
             * @event dependencystorechange
             * Fires when new dependency store is set via {@link #setDependencyStore} method.
             * @param {Gnt.data.TaskStore}           this
             * @param {Gnt.data.DependencyStore|null} newAssignmentStore
             * @param {Gnt.data.DependencyStore|null} oldAssignmentStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('dependencystorechange', me, dependencyStore, oldStore);
        }
    },
    /**
     * Returns a resource store instance this task store is associated with. See also {@link #setResourceStore}.
     *
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function() {
        return this.resourceStore || null;
    },
    /**
     * Sets the resource store for this task store
     *
     * @param {Gnt.data.ResourceStore} resourceStore
     */
    setResourceStore: function(resourceStore) {
        var me = this,
            oldStore = me.resourceStore;
        if (oldStore && oldStore.isStore) {
            oldStore.setTaskStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
        }
        me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;
        if (me.resourceStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
            me.resourceStore.setTaskStore(me);
            me.resourceStore.normalizeResources();
        }
        if ((oldStore || resourceStore) && (oldStore !== resourceStore)) {
            /**
             * @event resourcestorechange
             * Fires when new resource store is set via {@link #setResourceStore} method.
             * @param {Gnt.data.TaskStore}          this
             * @param {Gnt.data.ResourceStore|null} newResourceStore
             * @param {Gnt.data.ResourceStore|null} oldResourceStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
        }
    },
    /**
     * Returns an assignment store this task store is associated with. See also {@link #setAssignmentStore}.
     *
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.assignmentStore || null;
    },
    /**
     * Sets the assignment store for this task store
     *
     * @param {Gnt.data.AssignmentStore} assignmentStore
     */
    setAssignmentStore: function(assignmentStore) {
        var me = this,
            oldStore = me.assignmentStore,
            listeners = {
                add: me.onAssignmentStructureMutation,
                update: me.onAssignmentMutation,
                remove: me.onAssignmentStructureMutation,
                scope: me
            };
        if (oldStore && oldStore.isStore) {
            oldStore.un(listeners);
            oldStore.setTaskStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
        }
        me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;
        if (me.assignmentStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
            assignmentStore.setTaskStore(me);
            assignmentStore.on(listeners);
        }
        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * @event assignmentstorechange
             * Fires when new assignment store is set via {@link #setAssignmentStore} method.
             * @param {Gnt.data.TaskStore}            this
             * @param {Gnt.data.AssignmentStore|null} newAssignmentStore
             * @param {Gnt.data.AssignmentStore|null} oldAssignmentStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
        }
    },
    /**
     * Call this method if you want to adjust tasks according to the calendar dates.
     * @param  {Gnt.modelTask/Gnt.modelTask[]} [tasks] Task or list of tasks to be adjusted. If omitted all tasks will be adjusted.
     * @param  {Function} callback Function to call on propagation changes completion or failure.
     */
    adjustToCalendar: function(tasks, callback) {
        var me = this;
        // reset early/late dates cache
        me.resetEarlyDates();
        me.resetLateDates();
        if (tasks instanceof Gnt.model.Task) {
            tasks.adjustToCalendar(callback);
        } else {
            if (Ext.isFunction(tasks)) {
                callback = tasks;
                tasks = [];
            }
            var root = me.getRoot(),
                doneNodes = {},
                globalPropagation = false;
            // if no tasks provided
            if (!Ext.isArray(tasks) || !tasks.length) {
                // get 1st level tasks
                tasks = root && root.childNodes || [];
                globalPropagation = true;
            }
            // we will initiate propagation starting from the root
            // yet real propagation sources are returned in the "propagationSources" array
            root && root.propagateChanges(function() {
                var propagationSources = [];
                for (var i = 0,
                    l = tasks.length; i < l; i++) {
                    var node = tasks[i];
                    // each node's child we adjust to calendar
                    node.cascadeBy(function(n) {
                        if (n !== root)  {
                            n.adjustToCalendarWithoutPropagation();
                        }
                        
                    });
                    // if we renormalize globally we say that we started propagation from tasks w/o incoming
                    // dependencies (since if we include them into "propagationSources" they will be treated as already processed
                    // and won't be aligned by incoming dependencies
                    if (!globalPropagation || !node.hasIncomingDependencies()) {
                        propagationSources.push(node);
                    }
                }
                return propagationSources.length && propagationSources || false;
            }, function(cancel, affected) {
                // remember tasks already processed as result of changes propagation
                if (!cancel)  {
                    Ext.apply(doneNodes, affected);
                }
                
                callback && callback.apply(this, arguments);
            });
        }
    },
    /**
     * Call this method if you want to adjust the tasks according to the calendar dates.
     * @deprecated This method is internal. Please use {@link #adjustToCalendar} instead.
     * @private
     */
    renormalizeTasks: function(store, nodes, callback) {
        this.adjustToCalendar(nodes, callback);
    },
    /**
     * Returns a project calendar instance.
     *
     * @return {Gnt.data.Calendar}
     */
    getCalendar: function() {
        return this.calendar || null;
    },
    /**
     * Sets the calendar for this task store
     *
     * @param {Gnt.data.Calendar} calendar
     */
    setCalendar: function(calendar, doNotChangeTasks, suppressEvent) {
        if (this.settingCalendar)  {
            return;
        }
        
        this.settingCalendar = true;
        var listeners = {
                calendarchange: this.renormalizeTasks,
                scope: this
            };
        if (this.calendar) {
            this.calendar.un(listeners);
        }
        this.calendar = calendar;
        if (calendar) {
            calendar.on(listeners);
            var root = this.getRoot();
            if (root) {
                root.calendar = calendar;
            }
            if (!doNotChangeTasks) {
                this.renormalizeTasks();
            }
            if (!suppressEvent) {
                this.fireEvent('calendarset', this, calendar);
            }
            // let calendarManager know of project calendar change
            if (this.calendarManager) {
                this.calendarManager.setProjectCalendar(calendar);
            }
        }
        this.settingCalendar = false;
    },
    /**
     * Returns the critical path(s) containing tasks with no slack that, if shifted, will push the end date of the project forward.
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths: function() {
        // Grab task id's that don't have any "incoming" dependencies
        var finalTasks = [],
            projects = this.getProjects(),
            lastTaskEndDate = new Date(0),
            roots = projects.length === 0 ? [
                this.getRoot()
            ] : projects;
        Ext.Array.each(roots, function(projectRoot) {
            // find the project end date
            projectRoot.cascadeBy(function(task) {
                lastTaskEndDate = Sch.util.Date.max(task.getEndDate(), lastTaskEndDate);
            });
            // find the tasks that ends on that date
            projectRoot.cascadeBy(function(task) {
                // do not include the parent tasks that has children
                // since their influence on the project end date is determined by their children
                if (lastTaskEndDate - task.getEndDate() === 0 && !task.isRoot() && !(!task.isLeaf() && task.childNodes.length)) {
                    finalTasks.push(task);
                }
            });
        });
        return Ext.Array.map(finalTasks, function(task) {
            return task.getCriticalPaths();
        });
    },
    onMyNodeAdded: function(parent, node) {
        var me = this;
        if (!node.isRoot()) {
            if (me.lastTotalTimeSpan) {
                var span = me.getTotalTimeSpan();
                // if new task dates violates cached total range then let's reset getTotalTimeSpan() cache
                if (node.getEndDate() > span.end || node.getStartDate() < span.start) {
                    me.lastTotalTimeSpan = null;
                }
            }
            // if it's a latest task
            if (node.getEndDate() - me.getProjectEndDate() === 0) {
                me.resetLateDates();
            }
            // Scheduling new added and linked tasks
            // Similar logic is present in DependencyStore::onDependencyAdded
            var dependencyStore = this.getDependencyStore();
            !me.isUndoingOrRedoing() && dependencyStore && dependencyStore.reduceTaskDependencies(node, function(result, dependency) {
                var from = dependency.getSourceTask(),
                    to = dependency.getTargetTask();
                from && to && dependencyStore.scheduleLinkedTasks(from, to);
            }, null, false);
            // if we should respect dependencies
            if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
                // and new ancestors of the node have incoming dependencies
                // we need to re-align the node to take them into account
                if (node.getParentsIncomingDependencies().length) {
                    node.alignByIncomingDependenciesWithoutPropagation();
                }
            }
            if (!me.cascading && me.recalculateParents && !me.suspendAutoRecalculateParents && !me.isUndoingOrRedoing()) {
                if (me.updating) {
                    me.pendingDataUpdates.recalculateParents[node.getId()] = node;
                } else {
                    node.recalculateParents();
                }
            }
        }
    },
    onTaskUpdated: function(store, task, operation) {
        var prev = task.previous;
        if (this.lastTotalTimeSpan) {
            var span = this.getTotalTimeSpan();
            // if new task dates violates cached total range then let's reset the cache
            if (prev && (prev[task.endDateField] - span.end === 0 || prev[task.startDateField] - span.start === 0) || (task.getEndDate() > span.end || task.getStartDate() < span.start)) {
                this.lastTotalTimeSpan = null;
            }
        }
        if (!this.cascading && operation !== Ext.data.Model.COMMIT && prev && !this.isUndoingOrRedoing()) {
            var doRecalcParents = task.percentDoneField in prev;
            // Check if we should cascade this update to successors
            // We're only interested in cascading operations that affect the start/end dates
            if (task.startDateField in prev || task.endDateField in prev || 'parentId' in prev || task.effortField in prev || // if task has changed _from_ manually scheduled mode
            prev[task.schedulingModeField] === 'Manual' || prev[task.manuallyScheduledField]) {
                var cascadeSourceTask = task;
                if (this.cascadeChanges && !this.suspendAutoCascade) {
                    // if we switched scheduling mode from manual then we'll call cascadeChangesForTask() for some of
                    // task predecessors (if any) to update task itself
                    if (prev[cascadeSourceTask.schedulingModeField] == 'Manual') {
                        var deps = cascadeSourceTask.getIncomingDependencies(true);
                        if (deps.length) {
                            cascadeSourceTask = deps[0].getSourceTask();
                        }
                    }
                    this.cascadeTimer = Ext.Function.defer(this.cascadeChangesForTask, this.cascadeDelay, this, [
                        cascadeSourceTask
                    ]);
                } else {
                    // reset early/late dates cache
                    this.resetEarlyDates();
                    this.resetLateDates();
                }
                doRecalcParents = true;
            }
            // if task scheduling turned to manual
            else if ((prev[task.schedulingModeField] || task.manuallyScheduledField in prev) && task.isManuallyScheduled()) {
                // reset early/late dates cache
                this.resetEarlyDates();
                this.resetLateDates();
            }
            if (doRecalcParents && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[task.getId()] = task;
                } else {
                    task.recalculateParents();
                }
            }
        }
    },
    onEndUpdate: function() {
        var me = this,
            toRecalculateParents = {},
            task;
        if (!this.isUndoingOrRedoing()) {
            Ext.Object.each(me.pendingDataUpdates.recalculateParents, function(id, task) {
                task.parentNode && (toRecalculateParents[task.parentNode.getId()] = task.parentNode);
            });
            // Sorting lower depth first, but then pop()'ing to process deepest depth first
            toRecalculateParents = Ext.Array.sort(Ext.Object.getValues(toRecalculateParents), function(a, b) {
                return (a.data.depth > b.data.depth) ? 1 : ((a.data.depth < b.data.depth) ? -1 : 0);
            });
            while (toRecalculateParents.length > 0) {
                task = toRecalculateParents.pop();
                task.refreshCalculatedParentNodeData();
                task.recalculateParents();
            }
        }
        me.pendingDataUpdates.recalculateParents = {};
        return me.callParent(arguments);
    },
    getEmptyCascadeBatch: function() {
        var me = this;
        return {
            nbrAffected: 0,
            affected: {},
            visitedCounters: {},
            addVisited: function(task) {
                var internalId = task.internalId;
                if (!this.visitedCounters[internalId]) {
                    this.visitedCounters[internalId] = 1;
                } else {
                    this.visitedCounters[internalId]++;
                }
            },
            addAffected: function(task, doNotAddParents) {
                var internalId = task.internalId;
                if (this.affected[internalId]) {
                    // already added
                    return;
                } else {
                    this.affected[internalId] = task;
                    this.nbrAffected++;
                }
                if (!me.cascading && this.nbrAffected > 1) {
                    me.fireEvent('beforecascade', me);
                    me.cascading = true;
                }
                if (!doNotAddParents) {
                    var byId = this.affectedParentsbyInternalId;
                    var array = this.affectedParentsArray;
                    var parent = task.isLeaf() ? task.parentNode : task;
                    while (parent && !parent.data.root) {
                        if (byId[parent.internalId])  {
                            break;
                        }
                        
                        byId[parent.internalId] = parent;
                        array.push(parent);
                        this.addAffected(parent, true);
                        parent = parent.parentNode;
                    }
                }
            },
            affectedParentsArray: [],
            affectedParentsbyInternalId: {},
            parentsStartDates: {}
        };
    },
    // starts a `batched` cascade (can contain several cascades, combined in one `currentCascadeBatch` context
    // cascade batch may actually contain 0 cascades (if for example deps are invalid)
    startBatchCascade: function() {
        if (!this.batchCascadeLevel) {
            this.currentCascadeBatch = this.getEmptyCascadeBatch();
            this.suspendAutoRecalculateParents++;
            this.suspendAutoCascade++;
        }
        this.batchCascadeLevel++;
        return this.currentCascadeBatch;
    },
    endBatchCascade: function() {
        this.batchCascadeLevel--;
        if (!this.batchCascadeLevel) {
            this.suspendAutoRecalculateParents--;
            this.suspendAutoCascade--;
            var currentCascadeBatch = this.currentCascadeBatch;
            this.currentCascadeBatch = null;
            this.resetEarlyDates();
            this.resetLateDates();
            if (this.cascading) {
                this.cascading = false;
                this.fireEvent('cascade', this, currentCascadeBatch);
            }
        }
    },
    /**
     * @deprecated
     *
     * Use {@link Gnt.model.Task#propagateChanges} instead.
     *
     * Cascade the updates to the *depended* tasks of given `task` (re-schedule them according to dependencies and constraints).
     *
     * Note, that source task of cascading is considered already having "stable" position, which will not be adjusted in any way.
     * Also, the cascading process is asynchronous (because of potential constraints violations).
     *
     * @param {Gnt.model.Task} sourceTask
     * @param {Function} callback A function to call after the casading has been completed.
     */
    cascadeChangesForTask: function(sourceTask, callback) {
        sourceTask.propagateChanges(Ext.emptyFn, callback, true);
    },
    removeTaskDependencies: function(task) {
        var dependencyStore = this.dependencyStore,
            deps = task.getAllDependencies(dependencyStore);
        if (deps.length)  {
            dependencyStore.remove(deps);
        }
        
    },
    removeTaskAssignments: function(task) {
        var assignmentStore = this.getAssignmentStore(),
            assignments = task.getAssignments();
        if (assignments.length)  {
            assignmentStore.remove(assignments);
        }
        
    },
    // TODO: constraints
    onTaskRemoved: function(store, removedNode, isMove) {
        var dependencyStore = this.getDependencyStore();
        var assignmentStore = this.getAssignmentStore();
        var taskDropped = !removedNode.isReplace && !isMove;
        // remove dependencies associated with the task
        if (dependencyStore && taskDropped) {
            removedNode.cascadeBy(this.removeTaskDependencies, this);
        }
        // remove task assignments
        if (assignmentStore && taskDropped) {
            // Fire this event so UI can ignore the datachanged events possibly fired below
            assignmentStore.fireEvent('beforetaskassignmentschange', assignmentStore, removedNode.getId(), []);
            removedNode.cascadeBy(this.removeTaskAssignments, this);
            // Fire this event so UI can just react and update the row for the task
            assignmentStore.fireEvent('taskassignmentschanged', assignmentStore, removedNode.getId(), []);
        }
        var span = this.getTotalTimeSpan();
        var startDate = removedNode.getStartDate();
        var endDate = removedNode.getEndDate();
        // if removed task dates were equal to total range then removing can affect total time span
        // so let's reset getTotalTimeSpan() cache
        if (endDate - span.end === 0 || startDate - span.start === 0) {
            this.lastTotalTimeSpan = null;
        }
        // mark task that it's no longer belong to the task store
        if (taskDropped)  {
            removedNode.setTaskStore(null);
        }
        
        //if early/late dates are supported
        this.resetEarlyDates();
        this.resetLateDates();
    },
    onTaskMoved: function(task, oldParent, newParent, index) {
        var span = this.getTotalTimeSpan();
        var startDate = task.getStartDate();
        var endDate = task.getEndDate();
        // if removed task dates were equal to total range then removing can affect total time span
        // so let's reset getTotalTimeSpan() cache
        if (endDate - span.end === 0 || startDate - span.start === 0) {
            this.lastTotalTimeSpan = null;
        }
        //if early/late dates are supported
        this.resetEarlyDates();
        this.resetLateDates();
    },
    // TODO: constraints
    onAssignmentMutation: function(assignmentStore, assignments) {
        var me = this;
        if (!this.isUndoingOrRedoing()) {
            Ext.Array.each([].concat(assignments), function(assignment) {
                // Taskstore could be filtered etc.
                var t = assignment.getTask(me);
                if (t) {
                    t.onAssignmentMutation(assignment);
                }
            });
        }
    },
    // TODO: constraints
    onAssignmentStructureMutation: function(assignmentStore, assignments) {
        var me = this;
        if (!this.isUndoingOrRedoing()) {
            Ext.Array.each([].concat(assignments), function(assignment) {
                var task = assignment.getTask(me);
                if (task) {
                    task.onAssignmentStructureMutation(assignment);
                }
            });
        }
    },
    onDependencyUpdate: function(store, dependency, operation) {
        if (operation !== Ext.data.Model.COMMIT) {
            this.onDependencyAdd(store, dependency);
        }
    },
    onDependencyAdd: function(store, dependencies) {
        var me = this,
            source, tasks;
        // reset early late dates cache
        me.resetEarlyDates();
        me.resetLateDates();
        // TODO: the following is very fragile code in case any constraint is violated (and we switch to async
        // execution) we should not propagate changes here, all changes should be propagated using corresponding
        // task/dependency model interface (linkTo/unlinkFrom etc).
        // -- Maxim
        // If cascade changes is activated, adjust the connected task start/end date
        if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
            tasks = [];
            if (Ext.isArray(dependencies)) {
                Ext.Array.each(dependencies, function(dependency) {
                    source = dependency.getSourceTask();
                    source && tasks.push(source);
                });
                tasks.length && me.getRoot().propagateChanges(function() {
                    return tasks;
                });
            } else {
                tasks = dependencies.getSourceTask();
                tasks && tasks.propagateChanges();
            }
        }
    },
    onDependencyDelete: function(store, dependencies) {
        // reset early late dates cache
        this.resetEarlyDates();
        this.resetLateDates();
    },
    // TODO: chieck if it's needed and remove it if it's not
    // When store has synced, we need to update phantom tasks which have now have a 'real' Id
    // and can be written to the backend
    onTaskStoreWrite: function(store, operation) {
        var me = this,
            records = operation.getRecords(),
            triggerNewSync;
        Ext.Array.each(records, function(task) {
            Ext.each(task.childNodes, function(child) {
                if (child.phantom) {
                    triggerNewSync = true;
                    return false;
                }
            });
        });
        // In the case of autoSync, a new sync will be triggered after a parent node is 'realized',
        // since Ext JS then sets a new 'parentId' property on all the childNodes.
        if (triggerNewSync && !this.autoSync) {
            // Ext JS won't let you call sync inside a 'write' handler, need to defer the call
            // http://www.sencha.com/forum/showthread.php?283908-Store-quot-isSyncing-quot-true-inside-a-write-listener
            me.syncTimer = setTimeout(function() {
                me.sync();
            }, 1);
        }
    },
    forEachTaskUnordered: function(fn, scope) {
        var root = this.getRoot();
        if (root) {
            root.cascadeBy(function(rec) {
                if (rec !== root) {
                    return fn.call(scope || this, rec);
                }
            });
        }
    },
    getTimeSpanForTasks: function(tasks) {
        var earliest = new Date(9999, 0, 1),
            latest = new Date(0);
        var compareFn = function(r) {
                var startDate = r.getStartDate();
                var endDate = r.getEndDate();
                if (startDate && startDate < earliest) {
                    earliest = startDate;
                }
                // Ignore tasks without start date as they aren't rendered anyway
                if (startDate && endDate && endDate > latest) {
                    latest = endDate;
                }
            };
        if (tasks) {
            if (!Ext.isArray(tasks))  {
                tasks = [
                    tasks
                ];
            }
            
            Ext.Array.each(tasks, compareFn);
        } else {
            this.forEachTaskUnordered(compareFn);
        }
        earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
        latest = latest > new Date(0) ? latest : null;
        return {
            start: earliest,
            end: latest || (earliest && Ext.Date.add(earliest, Ext.Date.DAY, 1)) || null
        };
    },
    /**
     * Returns an object defining the earliest start date and the latest end date of all the tasks in the store.
     * Tasks without start date are ignored, tasks without end date use their start date (if any) + 1 day
     * @return {Object} An object with 'start' and 'end' Date properties.
     */
    getTotalTimeSpan: function() {
        if (this.lastTotalTimeSpan)  {
            return this.lastTotalTimeSpan;
        }
        
        this.lastTotalTimeSpan = this.getTimeSpanForTasks();
        return this.lastTotalTimeSpan;
    },
    /**
     * Returns the project start date. This value is calculated (using {@link #getTotalTimeSpan} method) as an earliest start of all the tasks in the store.
     * **Note:** You can override this method to make alternative way of project start date calculation
     * (or for example to make this value configurable to store it in a database).
     * @return {Date} The project start date.
     */
    getProjectStartDate: function() {
        return this.getTotalTimeSpan().start;
    },
    /**
     * Returns the project end date. This value is calculated (using {@link #getTotalTimeSpan} method) as a latest end of all the tasks in the store.
     * @return {Date} The project end date.
     */
    getProjectEndDate: function() {
        return this.getTotalTimeSpan().end;
    },
    /**
     * Returns all projects kept in the store.
     * @return {Gnt.model.Project[]}
     */
    getProjects: function() {
        var root = this.getRoot(),
            projects = [],
            childNodes = root.childNodes;
        for (var i = 0,
            l = childNodes.length; i < l; i++) {
            if (childNodes[i].isProject) {
                projects.push(childNodes[i]);
            }
        }
        return projects;
    },
    // Internal helper method
    getTotalTaskCount: function(ignoreRoot) {
        var count = ignoreRoot === false ? 1 : 0;
        this.forEachTaskUnordered(function() {
            count++;
        });
        return count;
    },
    /**
     * Returns an array of all the tasks in this store.
     *
     * @return {Gnt.model.Task[]} The tasks currently loaded in the store
     */
    toArray: function() {
        var tasks = [];
        this.getRoot().cascadeBy(function(t) {
            tasks.push(t);
        });
        return tasks;
    },
    beginIndent: function(nodes, context) {
        this.fireEvent('beforeindentationchange', this, nodes, context);
    },
    endIndent: function(nodes, context) {
        this.fireEvent('indentationchange', this, nodes, context);
    },
    /**
     * Increase the indendation level of one or more tasks in the tree
     *
     * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to indent
     * @param {Function} [callback] Callback function to call after nodes have been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    indent: function(nodes, callback) {
        var me = this,
            canceled = false,
            affected = {},
            context, nodesToProcess;
        nodes = Ext.isArray(nodes) ? nodes.slice() : [
            nodes
        ];
        // 1. Filtering out all nodes which parents are also to be indented as well as the ones having no previous sibling
        //    since such nodes can't be indented
        nodes = Ext.Array.filter(nodes, function(node) {
            var result;
            result = !!node.previousSibling;
            while (result && !node.isRoot()) {
                result = !Ext.Array.contains(nodes, node.parentNode);
                node = node.parentNode;
            }
            return result;
        });
        // 2. Sorting nodes by index ascending, that's related on how task.indent() method actually indents
        nodes = Ext.Array.sort(nodes, function(a, b) {
            return a.get('index') - b.get('index');
        });
        // 3. Accumulating context
        context = Ext.Array.reduce(nodes, function(prev, curr) {
            prev[curr.getId()] = {
                parentNode: curr.parentNode,
                index: curr.get('index')
            };
            return prev;
        }, {});
        // 4. Indenting taking constraints related behaviour in mind
        me.beginIndent(nodes, context);
        me.suspendEvent('beforeindentationchange', 'indentationchange');
        nodesToProcess = nodes.slice();
        (function processStep() {
            if (nodesToProcess.length) {
                nodesToProcess.shift().indent(function(cancel, affectedNodes) {
                    if (!cancel) {
                        affected = Ext.apply(affected, affectedNodes);
                        processStep();
                    } else {
                        canceled = true;
                        affected = {};
                    }
                });
            } else {
                me.resumeEvent('beforeindentationchange', 'indentationchange');
                me.endIndent(nodes, context);
                callback && callback(canceled, affected);
            }
        })();
    },
    /**
     * Decrease the indendation level of one or more tasks in the tree
     *
     * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to outdent
     * @param {Function} [callback] Callback function to call after task has been outdented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    outdent: function(nodes, callback) {
        var me = this,
            canceled = false,
            affected = {},
            context, nodesToProcess;
        nodes = Ext.isArray(nodes) ? nodes.slice() : [
            nodes
        ];
        // 1. Filtering out all nodes which parents are also to be outdented as well as the ones having root parent
        //    since such nodes can't be indented
        nodes = Ext.Array.filter(nodes, function(node) {
            var result;
            result = node.parentNode && !node.parentNode.isRoot();
            while (result && !node.isRoot()) {
                result = !Ext.Array.contains(nodes, node.parentNode);
                node = node.parentNode;
            }
            return result;
        });
        // 2. Sorting nodes by index descending, that's related on how task.outdent() method actually outdents
        nodes = Ext.Array.sort(nodes, function(a, b) {
            return b.get('index') - a.get('index');
        });
        // 3. Accumulating context
        context = Ext.Array.reduce(nodes, function(prev, curr) {
            prev[curr.getId()] = {
                parentNode: curr.parentNode,
                index: curr.get('index')
            };
            return prev;
        }, {});
        // 4. Outdenting taking constraints related behaviour in mind
        me.beginIndent(nodes, context);
        me.suspendEvent('beforeindentationchange', 'indentationchange');
        nodesToProcess = nodes.slice();
        (function processStep() {
            if (nodesToProcess.length) {
                nodesToProcess.shift().outdent(function(cancel, affectedNodes) {
                    if (!cancel) {
                        affected = Ext.apply(affected, affectedNodes);
                        processStep();
                    } else {
                        canceled = true;
                        affected = {};
                    }
                });
            } else {
                me.resumeEvent('beforeindentationchange', 'indentationchange');
                me.endIndent(nodes, context);
                callback && callback(canceled, affected);
            }
        })();
    },
    /**
     * Returns the tasks associated with a resource
     * @param {Gnt.model.Resource} resource
     * @return {Gnt.model.Task[]} the tasks assigned to this resource
     */
    getTasksForResource: function(resource) {
        return this.getEventsForResource(resource);
    },
    /**
     * Returns the resources associated with a task
     * @param {Gnt.model.Task} task
     * @return {Gnt.model.Resource[]}
     */
    getResourcesForTask: function(task) {
        return this.getResourcesForEvent(task);
    },
    // Event store adaptions (flat store vs tree store)
    forEachScheduledEvent: function(fn, scope) {
        scope = scope || this;
        this.forEachTaskUnordered(function(event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();
            if (eventStart && eventEnd) {
                return fn.call(scope, event, eventStart, eventEnd);
            }
        });
    },
    onTasksSorted: function() {
        // After sorting we need to reapply filters if store was previously filtered
        if (this.lastTreeFilter) {
            this.filterTreeBy(this.lastTreeFilter);
        }
    },
    /**
     * Appends a new task to the store
     * @param {Gnt.model.Task/Object} record The record to append to the store
     * @return {Gnt.model.Task} The appended record
     */
    append: function(record) {
        return this.getRoot().appendChild(record);
    },
    resetEarlyDates: function(suppress) {
        this.earlyStartDates = {};
        this.earlyEndDates = {};
        if (!suppress)  {
            this.fireEvent('resetearlydates');
        }
        
    },
    resetLateDates: function(suppress) {
        this.lateStartDates = {};
        this.lateEndDates = {};
        if (!suppress)  {
            this.fireEvent('resetlatedates');
        }
        
    },
    /**
     * Returns Task by sequential number. See {@link Gnt.model.Task#getSequenceNumber} for details.
     *
     * @param {Number} number
     *
     * @return {Gnt.model.Task}
     */
    getBySequenceNumber: function(number) {
        return this.getRoot().getBySequenceNumber(number);
    },
    destroy: function() {
        this.setCalendar(null);
        this.setCalendarManager(null);
        this.setAssignmentStore(null);
        this.setDependencyStore(null);
        this.setResourceStore(null);
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy();
        }
        clearTimeout(this.cascadeTimer);
        clearTimeout(this.syncTimer);
        this.callParent(arguments);
    },
    moveSeveralTasks: function(taskConsumer) {
        // this will suspend auto-cascade and auto-recalculate parents
        var currentCascadeBatch = this.startBatchCascade();
        var taskMovement;
        while (taskMovement = taskConsumer()) {
            var task = taskMovement.task;
            // in case a parent task has no children it should be treated as a leaf
            if (task.isLeaf() || !task.childNodes.length) {
                // do not try to re-position manually scheduled tasks and the tasks, affected by cascading
                if (!currentCascadeBatch.affected[task.internalId]) {
                    // add child tasks to the cascade context as affected ones
                    // its not a cascade in previous meaning, but still can be seen as such,
                    // because parent task "pushes" date changes to its children
                    currentCascadeBatch.addAffected(task);
                    // this won't cascade because cascading is suspended
                    taskMovement.method && task[taskMovement.method].apply(task, taskMovement.args);
                    if (this.cascadeChanges) {
                        // cascading manually, saving affected tasks
                        this.cascadeChangesForTask(task);
                    }
                }
            } else {
                if (this.recalculateParents)  {
                    currentCascadeBatch.addAffected(task);
                }
                
            }
        }
        // will resume auto-cascade and auto-recalculate parents
        this.endBatchCascade();
    },
    linearWalkDependentTasks: function(sourceTaskList, processor, walkingSpecification) {
        var me = this;
        !walkingSpecification || Ext.isObject(walkingSpecification) || Ext.Error.raise("Invalid arguments: walking specification must be an object");
        walkingSpecification = walkingSpecification || {
            self: true,
            ancestors: me.recalculateParents,
            descendants: me.moveParentAsGroup,
            successors: me.cascadeChanges,
            cycles: me.cycleResolutionStrategy
        };
        return Gnt.data.Linearizator.linearWalkBySpecification(sourceTaskList, processor, walkingSpecification);
    },
    getLinearWalkingSequenceForDependentTasks: function(sourceTaskList, walkingSpecification) {
        var result = [];
        this.linearWalkDependentTasks(sourceTaskList, function(task, color, sourceSet, depsData) {
            result.push(Array.prototype.slice.call(arguments));
        }, walkingSpecification);
        return result;
    },
    // @override
    // ExtJS doesn't use getters in this method but we need to use them to take model projections into account.
    // We literally copied Ext.data.TreeStore.isVisible and replaced every node.data.* with node.get(*)
    isVisible: function(node) {
        var parentNode = node.parentNode,
            visible = node.get('visible'),
            root = this.getRoot();
        while (visible && parentNode) {
            visible = parentNode.get('expanded') && parentNode.get('visible');
            parentNode = parentNode.parentNode;
        }
        return visible && !(node === root && !this.getRootVisible());
    },
    /**
     * Removes tasks from the store, ignoring all readOnly tasks.
     * @param {[Gnt.model.Task]/Gnt.model.Task} tasks The task(s) to remove
     * @return {[Gnt.model.Task]} The removed records
     */
    removeTasks: function(tasks) {
        tasks = [].concat(tasks);
        // Don't allow removing readOnly tasks
        tasks = Ext.Array.filter(tasks, function(task) {
            return !task.parentNode || !task.parentNode.isReadOnly();
        });
        // Sorting tasks by depth, such that children were removed before parents, otherwise
        // undo manager might have difficulties restoring the hierarchy. If children are removed
        // after parents then undo manager will catch no notification about the removal, after parents
        // have been removed the undo manager has no control over tree detached hierarchy anymore.
        tasks = Ext.Array.sort(tasks, function(a, b) {
            return b.getDepth() - a.getDepth();
        });
        this.fireEvent('beforebatchremove', this, tasks);
        Ext.Array.forEach(tasks, function(task) {
            task.remove();
        });
        this.fireEvent('batchremove', this, tasks);
        return tasks;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.data.calendar.BusinessTime
@extends Gnt.data.Calendar

A class representing a customizable calendar with weekends, holidays and availability information for any day. 

This class is basically a subclass of {@link Gnt.data.Calendar}, configured for normal business hours availability, 
you can fine-tune its setting if needed. Default availability hours for every day are 08:00-12:00 and 13:00-17:00 
(can be configured with {@link #defaultAvailability} property.

See also {@link Gnt.data.Calendar} for additional information.

*/
Ext.define('Gnt.data.calendar.BusinessTime', {
    extend: 'Gnt.data.Calendar',
    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     * 
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth: 20,
    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     * 
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek: 5,
    /**
     * Number of hours per day. Will be used when converting the duration in days to hours.
     * 
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     * 
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay: 8,
    /**
     * @cfg {String[]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Gnt.model.CalendarDay}) for each working weekday (Monday-Friday). 
     */
    defaultAvailability: [
        '08:00-12:00',
        '13:00-17:00'
    ]
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.util.Array', {
    singleton: true,
    reduce: function(array, reduceFn, initialValue) {
        array = Object(array);
        if (!Ext.isFunction(reduceFn)) {
            Ext.raise('Invalid parameter: expected a function.');
        }
        var index = 0,
            length = array.length >>> 0,
            reduced = initialValue;
        if (arguments.length < 3) {
            while (true) {
                if (index in array) {
                    reduced = array[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
            }
        }
        for (; index < length; ++index) {
            if (index in array) {
                reduced = reduceFn(reduced, array[index], index, array);
            }
        }
        return reduced;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Robo.Transaction

This class encapsulates a single undo/redo transaction used with the {@link Robo.Manager}.

Transaction consists from at least one action {@link Robo.action.Base}

*/
Ext.define('Robo.Transaction', {
    actions: null,
    /**
     * @cfg {String} title
     * 
     * A human-readable name for this transaction.
     */
    title: null,
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        this.callParent([
            config
        ]);
        this.actions = [];
    },
    /**
     * Checks wheither a transaction has any actions recorded
     *
     * @return {Boolean}
     */
    hasActions: function() {
        return this.actions.length > 0;
    },
    addAction: function(action) {
        this.actions.push(action);
    },
    getActions: function() {
        return this.actions;
    },
    /**
     * Undoes this transaction. Generally should not be called directly.  
     */
    undo: function() {
        for (var i = this.actions.length - 1; i >= 0; i--) {
            this.actions[i].undo();
        }
    },
    /**
     * Redoes this transaction. Generally should not be called directly.
     */
    redo: function() {
        for (var i = 0; i < this.actions.length; i++) {
            this.actions[i].redo();
        }
    },
    /**
     * Returns the title for this transaction. If not provided explicitly, a title of the first action is returned.
     * 
     * @return {String}
     */
    getTitle: function() {
        if (this.title)  {
            return this.title;
        }
        
        var firstAction = this.actions[0];
        return firstAction ? firstAction.getTitle() : null;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Robo.action.Base

Base class for actions - entities that represents a change in a managed store.

*/
Ext.define('Robo.action.Base', {
    constructor: function(config) {
        Ext.apply(this, config);
    },
    undo: function() {
        throw new Error("Abstract method call");
    },
    redo: function() {
        throw new Error("Abstract method call");
    },
    getTitle: function() {
        return '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.flat.Update', {
    extend: 'Robo.action.Base',
    requires: [
        'Ext.Array'
    ],
    inheritableStatics: {
        CUSTOMLY_PROCESSED: {}
    },
    config: {
        record: null,
        fieldNames: null
    },
    oldValues: null,
    newValues: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.initConfig(config);
        me.saveValues();
    },
    saveValues: function() {
        var me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames();
        if (fieldNames) {
            me.oldValues = Ext.Array.map(fieldNames, function(fieldName) {
                return me.processSavingOldValue(fieldName, record);
            });
            me.newValues = Ext.Array.map(fieldNames, function(fieldName) {
                return me.processSavingNewValue(fieldName, record);
            });
        }
    },
    undo: function() {
        var CPM,
            me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames(),
            setObj;
        if (fieldNames) {
            CPM = me.self.CUSTOMLY_PROCESSED;
            record.beginEdit();
            setObj = Robo.util.Array.reduce(fieldNames, function(prev, curr, i) {
                var processedVal;
                // we'll be a bit defensive
                if (curr) {
                    processedVal = me.processRestoringValue(me.oldValues[i], curr, record, 'undo');
                    if (processedVal !== CPM) {
                        prev[curr] = processedVal;
                    }
                }
                return prev;
            }, {});
            record.set(setObj);
            record.endEdit();
        }
    },
    redo: function() {
        var CPM,
            me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames(),
            setObj;
        if (fieldNames) {
            CPM = me.self.CUSTOMLY_PROCESSED;
            record.beginEdit();
            setObj = Robo.util.Array.reduce(fieldNames, function(prev, curr, i) {
                var processedVal;
                // we'll be a bit defensive
                if (curr) {
                    processedVal = me.processRestoringValue(me.newValues[i], curr, record, 'redo');
                    if (processedVal !== CPM) {
                        prev[curr] = processedVal;
                    }
                }
                return prev;
            }, {});
            record.set(setObj);
            record.endEdit();
        }
    },
    /**
     * @method
     */
    processSavingOldValue: function(fieldName, record) {
        //                 our own implementation for Ext4 || Ext6 implementation
        var previousValues = record.previous || record.previousValues;
        if (previousValues && previousValues.hasOwnProperty(fieldName))  {
            return previousValues[fieldName];
        }
        else if (record.editMementoFix) {
            previousValues = record.editMementoFix.previousValues || record.editMementoFix.data;
            return previousValues[fieldName];
        } else  {
            throw "Can not get previous value";
        }
        
    },
    /**
     * @method
     */
    processSavingNewValue: function(fieldName, record) {
        return record.get(fieldName);
    },
    /**
     * @method
     */
    processRestoringValue: Ext.identityFn,
    getTitle: function() {
        var record = this.getRecord();
        var fieldNames = this.getFieldNames();
        if (record.getTitle)  {
            return "Edit of " + fieldNames[0] + " for " + record.getTitle(this);
        }
        
        if (record.modelName)  {
            return "Edit of " + record.modelName + " " + record.getId();
        }
        
        return '';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.flat.Add', {
    extend: 'Robo.action.Base',
    store: null,
    records: null,
    index: null,
    undo: function() {
        var records = this.records;
        this.store.remove(records);
        for (var i = 0; i < records.length; i++) {
            this.store.removeFromRemoved(records[i]);
        }
    },
    redo: function() {
        this.store.insert(this.index, this.records);
    },
    getRecord: function() {
        return this.records[0];
    },
    getTitle: function() {
        var me = this;
        var titles = Ext.Array.map(this.records, function(record) {
                if (record.getTitle)  {
                    return record.getTitle(me);
                }
                
                if (record.modelName)  {
                    return record.modelName + " " + record.getId();
                }
                
                return 'unknown';
            });
        return 'Addition of ' + titles.join(',');
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.flat.Remove', {
    extend: 'Robo.action.Base',
    store: null,
    records: null,
    index: null,
    undo: function() {
        var me = this;
        me.store.insert(me.index, me.records);
    },
    redo: function() {
        var me = this;
        me.store.remove(me.records);
    },
    getRecord: function() {
        return this.records[0];
    },
    getTitle: function() {
        var me = this;
        var titles = Ext.Array.map(this.records, function(record) {
                if (record.getTitle)  {
                    return record.getTitle(me);
                }
                
                if (record.modelName)  {
                    return record.modelName + " " + record.getId();
                }
                
                return 'unknown';
            });
        return 'Removal of ' + titles.join(',');
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.tree.Append', {
    extend: 'Robo.action.Base',
    parent: null,
    newChild: null,
    undo: function() {
        var newChild = this.newChild;
        this.parent.removeChild(newChild);
        delete newChild.data.lastParentId;
        var store = this.parent.getTreeStore();
        Ext.Array.remove(store.removedNodes, newChild);
    },
    redo: function() {
        this.parent.appendChild(this.newChild);
    },
    getRecord: function() {
        return this.newChild;
    },
    getTitle: function() {
        var record = this.newChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + " " + record.getId();
        }
        
        return 'Append of ' + title;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.tree.Insert', {
    extend: 'Robo.action.Base',
    parent: null,
    newChild: null,
    insertedBefore: null,
    undo: function() {
        var newChild = this.newChild;
        this.parent.removeChild(newChild);
        delete newChild.data.lastParentId;
        var store = this.parent.getTreeStore();
        Ext.Array.remove(store.removedNodes, newChild);
    },
    redo: function() {
        var insertedBefore = this.insertedBefore;
        var insertedAsFirst = insertedBefore && insertedBefore.isFirst();
        this.parent.insertBefore(this.newChild, insertedBefore);
        // https://www.sencha.com/forum/showthread.php?308814-6.0.1-quot-isFirst-quot-field-is-not-updated-correctly-after-the-child-node-insertion&p=1127985#post1127985
        if (insertedAsFirst)  {
            insertedBefore.updateInfo(false, {
                isFirst: false
            });
        }
        
    },
    getRecord: function() {
        return this.newChild;
    },
    getTitle: function() {
        var record = this.newChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + " " + record.getId();
        }
        
        return 'Insertion of ' + title;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.tree.Remove', {
    extend: 'Robo.action.Base',
    parent: null,
    removedChild: null,
    nextSibling: null,
    newParent: null,
    newNextSibling: null,
    dirty: false,
    isMove: false,
    constructor: function(config) {
        this.callParent(arguments);
        this.dirty = this.removedChild.dirty;
    },
    undo: function() {
        if (this.isMove) {
            this.newParent = this.removedChild.parentNode;
            this.newNextSibling = this.removedChild.nextSibling;
        }
        var nextSibling = this.nextSibling;
        var insertedAsFirst = nextSibling && nextSibling.isFirst();
        var removedChild = this.removedChild;
        this.parent.insertBefore(removedChild, nextSibling);
        removedChild.dirty = this.dirty;
        if (!this.isMove) {
            var store = removedChild.getTreeStore();
            removedChild.cascadeBy(function(node) {
                Ext.Array.remove(store.removedNodes, node);
            });
        }
        if (insertedAsFirst)  {
            nextSibling.updateInfo(false, {
                isFirst: false
            });
        }
        
    },
    redo: function() {
        if (this.isMove) {
            var newNextSibling = this.newNextSibling;
            var insertedAsFirst = newNextSibling && newNextSibling.isFirst();
            this.newParent.insertBefore(this.removedChild, newNextSibling);
            // https://www.sencha.com/forum/showthread.php?308814-6.0.1-quot-isFirst-quot-field-is-not-updated-correctly-after-the-child-node-insertion&p=1127985#post1127985
            if (insertedAsFirst)  {
                newNextSibling.updateInfo(false, {
                    isFirst: false
                });
            }
            
        } else {
            this.parent.removeChild(this.removedChild);
            delete this.removedChild.data.lastParentId;
        }
    },
    getRecord: function() {
        return this.removedChild;
    },
    getTitle: function() {
        var record = this.removedChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + " " + record.getId();
        }
        
        return this.isMove ? 'Move of ' + title : 'Removal of ' + title;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Robo.action.tree.Update', {
    extend: 'Robo.action.flat.Update',
    // Ext JS UI doesn't react to record.set('expanded', false). Need to call API methods for this field
    processRestoringValue: function(value, fieldName, record, op) {
        var me = this;
        if (fieldName === 'expanded') {
            if (value) {
                record.expand();
            } else {
                record.collapse();
            }
            value = me.self.CUSTOMLY_PROCESSED;
        } else if (fieldName == 'leaf') {
            value = me.callParent(arguments);
            if (value === true && op == 'undo')  {
                record.data.loaded = false;
            }
            
        } else {
            value = me.callParent(arguments);
        }
        return value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Robo.Manager
@extends Ext.util.Observable

This is the main class that provides undo-redo capabilities for an array of {@link Ext.data.Store} instances.
To enable undo support, simply create a Robo.Manager instance and configure it with your stores:

    var yourStore1  = new Ext.data.Store({ ... });
    var yourStore2  = new Ext.data.TreeStore({ ... });
 
    var robo        = new Robo.Manager({
        stores              : [ yourStore1, yourStore2 ]
    });

    // start monitoring
    robo.start();
    
See also {@link Robo.data.Model} and {@link Robo.data.Store} mixins - they need to be mixed into your models and stores.

By default, Robo uses timeout-based transactions (see {@link #transactionBoundary}). So all changes during {@link #transactionMaxDuration}
ms will be batched into a single transaction:

    // in some button handler, several changes are batched in single transaction
    yourStore.getAt(0).set('name', 'a new name');
    yourStore.getAt(1).set('value', 'a new value');

    // user clicks the `undo` button after some time
    // whole transaction is reverted
    robo.undo(); 

*/
Ext.define('Robo.Manager', {
    extend: 'Ext.util.Observable',
    requires: [
        'Robo.util.Array',
        'Robo.Transaction',
        'Robo.data.Model',
        'Robo.action.flat.Update',
        'Robo.action.flat.Add',
        'Robo.action.flat.Remove',
        'Robo.action.tree.Append',
        'Robo.action.tree.Insert',
        'Robo.action.tree.Remove',
        'Robo.action.tree.Update',
        'Ext.data.Store',
        'Ext.data.StoreManager'
    ],
    /**
     * @cfg {Array[Ext.data.Store]} stores An array of stores to be managed by the Robo
     */
    stores: null,
    storesById: null,
    treeStoreListeners: null,
    flatStoreListeners: null,
    stub: function() {},
    undoQueue: null,
    redoQueue: null,
    ignoredFieldNames: {
        // Tree store view state should not be considered 'data' to be tracked
        expanded: 1
    },
    // one of the 'created', 'enabled', 'disabled', 'paused', 'hold'
    state: 'created',
    /**
     * @cfg {String} transactionBoundary
     *
     * Transaction boundary mode, either 'manual' or 'timeout'.
     *
     * In the 'timeout' mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
     * records any changes in its monitored stores. The transaction lasts for {@link #transactionMaxDuration} and
     * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
     *
     * In 'manual' mode you have to call {@link #startTransaction} / {@link #endTransaction} to start and end
     * a transaction. Note, that in this mode a change in any tracked store will start a transaction automatically,
     * so you will need to issue a finalizing {@link #endTransaction} call manually.
     */
    transactionBoundary: 'timeout',
    /**
     * @cfg {Number} transactionMaxDuration
     *
     * The transaction duration (in ms) for the 'manual' {@link #transactionBoundary transaction boundary}
     */
    transactionMaxDuration: 100,
    /**
     * @cfg {Boolean} clearQueuesOnLoad
     *
     * True to automatically clear the queues upon 'load' and 'clear' events on any of the stores monitored
     */
    clearQueuesOnLoad: false,
    transactionTimeout: null,
    currentTransaction: null,
    /**
     * @event start Fired when the undo manager starts recording events
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event stop Fired after the undo manager has stopped recording events
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event transactionadd
     *
     * @param {Robo.Manager} this
     * @param {Robo.Transaction} transaction
     */
    /**
     * @event undoqueuechange
     *
     * @param {Robo.Manager} this
     * @param {[Robo.Transaction]} undoQueue
     */
    /**
     * @event redoqueuechange
     *
     * @param {Robo.Manager} this
     * @param {[Robo.Transaction]} redoQueue
     */
    /**
     * @event beforeundo Fired before an undo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event afterundo Fired after an undo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event beforeredo Fired before a redo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event afterredo Fired after a redo operation
     *
     * @param {Robo.Manager} this
     */
    constructor: function(config) {
        var me = this;
        config = config || {};
        Ext.apply(me, config);
        me.treeStoreListeners = {
            nodeappend: me.onTreeStoreAppend,
            nodeinsert: me.onTreeStoreInsert,
            noderemove: me.onTreeStoreRemove,
            update: me.onTreeStoreUpdate,
            scope: me
        };
        me.flatStoreListeners = {
            add: me.onFlatStoreAdd,
            remove: me.onFlatStoreRemove,
            update: me.onFlatStoreUpdate,
            scope: me
        };
        if (me.clearQueuesOnLoad) {
            Ext.apply(me.treeStoreListeners, {
                load: me.clearQueues,
                clear: me.clearQueues
            });
            Ext.apply(me.flatStoreListeners, {
                load: me.clearQueues,
                clear: me.clearQueues
            });
        }
        me.callParent([
            config
        ]);
        var myStores = me.stores || [];
        me.stores = [];
        me.storesById = {};
        me.undoQueue = [];
        me.redoQueue = [];
        Ext.Array.forEach(myStores, function(store) {
            me.addStore(store);
        });
    },
    /**
     * Adds a store to the list of managed stores
     *
     * @param {Ext.data.Store/String} store A data store or a 'storeId' identifier
     */
    addStore: function(store, id) {
        store = Ext.data.StoreManager.lookup(store);
        Ext.Assert && Ext.Assert.isObject(store, 'Must provide a store or a valid store id');
        this.stores.push(store);
        if (id)  {
            store.setStoreId(id);
        }
        
        var model = store.getModel();
        var associations = model.prototype.associations || {};
        for (var roleName in associations) {
            var role = associations[roleName];
            var old = role.getAssociatedStore;
            if (old && !old.ROBO_MANAGED) {
                var me = this;
                role.getAssociatedStore = function() {
                    var store = old.apply(this, arguments);
                    if (!me.hasStore(store)) {
                        me.addStore(store);
                        if (me.state !== 'disabled' && me.state !== 'created') {
                            me.bindStore(store);
                        }
                    }
                    return store;
                };
                role.getAssociatedStore.ROBO_MANAGED = true;
            }
        }
        if (store.storeId) {
            this.storesById[store.storeId] = store;
        }
    },
    /**
     * Gets a store from the managed store list by its id
     *
     * @param {String} id
     * @return {Ext.data.Store}
     */
    getStoreById: function(id) {
        return this.storesById[id];
    },
    hasStore: function(store) {
        return Ext.Array.indexOf(this.stores, store) != -1;
    },
    bindStore: function(store) {
        (store.undoRedoEventBus || store).on(this.getStoreTypeListeners(store));
        // subscribe to the stubs (empty functions) to fill the "hasListeners" cache of the store
        // this is to enable events propagation in tree store, in which event first bubbles through the
        // nodes (to the root) and then is fired on the store itself (if the "hasListeners" check passes)
        if (store.undoRedoEventBus)  {
            store.on(this.getStoreTypeListenerStubs(store));
        }
        
    },
    unbindStore: function(store) {
        (store.undoRedoEventBus || store).un(this.getStoreTypeListeners(store));
        if (store.undoRedoEventBus)  {
            store.un(this.getStoreTypeListenerStubs(store));
        }
        
    },
    getStoreTypeListenerStubs: function(store) {
        var me = this;
        var listeners = this.getStoreTypeListeners(store);
        listeners = Ext.apply({}, listeners);
        Ext.Object.each(listeners, function(key, value) {
            listeners[key] = me.stub;
        });
        return listeners;
    },
    /**
     * Returns the listeners object to use with a particular store type
     *
     * @param {Ext.data.Store} store
     * @return {Object}
     *
     * @protected
     */
    getStoreTypeListeners: function(store) {
        var listeners;
        if (Ext.data.TreeStore && store instanceof Ext.data.TreeStore) {
            listeners = this.treeStoreListeners;
        } else {
            listeners = this.flatStoreListeners;
        }
        return listeners;
    },
    /**
     * Removes a store from the list of managed stores
     *
     * @param {Ext.data.Store} store
     */
    removeStore: function(store) {
        Ext.Array.remove(this.stores, store);
        this.storesById[store.storeId] = null;
        this.unbindStore(store);
    },
    forEachStore: function(func) {
        Ext.Array.forEach(this.stores, func, this);
    },
    onAnyChangeInAnyStore: function(store) {
        if (this.state === 'paused' || (store.isRootSettingOrLoading && store.isRootSettingOrLoading())) {
            return false;
        }
        if (!this.currentTransaction) {
            this.startTransaction();
        }
        return true;
    },
    hasPersistableChanges: function(record, modifiedFieldNames) {
        var ignored = this.ignoredFieldNames;
        return Robo.util.Array.reduce(modifiedFieldNames, function(result, field) {
            var fieldInstance = record.getField(field);
            return result || !fieldInstance || (fieldInstance.persist && (!record.isNode || !ignored.hasOwnProperty(field)));
        }, false);
    },
    onFlatStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        if (!this.onAnyChangeInAnyStore(store) || operation != 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !this.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.flat.Update({
            record: record,
            fieldNames: modifiedFieldNames
        }));
    },
    onFlatStoreAdd: function(store, records, index) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.flat.Add({
            store: store,
            records: records,
            index: index
        }));
    },
    onFlatStoreRemove: function(store, records, index, isMove) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.flat.Remove({
            store: store,
            records: records,
            index: index,
            isMove: isMove
        }));
    },
    onTreeStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        if (!this.onAnyChangeInAnyStore(store) || operation != 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !this.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.tree.Update({
            record: record,
            fieldNames: modifiedFieldNames
        }));
    },
    onTreeStoreAppend: function(parent, newChild, index) {
        if (!parent || !this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (newChild.$undoRedoMoving) {
            delete newChild.$undoRedoMoving;
        } else {
            this.currentTransaction.addAction(new Robo.action.tree.Append({
                parent: parent,
                newChild: newChild
            }));
        }
    },
    onTreeStoreInsert: function(parent, newChild, insertedBefore) {
        // Don't react to root loading
        if (!parent || !this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (newChild.$undoRedoMoving) {
            delete newChild.$undoRedoMoving;
        } else {
            this.currentTransaction.addAction(new Robo.action.tree.Insert({
                parent: parent,
                newChild: newChild,
                insertedBefore: insertedBefore
            }));
        }
    },
    onTreeStoreRemove: function(parent, removedChild, isMove, context) {
        if (!this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (isMove) {
            removedChild.$undoRedoMoving = true;
        }
        this.currentTransaction.addAction(new Robo.action.tree.Remove({
            parent: parent,
            removedChild: removedChild,
            nextSibling: context.nextSibling,
            isMove: isMove
        }));
    },
    /**
     * Starts the undo/redo monitoring.
     */
    start: function() {
        // when we start first time - fire events to notify the possibly listening UI about our current state
        if (this.state == 'created' || this.state == 'disabled') {
            this.fireEvent('start', this);
            this.fireEvent('undoqueuechange', this, this.undoQueue);
            this.fireEvent('redoqueuechange', this, this.redoQueue);
        }
        if (this.state !== 'hold') {
            this.forEachStore(this.bindStore);
            this.state = 'enabled';
        }
    },
    /**
     * Stops the undo/redo monitoring and clears any recorded transactions (since we cannot guarantee correct
     * undo or redo after monitoring has stopped).
     */
    stop: function() {
        this.endTransaction();
        this.forEachStore(this.unbindStore);
        this.state = 'disabled';
        this.clearQueues();
        this.fireEvent('stop', this);
    },
    clearQueues: function() {
        this.clearUndoQueue();
        this.clearRedoQueue();
    },
    // @protected
    pause: function() {
        this.state = 'paused';
    },
    // @protected
    resume: function() {
        this.state = 'enabled';
    },
    // @protected
    hold: function() {
        Ext.Assert && Ext.Assert.isObject(this.currentTransaction, "Can't hold, no transaction is currently in progress");
        this.state = 'hold';
    },
    // @protected
    release: function() {
        Ext.Assert && Ext.Assert.isObject(this.currentTransaction, "Can't release, no transaction is currently in progress");
        this.state = 'enabled';
    },
    /**
     * Gets the undo queue
     *
     * @return {Array[Robo.Transaction]}
     */
    getUndoQueue: function() {
        return this.undoQueue.slice();
    },
    /**
     * Gets the redo queue
     *
     * @return {Array[Robo.Transaction]}
     */
    getRedoQueue: function() {
        return this.redoQueue.slice();
    },
    clearUndoQueue: function() {
        if (this.undoQueue.length) {
            this.undoQueue = [];
            this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        }
    },
    clearRedoQueue: function() {
        if (this.redoQueue.length) {
            this.redoQueue = [];
            this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        }
    },
    /**
     * Starts a new undo/redo transaction.
     *
     * @param {String} title Transaction title
     */
    startTransaction: function(title) {
        var me = this,
            transaction;
        if (me.state == 'disabled') {
            return;
        }
        if (me.currentTransaction) {
            me.endTransaction();
        }
        transaction = new Robo.Transaction({
            title: title
        });
        me.currentTransaction = transaction;
        me.notifyStoresAboutTransactionStart(transaction);
        if (me.transactionBoundary == 'timeout') {
            me.scheduleEndTransaction();
        }
    },
    scheduleEndTransaction: function() {
        var me = this;
        if (me.transactionTimeout) {
            clearTimeout(me.transactionTimeout);
        }
        me.transactionTimeout = setTimeout(function() {
            if (me.state !== 'hold') {
                me.endTransaction();
                me.transactionTimeout = null;
            } else {
                me.scheduleEndTransaction();
            }
        }, me.transactionMaxDuration);
    },
    /**
     * Ends the current undo/redo transaction.
     */
    endTransaction: function() {
        var me = this,
            currentTransaction = me.currentTransaction;
        if (!currentTransaction) {
            return false;
        }
        me.currentTransaction = null;
        if (me.transactionBoundary == 'timeout') {
            clearTimeout(me.transactionTimeout);
            me.transactionTimeout = null;
        }
        if (currentTransaction.hasActions()) {
            me.addTransaction(currentTransaction);
        }
        me.notifyStoresAboutTransactionEnd(currentTransaction);
        return currentTransaction.hasActions();
    },
    addTransaction: function(transaction) {
        this.undoQueue.push(transaction);
        this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        if (this.redoQueue.length) {
            this.redoQueue.length = 0;
            this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        }
        this.fireEvent('transactionadd', this, transaction);
    },
    /**
     * Undoes previously recorded undo/redo transaction(s), amount of transactions defined by the optional parameter.
     *
     * @param {Number} [howMany] The number of transactions to undo. Optional, default value is 1
     */
    undo: function(howMany) {
        var undoQueue = this.undoQueue,
            index, transaction, i,
            l = undoQueue.length;
        if (this.state == 'disabled' || howMany === 0 || !undoQueue.length) {
            return;
        }
        // is this feature used anywhere? probably unnesessary complication
        if (howMany instanceof Robo.Transaction) {
            index = Ext.Array.indexOf(undoQueue, howMany);
            if (index == -1) {
                return;
            }
            howMany = undoQueue.length - index;
        }
        howMany = howMany || 1;
        this.fireEvent('beforeundo', this);
        this.pause();
        this.notifyStoresAboutUndoRedoStart();
        for (i = 0; i < Math.min(howMany, l); i++) {
            transaction = undoQueue.pop();
            transaction.undo();
            this.redoQueue.unshift(transaction);
        }
        this.notifyStoresAboutUndoRedoComplete();
        this.fireEvent('undoqueuechange', this, undoQueue.slice());
        this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        this.resume();
        this.fireEvent('afterundo', this);
    },
    /**
     * Redoes previously recorded undo/redo transaction(s), amount of transactions defined by the optional parameter.
     *
     * @param {Number} [howMany] how many transactions to redo. Optional, default value is 1
     */
    redo: function(howMany) {
        var redoQueue = this.redoQueue,
            transaction, index, i,
            l = redoQueue.length;
        if (this.state == 'disabled' || howMany === 0 || !redoQueue.length) {
            return;
        }
        // is this feature used anywhere? probably unnesessary complication
        if (howMany instanceof Robo.Transaction) {
            index = Ext.Array.indexOf(redoQueue, howMany);
            if (index == -1) {
                return;
            }
            howMany = index + 1;
        }
        howMany = howMany || 1;
        this.fireEvent('beforeredo', this);
        this.pause();
        this.notifyStoresAboutUndoRedoStart();
        for (i = 0; i < Math.min(howMany, l); i++) {
            transaction = this.redoQueue.shift();
            transaction.redo();
            this.undoQueue.push(transaction);
        }
        this.notifyStoresAboutUndoRedoComplete();
        this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        this.resume();
        this.fireEvent('afterredo', this);
    },
    undoAll: function() {
        this.undo(this.undoQueue.length);
    },
    notifyStoresAboutTransactionStart: function(transaction) {
        this.forEachStore(function(store) {
            store.onUndoRedoTransactionStart && store.onUndoRedoTransactionStart(this, transaction);
        });
    },
    notifyStoresAboutTransactionEnd: function(transaction) {
        this.forEachStore(function(store) {
            store.onUndoRedoTransactionEnd && store.onUndoRedoTransactionEnd(this, transaction);
        });
    },
    notifyStoresAboutUndoRedoStart: function() {
        this.forEachStore(function(store) {
            store.beforeUndoRedo && store.beforeUndoRedo(this);
        });
    },
    notifyStoresAboutUndoRedoComplete: function() {
        this.forEachStore(function(store) {
            store.afterUndoRedo && store.afterUndoRedo(this);
        });
    }
}, function() {
    Ext.apply(Robo, {
        VERSION: '4.2.7'
    });
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.data.undoredo.Manager
 * @extends Robo.Manager
 *
 * This class provides Gantt-aware undo-redo capabilities for the provided array of {@link Ext.data.Store} instances. To enable undo support for your Gantt chart stores, simply
 * create an UndoManager and configure it with your stores:
 *
 *      var undoManager = new Gnt.data.undoredo.Manager({
            transactionBoundary : 'timeout',
            stores              : [
                taskStore,
                dependencyStore,
                ...
            ]
        });

        undoManager.start();

        yourStore.getAt(0).set('name', 'a new name');

        undoManager.undo(); // Call 'undo' to revert last action
 *
 */
Ext.define('Gnt.data.undoredo.Manager', {
    extend: 'Robo.Manager',
    uses: [
        'Gnt.data.TaskStore',
        'Gnt.data.undoredo.action.taskstore.Update'
    ],
    getStoreTypeListeners: function(store) {
        var me = this,
            listeners = me.callParent([
                store
            ]);
        if (store instanceof Gnt.data.TaskStore) {
            listeners.update = me.onTaskStoreUpdate;
            listeners.projectionstart = me.onTaskStoreProjectionStart;
            listeners.projectioncommit = me.onTaskStoreProjectionEnd;
            listeners.projectionreject = me.onTaskStoreProjectionEnd;
        }
        return listeners;
    },
    onTaskStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        if (!this.onAnyChangeInAnyStore(store) || operation != 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !this.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        this.currentTransaction.addAction(new Gnt.data.undoredo.action.taskstore.Update({
            record: record,
            fieldNames: modifiedFieldNames
        }));
    },
    onTaskStoreProjectionStart: function(store, projectionLevel) {
        var me = this;
        if (projectionLevel == 1 && me.transactionBoundary === 'timeout') {
            if (!me.currentTransaction) {
                // This will start an undo/redo transaction if one isn't started yet
                me.onAnyChangeInAnyStore(store);
            }
            if (me.currentTransaction) {
                me.hold();
            }
        }
    },
    onTaskStoreProjectionEnd: function(store, projection, data, projectionLevel) {
        var me = this;
        if (projectionLevel === 0 && me.transactionBoundary === 'timeout' && me.currentTransaction) {
            me.release();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Special update action which knows how to properly store segments snapshot, works in conjuction with
 * {@link Gnt.data.undoredo.mixin.TaskStoreHint} which does actual segments snapshot in response upon undo/redo
 * transaction start
 */
Ext.define('Gnt.data.undoredo.action.taskstore.Update', {
    extend: 'Robo.action.tree.Update',
    uses: [
        'Ext.Array'
    ],
    getSerializedSegments: function(segments) {
        return segments ? Ext.Array.map(segments, function(seg) {
            return Ext.clone(seg.data);
        }) : segments;
    },
    processSavingOldValue: function(fieldName, record) {
        var me = this,
            value;
        if (fieldName == record.segmentsField) {
            value = record.getTaskStore().getOriginalSegmentsState(record);
        } else {
            value = me.callParent([
                fieldName,
                record
            ]);
        }
        return value;
    },
    processSavingNewValue: function(fieldName, record) {
        var me = this,
            value;
        if (fieldName === record.segmentsField) {
            value = record.buildSegmentsSnapshot();
        } else {
            value = me.callParent([
                fieldName,
                record
            ]);
        }
        return value;
    },
    processRestoringValue: function(value, fieldName, record) {
        var me = this;
        if (fieldName == record.segmentsField) {
            record.rollbackSegmentsToSnapshot(value);
            value = me.self.CUSTOMLY_PROCESSED;
        } else {
            value = me.callParent([
                value,
                fieldName,
                record
            ]);
        }
        return value;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Dependency store event->dependencies cache.
 * Uses event records or event record ids as keys.
 *
 * The cache uses 3 keys for each event:
 * - {EventId} - contains both successors and predecessors
 * - {EventId}-succ - contains successors only
 * - {EventId}-pred - contains predecessors only
 *
 * @private
 */
Ext.define('Sch.data.util.EventDependencyCache', {
    extend: 'Sch.util.Cache',
    dependencyStore: null,
    dependencyStoreDetacher: null,
    eventStoreDetacher: null,
    constructor: function(dependencyStore) {
        var me = this,
            eventStore = dependencyStore.getEventStore();
        function onDependencyAdd(store, dependencies) {
            Ext.Array.each(dependencies, function(dependency) {
                var sourceId = dependency.getSourceId(),
                    targetId = dependency.getTargetId();
                if (sourceId) {
                    me.add(sourceId, dependency);
                }
                if (targetId) {
                    me.add(targetId, dependency);
                }
                if (sourceId && targetId) {
                    me.addSuccessor(sourceId, dependency);
                    me.addPredecessor(targetId, dependency);
                }
            });
        }
        function onDependencyRemove(store, dependencies) {
            Ext.Array.each(dependencies, function(dependency) {
                var sourceId = dependency.getSourceId(),
                    targetId = dependency.getTargetId();
                if (sourceId) {
                    me.remove(sourceId, dependency);
                    me.removeSuccessor(sourceId, dependency);
                }
                if (targetId) {
                    me.remove(targetId, dependency);
                    me.removePredecessor(targetId, dependency);
                }
            });
        }
        function onDependencyUpdate(store, dependency, operation) {
            var sourceIdField = dependency.fromField,
                targetIdField = dependency.toField,
                sourceIdChanged = dependency.previous && sourceIdField in dependency.previous,
                targetIdChanged = dependency.previous && targetIdField in dependency.previous,
                previousSourceId = sourceIdChanged && dependency.previous[sourceIdField],
                previousTargetId = targetIdChanged && dependency.previous[targetIdField];
            if (sourceIdChanged) {
                me.move(previousSourceId, dependency.getSourceId(), dependency);
                me.moveSuccessors(previousSourceId, dependency.getSourceId(), dependency);
            }
            if (targetIdChanged) {
                me.move(previousTargetId, dependency.getTargetId(), dependency);
                me.movePredecessors(previousTargetId, dependency.getTargetId(), dependency);
            }
        }
        function onDependencyStoreClearOrReset(store) {
            me.clear();
        }
        function onDependencyStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
        }
        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
            me.moveSuccessors(oldId, newId);
            me.movePredecessors(oldId, newId);
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.clear(event);
                me.clearSuccessors(event);
                me.clearPredecessors(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(store) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = store && store.on({
                'idchanged': onEventIdChanged,
                'remove': onEventRemove,
                'cacheresethint': onEventStoreClearOrReset,
                'clear': onEventStoreClearOrReset,
                'rootchange': onEventStoreClearOrReset,
                // subscribing to the CRUD using priority - should guarantee that our listeners
                // will be called first (before any other listeners, that could be provided in the "listeners" config)
                // and state in other listeners will be correct
                priority: 100,
                destroyable: true
            });
        }
        me.dependencyStoreDetacher = dependencyStore.on({
            'add': onDependencyAdd,
            'remove': onDependencyRemove,
            'update': onDependencyUpdate,
            'cacheresethint': onDependencyStoreClearOrReset,
            'clear': onDependencyStoreClearOrReset,
            'eventstorechange': onDependencyStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.dependencyStoreFiltersDetacher = dependencyStore.getFilters().on({
            endupdate: onDependencyStoreClearOrReset,
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToEventStore(eventStore);
        me.dependencyStore = dependencyStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'dependencyStoreDetacher', 'eventStoreDetacher');
        me.dependencyStore = null;
    },
    get: function(k, fn) {
        var me = this,
            idtype, id, type;
        if (!fn) {
            k = me.key(k);
            idtype = me.self.splitKey(k);
            id = idtype.id;
            type = idtype.type;
            switch (type) {
                case 'pred':
                    fn = function() {
                        return Ext.Array.filter(me.get(id), function(dependency) {
                            return dependency.getTargetId() == id;
                        });
                    };
                    break;
                case 'succ':
                    fn = function() {
                        return Ext.Array.filter(me.get(id), function(dependency) {
                            return dependency.getSourceId() == id;
                        });
                    };
                    break;
                default:
                    fn = function() {
                        return Ext.Array.filter(me.dependencyStore.getRange(), function(dependency) {
                            return dependency.getTargetId() == id || dependency.getSourceId() == id;
                        });
                    };
            }
        }
        return me.callParent([
            k,
            fn
        ]);
    },
    getSuccessors: function(k) {
        var me = this;
        return me.get(me.self.makeSuccessorsKey(me.key(k)));
    },
    getPredecessors: function(k) {
        var me = this;
        return me.get(me.self.makePredecessorsKey(me.key(k)));
    },
    addSuccessor: function(k, v) {
        var me = this;
        return me.add(me.self.makeSuccessorsKey(me.key(k)), v);
    },
    addPredecessor: function(k, v) {
        var me = this;
        return me.add(me.self.makePredecessorsKey(me.key(k)), v);
    },
    removeSuccessor: function(k, v) {
        var me = this;
        return me.remove(me.self.makeSuccessorsKey(me.key(k)), v);
    },
    removePredecessor: function(k, v) {
        var me = this;
        return me.remove(me.self.makePredecessorsKey(me.key(k)), v);
    },
    moveSuccessors: function(oldKey, newKey, v) {
        var me = this;
        return arguments.length >= 3 ? me.move(me.self.makeSuccessorsKey(me.key(oldKey)), me.self.makeSuccessorsKey(me.key(newKey)), v) : me.move(me.self.makeSuccessorsKey(me.key(oldKey)), me.self.makeSuccessorsKey(me.key(newKey)));
    },
    movePredecessors: function(oldKey, newKey, v) {
        var me = this;
        return arguments.length >= 3 ? me.move(me.self.makePredecessorsKey(me.key(oldKey)), me.self.makePredecessorsKey(me.key(newKey)), v) : me.move(me.self.makePredecessorsKey(me.key(oldKey)), me.self.makePredecessorsKey(me.key(newKey)));
    },
    clearSuccessors: function(k) {
        var me = this;
        return me.clear(me.self.makeSuccessorsKey(me.key(k)));
    },
    clearPredecessors: function(k) {
        var me = this;
        return me.clear(me.self.makePredecessorsKey(me.key(k)));
    },
    inheritableStatics: {
        splitKey: function(k) {
            k = k.split('@#!#@');
            return {
                id: k[0],
                type: k.length && k[1] || false
            };
        },
        makeSuccessorsKey: function(k) {
            return k + '@#!#@succ';
        },
        makePredecessorsKey: function(k) {
            return k + '@#!#@pred';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This extension of EventDependencyCache is needed for backwards compatibility only. The keys of this cache are Task ids
 * (or complex keys encoding a Task id), the values are dependencies. The Task interface declares two deprecated properties
 * `successors` and `predecessors` this class fills those properties in supporting backwards compatibility.
 *
 * TODO: remove this class and modify Gnt.data.DependencyStore constructor, where instance of this class is created
 *       and assigned to `eventDependencyCache` property, when Task::successors/Task::predecessors are finaly removed
 *       and not supported anymore.
 */
Ext.define('Gnt.data.util.TaskDependencyCache', function(thisCls) {
    function keyToTask(me, k) {
        var ts;
        if (!(k instanceof Ext.data.Model)) {
            ts = me.dependencyStore.getTaskStore();
            k = ts && ts.getModelById(k);
        }
        return k;
    }
    function fillSuccessors(me, k) {
        var t = keyToTask(me, k);
        t && (t.successors = me.getSuccessors(k));
    }
    function fillPredecessors(me, k) {
        var t = keyToTask(me, k);
        t && (t.predecessors = me.getPredecessors(k));
    }
    function clearSuccessorsPredecessors(me) {
        var ts = me.dependencyStore.getTaskStore(),
            root = ts && ts.getRoot();
        root && root.cascadeBy(function(node) {
            node.successors = [];
            node.predecessors = [];
        });
    }
    function fillTasksWithDepInfo(me) {
        var ts = me.dependencyStore.getTaskStore(),
            root = ts && ts.getRoot();
        root && root.cascadeBy(function(node) {
            node.successors = me.getSuccessors(node);
            node.predecessors = me.getPredecessors(node);
        });
    }
    return {
        extend: 'Sch.data.util.EventDependencyCache',
        taskStoreDetacher: null,
        taskStoreDependencyStoreDetacher: null,
        constructor: function(dependencyStore) {
            var me = this,
                taskStore;
            me.callParent([
                dependencyStore
            ]);
            function onTaskStoreRootChange(store) {
                fillTasksWithDepInfo(me);
            }
            function onTaskStoreNodeAppend(store, node) {
                fillSuccessors(me, node);
                fillPredecessors(me, node);
            }
            function onDependencyStoreTaskStoreChange(store, taskStore) {
                attachToTaskStore(taskStore);
            }
            function onDependencyStoreRefresh(store) {
                fillTasksWithDepInfo(me);
            }
            function attachToTaskStore(store) {
                Ext.destroy(me.taskStoreDetacher);
                me.taskStoreDetacher = store && store.on({
                    'rootchange': onTaskStoreRootChange,
                    'nodeappend': onTaskStoreNodeAppend,
                    priority: 99,
                    destroyable: true
                });
                // This cache can't work lazyly, so if a task store changes then it should fill itself
                // otherwise task's `successors`, `predecessors` properties won't be up-to-date
                fillTasksWithDepInfo(me);
            }
            me.taskStoreDependencyStoreDetacher = dependencyStore.on({
                'eventstorechange': onDependencyStoreTaskStoreChange,
                'refresh': onDependencyStoreRefresh,
                priority: 100,
                destroyable: true
            });
            attachToTaskStore(dependencyStore.getTaskStore());
        },
        destroy: function() {
            var me = this;
            me.callParent();
            Ext.destroyMembers(me, 'taskStoreDetacher', 'taskStoreDependencyStoreDetacher');
        },
        addSuccessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillSuccessors(me, k);
        },
        addPredecessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillPredecessors(me, k);
        },
        removeSuccessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillSuccessors(me, k);
        },
        removePredecessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillPredecessors(me, k);
        },
        moveSuccessors: function(oldKey, newKey, v) {
            var me = this;
            me.callParent(arguments);
            fillSuccessors(me, oldKey);
            fillSuccessors(me, newKey);
        },
        movePredecessors: function(oldKey, newKey, v) {
            var me = this;
            me.callParent(arguments);
            fillPredecessors(me, oldKey);
            fillPredecessors(me, newKey);
        },
        clearSuccessors: function(k) {
            var me = this;
            me.callParent([
                k
            ]);
            fillSuccessors(me, k);
        },
        clearPredecessors: function(k) {
            var me = this;
            me.callParent([
                k
            ]);
            fillPredecessors(me, k);
        },
        clear: function(k) {
            var me = this;
            me.callParent(arguments);
            if (k) {
                fillSuccessors(me, k);
                fillPredecessors(me, k);
            } else {
                clearSuccessorsPredecessors(me);
            }
        }
    };
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Gnt.feature.DependencyDragZone
 * @extends Ext.util.Observable
 * @private
 * Internal drag zone class for dependency drag drop.
 */
Ext.define("Gnt.feature.DependencyDragZone", {
    extend: 'Ext.dd.DragZone',
    mixins: {
        observable: 'Ext.util.Observable'
    },
    rtl: null,
    useLineProxy: null,
    terminalSelector: null,
    ganttView: null,
    fromText: null,
    toText: null,
    startText: null,
    endText: null,
    toolTipTpl: null,
    constructor: function(el, config) {
        this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    initLineProxy: function(sourceEl, isStart) {
        var lpEl = this.lineProxyEl = this.lineProxyEl || this.el.createChild({
                cls: 'sch-gantt-connector-proxy'
            });
        var adjust = Ext.isIE9m ? 0 : 4;
        var side = this.rtl ? (isStart ? 'r' : 'l') : (isStart ? 'l' : 'r');
        var scroll = this.ganttView.getScroll();
        lpEl.alignTo(sourceEl, side, [
            isStart ? -adjust : adjust,
            0
        ]);
        Ext.apply(this, {
            containerTop: this.el.getTop(),
            containerLeft: this.el.getLeft(),
            startXY: lpEl.getXY(),
            startScrollLeft: scroll.left,
            startScrollTop: scroll.top
        });
    },
    onDrag: function(e, t) {
        if (this.useLineProxy) {
            this.updateLineProxy(e.getXY());
        }
    },
    updateLineProxy: function(xy) {
        var lineProxy = this.lineProxyEl,
            scroll = this.ganttView.getScroll(),
            diffX = xy[0] - this.startXY[0] + scroll.left - this.startScrollLeft,
            diffY = xy[1] - this.startXY[1] + scroll.top - this.startScrollTop,
            newHeight = Math.max(1, Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) - 2),
            // Calculate new angle relative to start XY
            rad = Math.atan2(diffY, diffX) - (Math.PI / 2),
            styleBlob;
        if (Ext.isIE9m) {
            var cos = Math.cos(rad),
                sin = Math.sin(rad),
                matrixString = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos + ', M12 = ' + (-sin) + ', M21 = ' + sin + ', M22 = ' + cos + ')',
                scrollValueTop, scrollValueLeft;
            if (scroll.top !== this.startScrollTop) {
                scrollValueTop = this.startScrollTop - this.containerTop;
            } else {
                scrollValueTop = scroll.top - this.containerTop;
            }
            if (scroll.left !== this.startScrollLeft) {
                scrollValueLeft = this.startScrollLeft - this.containerLeft;
            } else {
                scrollValueLeft = scroll.left - this.containerLeft;
            }
            styleBlob = {
                "height": newHeight + 'px',
                "top": Math.min(0, diffY) + this.startXY[1] + scrollValueTop + (diffY < 0 ? 2 : 0) + 'px',
                "left": Math.min(0, diffX) + this.startXY[0] + scrollValueLeft + (diffX < 0 ? 2 : 0) + 'px',
                "filter": matrixString,
                "-ms-filter": matrixString
            };
        } else {
            var rotateString = 'rotate(' + rad + 'rad)';
            styleBlob = {
                "height": newHeight + 'px',
                "-o-transform": rotateString,
                "-webkit-transform": rotateString,
                "-ms-transform": rotateString,
                "-moz-transform": rotateString,
                "transform": rotateString
            };
        }
        lineProxy.setStyle(styleBlob);
    },
    onStartDrag: function() {
        this.el.addCls('sch-gantt-dep-dd-dragging');
        this.proxy.el.addCls('sch-dd-dependency-proxy');
        this.fireEvent('dndstart', this);
        if (this.useLineProxy) {
            var dd = this.dragData;
            this.initLineProxy(dd.sourceNode, dd.isStart);
            this.lineProxyEl.show();
        }
    },
    // On receipt of a mousedown event, see if it is within a draggable element.
    // Return a drag data object if so. The data object can contain arbitrary application
    // data, but it should also contain a DOM element in the ddel property to provide
    // a proxy to drag.
    getDragData: function(e) {
        var sourceNode = e.getTarget(this.terminalSelector);
        if (sourceNode) {
            var sourceTaskRecord = this.ganttView.resolveTaskRecord(sourceNode);
            if (this.fireEvent('beforednd', this, sourceTaskRecord) === false) {
                return null;
            }
            var isStart = !!sourceNode.className.match('sch-gantt-terminal-start');
            var tplData = {
                    fromLabel: this.fromText,
                    fromTaskName: Ext.String.htmlEncode(sourceTaskRecord.getName()),
                    fromSide: isStart ? this.startText : this.endText,
                    toLabel: this.toText,
                    toTaskName: '',
                    toSide: ''
                };
            var ddel = Ext.core.DomHelper.createDom({
                    html: this.toolTipTpl.apply(tplData)
                }).firstChild;
            return {
                fromId: sourceTaskRecord.getId() || sourceTaskRecord.internalId,
                tplData: tplData,
                isStart: isStart,
                repairXY: Ext.fly(sourceNode).getXY(),
                ddel: ddel,
                sourceNode: Ext.fly(sourceNode).up(this.ganttView.eventSelector)
            };
        }
        return false;
    },
    // Override, get rid of weird highlight fx in default implementation
    afterRepair: function() {
        this.dragging = false;
        if (!this.destroyed) {
            this.el.removeCls('sch-gantt-dep-dd-dragging');
            this.fireEvent('afterdnd', this);
        }
    },
    onMouseUp: function() {
        this.el.removeCls('sch-gantt-dep-dd-dragging');
        if (this.lineProxyEl) {
            var duration = Ext.isIE9m ? 0 : 400;
            var el = this.lineProxyEl;
            el.animate({
                to: {
                    height: 0
                },
                duration: duration,
                callback: function() {
                    Ext.destroy(el);
                }
            });
            this.lineProxyEl = null;
        }
    },
    // Provide coordinates for the proxy to slide back to on failed drag.
    // This is the original XY coordinates of the draggable element.
    getRepairXY: function() {
        return this.dragData.repairXY;
    },
    destroy: function() {
        Ext.destroy(this.lineProxyEl);
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Gnt.feature.DependencyDropZone
 * @extends Ext.util.Observable
 * @private
 * Internal drop zone class for dependency drag drop.
 */
Ext.define("Gnt.feature.DependencyDropZone", {
    extend: 'Ext.dd.DropZone',
    mixins: {
        observable: 'Ext.util.Observable'
    },
    terminalSelector: null,
    dependencyStore: null,
    toText: null,
    startText: null,
    endText: null,
    ganttView: null,
    constructor: function(el, config) {
        this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    getTargetFromEvent: function(e) {
        return e.getTarget(this.terminalSelector);
    },
    // On entry into a target node, highlight that node.
    onNodeEnter: function(target, dd, e, data) {
        Ext.fly(target).addCls('sch-gantt-terminal-drophover');
    },
    // On exit from a target node, unhighlight that node.
    onNodeOut: function(target, dd, e, data) {
        Ext.fly(target).removeCls('sch-gantt-terminal-drophover');
        // Clear the proxy text showing the target task
        this.toolTipTpl.overwrite(dd.proxy.el.down('.sch-dd-dependency'), data.tplData);
    },
    onNodeOver: function(target, dd, e, data) {
        var targetRecord = this.ganttView.resolveTaskRecord(target),
            targetId = targetRecord.getId() || targetRecord.internalId,
            isTargetStart = target.className.match('sch-gantt-terminal-start');
        var tplData = {};
        Ext.apply(tplData, {
            toLabel: this.toText,
            toTaskName: Ext.String.htmlEncode(targetRecord.getName()),
            toSide: isTargetStart ? this.startText : this.endText
        }, data.tplData);
        this.toolTipTpl.overwrite(dd.proxy.el.down('.sch-dd-dependency'), tplData);
        var type = this.resolveType(data.isStart, target);
        if (this.dependencyStore.isValidDependency(data.fromId, targetId, type)) {
            return this.dropAllowed;
        } else {
            return this.dropNotAllowed;
        }
    },
    onNodeDrop: function(target, dd, e, data) {
        var type = this.resolveType(data.isStart, target),
            retVal,
            targetRec = this.ganttView.resolveTaskRecord(target),
            targetId = targetRec.getId() || targetRec.internalId;
        this.el.removeCls('sch-gantt-dep-dd-dragging');
        retVal = this.dependencyStore.isValidDependency(data.fromId, targetId, type);
        if (retVal) {
            this.fireEvent('drop', this, data.fromId, targetId, type);
        }
        this.fireEvent('afterdnd', this);
        return retVal;
    },
    resolveType: function(isFromStart, target) {
        var DepType = Gnt.model.Dependency.Type,
            isToStart = target.className.match('sch-gantt-terminal-start');
        if (isFromStart && isToStart)  {
            return DepType.StartToStart;
        }
        
        if (isFromStart && !isToStart)  {
            return DepType.StartToEnd;
        }
        
        if (!isFromStart && isToStart)  {
            return DepType.EndToStart;
        }
        
        return DepType.EndToEnd;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.feature.DependencyDragDrop
 * @extends Ext.util.Observable
 * @private
 * Internal class managing the interaction of setting up new dependencies using drag and drop between dependency terminals.
 */
Ext.define("Gnt.feature.DependencyDragDrop", {
    extend: 'Ext.util.Observable',
    mixins: {
        localizable: 'Gnt.mixin.Localizable'
    },
    requires: [
        'Gnt.feature.DependencyDragZone',
        'Gnt.feature.DependencyDropZone',
        'Ext.XTemplate'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - fromText    : 'From: <strong>{0},</strong> {1},<br/>',
     - toText      : 'To: <strong>{0},</strong> {1},',
     - startText   : 'Start',
     - endText     : 'End'
     */
    /**
     * @cfg {Boolean} useLineProxy True to display a line while dragging
     */
    useLineProxy: true,
    /**
     * @cfg {Object} dragZoneConfig
     * A custom config object used to configure the Ext.dd.DragZone instance.
     */
    dragZoneConfig: null,
    /**
     * @cfg {Object} dropZoneConfig
     * A custom config object used to configure the Ext.dd.DropZone instance.
     */
    dropZoneConfig: null,
    /**
     * @cfg {Object} toolTipTpl
     * A custom config object to configure the template for the drag tooltip.
     */
    toolTipTpl: [
        '<div class="sch-dd-dependency">',
        '<table><tbody>',
        '<tr>',
        '<td><span class="sch-dd-dependency-from">{fromLabel}:</span></td>',
        '<td><span class="sch-dd-dependency-from-name">{fromTaskName}</span> - {fromSide}</td>',
        '</tr>',
        '<tr>',
        '<td><span class="sch-dd-dependency-to">{toLabel}:</span></td>',
        '<td><span class="sch-dd-dependency-to-name">{toTaskName}</span> - {toSide}</td>',
        '</tr>',
        '</tbody></table>',
        '</div>'
    ],
    // private, the terminal CSS selector
    terminalSelector: '.sch-gantt-terminal',
    el: null,
    rtl: null,
    ddGroup: null,
    ganttView: null,
    dependencyStore: null,
    /**
     * @event beforednd
     * Fires before a drag and drop operation is initiated, return false to cancel it
     * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
     * @param {Ext.data.Model} fromRecord The task record
     */
    /**
     * @event dndstart
     * Fires when a drag and drop operation starts
     * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
     */
    /**
     * @event drop
     * Fires after a drop has been made on a receiving terminal
     * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
     * @param {Mixed} fromId The source dependency task record id
     * @param {Mixed} toId The target dependency task record id
     * @param {Number} type The dependency type, see {@link Gnt.model.Dependency} for more information about possible values.
     */
    /**
     * @event afterdnd
     * Always fires after a dependency drag and drop operation
     * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
     */
    constructor: function(config) {
        var view = config.ganttView;
        Ext.apply(this, config);
        this.ddGroup = view.id + '-sch-dependency-dd';
        // Lazy setup
        this.el.on('mousemove', this.doSetup, this, {
            single: true
        });
        this.callParent(arguments);
    },
    doSetup: function() {
        var me = this;
        // The drag zone behaviour
        this.dragZone = new Gnt.feature.DependencyDragZone(this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            useLineProxy: this.useLineProxy,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            startText: this.L('startText'),
            endText: this.L('endText'),
            fromText: this.L('fromText'),
            toText: this.L('toText'),
            toolTipTpl: Ext.XTemplate.getTpl(this, 'toolTipTpl')
        }, this.dragZoneConfig));
        this.relayEvents(this.dragZone, [
            'beforednd',
            'dndstart',
            'afterdnd'
        ]);
        this.dropZone = Ext.create("Gnt.feature.DependencyDropZone", this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            dependencyStore: this.dependencyStore,
            startText: this.L('startText'),
            endText: this.L('endText'),
            toText: this.L('toText'),
            toolTipTpl: Ext.XTemplate.getTpl(this, 'toolTipTpl')
        }, this.dropZoneConfig));
        this.relayEvents(this.dropZone, [
            'drop',
            'afterdnd'
        ]);
        this.configureAllowedSourceTerminals();
        if (this.dependencyStore.allowedDependencyTypes) {
            // Define the allowed targets at drag start time
            this.dragZone.on('dndstart', this.configureAllowedTargetTerminals, this);
        } else {
            // Allow all types
            this.el.addCls([
                'sch-gantt-terminal-allow-target-start',
                'sch-gantt-terminal-allow-target-end'
            ]);
        }
    },
    configureAllowedSourceTerminals: function() {
        var allowed = this.dependencyStore.allowedDependencyTypes;
        var classes = [
                'sch-gantt-terminal-allow-source-start',
                'sch-gantt-terminal-allow-source-end'
            ];
        if (allowed) {
            classes = [];
            if (Ext.Array.indexOf(allowed, 'EndToEnd') > -1 || Ext.Array.indexOf(allowed, 'EndToStart') > -1) {
                classes.push('sch-gantt-terminal-allow-source-end');
            }
            if (Ext.Array.indexOf(allowed, 'StartToStart') > -1 || Ext.Array.indexOf(allowed, 'StartToEnd') > -1) {
                classes.push('sch-gantt-terminal-allow-source-start');
            }
        }
        this.el.addCls(classes);
    },
    configureAllowedTargetTerminals: function() {
        var allowed = this.dependencyStore.allowedDependencyTypes;
        var classes = [];
        this.el.removeCls([
            'sch-gantt-terminal-allow-target-start',
            'sch-gantt-terminal-allow-target-end'
        ]);
        if (Ext.Array.contains(allowed, 'EndToEnd') || Ext.Array.contains(allowed, 'StartToEnd')) {
            classes.push('sch-gantt-terminal-allow-target-end');
        }
        if (Ext.Array.contains(allowed, 'StartToStart') || Ext.Array.contains(allowed, 'EndToStart')) {
            classes.push('sch-gantt-terminal-allow-target-start');
        }
        this.el.addCls(classes);
    },
    destroy: function() {
        if (this.dragZone) {
            this.dragZone.destroy();
        }
        if (this.dropZone) {
            this.dropZone.destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.util.DragTracker
 * @private
 *
 * Simple drag tracker with an extra useful getRegion method
 **/
Ext.define('Sch.util.DragTracker', {
    extend: 'Ext.dd.DragTracker',
    requires: [
        'Ext.util.Region'
    ],
    /**
     * @cfg {Number} xStep
     * The number of horizontal pixels to snap to when dragging
     */
    xStep: 1,
    /**
     * @cfg {Number} yStep
     * The number of vertical pixels to snap to when dragging
     */
    yStep: 1,
    /**
     * @cfg {Number} deferredTouchActivation
     * The number of ms to defer the activation of the drag tracker for touch interactions
     */
    deferredTouchActivation: 0,
    constructor: function() {
        this.callParent(arguments);
        // ScrollManager might trigger a scroll as we are dragging, trigger manual onMouseMove in this case
        this.on('dragstart', function() {
            var el = this.el;
            var listeners = {
                    scroll: this.onMouseMove,
                    // We only care about single touches
                    pinchstart: this.onMouseUp,
                    scope: this
                };
            el.on(listeners);
            this.on('dragend', function() {
                el.un(listeners);
            }, this, {
                single: true
            });
        });
        this.moveListener = {
            pinchstart: this.abortWait,
            touchend: this.abortWait,
            mouseup: this.abortWait,
            mousemove: this.onMoveWhileWaiting,
            scope: this,
            capture: true
        };
    },
    destroy: function() {
        clearTimeout(this.deferTimer);
        this.callParent(arguments);
    },
    /**
     * Set the number of horizontal pixels to snap to when dragging
     * @param {Number} step
     */
    setXStep: function(step) {
        this.xStep = step;
    },
    startScroll: null,
    deferTimer: null,
    deferTolerance: 10,
    moveListener: null,
    /**
     * Set the number of vertical pixels to snap to when dragging
     * @param {Number} step
     */
    setYStep: function(step) {
        this.yStep = step;
    },
    onMoveWhileWaiting: function(e, t) {
        var xy = e.getXY();
        var s = this.startXY;
        if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.deferTolerance) {
            this.abortWait();
            this.onMouseUp(e);
        }
    },
    abortWait: function() {
        clearTimeout(this.deferTimer);
        this.deferTimer = null;
        Ext.getDoc().un(this.moveListener);
    },
    getRegion: function() {
        var startXY = this.startXY,
            currentScroll = this.el.getScroll();
        // In IE scroll on element will contain scroll from right-most position
        // All calculations are made with assumption scroll is from left edge
        if (Ext.isIE && this.rtl) {
            currentScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - currentScroll.left;
        }
        var currentXY = this.getXY(),
            currentX = currentXY[0],
            currentY = currentXY[1],
            scrollLeftDelta = currentScroll.left - this.startScroll.left,
            scrollTopDelta = currentScroll.top - this.startScroll.top,
            startX = startXY[0] - scrollLeftDelta,
            startY = startXY[1] - scrollTopDelta,
            minX = Math.min(startX, currentX),
            minY = Math.min(startY, currentY),
            width = Math.abs(startX - currentX),
            height = Math.abs(startY - currentY);
        return new Ext.util.Region(minY, minX + width, minY + height, minX);
    },
    // @OVERRIDE
    onMouseDown: function(e, target) {
        var touches = e.event.touches || [];
        // Ignore multi touches
        if (touches.length > 1)  {
            return;
        }
        
        // HACK - Ext calls stopPropagation which prevents global mousedown listeners on the document/body
        // which messes up blur of EventEditor plugin. See event editor tests for reference
        e.stopPropagation = Ext.emptyFn;
        this.startXY = e.getXY();
        if (this.deferredTouchActivation && touches.length === 1) {
            var me = this;
            Ext.getDoc().on(this.moveListener);
            this.deferTimer = setTimeout(function() {
                var old = me.deferredTouchActivation;
                // Detect moves and abort if exceeding threshold
                Ext.getDoc().un(me.moveListener);
                me.deferredTouchActivation = false;
                me.onMouseDown(e, target);
                me.deferredTouchActivation = old;
            }, this.deferredTouchActivation);
            return;
        }
        this.callParent([
            e,
            target
        ]);
        this.lastXY = this.startXY;
        this.startScroll = this.el.getScroll();
        if (Ext.isIE && this.rtl) {
            this.startScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - this.startScroll.left;
        }
    },
    // @OVERRIDE
    // Adds support for snapping to increments while dragging
    onMouseMove: function(e, target) {
        // Bug fix required for IE
        if (this.active && e.type === 'mousemove' && Ext.isIE9m && !e.browserEvent.button) {
            e.preventDefault();
            this.onMouseUp(e);
            return;
        }
        e.preventDefault();
        var xy = e.type === 'scroll' ? this.lastXY : e.getXY(),
            s = this.startXY;
        if (!this.active) {
            if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.tolerance) {
                this.triggerStart(e);
            } else {
                return;
            }
        }
        var x = xy[0],
            y = xy[1];
        // TODO handle if this.el is scrolled
        if (this.xStep > 1) {
            x -= this.startXY[0];
            x = Math.round(x / this.xStep) * this.xStep;
            x += this.startXY[0];
        }
        if (this.yStep > 1) {
            y -= this.startXY[1];
            y = Math.round(y / this.yStep) * this.yStep;
            y += this.startXY[1];
        }
        var snapping = this.xStep > 1 || this.yStep > 1;
        if (!snapping || x !== xy[0] || y !== xy[1]) {
            this.lastXY = [
                x,
                y
            ];
            if (this.fireEvent('mousemove', this, e) === false) {
                this.onMouseUp(e);
            } else {
                this.onDrag(e);
                this.fireEvent('drag', this, e);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.feature.DragCreator
 * @private
 *
 * An internal class which shows a drag proxy while clicking and dragging.
 * Create a new instance of this plugin
 */
Ext.define("Gnt.feature.DragCreator", {
    requires: [
        'Ext.Template',
        'Sch.util.DragTracker',
        'Gnt.Tooltip'
    ],
    /**
     * @cfg {Boolean} disabled true to start disabled
     */
    disabled: false,
    /**
     * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
     */
    showDragTip: true,
    /**
     * @cfg {Object} tooltipConfig A custom config object to apply to the {@link Gnt.Tooltip} instance.
     */
    tooltipConfig: null,
    /**
     * @cfg {Number} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started.
     */
    dragTolerance: 2,
    /**
     * @cfg {Ext.Template/String} template The HTML template shown when dragging to create new items
     */
    template: '<div class="sch-gantt-dragcreator-proxy"></div>',
    /**
     * @cfg {Function} validatorFn An empty function by default.
     * Provide to perform custom validation on the item being created.
     * @param {Ext.data.Model} record the resource for which the task is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the creation event is valid, else false to cancel
     */
    validatorFn: Ext.emptyFn,
    /**
    * @cfg {Object} validatorFnScope
    * The scope for the {@link #validatorFn}
    */
    validatorFnScope: null,
    constructor: function(config) {
        Ext.apply(this, config || {});
        this.init();
    },
    // private
    init: function() {
        var view = this.ganttView,
            gridViewBodyEl = view.el,
            bind = Ext.Function.bind;
        this.lastTime = new Date();
        view.on({
            destroy: this.onGanttDestroy,
            scope: this
        });
        this.tracker = new Sch.util.DragTracker({
            el: gridViewBodyEl,
            tolerance: this.dragTolerance,
            onBeforeStart: bind(this.onBeforeDragStart, this),
            onStart: bind(this.onDragStart, this),
            onDrag: bind(this.onDrag, this),
            onEnd: bind(this.onDragEnd, this)
        });
        if (this.showDragTip) {
            this.dragTip = new Gnt.Tooltip(Ext.apply({
                mode: 'duration',
                cls: 'sch-gantt-dragcreate-tip',
                gantt: view
            }, this.tooltipConfig));
        }
    },
    /**
    * Enables/disables the plugin
    * @param {Boolean} disabled True to disable this plugin
    */
    setDisabled: function(disabled) {
        this.disabled = disabled;
        if (this.dragTip) {
            this.dragTip.setDisabled(disabled);
        }
    },
    getProxy: function() {
        if (!this.proxy) {
            var containerEl = this.ganttView.up('tablepanel').el;
            if (!(this.template instanceof Ext.Template)) {
                this.template = new Ext.Template(this.template);
            }
            // Attach this element to the nested gantt panel element (view el is cleared by refreshes)
            this.proxy = this.template.append(containerEl, {}, true);
        }
        return this.proxy;
    },
    // private
    onBeforeDragStart: function(e) {
        var s = this.ganttView,
            t = e.getTarget('.' + s.timeCellCls, 2);
        if (t && !this.disabled) {
            var record = s.resolveTaskRecord(t);
            var dateTime = s.getDateFromDomEvent(e);
            if (!record.isReadOnly() && !record.getStartDate() && !record.getEndDate() && s.fireEvent('beforedragcreate', s, record, dateTime, e) !== false) {
                e.stopEvent();
                // Save record if the user ends the drag outside the current row
                this.record = record;
                // Start time of the task to be created
                this.originalStart = dateTime;
                // Constrain the dragging within the current row schedule area
                this.rowRegion = s.getScheduleRegion(this.record, this.originalStart);
                // Save date constraints
                this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);
                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },
    // private
    onDragStart: function() {
        var me = this,
            view = me.ganttView,
            proxy = me.getProxy();
        me.start = me.originalStart;
        me.end = me.start;
        me.rowBoundaries = {
            top: me.rowRegion.top,
            bottom: me.rowRegion.bottom
        };
        proxy.setBox({
            x: me.tracker.startXY[0],
            y: me.rowBoundaries.top,
            height: me.rowBoundaries.bottom - me.rowBoundaries.top
        });
        proxy.show();
        view.fireEvent('dragcreatestart', view);
        if (me.showDragTip) {
            me.dragTip.updateContent(me.start, me.end, true, me.record);
            me.dragTip.enable();
            me.dragTip.showBy(proxy);
        }
    },
    // private
    onDrag: function(e) {
        var me = this,
            view = me.ganttView,
            dragRegion = me.tracker.getRegion().constrainTo(me.rowRegion),
            dates = view.getStartEndDatesFromRegion(dragRegion, 'round');
        if (!dates) {
            return;
        }
        me.start = dates.start || me.start;
        me.end = dates.end || me.end;
        var dc = me.dateConstraints;
        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }
        me.valid = me.validatorFn.call(me.validatorFnScope || me, me.record, me.start, me.end, e) !== false;
        if (me.showDragTip) {
            me.dragTip.updateContent(me.start, me.end, me.valid, me.record);
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        me.getProxy().setBox(dragRegion);
    },
    // private
    onDragEnd: function(e) {
        var me = this,
            view = me.ganttView,
            doFinalize = false;
        me.createContext = {
            start: me.start,
            end: me.end,
            e: e,
            record: me.record,
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        if (me.showDragTip) {
            me.dragTip.disable();
        }
        if (!me.start || !me.end || (me.end < me.start)) {
            me.valid = false;
        }
        if (me.valid) {
            doFinalize = view.fireEvent('beforedragcreatefinalize', me, me.createContext, e) !== false;
        }
        if (doFinalize) {
            me.finalize(me.valid);
        }
    },
    finalize: function(doCreate) {
        var me = this,
            context = me.createContext,
            view = me.ganttView;
        if (doCreate) {
            context.record.setStartEndDate(context.start, context.end, context.record.getTaskStore().skipWeekendsDuringDragDrop);
            view.fireEvent('dragcreateend', view, context.record, context.e);
        }
        me.proxy.hide();
        view.fireEvent('afterdragcreate', view);
    },
    onGanttDestroy: function() {
        if (this.dragTip) {
            this.dragTip.destroy();
        }
        if (this.tracker) {
            this.tracker.destroy();
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.feature.LabelEditor
 * @protected
 * @extends Ext.Editor
 *
 * Internal class used by the Gantt chart internals allowing inline editing of the task labels.
 */
Ext.define("Gnt.feature.LabelEditor", {
    extend: "Ext.Editor",
    /**
     * @cfg {String} labelPosition Identifies which side of task this editor is used for. Possible values: 'left', 'right', 'top' or 'bottom'.
     * @property
     */
    labelPosition: '',
    triggerEvent: 'dblclick',
    // private, must be supplied
    delegate: null,
    // The field name to edit - private, must be supplied
    dataIndex: null,
    shadow: false,
    completeOnEnter: true,
    cancelOnEsc: true,
    ignoreNoChange: true,
    ganttView: null,
    constructor: function(ganttView, config) {
        this.ganttView = ganttView;
        this.ganttView.on('afterrender', this.onGanttRender, this);
        Ext.apply(this, config);
        if (this.labelPosition === 'left') {
            this.alignment = 'r-r';
        } else if (this.labelPosition === 'right') {
            this.alignment = 'l-l';
        } else {
            // default for editor is c-c? (constrained)
            // which dosen't work in our case
            this.alignment = 'c-c';
        }
        this.delegate = '.sch-gantt-label-' + this.labelPosition;
        this.callParent([
            config
        ]);
    },
    // Programmatically enter edit mode
    edit: function(record) {
        if (!record.isEditable(this.dataIndex)) {
            return;
        }
        var eventEl = this.ganttView.getElementFromEventRecord(record);
        if (eventEl) {
            var wrap = eventEl.up(this.ganttView.eventWrapSelector);
            var pnl, old;
            this.record = record;
            if (!this.rendered) {
                this.render(this.ganttView.getSecondaryCanvasEl());
            }
            this.startEdit(wrap.down(this.delegate), this.dataIndex ? record.get(this.dataIndex) : '');
        }
    },
    onGanttRender: function(ganttView) {
        if (!this.field.width) {
            this.autoSize = 'width';
        }
        this.on({
            beforestartedit: function(editor, el, value) {
                return ganttView.fireEvent('labeledit_beforestartedit', ganttView, this.record, value, editor);
            },
            beforecomplete: function(editor, value, original) {
                return ganttView.fireEvent('labeledit_beforecomplete', ganttView, value, original, this.record, editor);
            },
            complete: function(editor, value, original) {
                this.record.set(this.dataIndex, value);
                ganttView.fireEvent('labeledit_complete', ganttView, value, original, this.record, editor);
            },
            scope: this
        });
        ganttView.el.on(this.triggerEvent, function(e, t) {
            this.edit(ganttView.resolveTaskRecord(t));
        }, this, {
            delegate: this.delegate
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
* @class Gnt.feature.ProgressBarResize
*
* Internal plugin enabling resizing of a task progress bar, configure this feature using the {@link Gnt.panel.Gantt#progressBarResizeConfig} config setting.
*/
Ext.define("Gnt.feature.ProgressBarResize", {
    requires: [
        'Ext.ToolTip',
        'Ext.resizer.Resizer'
    ],
    /**
    * @cfg {Boolean} useTooltip false to not show a tooltip while resizing. Defaults to true.
    */
    useTooltip: true,
    /**
    * @cfg {Number} increment
    * The increment in percent to use during a progress element resize
    */
    increment: 10,
    tip: null,
    resizable: null,
    ganttView: null,
    constructor: function(config) {
        Ext.apply(this, config || {});
        var g = this.ganttView;
        g.on({
            destroy: this.cleanUp,
            scope: this
        });
        g.el.on('mousedown', this.onMouseDown, this, {
            delegate: '.sch-gantt-progressbar-handle'
        });
        this.callParent(arguments);
    },
    onMouseDown: function(e, t) {
        var g = this.ganttView,
            rec = g.resolveTaskRecord(t);
        if (g.fireEvent('beforeprogressbarresize', g, rec) !== false) {
            var progBar = Ext.fly(t).prev('.sch-gantt-progress-bar');
            e.stopEvent();
            progBar.addCls('sch-progress-bar-resizing');
            this.resizable = this.createResizable(progBar, rec, e);
            g.fireEvent('progressbarresizestart', g, rec);
            // If the mouse isn't moved after mousedown, no resize event will be fired by the Ext.Resizable. Handle this case manually
            Ext.getBody().on('mouseup', this.onBodyMouseUp, this, {
                single: true,
                delay: 1
            });
        }
    },
    // private
    createResizable: function(el, taskRecord, e) {
        var rtl = this.ganttView.rtl,
            taskEl = el.up(this.ganttView.eventSelector),
            taskWidth = taskEl.getWidth() - 2 * this.ganttView.eventBorderWidth,
            widthIncrement = taskWidth * this.increment / 100;
        var rz = Ext.create('Ext.resizer.Resizer', {
                target: el,
                taskRecord: taskRecord,
                handles: rtl ? 'w' : 'e',
                minWidth: 0,
                maxWidth: taskWidth,
                minHeight: 1,
                widthIncrement: widthIncrement,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            });
        rz.resizeTracker.onMouseDown(e, rz[rtl ? 'west' : 'east'].dom);
        taskEl.addCls('sch-gantt-resizing');
        if (this.useTooltip) {
            this.tip = Ext.create("Ext.ToolTip", {
                autoHide: false,
                anchor: 'b',
                html: '%'
            });
            this.tip.setTarget(el);
            this.tip.update(taskRecord.getPercentDone() + '%');
            this.tip.show();
        }
        return rz;
    },
    // private
    partialResize: function(rz, newWidth) {
        var percent = Math.round(newWidth * 100 / (rz.maxWidth * this.increment)) * this.increment;
        if (this.tip) {
            this.tip.body.update(percent + '%');
        }
    },
    // private
    afterResize: function(rz, w, h, e) {
        var rec = rz.taskRecord;
        if (this.tip) {
            this.tip.destroy();
            this.tip = null;
        }
        var old = rz.taskRecord.getPercentDone();
        if (Ext.isNumber(w)) {
            var percent = Math.round(w * 100 / (rz.maxWidth * this.increment)) * this.increment;
            // Constrain between 0-100
            percent = Math.min(100, Math.max(0, percent));
            rz.taskRecord.setPercentDone(percent);
        }
        if (old === rz.taskRecord.getPercentDone()) {
            // Value didn't change, manually refresh the row
            this.ganttView.refreshNode(this.ganttView.indexOf(rz.taskRecord));
        }
        // Destroy resizable
        rz.destroy();
        this.resizable = null;
        this.ganttView.fireEvent('afterprogressbarresize', this.ganttView, rec);
    },
    // If the new percent done is the same as the old, no resize event will be fired by the Ext.Resizable. Handle this case manually
    onBodyMouseUp: function() {
        if (this.resizable) {
            this.afterResize(this.resizable);
        }
    },
    cleanUp: function() {
        if (this.tip) {
            this.tip.destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.feature.TaskDragDrop
 * @extends Ext.dd.DragZone
 * @private
 *
 * Internal plugin enabling drag and drop for tasks
 */
Ext.define("Gnt.feature.TaskDragDrop", {
    extend: "Ext.dd.DragZone",
    requires: [
        'Gnt.Tooltip',
        'Ext.dd.StatusProxy'
    ],
    /**
     * @cfg {Boolean} useTooltip `false` to not show a tooltip while dragging
     */
    useTooltip: true,
    /**
     * @cfg {Object} tooltipConfig A custom config object to apply to the {@link Gnt.Tooltip} instance.
     */
    tooltipConfig: null,
    /**
     * @cfg {Function} validatorFn An empty function by default.
     * Provide to perform custom validation on the item being dragged.
     * This function is called during the drag and drop process and also after the drop is made.
     * @param {Gnt.model.Task} record The record being dragged
     * @param {Date} date The new start date
     * @param {Number} duration The duration of the item being dragged, in minutes
     * @param {Ext.EventObject} e The event object
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    validatorFn: function(record, date, duration, e) {
        return true;
    },
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn, defaults to the gantt view instance
     */
    validatorFnScope: null,
    /**
     * @cfg {Boolean} showExactDropPosition When enabled, the task being dragged always "snaps" to the exact start date / duration that it will have after being drop.
     */
    showExactDropPosition: false,
    // has to be set to `false` - we'll register the gantt view in the ScrollManager manually
    containerScroll: false,
    dropAllowed: "sch-gantt-dragproxy",
    dropNotAllowed: "sch-gantt-dragproxy",
    // Reference to the gantt view
    gantt: null,
    // Don't seem to need these
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    tip: null,
    skipWeekendsDuringDragDrop: false,
    taskSelector: null,
    deadlineSelector: null,
    invalidTargetSelector: [
        // Stop task drag and drop when a resize handle, a terminal or a parent task is clicked
        '.' + Ext.baseCSSPrefix + 'resizable-handle',
        '.sch-resizable-handle',
        '.sch-gantt-terminal',
        '.sch-gantt-progressbar-handle',
        '.sch-rollup-task',
        '.sch-gantt-baseline-item .sch-gantt-item'
    ].join(','),
    constructor: function(viewEl, config) {
        // We want the proxy to live inside the view parent element since the view element is volatile as it refreshes.
        var el = config.el = viewEl.up();
        config = config || {};
        Ext.apply(this, config);
        // Drag drop won't work in IE8 if running in an iframe
        // https://www.assembla.com/spaces/bryntum/tickets/712#/activity/ticket:
        if (Ext.isIE && (Ext.isIE8 || Ext.ieVersion < 9) && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true;
        }
        this.proxy = this.proxy || new Ext.dd.StatusProxy({
            shadow: false,
            dropAllowed: "sch-gantt-dragproxy",
            dropNotAllowed: "sch-gantt-dragproxy",
            // HACK, we want the proxy inside the gantt chart, otherwise drag drop breaks in fullscreen mode
            ensureAttachedToBody: Ext.emptyFn
        });
        this.gantt.rtl && this.proxy.addCls('sch-rtl');
        var me = this,
            gantt = me.gantt;
        if (me.useTooltip) {
            me.tip = new Gnt.Tooltip(Ext.apply({
                cls: 'gnt-dragdrop-tip',
                gantt: gantt
            }, me.tooltipConfig));
        }
        me.callParent([
            el,
            Ext.apply(config, {
                ddGroup: gantt.id + '-task-dd'
            })
        ]);
        me.scroll = false;
        me.isTarget = true;
        me.ignoreSelf = false;
        el.appendChild(me.proxy.el);
        gantt.on({
            destroy: me.destroy,
            scope: me
        });
    },
    destroy: function() {
        if (this.tip) {
            this.tip.destroy();
        }
        clearTimeout(this.validDropTimer);
        this.callParent(arguments);
    },
    // On receipt of a mousedown event, see if it is within a draggable element.
    // Return a drag data object if so. The data object can contain arbitrary application
    // data, but it should also contain a DOM element in the ddel property to provide
    // a proxy to drag.
    getDragData: function(e) {
        if (Ext.fly(e.getTarget()).is(this.invalidTargetSelector)) {
            return;
        }
        var taskEl = e.getTarget(this.taskSelector);
        var deadlineEl = !taskEl && e.getTarget(this.deadlineSelector);
        var elementToDrag = taskEl || deadlineEl;
        if (elementToDrag) {
            var ganttView = this.gantt;
            var segmentNode = taskEl && e.getTarget('.sch-gantt-task-segment');
            var sourceTask = ganttView.resolveTaskRecord(elementToDrag);
            var segmentIndex = 0;
            var minDate, maxDate, constrainingRegion;
            if (!sourceTask || sourceTask.isReadOnly()) {
                return;
            }
            // Check if we're dragging a split-task segment
            if (segmentNode) {
                segmentIndex = Number(segmentNode.getAttribute('data-segmentIndex'));
                // Dragging the first segment means move the entire task, otherwise drag the segment node
                if (segmentIndex > 0) {
                    elementToDrag = segmentNode;
                    sourceTask = sourceTask.getSegment(segmentIndex);
                }
            }
            if (taskEl && ganttView.fireEvent('beforetaskdrag', ganttView, sourceTask, e) === false) {
                return;
            }
            var xy = e.getXY();
            var copy = elementToDrag.cloneNode(true),
                increment = this.showExactDropPosition ? 0 : ganttView.getSnapPixelAmount(),
                origXY = Ext.fly(elementToDrag).getXY();
            var offsets = [
                    xy[0] - origXY[0],
                    xy[1] - origXY[1]
                ];
            copy.id = Ext.id();
            var height = Ext.fly(elementToDrag).getHeight();
            var width = Ext.fly(elementToDrag).getWidth();
            // Height needs to be hardcoded since the copied task bar is put in the drag proxy
            Ext.fly(copy).setHeight(height);
            if (Ext.isIE8m && taskEl && sourceTask.isMilestone()) {
                Ext.fly(copy).setSize(height + 5, height + 5);
            }
            if (!ganttView.rtl) {
                copy.style.left = -offsets[0] + 'px';
            } else {
                copy.style.left = width - offsets[0] + 'px';
            }
            // BEGIN CONSTRAINING PROXY ELEMENT
            if (segmentIndex > 0) {
                var previousSibling = sourceTask.getPrevSegment();
                var nextSibling = sourceTask.getNextSegment();
                minDate = Sch.util.Date.max(previousSibling.getEndDate(), ganttView.timeAxis.getStart());
                maxDate = nextSibling ? Sch.util.Date.min(nextSibling.getStartDate(), ganttView.timeAxis.getEnd()) : ganttView.timeAxis.getEnd();
                // Limit the dragging to the sibling segments (if any)
                constrainingRegion = {
                    left: ganttView.getCoordinateFromDate(minDate, false) + offsets[0],
                    right: ganttView.getCoordinateFromDate(maxDate, false) - width + offsets[0]
                };
            } else {
                constrainingRegion = Ext.fly(ganttView.findItemByChild(elementToDrag)).getRegion();
            }
            this.constrainTo(constrainingRegion, Ext.fly(elementToDrag).getRegion(), offsets[0], offsets[1]);
            // EOF CONSTRAINING PROXY ELEMENT
            if (increment >= 1) {
                this.setXConstraint(this.leftConstraint, this.rightConstraint, increment);
            }
            return {
                sourceNode: elementToDrag,
                repairXY: origXY,
                offsetX: offsets[0],
                ddel: copy,
                record: sourceTask,
                duration: Sch.util.Date.getDurationInMinutes(sourceTask.getStartDate(), sourceTask.getEndDate()),
                startPointDate: ganttView.getDateFromCoordinate(xy[0]),
                minDate: minDate,
                maxDate: maxDate,
                start: null,
                isTaskDrag: Boolean(taskEl),
                originalStart: taskEl ? sourceTask.getStartDate() : sourceTask.getDeadlineDate(),
                // cached value of the validity of the drop position
                // Initialize to false for task drag, this value is continuously updated on mouse move.
                // For deadline elements, no validation is done and the operation is assumed to always be valid
                valid: Boolean(deadlineEl)
            };
        }
    },
    onDragOver: function(e) {
        var dragContext = this.dragData,
            task = dragContext.record,
            origStart = dragContext.originalStart,
            gantt = this.gantt,
            newStart = gantt.getDateFromCoordinate(e.getXY()[0]);
        if (!dragContext.hidden) {
            Ext.fly(dragContext.sourceNode).hide();
            dragContext.hidden = true;
        }
        // User might have dragged proxy outside of the time axis area, just ignore
        if (!newStart)  {
            return;
        }
        
        var timeDiff = newStart - dragContext.startPointDate;
        var realStart = new Date(origStart - 0 + timeDiff);
        var proxyEl = this.proxy.el;
        if (dragContext.minDate) {
            realStart = Sch.util.Date.constrain(new Date(origStart - 0 + timeDiff), dragContext.minDate, dragContext.maxDate);
        }
        // the time diff method can be used for continuous time axis only
        // fallback to proxy element position resolving for filtered time axis
        if (gantt.timeAxis.isContinuous()) {
            newStart = gantt.timeAxis.roundDate(realStart, gantt.snapRelativeToEventStartDate ? origStart : false);
        } else {
            // Adjust x position for certain task types
            var x = proxyEl.getX() + (gantt.rtl ? proxyEl.getWidth() : 0) + gantt.getXOffset(task) - dragContext.offsetX;
            newStart = gantt.getDateFromXY([
                x,
                0
            ], 'round');
        }
        if (dragContext.isTaskDrag) {
            this.onTaskDrag(task, e, newStart, realStart);
        } else if (newStart && newStart - origStart !== 0) {
            this.onCustomElementDrag(task, e, newStart);
        }
        dragContext.start = newStart;
    },
    onTaskDrag: function(task, e, newStart, realStart) {
        var dragContext = this.dragData;
        var gantt = this.gantt;
        if (this.showExactDropPosition && this.skipWeekendsDuringDragDrop) {
            var offsetX = 0;
            var afterDropStart = task.skipNonWorkingTime(newStart, !task.isMilestone());
            var newEnd = task.recalculateEndDate(afterDropStart);
            if (realStart.getTime() != afterDropStart.getTime()) {
                offsetX = gantt.timeAxisViewModel.getDistanceBetweenDates(realStart, afterDropStart);
            }
            if (realStart > gantt.timeAxis.getStart()) {
                Ext.fly(dragContext.ddel.id).setWidth(gantt.timeAxisViewModel.getDistanceBetweenDates(afterDropStart, Sch.util.Date.min(newEnd, gantt.timeAxis.getEnd())));
                if (offsetX) {
                    this.proxy.setX(this.proxy.getX() + offsetX);
                }
            }
        }
        if (newStart && newStart - dragContext.start !== 0) {
            dragContext.valid = this.validatorFn.call(this.validatorFnScope || gantt, task, newStart, dragContext.duration, e) !== false;
            if (this.tip) {
                var end = task.calculateEndDate(newStart, task.getDuration(), task.getDurationUnit());
                this.updateTip(task, newStart, end, dragContext.valid);
            }
        }
    },
    onCustomElementDrag: function(task, e, date) {
        if (this.tip) {
            this.updateTip(task, date, date, true);
        }
    },
    onStartDrag: function() {
        var dd = this.dragData;
        var rec = dd.record;
        var tip = this.tip;
        if (tip) {
            tip.enable();
            this.updateTip(rec, this.dragData.originalStart, rec.getEndDate());
            tip.showBy(this.dragData.sourceNode, dd.repairXY[0] + dd.offsetX);
        }
        if (this.dragData.isTaskDrag) {
            this.gantt.fireEvent('taskdragstart', this.gantt, rec);
        }
    },
    updateTip: function(record, start, end) {
        if (this.dragData.isTaskDrag) {
            if (record.isMilestone() && start - Ext.Date.clearTime(start, true) === 0) {
                start = Sch.util.Date.add(start, Sch.util.Date.MILLI, -1);
                end = Sch.util.Date.add(end, Sch.util.Date.MILLI, -1);
            }
            this.tip.updateContent(start, end, true, record);
        } else {
            // nullify the start and pass only end date if we're dealing with a single point in time and not a range
            this.tip.updateContent(null, start, true, record);
        }
    },
    // Override, get rid of weird highlight fx in default implementation
    afterRepair: function() {
        Ext.fly(this.dragData.sourceNode).show();
        if (this.tip) {
            this.tip.hide();
        }
        this.dragging = false;
    },
    // Provide coordinates for the proxy to slide back to on failed drag.
    // This is the original XY coordinates of the draggable element.
    getRepairXY: function() {
        this.dragData.isTaskDrag && this.gantt.fireEvent('aftertaskdrop', this.gantt);
        return this.dragData.repairXY;
    },
    onDragDrop: function(e, id) {
        var me = this,
            target = me.cachedTarget || Ext.dd.DragDropMgr.getDDById(id),
            dragContext = me.dragData,
            gantt = me.gantt,
            start = dragContext.start,
            doFinalize = true,
            validDrop = dragContext.valid && start && dragContext.originalStart - start !== 0;
        dragContext.ddCallbackArgs = [
            target,
            e,
            id
        ];
        if (this.tip) {
            this.tip.disable();
        }
        // If all seems ok, allow implementer to do an asynchronous last validation
        if (dragContext.isTaskDrag && validDrop) {
            dragContext.finalize = function() {
                me.finalize.apply(me, arguments);
            };
            // Allow implementor to take control of the flow, by returning false from this listener,
            // to show a confirmation popup etc.
            doFinalize = gantt.fireEvent('beforetaskdropfinalize', gantt, dragContext, e) !== false;
        }
        if (doFinalize) {
            this.finalize(validDrop);
        }
    },
    finalize: function(updateRecords) {
        var me = this,
            dragContext = this.dragData,
            gantt = this.gantt,
            task = dragContext.record,
            start = dragContext.start,
            previousStartDate, currentStartDate;
        if (updateRecords) {
            previousStartDate = dragContext.originalStart;
            if (dragContext.isTaskDrag) {
                task.setStartDate(start, true, this.skipWeekendsDuringDragDrop, function() {
                    currentStartDate = task.getStartDate();
                    if (previousStartDate - currentStartDate !== 0) {
                        gantt.fireEvent('taskdrop', gantt, task);
                        // For our good friend IE9, the pointer cursor gets stuck without the defer
                        if (Ext.isIE9) {
                            me.proxy.el.setStyle('visibility', 'hidden');
                            me.validDropTimer = Ext.Function.defer(me.onValidDrop, 10, me, dragContext.ddCallbackArgs);
                        } else {
                            me.onValidDrop.apply(me, dragContext.ddCallbackArgs);
                        }
                    } else {
                        me.onInvalidDrop.apply(me, dragContext.ddCallbackArgs);
                    }
                    gantt.fireEvent('aftertaskdrop', gantt, task);
                });
            } else {
                task.setDeadlineDate(start);
                me.onValidDrop.apply(me, dragContext.ddCallbackArgs);
            }
        } else {
            me.onInvalidDrop.apply(me, dragContext.ddCallbackArgs);
            dragContext.isTaskDrag && gantt.fireEvent('aftertaskdrop', gantt, task);
        }
    },
    // HACK: Override for IE (or touch capable monitors), if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // Ext JS calls with only the 'e' argument in this case which is a bit weird
    // https://www.assembla.com/spaces/bryntum/tickets/716
    onInvalidDrop: function(target, e, id) {
        if (!e) {
            e = target;
            target = target.getTarget() || document.body;
        }
        if (this.tip) {
            this.tip.disable();
        }
        return this.callParent([
            target,
            e,
            id
        ]);
    },
    // CONSTRAINING OVERRIDES
    // @OVERRIDE
    autoOffset: function() {
        this.setDelta(0, 0);
    },
    // @OVERRIDE
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = iLeft;
        this.rightConstraint = iRight;
        this.minX = iLeft;
        this.maxX = iRight;
        if (iTickSize) {
            this.setXTicks(this.initPageX, iTickSize);
        }
        this.constrainX = true;
    },
    // @OVERRIDE
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = iUp;
        this.bottomConstraint = iDown;
        this.minY = iUp;
        this.maxY = iDown;
        if (iTickSize) {
            this.setYTicks(this.initPageY, iTickSize);
        }
        this.constrainY = true;
    },
    constrainTo: function(constrainingRegion, elRegion, offsetX, offsetY) {
        this.resetConstraints();
        this.initPageX = constrainingRegion.left + offsetX;
        this.initPageY = elRegion.top + offsetY;
        this.setXConstraint(constrainingRegion.left, constrainingRegion.right, this.xTickSize);
        this.setYConstraint(elRegion.top - 1, elRegion.top - 1, this.yTickSize);
    },
    // EOF CONSTRAINING OVERRIDES
    // SCROLLMANAGER OVERRIDES
    startDrag: function() {
        this.gantt.el.ddScrollConfig = {
            increment: Ext.dd.ScrollManager.increment,
            hthresh: Ext.dd.ScrollManager.hthresh,
            // disable the vertical container scroll while dragging the task
            vthresh: -1
        };
        return this.callParent(arguments);
    },
    endDrag: function() {
        // remove previous constraints for container scroll
        delete this.gantt.el.ddScrollConfig;
        return this.callParent(arguments);
    }
});
// EOF SCROLLMANAGER OVERRIDES

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.feature.TaskResize
 @extends Ext.util.Observable

 A plugin enabling the task resizing feature. Generally there's no need to manually create it,
 it can be activated with the {@link Gnt.panel.Gantt#taskResizeHandles} option of the gantt panel and configured with the {@link Gnt.panel.Gantt#resizeConfig}.


 */
Ext.define("Gnt.feature.TaskResize", {
    requires: [
        'Ext.resizer.Resizer',
        'Gnt.Tooltip'
    ],
    constructor: function(config) {
        Ext.apply(this, config);
        var g = this.ganttView;
        g.on({
            destroy: this.cleanUp,
            scope: this
        });
        g.mon(g.el, 'mousedown', this.onMouseDown, this, {
            delegate: '.sch-resizable-handle'
        });
        this.callParent(arguments);
    },
    /**
     * @cfg {Boolean} showDuration true to show the duration instead of the end date when resizing a task
     */
    showDuration: true,
    /**
     * @type {Boolean} showExactResizePosition true to see exact task length during resizing
     */
    showExactResizePosition: false,
    /**
     * @cfg {Boolean} useTooltip `False` to not show a tooltip while resizing
     */
    useTooltip: true,
    /**
     * @cfg {Object} tooltipConfig A custom config object to apply to the {@link Gnt.Tooltip} instance.
     */
    tooltipConfig: null,
    /**
     * @cfg {Function} validatorFn An empty function by default.
     * Provide to perform custom validation on the item being resized.
     * @param {Ext.data.Model} record The task being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the creation event is valid, else false to cancel
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    taskRec: null,
    taskEl: null,
    isStart: null,
    ganttView: null,
    resizable: null,
    onMouseDown: function(e, t) {
        var ganttView = this.ganttView;
        var segmentNode = e.getTarget('.sch-gantt-task-segment');
        var taskNode = e.getTarget(ganttView.eventSelector);
        var taskRecord = ganttView.resolveTaskRecord(taskNode);
        // Check if we're resizing a split-task segment
        if (segmentNode) {
            taskNode = segmentNode;
            taskRecord = taskRecord.getSegment(parseInt(segmentNode.getAttribute('data-segmentIndex'), 10));
        }
        var isResizable = taskRecord.isResizable();
        // Don't trigger on right clicks
        if (e.button !== 0 || isResizable === false || typeof isResizable === 'string' && !taskNode.className.match(isResizable)) {
            return;
        }
        // Allow observers to abort the resize operation
        if (ganttView.fireEvent('beforetaskresize', ganttView, taskRecord, e) === false) {
            return;
        }
        e.stopEvent();
        this.taskEl = Ext.get(taskNode);
        this.taskRec = taskRecord;
        this.isStart = !!t.className.match('sch-resizable-handle-start');
        ganttView.el.on({
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            scope: this,
            single: true
        });
    },
    // private
    onMouseMove: function(e, t) {
        var g = this.ganttView,
            record = this.taskRec,
            taskEl = this.taskEl,
            rtl = g.rtl,
            isStart = this.isStart,
            isWest = (rtl && !isStart) || (!rtl && isStart),
            widthIncrement = g.getSnapPixelAmount(),
            currentWidth = taskEl.getWidth(),
            maxWidth, sibling;
        // Not all zoom levels support perfect snapping (e.g. in Month view we cannot snap to days)
        widthIncrement = Math.max(1, widthIncrement);
        var resizerConfig = {
                otherEdgeX: isWest ? taskEl.getRight() : taskEl.getLeft(),
                target: taskEl,
                record: record,
                isStart: isStart,
                isWest: isWest,
                handles: isWest ? 'w' : 'e',
                minHeight: 1,
                minWidth: widthIncrement,
                widthIncrement: widthIncrement,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            };
        if (record instanceof Gnt.model.TaskSegment && (sibling = this.taskEl.next('.sch-gantt-task-segment'))) {
            // Segment tasks in a split-task are constrained horizontally to the following segment border
            resizerConfig.maxWidth = rtl ? sibling.getRight() - taskEl.getRight() : sibling.getLeft() - taskEl.getLeft();
        }
        // Normal tasks, and last segment in a split-task are constrained to the row element
        resizerConfig.constrainRegion = taskEl.up(g.getItemSelector()).getRegion();
        taskEl.addCls('sch-gantt-resizing');
        this.ganttView.fireEvent('taskresizestart', this.ganttView, this.taskRec);
        // Since percent complete indicator uses fixed amount of pixels, we need to switch
        // it to use % during the resize operation (visual indication only)
        var progressBarEl = taskEl.down('.sch-gantt-progress-bar');
        if (progressBarEl) {
            progressBarEl.setWidth(100 * progressBarEl.getWidth() / taskEl.getWidth() + '%');
        }
        this.resizable = Ext.create('Ext.resizer.Resizer', resizerConfig);
        // HACK calling private method
        this.resizable.resizeTracker.onMouseDown(e, this.resizable[isWest ? 'west' : 'east'].dom);
        if (this.useTooltip) {
            if (!this.tip) {
                this.tip = Ext.create("Gnt.Tooltip", Ext.apply({
                    mode: this.showDuration ? 'duration' : 'startend',
                    gantt: this.ganttView
                }, this.tooltipConfig));
            } else {
                this.tip.enable();
            }
            this.tip.showBy(taskEl, e.getX());
            this.tip.updateContent(record.getStartDate(), record.getEndDate(), true, record);
            // Catch case of user not moving the mouse at all
            Ext.getBody().on('mouseup', function() {
                this.tip.disable();
            }, this, {
                single: true
            });
        }
    },
    onMouseUp: function(e, t) {
        var g = this.ganttView;
        g.el.un({
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            scope: this,
            single: true
        });
    },
    // private
    partialResize: function(resizer, newWidth, oldWidth, e) {
        var ganttView = this.ganttView,
            isWest = resizer.isWest,
            task = resizer.record,
            cursorDate;
        // we need actual date under cursor
        if (isWest) {
            cursorDate = ganttView.getDateFromCoordinate(resizer.otherEdgeX - Math.min(newWidth, this.resizable.maxWidth), !this.showExactResizePosition ? 'round' : null);
        } else {
            cursorDate = ganttView.getDateFromCoordinate(resizer.otherEdgeX + Math.min(newWidth, this.resizable.maxWidth), !this.showExactResizePosition ? 'round' : null);
        }
        if (!cursorDate || resizer.date - cursorDate === 0) {
            return;
        }
        var start, end, newDate;
        if (this.showExactResizePosition) {
            var adjustedDate = ganttView.timeAxis.roundDate(cursorDate, ganttView.snapRelativeToEventStartDate ? task.getStartDate() : false);
            adjustedDate = task.skipNonWorkingTime(adjustedDate, !task.isMilestone());
            var target = resizer.target.el,
                exactWidth;
            if (isWest) {
                start = task.skipNonWorkingTime(adjustedDate, !task.isMilestone());
                newDate = start;
                exactWidth = ganttView.timeAxisViewModel.getDistanceBetweenDates(start, task.getEndDate());
                target.setWidth(exactWidth);
                var offsetX = ganttView.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                target.setX(target.getX() + offsetX);
            } else {
                // to calculate endDate properly we have to clone task and set endDate
                var clone = Gnt.util.Data.cloneModelSet([
                        task
                    ])[0];
                var taskStore = task.getTaskStore();
                clone.setTaskStore(taskStore);
                clone.setCalendar(task.getCalendar());
                clone.setEndDateWithoutPropagation(adjustedDate, false, taskStore.skipWeekendsDuringDragDrop);
                end = clone.getEndDate();
                newDate = end;
                exactWidth = ganttView.timeAxisViewModel.getDistanceBetweenDates(task.getStartDate(), end);
                target.setWidth(exactWidth);
            }
        } else {
            start = resizer.isStart ? cursorDate : resizer.record.getStartDate();
            end = resizer.isStart ? resizer.record.getEndDate() : cursorDate;
            newDate = cursorDate;
        }
        resizer.date = newDate;
        ganttView.fireEvent('partialtaskresize', ganttView, task, start, end, resizer.el, e);
        if (this.useTooltip) {
            var valid = this.validatorFn.call(this.validatorFnScope || this, task, start, end) !== false;
            this.tip.updateContent(start, end, valid, task);
        }
    },
    // private
    afterResize: function(resizer, w, h, e) {
        if (this.useTooltip) {
            this.tip.disable();
        }
        var me = this,
            record = resizer.record,
            oldStart = record.getStartDate(),
            oldEnd = record.getEndDate(),
            start = resizer.isStart ? resizer.date : oldStart,
            end = resizer.isStart ? oldEnd : resizer.date,
            ganttView = me.ganttView,
            modified = false,
            doFinalize = true;
        me.resizeContext = {
            record: record,
            start: start,
            end: end,
            oldStart: record.getStartDate(),
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        if (start && end && // Input sanity check
        (start - oldStart || end - oldEnd) && // Make sure start OR end changed
        me.validatorFn.call(me.validatorFnScope || me, record, start, end, e) !== false) {
            doFinalize = ganttView.fireEvent('beforetaskresizefinalize', me, me.resizeContext, e) !== false;
            modified = true;
        } else {
            ganttView.refreshKeepingScroll();
        }
        if (doFinalize) {
            me.finalize(modified);
        }
    },
    finalize: function(updateRecord) {
        var me = this,
            view = me.ganttView,
            context = me.resizeContext,
            record = context.record,
            rowTask = record.task || record,
            // Make sure we tell the view to resize a record in its store, and not a segment
            skipWeekends = view.taskStore.skipWeekendsDuringDragDrop,
            previousDate, newDate;
        if (updateRecord) {
            // start <= end is "normal" case
            // start > end is case when task should be resized to 0
            if (context.start - context.oldStart !== 0) {
                previousDate = record.getStartDate();
                newDate = context.start <= context.end ? context.start : context.end;
                record.setStartDate(newDate, false, skipWeekends, function(cancelChanges, affectedTasks) {
                    newDate = record.getStartDate();
                    if (!(newDate < previousDate || newDate > previousDate)) {
                        view.refreshNode(view.store.indexOf(rowTask));
                    }
                    view.fireEvent('aftertaskresize', view, rowTask);
                });
            } else {
                previousDate = record.getEndDate();
                newDate = context.start <= context.end ? context.end : context.start;
                record.setEndDate(newDate, false, skipWeekends, function(cancelChanges, affectedTasks) {
                    newDate = record.getEndDate();
                    if (!(newDate < previousDate || newDate > previousDate)) {
                        view.refreshNode(view.store.indexOf(rowTask));
                    }
                    view.fireEvent('aftertaskresize', view, rowTask);
                });
            }
        } else {
            view.refreshNode(view.store.indexOf(rowTask));
            view.fireEvent('aftertaskresize', view, rowTask);
        }
        // Destroy resizable
        me.resizable.destroy();
        me.resizeContext = null;
    },
    cleanUp: function() {
        if (this.tip) {
            this.tip.destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
@class Gnt.field.ReadOnly
@extends Ext.form.field.Checkbox

A specialized field allowing a user to switch a task to readonly mode.

*/
Ext.define('Gnt.field.ReadOnly', {
    extend: 'Ext.form.field.Checkbox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.readonlyfield',
    alternateClassName: [
        'Gnt.widget.ReadOnlyField'
    ],
    taskField: 'readOnlyField',
    setTaskValueMethod: 'setReadOnly',
    getTaskValueMethod: 'getReadOnly',
    instantUpdate: true,
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    getValue: function() {
        return this.value;
    },
    setValue: function(value) {
        this.callParent([
            value
        ]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.field.ShowInTimeline', {
    extend: 'Ext.form.field.Checkbox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.showintimelinefield',
    alternateClassName: [
        'Gnt.widget.ShowInTimelineField'
    ],
    taskField: 'showInTimelineField',
    setTaskValueMethod: 'setShowInTimeline',
    getTaskValueMethod: 'getShowInTimeline',
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    setValue: function(value) {
        this.callParent(arguments);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.model.TaskSegment
@extends Gnt.model.Task

This class represents a segment of a split task in your Gantt chart.

*/
Ext.define('Gnt.model.TaskSegment', {
    extend: 'Gnt.model.Task',
    /**
     * @hide
     * @method setName
     */
    /**
     * @hide
     * @method getName
     */
    /**
     * @hide
     * @cfg autoCalculateEffortForParentTask
     */
    /**
     * @hide
     * @cfg autoCalculatePercentDoneForParentTask
     */
    /**
     * @hide
     * @cfg baselineEndDateField
     */
    /**
     * @hide
     * @cfg baselinePercentDoneField
     */
    /**
     * @hide
     * @cfg baselineStartDateField
     */
    /**
     * @hide
     * @cfg calendar
     */
    /**
     * @hide
     * @cfg calendarIdField
     */
    /**
     * @hide
     * @cfg constraintDateField
     */
    /**
     * @hide
     * @cfg constraintTypeField
     */
    /**
     * @hide
     * @cfg convertEmptyParentToLeaf
     */
    /**
     * @hide
     * @cfg draggableField
     */
    /**
     * @hide
     * @cfg effortField
     */
    /**
     * @hide
     * @cfg effortUnitField
     */
    /**
     * @hide
     * @cfg manuallyScheduledField
     */
    /**
     * @hide
     * @cfg percentDoneField
     */
    /**
     * @hide
     * @cfg phantomParentIdField
     */
    /**
     * @hide
     * @cfg resizableField
     */
    /**
     * @hide
     * @cfg rollupField
     */
    /**
     * @hide
     * @cfg schedulingModeField
     */
    /**
     * @hide
     * @cfg taskStore
     */
    /**
     * @hide
     * @cfg dependencyStore
     */
    /**
     * @hide
     * @property assignments
     */
    /**
     * @hide
     * @property predecessors
     */
    /**
     * @hide
     * @property successors
     */
    /**
     * @hide
     * @method addMilestone
     */
    /**
     * @hide
     * @method addPredecessor
     */
    /**
     * @hide
     * @method addSubtask
     */
    /**
     * @hide
     * @method addSuccessor
     */
    /**
     * @hide
     * @method addTaskAbove
     */
    /**
     * @hide
     * @method addTaskBelow
     */
    /**
     * @hide
     * @method assign
     */
    /**
     * @hide
     * @method cascadeChanges
     */
    /**
     * @hide
     * @method cascadeChildren
     */
    /**
     * @hide
     * @method convertToMilestone
     */
    /**
     * @hide
     * @method convertToRegular
     */
    /**
     * @hide
     * @method forEachDate
     */
    /**
     * @hide
     * @method getAllDependencies
     */
    /**
     * @hide
     * @method getAssignmentFor
     */
    /**
     * @hide
     * @method getAssignmentStore
     */
    /**
     * @hide
     * @method getAssignments
     */
    /**
     * @hide
     * @method getBaselineEndDate
     */
    /**
     * @hide
     * @method getBaselinePercentDone
     */
    /**
     * @hide
     * @method getBaselineStartDate
     */
    /**
     * @hide
     * @method setBaselineEndDate
     */
    /**
     * @hide
     * @method setBaselinePercentDone
     */
    /**
     * @hide
     * @method setBaselineStartDate
     */
    /**
     * @hide
     * @method getCalendar
     */
    /**
     * @hide
     * @method getCalendarDuration
     */
    /**
     * @hide
     * @method getConstraintClass
     */
    /**
     * @hide
     * @method getDates
     */
    /**
     * @hide
     * @method getDependencyStore
     */
    /**
     * @hide
     * @method getDisplayEndDate
     */
    /**
     * @hide
     * @method getDisplayStartDate
     */
    /**
     * @hide
     * @method getEarlyEndDate
     */
    /**
     * @hide
     * @method getEarlyStartDate
     */
    /**
     * @hide
     * @method getEffort
     */
    /**
     * @hide
     * @method getEffortUnit
     */
    /**
     * @hide
     * @method getIncomingDependencies
     */
    /**
     * @hide
     * @method getLateEndDate
     */
    /**
     * @hide
     * @method getLateStartDate
     */
    /**
     * @hide
     * @method getOutgoingDependencies
     */
    /**
     * @hide
     * @method getOwnCalendar
     */
    /**
     * @hide
     * @method getPercentDone
     */
    /**
     * @hide
     * @method getPredecessors
     */
    /**
     * @hide
     * @method getPredecessorsCount
     */
    /**
     * @hide
     * @method getResourceStore
     */
    /**
     * @hide
     * @method getResources
     */
    /**
     * @hide
     * @method getSchedulingMode
     */
    /**
     * @hide
     * @method getSegment
     */
    /**
     * @hide
     * @method getSequenceNumber
     */
    /**
     * @hide
     * @method getSlack
     */
    /**
     * @hide
     * @method getSuccessors
     */
    /**
     * @hide
     * @method getTaskStore
     */
    /**
     * @hide
     * @method getTotalCount
     */
    /**
     * @hide
     * @method getWBSCode
     */
    /**
     * @hide
     * @method hasAssignments
     */
    /**
     * @hide
     * @method hasConstraint
     */
    /**
     * @hide
     * @method hasIncomingDependencies
     */
    /**
     * @hide
     * @method hasOutgoingDependencies
     */
    /**
     * @hide
     * @method hasResources
     */
    /**
     * @hide
     * @method indent
     */
    /**
     * @hide
     * @method insertSubtask
     */
    /**
     * @hide
     * @method isAssignedTo
     */
    /**
     * @hide
     * @method isBaselineMilestone
     */
    /**
     * @hide
     * @method isConstraintSatisfied
     */
    /**
     * @hide
     * @method isManuallyScheduled
     */
    /**
     * @hide
     * @method isMilestone
     */
    /**
     * @hide
     * @method isPersistable
     */
    /**
     * @hide
     * @method isProjected
     */
    /**
     * @hide
     * @method isSegmented
     */
    /**
     * @hide
     * @method linkTo
     */
    /**
     * @hide
     * @method merge
     */
    /**
     * @hide
     * @method outdent
     */
    /**
     * @hide
     * @method setBaselinePercentDone
     */
    /**
     * @hide
     * @method setCalendar
     */
    /**
     * @hide
     * @method setConstraint
     */
    /**
     * @hide
     * @method setConstraintDate
     */
    /**
     * @hide
     * @method setConstraintType
     */
    /**
     * @hide
     * @method setEffort
     */
    /**
     * @hide
     * @method setEffortUnit
     */
    /**
     * @hide
     * @method setPercentDone
     */
    /**
     * @hide
     * @method setSchedulingMode
     */
    /**
     * @hide
     * @method setSegments
     */
    /**
     * @hide
     * @method setTaskStore
     */
    /**
     * @hide
     * @method shift
     */
    /**
     * @hide
     * @method split
     */
    /**
     * @hide
     * @method unAssign
     */
    /**
     * @hide
     * @method unlinkFrom
     */
    /**
     * @cfg {Gnt.model.Task} task The task part of which this segment is.
     * @required
     */
    task: null,
    customizableFields: [
        {
            name: 'StartOffset',
            type: 'int',
            defaultValue: null
        },
        {
            name: 'EndOffset',
            type: 'int',
            defaultValue: null
        }
    ],
    startOffsetField: 'StartOffset',
    endOffsetField: 'EndOffset',
    taskNotifyingSuspended: 0,
    respectNeighbours: 0,
    constructor: function(cfg) {
        cfg = cfg || {};
        cfg.leaf = true;
        if (!cfg.task)  {
            throw "'task' has to be specified";
        }
        
        this.task = cfg.task;
        this.callParent(arguments);
        Ext.override(this, this.overridables);
        if (this.getTask().normalized && this.getTaskStore(true) && !this.normalized) {
            this.normalize();
        }
    },
    overridables: {
        // we have to treat set() method override this way since we use explicit Ext.override() call
        // to override it in Gnt.model.mixin.ProjectableModel, and thus we can override it using the same approach only
        set: function() {
            var task = this.getTask();
            if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
                // let master task know of editing being started
                task.onSegmentEditBegin(this);
            }
            this.callParent(arguments);
            if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
                // let master task know of editing being ended
                task.onSegmentEditEnd(this);
            }
        }
    },
    serialize: function() {
        var data = {};
        if (this.getId()) {
            data[this.idProperty] = this.getId();
        }
        data[this.phantomIdField] = this.getPhantomId();
        data[this.startDateField] = this.getStartDate();
        data[this.endDateField] = this.getEndDate();
        data[this.durationField] = this.getDuration();
        data[this.durationUnitField] = this.getDurationUnit();
        data[this.clsField] = this.getCls();
        return data;
    },
    setStartOffset: function(startOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(this.getEndOffset() - startOffset, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, startOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    setEndOffset: function(endOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(endOffset - this.getStartOffset(), this.getDurationUnit());
        this.beginEdit();
        this.set(this.endOffsetField, endOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    setStartEndOffset: function(startOffset, endOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(endOffset - startOffset, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, startOffset);
        this.set(this.endOffsetField, endOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    normalize: function() {
        // fill missing standard task fields: end date based on duration or duration based on end date etc.
        this.callParent(arguments);
        var startDate = this.getStartDate();
        // fill offsets if needed
        if (!Ext.isNumber(this.getStartOffset()) && startDate) {
            var task = this.getTask();
            var startOffset = this.calculateDuration(task.getStartDate(), startDate, 'MILLI');
            var endOffset = startOffset + this.getDuration('MILLI');
            var cal = task.getProjectCalendar();
            var durationInTaskUnits = cal.convertMSDurationToUnit(endOffset - startOffset, this.getDurationUnit());
            this.data[this.startOffsetField] = startOffset;
            this.data[this.endOffsetField] = endOffset;
            this.data[this.durationField] = durationInTaskUnits;
        }
    },
    updateOffsetsByDates: function() {
        // we need task store to use its project calendar
        if (!this.getTaskStore(true))  {
            return;
        }
        
        // prevents nested updating of offsets
        // and updating of offsets during start/end recalculation (based on offsets)
        if (this.updatingOffsets || this.updatingDates)  {
            return;
        }
        
        // set flag saying that we are in the middle of updating offsets by dates
        this.updatingOffsets = true;
        var offset = this.calculateDuration(this.getTask().getStartDate(), this.getStartDate(), 'MILLI');
        this.setStartEndOffset(offset, offset + this.getDuration('MILLI'));
        this.updatingOffsets = false;
    },
    updateDatesByOffsets: function(options) {
        options = options || {};
        // prevents nested updating of dates
        // and updating of dates during offsets updating
        if (this.updatingDates || this.updatingOffsets)  {
            return;
        }
        
        var isForward = options.isForward !== false,
            useAbsoluteOffset = options.useAbsoluteOffset !== false,
            startDate = options.startDate,
            endDate = options.endDate,
            taskStore = this.getTaskStore(true);
        if (!taskStore)  {
            return;
        }
        
        // set flag saying that we are in the middle of updating dates by offsets
        this.updatingDates = true;
        var date, neighbour;
        if (isForward) {
            neighbour = this.getPrevSegment();
            if (neighbour && !useAbsoluteOffset) {
                date = this.skipWorkingTime(neighbour.getEndDate(), this.getStartOffset() - neighbour.getEndOffset());
            } else {
                date = this.skipWorkingTime(startDate || this.getTask().getStartDate(), this.getStartOffset());
            }
        } else {
            neighbour = this.getNextSegment();
            if (neighbour && !useAbsoluteOffset) {
                date = this.skipWorkingTime(neighbour.getStartDate(), neighbour.getStartOffset() - this.getEndOffset() + this.getDuration('MILLI'), false);
            } else {
                date = this.skipWorkingTime(endDate || this.getTask().getEndDate(), this.getDuration('MILLI'), false);
            }
        }
        this.setStartDateWithoutPropagation(date, true, taskStore.skipWeekendsDuringDragDrop);
        this.updatingDates = false;
    },
    getPrevSegment: function() {
        var segments = this.task.getSegments();
        return segments[Ext.Array.indexOf(segments, this) - 1];
    },
    getNextSegment: function() {
        var segments = this.task.getSegments();
        return segments[Ext.Array.indexOf(segments, this) + 1];
    },
    buildSnapshot: function() {
        return [
            this,
            Ext.apply({}, this.data)
        ];
    },
    readSnapshot: function(snapshot) {
        if (snapshot) {
            Ext.apply(this.data, snapshot[1]);
            return this;
        }
        return snapshot;
    },
    enableRespectNeighbours: function() {
        this.respectNeighbours++;
    },
    disableRespectNeighbours: function() {
        this.respectNeighbours--;
    },
    suspendTaskNotifying: function() {
        this.taskNotifyingSuspended++;
    },
    resumeTaskNotifying: function() {
        this.taskNotifyingSuspended--;
    },
    setStartDate: function(date, keepDuration) {
        // if we move the segment their neighbours constraints the movement range
        if (keepDuration) {
            this.enableRespectNeighbours();
        }
        this.callParent(arguments);
        if (keepDuration) {
            this.disableRespectNeighbours();
        }
    },
    setStartDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        // if we have next segment(s) and we have to respect and not overlap them
        if (!this.inShifting && this.respectNeighbours && this.getNextSegment()) {
            // this.shiftNeighboursWithoutPropagation();
            var neighbour = this.getNextSegment();
            var shift = this.getEndOffset() - neighbour.getStartOffset();
            if (neighbour && shift > 0) {
                neighbour.suspendTaskNotifying();
                neighbour.enableRespectNeighbours();
                neighbour.shiftWithoutPropagation(shift);
                neighbour.resumeTaskNotifying();
                neighbour.disableRespectNeighbours();
            }
        }
        this.endEdit();
        return true;
    },
    /**
     * @private
     * Shifts the segment by provided number of milliseconds.
     * If the segment has {@link #respectNeighbours} set to `true` this call will shift further segments as well.
     * @param {Number} amountMS Number of milliseconds the segment shoud be mover by.
     */
    shiftWithoutPropagation: function(amountMS) {
        var me = this;
        if (!amountMS)  {
            return;
        }
        
        me.beginEdit();
        me.inShifting = true;
        me.setStartEndOffset(me.getStartOffset() + amountMS, me.getEndOffset() + amountMS);
        me.updateDatesByOffsets();
        var neighbour;
        if (me.respectNeighbours && (neighbour = amountMS > 0 ? me.getNextSegment() : me.getPrevSegment())) {
            neighbour.suspendTaskNotifying();
            neighbour.enableRespectNeighbours();
            neighbour.shiftWithoutPropagation(amountMS);
            neighbour.resumeTaskNotifying();
            neighbour.disableRespectNeighbours();
        }
        me.inShifting = false;
        me.endEdit();
        return true;
    },
    setEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true;
    },
    setStartEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true;
    },
    setDurationWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true;
    },
    /**
     * Gets the task to which the segment belongs.
     * @return {Gnt.model.Task} The task.
     */
    getTask: function() {
        return this.task;
    },
    beginEdit: function() {
        var task = this.getTask();
        if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
            // let master task know of editing being started
            task.onSegmentEditBegin(this);
        }
        this.callParent(arguments);
    },
    endEdit: function() {
        var modified = this.previous,
            task = this.getTask();
        this.callParent(arguments);
        if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
            // if the timespan was affected by the change we gonna let the master task know of it
            if (this.startDateField in modified || this.endDateField in modified || this.startOffsetField in modified || this.endOffsetField in modified || this.durationField in modified) {
                task.onSegmentsChanged(this, modified);
            }
            task.onSegmentEditEnd(this);
        }
    },
    // sub-segments are not supported
    //@ignore
    setSegments: Ext.emptyFn,
    //@ignore
    getSegments: Ext.emptyFn,
    callTask: function(args) {
        var task = this.task;
        var method = this.callTask.caller;
        var taskMethod = method && task[method.$name];
        if (taskMethod)  {
            return taskMethod.apply(task, args);
        }
        
    },
    //@ignore
    getSchedulingMode: function() {
        // #1902 here we redirected this call to the task previously (using: this.callTask(arguments);)
        // yet it brings few questions when it comes to "EfforDriven" mode
        // where end date is calculated based on effort value ..and segment just doesn't have it normally
        return 'Normal';
    },
    // methods mapped from the task
    getCalendar: function() {
        return this.callTask(arguments);
    },
    getOwnCalendar: function() {
        return this.callTask(arguments);
    },
    getProjectCalendar: function() {
        return this.callTask(arguments);
    },
    getDependencyStore: function() {
        return this.callTask(arguments);
    },
    getResourceStore: function() {
        return this.callTask(arguments);
    },
    getAssignmentStore: function() {
        return this.callTask(arguments);
    },
    getTaskStore: function() {
        return this.callTask(arguments);
    },
    forEachAvailabilityInterval: function(options) {
        // we query the task for available intervals
        // but force it to NOT take segmentation into account
        options.segments = options.segments || false;
        return this.callTask(arguments);
    },
    propagateChanges: function() /*...*/
    {
        return this.callTask(arguments);
    },
    rejectSegmentsProjection: function() {
        return this.callTask(arguments);
    },
    commitSegmentsProjection: function() {
        return this.callTask(arguments);
    },
    getAssignments: function() {
        return this.callTask(arguments);
    },
    getAssignmentFor: function() {
        return this.callTask(arguments);
    },
    isAssignedTo: function() {
        return this.callTask(arguments);
    },
    getResources: function() {
        return this.callTask(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.Week', {
    extend: 'Ext.data.Model',
    idProperty: 'Id',
    fields: [
        {
            name: 'Id'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'startDate',
            type: 'date'
        },
        {
            name: 'endDate',
            type: 'date'
        },
        {
            name: 'mainDay'
        },
        // type : Gnt.model.CalendarDay
        {
            name: 'weekAvailability'
        }
    ],
    set: function(field, value) {
        if (field === 'name') {
            // rename every CalendarDay instance embedded
            Ext.Array.each(this.get('weekAvailability').concat(this.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    weekDay.setName(value);
                }
            });
        }
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.utilization.DefaultUtilizationNegotiationStrategy', {
    uses: [
        'Ext.Date',
        'Ext.Object'
    ],
    /**
     * This method will be used by UtilizationEvent mostly to check if it's synchronized with primary data.
     * This method return value is suitable for comparison by {@link Ext.Object.equals}, but it isn't suitable
     * for direct usage. It's an object with volatile and cryptic set of keys which depend on event's start/end dates.
     *
     * @param  {Gnt.model.UtilizationEvent} utilizationEvent
     * @return {Object}
     */
    getUtilizationInfoForUtilizationEvent: function(utilizationEvent) {
        var me = this,
            result = {};
        me.forEachTimeSpanInterval(utilizationEvent, function getUtilizationInfoForUtilizationEventForEachTimeIntervalCallback(dayStartDate, dayEndDate) {
            var info;
            if (utilizationEvent.isSurrogateAssignment()) {
                info = utilizationEvent.getOriginalAssignment().getUtilizationInfo(dayStartDate, dayEndDate);
            } else if (utilizationEvent.isSurrogateSummary()) {
                info = utilizationEvent.getOriginalResource().getUtilizationInfo(dayStartDate, dayEndDate);
            } else {
                Ext.Error.raise('Unknown utilization event type');
                // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
                var foo = false;
            }
            Ext.Object.each(info, function(key, value) {
                result[me.self.makeUtilizationInfoKey(dayStartDate, dayEndDate, key)] = value;
            });
            return info;
        });
        return result;
    },
    /**
     * This method is in turn should return a value suitable for direct usage for particular interval within event
     * start/end dates.
     *
     * Note: utilization information is supposed to be consumed by intervals, by default it's daily intervals.
     *
     * @param  {Gnt.model.UtilizationEvent} utilizationEvent
     * @param  {Date} intervalStartDate Interval start date
     * @return {Object}  info
     * @return {Boolean} info.isUtilized
     * @return {Number}  info.allocationMs
     * @return {Number}  info.allocationDeltaMs
     * @return {Boolean} info.isOverallocated
     * @return {Boolean} info.isUnderllocated
     */
    getUtilizationInfoForAssignmentEventInterval: function(utilizationEvent, intervalStartDate, /* private */
    intervalEndDate) {
        var ED = Ext.Date,
            me = this,
            result = {
                isUtilized: false,
                allocationMs: 0,
                allocationDeltaMs: 0,
                isOverallocated: false,
                isUnderallocated: false,
                assignmentInfo: null,
                taskInfo: null
            },
            info = utilizationEvent.getUtilizationInfo();
        intervalEndDate = intervalEndDate || ED.add(intervalStartDate, ED.DAY, 1);
        Ext.Object.each(result, function(key, value) {
            var infoKey = me.self.makeUtilizationInfoKey(intervalStartDate, intervalEndDate, key);
            result[key] = info.hasOwnProperty(infoKey) ? info[infoKey] : value;
        });
        return result;
    },
    /**
     * Iterates over a timespan time intervals and calls the callback providing interval start/end dates
     * as parameters. For this strategy interval is one day, other strategies might use other intervals.
     *
     * @param {Sch.model.Range} timespan Any object supporting interface having getStartDate()/getEndDate() methods or startDate/endDate properties.
     * @param {Function} callback
     * @param {Date} callback.startDate
     * @param {Date} callback.endDate
     */
    forEachTimeSpanInterval: function(timespan, callback) {
        var ED = Ext.Date,
            startDate = timespan.getStartDate ? timespan.getStartDate() : timespan.startDate,
            endDate = timespan.getEndDate ? timespan.getEndDate() : timespan.endDate,
            date;
        date = ED.clearTime(startDate, true);
        while (date < endDate) {
            startDate = date;
            date = ED.add(date, ED.DAY, 1);
            callback(startDate, date);
        }
    },
    /**
     * Adjusts event start date to strategy tick.
     *
     * Note: this strategy uses daily intervals so ticks are at the begining of the days, other strategies might use
     *       different ticks.
     *
     * @param {Date} date
     * @return {Date}
     */
    adjustStartDateToTick: function(date) {
        return date && Ext.Date.clearTime(date, true) || date;
    },
    /**
     * Adjust event end date to strategy tick.
     *
     * Note: this strategy uses daily intervals so ticks are at the begining of the days, other strategies might use
     *       different ticks.
     *
     * @param {Date} date
     * @return {Date}
     */
    adjustEndDateToTick: function(date) {
        var ED = Ext.Date,
            result = date,
            testDate;
        if (date) {
            testDate = new Date(date.getTime() - 1);
            // If we were at the beggining of a day, then date given designates ending of timespan which actually ends at 23:59:59.999
            if (testDate.getDate() != date.getDate()) {
                // Returning a clone
                result = new Date(date);
            } else // otherwise given date point somewhere at mid day, so we adjust it to point to the end of that day (see previous comment);
            {
                result = ED.clearTime(ED.add(date, ED.DAY, 1));
            }
        }
        return result;
    },
    /**
     * Calculates timespan occupied by resource assignments and adjusts it to tick used
     *
     * @param {Gnt.model.Resource} resource
     * @return {Object} timespan
     * @return {Date}   timespan.startDate
     * @return {Date}   timespan.endDate
     */
    calculateResourceAssignmentsTimespan: function(resource) {
        var me = this,
            gotAssignments = false,
            minStartDate, maxEndDate;
        minStartDate = new Date(+8.64E15);
        maxEndDate = new Date(-8.64E15);
        resource.forEachAssignment(function resourceAssignmentsTimespanCalculationEnumeratorCallback(assignment) {
            var task = assignment.getTask(),
                taskStartDate = task && task.getStartDate() || minStartDate,
                taskEndDate = task && task.getEndDate() || maxEndDate;
            if (minStartDate > taskStartDate) {
                minStartDate = taskStartDate;
            }
            if (maxEndDate < taskEndDate) {
                maxEndDate = taskEndDate;
            }
            gotAssignments = true;
        });
        return {
            startDate: gotAssignments && me.adjustStartDateToTick(minStartDate) || null,
            endDate: gotAssignments && me.adjustEndDateToTick(maxEndDate) || null
        };
    },
    /**
     * Assignments comparison function, by default order by task name
     *
     * @param {Gnt.model.Assignment} a
     * @param {Gnt.model.Assignment} b
     * @return {Number}
     */
    assignmentsComparator: function(a, b) {
        if (a.getTask().getName() > b.getTask().getName()) {
            return 1;
        }
        return -1;
    },
    inheritableStatics: {
        /**
         * Makes utilization information key.
         *
         * @private
         */
        makeUtilizationInfoKey: function(startDate, endDate, suffix) {
            return [
                startDate.getTime(),
                endDate.getTime(),
                suffix
            ].join('-');
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.model.utilization.ResourceStoreUtilizationNegotiationStrategy', {
    extend: 'Gnt.model.utilization.DefaultUtilizationNegotiationStrategy',
    uses: [
        'Ext.Date',
        'Gnt.model.UtilizationEvent'
    ],
    config: {
        resourceUtilizationStore: null,
        underUtilizationThreshold: null,
        overUtilizationThreshold: null
    },
    constructor: function(config) {
        var me = this;
        me.initConfig(config);
    },
    getUtilizationInfoForUtilizationEvent: function(utilizationEvent) {
        var UE = Gnt.model.UtilizationEvent,
            me = this,
            store = me.getResourceUtilizationStore(),
            id = utilizationEvent.getId(),
            utilizationInfoCache = store && store.utilizationInfoCache || {},
            result = utilizationInfoCache[id] || null,
            originalResource, originalResourceTimespan, originalAssignments, allocationAcc;
        if (!result) {
            // If we have no cache result then we must request utilization information calculation for event resource, more precisely to it's surrogate summary event,
            // it's utilization information contains data about assignements, combining it with assignment sort order which is defined by assignmentComparator(),
            // we can designate the assignments which give overallocation to the resource according to bussiness logic required.
            // Obtaining summary event
            originalResource = utilizationEvent.getOriginalResource();
            originalResourceTimespan = me.calculateResourceAssignmentsTimespan(originalResource);
            // Obtaining all assignment under this surrogate summary event, we will need the assignment list later in the code
            originalAssignments = [];
            originalResource.forEachAssignment(function(a) {
                originalAssignments.push(a);
            });
            // and sort them according to strategy assignment sorting method
            originalAssignments.sort(function(a, b) {
                return me.assignmentsComparator(a, b);
            });
            // Calculating
            me.forEachTimeSpanInterval(originalResourceTimespan, function getUtilizationInfoForUtilizationEventForEachTimeIntervalCallback(intervalStartDate, intervalEndDate) {
                var info = originalResource.getUtilizationInfo(intervalStartDate, intervalEndDate, me.getUnderUtilizationThreshold(), me.getOverUtilizationThreshold()),
                    surrogateId, subcache;
                // Here we have utilization information for original resource on a particular interval, this data contains utilization information for the resource,
                // as well as for each assignment under this resource.
                // Caching the resource utilization information
                surrogateId = UE.getSurrogateIdFor(originalResource);
                subcache = utilizationInfoCache[surrogateId] = (utilizationInfoCache[surrogateId] || {});
                Ext.Object.each(info, function(key, value) {
                    subcache[me.self.makeUtilizationInfoKey(intervalStartDate, intervalEndDate, key)] = value;
                });
                // Now extracting assignments information from resource utilization information, and caching them as well.
                // Alongside we do additional calculation for assignment over/under/optimal allocation flag which is required by our bussiness logic
                allocationAcc = 0;
                Ext.Array.each(originalAssignments, function(originalAssignment) {
                    var subinfo,
                        originalId = originalAssignment.getId();
                    if (info.assignmentInfo.hasOwnProperty(originalId)) {
                        surrogateId = UE.getSurrogateIdFor(originalAssignment);
                        subcache = utilizationInfoCache[surrogateId] = (utilizationInfoCache[surrogateId] || {});
                        subinfo = info.assignmentInfo[originalId];
                        // If resource tells us that it neither underallocated nor overallocated then assignments shouldn't report those flag either
                        /*
                        if (!info.isOverallocated && !info.isUnderllocated) {
                            subinfo.isOverallocated = false;
                            subinfo.isUnderallocated = false;
                        }
                        // If resource tells that it's overallocated then we must determine exactly what assignments bring the overallocation
                        else if (info.isOverallocated) {
                            allocationAcc += subinfo.allocationMs;
                            if (allocationAcc > info.allocationMs - info.allocationDeltaMs) {
                                subinfo.isOverallocated = true;
                                subinfo.isUnderallocated = false;
                            }
                            else {
                                subinfo.isOverallocated = false;
                            }
                        }
                        */
                        Ext.Object.each(subinfo, function(key, value) {
                            subcache[me.self.makeUtilizationInfoKey(intervalStartDate, intervalEndDate, key)] = value;
                        });
                    }
                });
            });
            // Now we have required information cached, and can fill result in.
            result = utilizationInfoCache[id] || {};
        }
        // !result
        return result;
    },
    getUtilizationInfoForAssignmentEventInterval: function(utilizationEvent, intervalStartDate) {
        var ED = Ext.Date,
            me = this,
            resourceStore = me.getResourceUtilizationStore(),
            timeAxis = resourceStore.getTimeAxis(),
            tickIndex = timeAxis.getTickFromDate(intervalStartDate),
            intervalEndDate;
        // when "autoAdjust : true" tickIndex might get equal ticket count and not -1 (if we pass end date of last tick to getTickFromDate())
        if (tickIndex !== -1 && tickIndex < timeAxis.count()) {
            intervalEndDate = timeAxis.getAt(tickIndex).getEndDate();
        } else {
            intervalEndDate = ED.add(intervalStartDate, 1, timeAxis.unit);
        }
        return me.callParent([
            utilizationEvent,
            intervalStartDate,
            intervalEndDate
        ]);
    },
    forEachTimeSpanInterval: function(timespan, callback) {
        var me = this,
            resourceStore = me.getResourceUtilizationStore(),
            timeAxis = resourceStore.getTimeAxis(),
            startDate, endDate;
        if (timeAxis) {
            startDate = timespan.getStartDate ? timespan.getStartDate() : timespan.startDate;
            endDate = timespan.getEndDate ? timespan.getEndDate() : timespan.endDate;
            startDate = new Date(Math.max(startDate, timeAxis.getStart()));
            endDate = new Date(Math.min(endDate, timeAxis.getEnd()));
            // timeAxis.generateTicks() adjust start/end dates to time axis main unit boundaries, which is not
            // what we want here, adjusted start date might be lesser then time span start date, as well as
            // adjusted end date might be greater then time span end date, if, for example, main unit is week
            // whereas unit is day.
            Ext.Array.each(timeAxis.generateTicks(startDate, endDate, timeAxis.getUnit()), function(tick) {
                if (tick.start - startDate >= 0 && tick.end - endDate <= 0) {
                    callback(tick.start, tick.end);
                }
            });
        } else {
            me.callParent([
                timespan,
                callback
            ]);
        }
    },
    adjustStartDateToTick: function(date) {
        var me = this,
            resourceStore = me.getResourceUtilizationStore(),
            timeAxis = resourceStore.getTimeAxis();
        return timeAxis.floorDate(date, false, timeAxis.unit, 1);
    },
    adjustEndDateToTick: function(date) {
        var me = this,
            resourceStore = me.getResourceUtilizationStore(),
            timeAxis = resourceStore.getTimeAxis();
        return timeAxis.ceilDate(date, false, timeAxis.unit, 1);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// !XXX when adding new methods to this mixing need to also update the
// `setupLockableTree` method in the Sch.mixin.Lockable
Ext.define("Sch.mixin.FilterableTreeView", {
    prevBlockRefresh: null,
    initTreeFiltering: function() {
        var doInit = function() {
                var treeStore = this.store;
                this.mon(treeStore, 'nodestore-datachange-start', this.onFilterChangeStart, this);
                this.mon(treeStore, 'nodestore-datachange-end', this.onFilterChangeEnd, this);
                if (!treeStore.allowExpandCollapseWhileFiltered) {
                    this.mon(treeStore, 'filter-clear', this.onFilterCleared, this);
                    this.mon(treeStore, 'filter-set', this.onFilterSet, this);
                }
            };
        if (this.rendered)  {
            doInit.call(this);
        }
        else  {
            this.on('beforerender', doInit, this, {
                single: true
            });
        }
        
    },
    onFilterChangeStart: function() {
        this.prevBlockRefresh = this.blockRefresh;
        // block refresh in filterable tree view, for the cases when this mixin is consumed by non-tree views
        // "blockRefresh" is already true in all tree views, so in the Sch.data.mixin.FilterableTreeStore
        // we use "nodeStore.fireEvent('clear', nodeStore);" hack, which is directly tied to "refresh" method of the view
        // in case when non-tree view consumes this mixin, we need to temporarily block the refresh manually,
        // to avoid double refresh
        this.blockRefresh = true;
        Ext.suspendLayouts();
    },
    onFilterChangeEnd: function() {
        Ext.resumeLayouts(true);
        this.blockRefresh = this.prevBlockRefresh;
    },
    onFilterCleared: function() {
        delete this.toggle;
        var el = this.getEl();
        if (el)  {
            el.removeCls('sch-tree-filtered');
        }
        
    },
    onFilterSet: function() {
        this.toggle = function() {};
        var el = this.getEl();
        if (el)  {
            el.addCls('sch-tree-filtered');
        }
        
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?304819-Click-on-asterisk-throws-exception-in-tree
Ext.define('Sch.patches.TreeNavigationModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tree.NavigationModel',
    minVersion: '6.0.0',
    maxVersion: '6.0.2',
    overrides: {
        onAsterisk: function() {
            if (!this.view.ownerCt.expandAll) {
                this.view.lockingPartner.ownerCt.expandAll();
                return;
            }
            this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Sch.model.TimeAxisTick
 * @extends Sch.model.Range
 *
 * A simple model with a start/end date interval defining a 'tick' on the time axis.
 */
Ext.define('Sch.model.TimeAxisTick', {
    extend: 'Sch.model.Range',
    startDateField: 'start',
    endDateField: 'end'
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling {@link #clearFilter} will return you to a full time axis.

*/
Ext.define("Sch.data.TimeAxis", {
    extend: "Ext.data.JsonStore",
    requires: [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],
    model: 'Sch.model.TimeAxisTick',
    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous: true,
    originalContinuous: null,
    /**
    * @cfg {Boolean} autoAdjust
    * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
    * may lead to shifting time/date of ticks.
    */
    autoAdjust: true,
    unit: null,
    increment: null,
    resolutionUnit: null,
    resolutionIncrement: null,
    weekStartDay: null,
    mainUnit: null,
    shiftUnit: null,
    shiftIncrement: 1,
    defaultSpan: 1,
    isConfigured: false,
    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart: null,
    adjustedEnd: null,
    // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
    visibleTickStart: null,
    // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
    visibleTickEnd: null,
    // name of the current preset
    presetName: null,
    /**
     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for calendar we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'calendar']
     */
    mode: 'plain',
    /**
     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime: 0,
    /**
     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime: 24,
    /**
     * @event beforereconfigure
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */
    /**
     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */
    /**
     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */
    // private
    constructor: function(config) {
        var me = this;
        config = config || {};
        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }
        me.setMode(config.mode || me.mode);
        me.originalContinuous = me.continuous;
        me.callParent(arguments);
        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function() {
            me.fireEvent('reconfigure', me, false);
        });
        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });
        if (config.viewPreset) {
            var preset = Sch.preset.Manager.getPreset(config.viewPreset);
            preset && me.consumeViewPreset(preset);
        }
        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },
    /**
     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
     * @param {Object} config
     * @param {Boolean} [suppressRefresh]
     * @private
     */
    reconfigure: function(config, suppressRefresh) {
        this.isConfigured = true;
        Ext.apply(this, config);
        var adjusted = this.getAdjustedDates(config.start, config.end, true);
        var normalized = this.getAdjustedDates(config.start, config.end);
        var start = normalized.start;
        var end = normalized.end;
        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {
            this.fireEvent('beginreconfigure', this);
            var unit = this.unit;
            var increment = this.increment || 1;
            var ticks = this.generateTicks(start, end, unit, increment);
            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);
            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();
            var DATE = Sch.util.Date;
            var count = ticks.length;
            if (this.isContinuous()) {
                this.adjustedStart = adjusted.start;
                this.adjustedEnd = this.getNext(count > 1 ? ticks[count - 1].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart = this.getStart();
                this.adjustedEnd = this.getEnd();
            }
            // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust "adjustedStart" accordingly
            do {
                this.visibleTickStart = (this.getStart() - this.adjustedStart) / (DATE.getUnitDurationInMs(unit) * increment);
                if (this.visibleTickStart >= 1)  {
                    this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment);
                }
                
            } while (// TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
            this.visibleTickStart >= 1);
            do {
                this.visibleTickEnd = count - (this.adjustedEnd - this.getEnd()) / (DATE.getUnitDurationInMs(unit) * increment);
                if (count - this.visibleTickEnd >= 1)  {
                    this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1);
                }
                
            } while (count - this.visibleTickEnd >= 1);
            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },
    setMode: function(mode) {
        this.mode = mode;
        if (mode === 'calendar') {
            this.generateTicksValidatorFn = function(start) {
                if (this.startTime > 0 || this.endTime < 24) {
                    return (start.getHours() >= this.startTime && start.getHours() < this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function() {
                return true;
            };
        }
    },
    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end The new end date
    */
    setTimeSpan: function(start, end) {
        var adjusted = this.getAdjustedDates(start, end);
        start = adjusted.start;
        end = adjusted.end;
        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0) {
            this.reconfigure({
                start: start,
                end: end
            });
        }
    },
    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy: function(fn, scope) {
        this.continuous = false;
        scope = scope || this;
        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([
            {
                filterFn: function(t, index) {
                    return fn.call(scope, t.data, index);
                }
            }
        ]);
        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },
    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous: function() {
        var result = this.continuous && !this.isFiltered();
        if (this.mode === 'calendar') {
            result = result && this.startTime === 0 && this.endTime === 24;
        }
        return result;
    },
    /**
     * Clear the current filter of the time axis
     */
    clearFilter: function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },
    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} start The start date of the interval
     * @param {Date} end The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Number} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks: function(start, end, unit, increment) {
        var ticks = [],
            intervalEnd,
            DATE = Sch.util.Date,
            dstDiff = 0;
        unit = unit || this.unit;
        increment = increment || this.increment;
        var adjusted = this.getAdjustedDates(start, end);
        start = adjusted.start;
        end = adjusted.end;
        while (start < end) {
            intervalEnd = this.getNext(start, unit, increment);
            if (!this.autoAdjust && intervalEnd > end)  {
                intervalEnd = end;
            }
            
            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0) {
                var prev = ticks[ticks.length - 1];
                dstDiff = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();
                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }
            this.generateTicksValidatorFn(start) && ticks.push({
                start: start,
                end: intervalEnd
            });
            start = intervalEnd;
        }
        return ticks;
    },
    getVisibleTickTimeSpan: function() {
        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount();
    },
    getAdjustedDates: function(start, end, forceAdjust) {
        var DATE = Sch.util.Date;
        start = start || this.getStart();
        end = end || DATE.add(start, this.mainUnit, this.defaultSpan);
        if (this.mode === 'calendar') {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit);
                    end = this.ceilDate(end, false, this.mainUnit);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start: start,
                        end: end
                    };
                }
            }
            var adjustedStart, adjustedEnd, clone;
            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            adjustedStart = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart = this.floorDate(adjustedStart, false, this.mainUnit, 1);
            // https://www.assembla.com/spaces/bryntum/tickets/2811
            // Disabled autoAdjust will allow to show any time span
            if (this.autoAdjust) {
                clone = this.getNext(start, this.shiftUnit, 1);
                adjustedEnd = this.ceilDate(clone, false, this.shiftUnit);
                adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
            } else {
                adjustedEnd = this.ceilDate(end, false, this.shiftUnit);
                adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
            }
            return {
                start: adjustedStart,
                end: adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start: this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end: this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start: start,
                end: end
            };
        }
    },
    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate: function(date) {
        var ticks = this.data.items;
        var lastTickIndex = ticks.length - 1;
        // quick bailout
        if (date.valueOf() < ticks[0].data.start.valueOf() || date.valueOf() > ticks[lastTickIndex].data.end.valueOf()) {
            return -1;
        }
        var tick, tickStart, tickEnd;
        if (this.isContinuous()) {
            if (date - ticks[0].data.start === 0)  {
                return this.visibleTickStart;
            }
            
            if (date - ticks[lastTickIndex].data.end === 0)  {
                return this.visibleTickEnd;
            }
            
            var adjustedStart = this.adjustedStart;
            var adjustedEnd = this.adjustedEnd;
            var tickIndex = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));
            // for the date == adjustedEnd case
            if (tickIndex > lastTickIndex)  {
                tickIndex = lastTickIndex;
            }
            
            tickStart = tickIndex === 0 ? adjustedStart : ticks[tickIndex].data.start;
            tickEnd = tickIndex == lastTickIndex ? adjustedEnd : ticks[tickIndex].data.end;
            tick = tickIndex + (date - tickStart) / (tickEnd - tickStart);
            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // but still
            if (tick < this.visibleTickStart || tick > this.visibleTickEnd)  {
                return -1;
            }
            
            return tick;
        } else {
            for (var i = 0; i <= lastTickIndex; i++) {
                tickEnd = ticks[i].data.end;
                if (date <= tickEnd) {
                    tickStart = ticks[i].data.start;
                    // date < tickStart can occur in filtered case
                    tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);
                    return tick;
                }
            }
        }
        return -1;
    },
    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Number} tick the tick "coordinate"
    * @param {String} roundingMethod The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick: function(tick, roundingMethod) {
        if (tick === this.visibleTickEnd)  {
            return this.getEnd();
        }
        
        var wholeTick = Math.floor(tick),
            fraction = tick - wholeTick,
            t = this.getAt(wholeTick);
        if (!t)  {
            return null;
        }
        
        var tickData = t.data;
        var start = wholeTick === 0 ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end = (wholeTick == this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : tickData.end;
        var date = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));
        if (roundingMethod) {
            date = this[roundingMethod + 'Date'](date);
        }
        return date;
    },
    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks: function() {
        var ticks = [];
        this.each(function(r) {
            ticks.push(r.data);
        });
        return ticks;
    },
    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart: function() {
        var first = this.first();
        if (first) {
            return new Date(first.data.start);
        }
        return null;
    },
    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd: function() {
        var last = this.last();
        if (last) {
            return new Date(last.data.end);
        }
        return null;
    },
    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate: function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;
        var dt = Ext.Date.clone(date),
            relativeTo = relativeToStart ? this.getStart() : null,
            increment = incr || this.resolutionIncrement,
            unit;
        if (resolutionUnit) {
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }
        var DATE = Sch.util.Date;
        var snap = function(value, increment) {
                return Math.floor(value / increment) * increment;
            };
        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                };
                break;
            case DATE.SECOND:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setMilliseconds(0);
                    dt.setSeconds(snap(dt.getSeconds(), increment));
                };
                break;
            case DATE.MINUTE:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setMinutes(snap(dt.getMinutes(), increment));
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                };
                break;
            case DATE.HOUR:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                    dt.setHours(snap(dt.getHours(), increment));
                };
                break;
            case DATE.DAY:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                };
                break;
            case DATE.WEEK:
                var day = dt.getDay() || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);
                dt = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));
                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay && dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                };
                break;
            case DATE.MONTH:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                };
                break;
            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = DATE.add(dt, DATE.MONTH, -(dt.getMonth() % 3));
                break;
            case DATE.YEAR:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    dt = new Date(snap(date.getFullYear() - 1, increment) + 1, 0, 1);
                };
                break;
        }
        return dt;
    },
    // Rounds the date to nearest unit increment
    // private
    roundDate: function(date, relativeTo) {
        var dt = Ext.Date.clone(date),
            increment = this.resolutionIncrement;
        relativeTo = relativeTo || this.getStart();
        switch (this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                    snappedMilliseconds = Math.round(milliseconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                break;
            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                    snappedSeconds = Math.round(seconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                break;
            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                    snappedMinutes = Math.round(minutes / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                break;
            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt),
                    snappedHours = Math.round(nbrHours / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                break;
            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;
                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                };
                if (Math.round(distanceToWeekStartDay / 7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                };
                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;
            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;
            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }
        return dt;
    },
    // private
    ceilDate: function(date, relativeToStart, resolutionUnit) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;
        var increment = relativeToStart ? this.resolutionIncrement : 1,
            doCall = false,
            unit;
        if (resolutionUnit) {
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }
        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            default:
                break;
        }
        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },
    // private
    getNext: function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
    },
    // private
    getResolution: function() {
        return {
            unit: this.resolutionUnit,
            increment: this.resolutionIncrement
        };
    },
    // private
    setResolution: function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },
    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function(amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function(amount) {
        amount = amount || this.getShiftIncrement();
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function(amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    getShiftUnit: function() {
        return this.shiftUnit || this.mainUnit;
    },
    // private
    getShiftIncrement: function() {
        return this.shiftIncrement || 1;
    },
    // private
    getUnit: function() {
        return this.unit;
    },
    // private
    getIncrement: function() {
        return this.increment;
    },
    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
    getRowTicks: function() {
        if (this.mode !== 'plain') {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);
            var endIndex = this.findBy(function(record) {
                    return record.getStartDate().getTime() >= end.getTime();
                });
            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }
            return this.getRange(0, endIndex - 1);
        }
    },
    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date) {
        var result = Sch.util.Date.betweenLesser(date, this.getStart(), this.getEnd());
        // Date is between axis start/end and axis is not continuous - need to perform better lookup
        if (result && !this.isContinuous()) {
            var tickIndex = this.getTickFromDate(date);
            var tick = this.getAt(Math.floor(tickIndex));
            result = tick.getStartDate() <= date && tick.getEndDate() >= date;
        }
        return result;
    },
    /**
    * Returns true if the passed timespan is part of the current time axis (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @return {boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, this.getStart(), this.getEnd());
        } else {
            return (start < this.getStart() && end > this.getEnd()) || this.getTickFromDate(start) !== this.getTickFromDate(end);
        }
    },
    // Accepts a Sch.model.Range model
    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();
        // only consider fully scheduled ranges
        if (!start || !end)  {
            return false;
        }
        
        return this.timeSpanInAxis(start, end);
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachAuxInterval: function(unit, increment, iteratorFn, scope) {
        scope = scope || this;
        var end = this.getEnd(),
            dt = this.getStart(),
            i = 0,
            intervalEnd;
        if (dt > end)  {
            throw 'Invalid time axis configuration';
        }
        
        while (dt < end) {
            intervalEnd = Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt = intervalEnd;
            i++;
        }
    },
    consumeViewPreset: function(preset) {
        Ext.apply(this, {
            unit: preset.getBottomHeader().unit,
            increment: preset.getBottomHeader().increment || 1,
            resolutionUnit: preset.timeResolution.unit,
            resolutionIncrement: preset.timeResolution.increment,
            mainUnit: preset.getMainHeader().unit,
            shiftUnit: preset.shiftUnit,
            shiftIncrement: preset.shiftIncrement || 1,
            defaultSpan: preset.defaultSpan || 1,
            presetName: preset.name,
            // Calendar columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig: preset.headerConfig
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.preset.ViewPreset
Not used directly, but the properties below are rather provided inline as seen in the source of {@link Sch.preset.Manager}. This class is just provided for documentation purposes.

A sample preset looks like:

    hourAndDay : {
        timeColumnWidth         : 60,       // Time column width (used for rowHeight in vertical mode)
        rowHeight               : 24,       // Only used in horizontal orientation
        resourceColumnWidth     : 100,      // Only used in vertical orientation

        displayDateFormat       : 'G:i',    // Controls how dates will be displayed in tooltips etc

        shiftIncrement          : 1,        // Controls how much time to skip when calling shiftNext and shiftPrevious.
        shiftUnit               : "DAY",    // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
        defaultSpan             : 12,       // By default, if no end date is supplied to a view it will show 12 hours

        timeResolution          : {         // Dates will be snapped to this resolution
            unit        : "MINUTE",         // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 15
        },

        headerConfig            : {         // This defines your header, you must include a "middle" object, and top/bottom are optional.
            middle      : {                 // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                unit        : "HOUR",
                dateFormat  : 'G:i'
            },
            top         : {
                unit        : "DAY",
                dateFormat  : 'D d/m'
            }
        },

        linesFor                : 'middle'  // Defines header level column lines will be drawn for
    },

See the {@link Sch.preset.Manager} for the list of available presets.

## Duration units

There are a number of configs for duration units ({@link #shiftUnit} or `unit` in {@link #timeResolution}, {@link #headerConfig} configs).

When registering a preset using {@link Sch.preset.Manager#registerPreset} method the one can provide their values both using
{@link Sch.util.Date} unit name constant values ({@link Sch.until.Date.DAY}, {@link Sch.until.Date.WEEK} etc.) and using short constants names ("DAY", "WEEK" etc.):

        Sch.preset.Manager.registerPreset("hour", {
            displayDateFormat : 'G:i',
            shiftIncrement    : 1,
            shiftUnit         : "DAY",
            timeColumnWidth   : 150,
            timeResolution    : {
                // Here we use Sch.util.Date.MINUTE constant value
                unit      : Sch.util.Date.MINUTE,
                increment : 5
            },
            headerConfig      : {
                middle : {
                    // and here we use the last fraction Sch.util.Date.HOUR constant name
                    unit       : "HOUR",
                    dateFormat : 'G:i'
                },
                top    : {
                    // and here we use the last fraction of Sch.util.Date.DAY constant name
                    unit       : "DAY",
                    dateFormat : 'D d/m'
                }
            }
        });

But if the one deals with preset properties on the low level (without calling {@link Sch.preset.Manager#registerPreset} method)
he can use only constant values approach:

        // providing "MINUTE" won't work, we should use Sch.util.Date.MINUTE constant
        Sch.preset.Manager.get("hour").timeResolution.unit = Sch.util.Date.MINUTE;

*/
Ext.define("Sch.preset.ViewPreset", {
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {String} name The name of the preset by which it is registered in the Manager
     */
    name: null,
    /**
     * @cfg {Number} rowHeight The height of the row in horizontal orientation
     */
    rowHeight: 24,
    /**
     * @cfg {Number} timeColumnWidth The width of the time tick column in horizontal orientation. Also used as height of time tick row
     * in vertical orientation, unless {@link #timeRowHeight} is provided.
     */
    timeColumnWidth: 50,
    /**
     * @cfg {Number} timeRowHeight The height of the time tick row in vertical orientation. If omitted, a value of {@link #timeColumnWidth}
     * is used.
     */
    timeRowHeight: null,
    /**
     * @cfg {Number} timeAxisColumnWidth The width of the time axis column in the vertical orientation
     */
    timeAxisColumnWidth: null,
    /**
    * @cfg {String} displayDateFormat Defines how dates will be formatted in tooltips etc
    */
    displayDateFormat: 'G:i',
    /**
     * @cfg {String} shiftUnit The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.
     * Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
     */
    shiftUnit: "HOUR",
    /**
     * @cfg {Number} shiftIncrement The amount to shift (in shiftUnits)
     */
    shiftIncrement: 1,
    /**
     * @cfg {Number} defaultSpan The amount of time to show by default in a view (in the unit defined by the middle header)
     */
    defaultSpan: 12,
    /**
     * @cfg {Object} timeResolution An object containing a unit identifier and an increment variable. Example:
     *
        timeResolution : {
            unit        : "HOUR",  //Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 1
        }
     *
     */
    timeResolution: null,
    /**
     * @cfg {Object} headerConfig An object containing one or more {@link Sch.preset.ViewPresetHeaderRow} rows defining how your headers shall be composed.
     * Your 'main' unit should be the middle header unit. This object can contain "bottom", "middle" and "top" header definitions. The 'middle' header is mandatory.
     */
    headerConfig: null,
    /**
     * @cfg {String} columnLinesFor Defines the header level that the column lines will be drawn for. See {@link Sch.mixin.AbstractTimelinePanel#columnLines}
     */
    columnLinesFor: 'middle',
    // internal properties
    headers: null,
    mainHeader: 0,
    /**
     * @cfg {String} ptype The viewPreset to use and extend when the preset is passed as a config object.
     */
    ptype: '',
    constructor: function(cfg) {
        Ext.apply(this, cfg);
        this.normalizeUnits();
    },
    normalizeUnits: function() {
        var headerConfig = this.headerConfig;
        var DATE = Sch.util.Date;
        // Make sure date "unit" constant specified in the preset are resolved
        for (var o in headerConfig) {
            if (headerConfig.hasOwnProperty(o)) {
                if (DATE[headerConfig[o].unit]) {
                    headerConfig[o].unit = DATE[headerConfig[o].unit.toUpperCase()];
                }
                if (DATE[headerConfig[o].splitUnit]) {
                    headerConfig[o].splitUnit = DATE[headerConfig[o].splitUnit.toUpperCase()];
                }
            }
        }
        var timeResolution = this.timeResolution;
        // Resolve date units
        if (timeResolution && DATE[timeResolution.unit]) {
            timeResolution.unit = DATE[timeResolution.unit.toUpperCase()];
        }
        var shiftUnit = this.shiftUnit;
        // Resolve date units
        if (shiftUnit && DATE[shiftUnit]) {
            this.shiftUnit = DATE[shiftUnit.toUpperCase()];
        }
    },
    getHeaders: function() {
        if (this.headers)  {
            return this.headers;
        }
        
        var headerConfig = this.headerConfig;
        this.mainHeader = headerConfig.top ? 1 : 0;
        return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    getMainHeader: function() {
        return this.getHeaders()[this.mainHeader];
    },
    getBottomHeader: function() {
        var headers = this.getHeaders();
        return headers[headers.length - 1];
    },
    clone: function() {
        var config = {};
        var me = this;
        Ext.Array.each([
            'rowHeight',
            'timeColumnWidth',
            'timeRowHeight',
            'timeAxisColumnWidth',
            'displayDateFormat',
            'shiftUnit',
            'shiftIncrement',
            'defaultSpan',
            'timeResolution',
            'headerConfig'
        ], function(name) {
            config[name] = me[name];
        });
        return new this.self(Ext.clone(config));
    },
    isValid: function() {
        var D = Sch.util.Date,
            valid = true,
            validUnits = Sch.util.Date.units,
            ownKeys = {};
        // Make sure all date "unit" constants are valid
        for (var o in this.headerConfig) {
            if (this.headerConfig.hasOwnProperty(o)) {
                ownKeys[o] = true;
                valid = valid && Ext.Array.indexOf(validUnits, this.headerConfig[o].unit) >= 0;
            }
        }
        if (!(this.columnLinesFor in ownKeys)) {
            this.columnLinesFor = 'middle';
        }
        if (this.timeResolution) {
            valid = valid && Ext.Array.indexOf(validUnits, this.timeResolution.unit) >= 0;
        }
        if (this.shiftUnit) {
            valid = valid && Ext.Array.indexOf(validUnits, this.shiftUnit) >= 0;
        }
        return valid;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.preset.Manager
@singleton

Provides a registry of the possible view presets that any instance of a Panel with {@link Sch.mixin.SchedulerPanel} mixin can use.

See the {@link Sch.preset.ViewPreset} and {@link Sch.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.

Available presets are:

- `secondAndMinute` - creates 2 level header - minute and seconds within it: {@img scheduler/images/secondAndMinute.png}
- `minuteAndHour` - creates 2 level header - hour and minutes within it: {@img scheduler/images/minuteAndHour.png}
- `hourAndDay` - creates 2 level header - day and hours within it: {@img scheduler/images/hourAndDay.png}
- `dayAndWeek` - creates 2 level header - week and days within it: {@img scheduler/images/dayAndWeek.png}
- `weekAndDay` - just like `dayAndWeek` but with different formatting: {@img scheduler/images/weekAndDay.png}
- `weekAndMonth` - creates 2 level header - month and weeks within it: {@img scheduler/images/weekAndMonth.png}

- `monthAndYear` - creates 2 level header - year and months within it: {@img scheduler/images/monthAndYear.png}
- `year` - creates 2 level header - year and quarters within it: {@img scheduler/images/year-preset.png}
- `manyYears` - creates 2 level header - 5-years and year within it: {@img scheduler/images/manyYears.png}
- `weekAndDayLetter` - creates 2 level header - with weeks and day letters within it: {@img scheduler/images/weekAndDayLetter.png}
- `weekDateAndMonth` - creates 2 level header - month and weeks within it (weeks shown by first day only): {@img scheduler/images/weekDateAndMonth.png}

You can register your own preset with the {@link #registerPreset} call or pass a preset configuration in the scheduler panel.

*/
Ext.define('Sch.preset.Manager', {
    extend: 'Ext.util.MixedCollection',
    requires: [
        'Sch.util.Date',
        'Sch.preset.ViewPreset'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    singleton: true,
    defaultPresets: {
        secondAndMinute: {
            timeColumnWidth: 30,
            // Time column width (used for rowHeight in vertical mode)
            rowHeight: 24,
            // Only used in horizontal orientation
            resourceColumnWidth: 100,
            // Only used in vertical orientation
            displayDateFormat: 'G:i:s',
            // Controls how dates will be displayed in tooltips etc
            shiftIncrement: 10,
            // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit: 'MINUTE',
            // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan: 24,
            // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution: {
                // Dates will be snapped to this resolution
                unit: 'SECOND',
                // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment: 5
            },
            headerConfig: {
                // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle: {
                    unit: 'SECOND',
                    increment: 10,
                    align: 'center',
                    dateFormat: 's'
                },
                top: {
                    unit: 'MINUTE',
                    align: 'center',
                    dateFormat: 'D, d g:iA'
                }
            }
        },
        minuteAndHour: {
            timeColumnWidth: 100,
            // Time column width (used for rowHeight in vertical mode)
            rowHeight: 24,
            // Only used in horizontal orientation
            resourceColumnWidth: 100,
            // Only used in vertical orientation
            displayDateFormat: 'G:i',
            // Controls how dates will be displayed in tooltips etc
            shiftIncrement: 1,
            // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit: 'HOUR',
            // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan: 24,
            // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution: {
                // Dates will be snapped to this resolution
                unit: 'MINUTE',
                // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment: 30
            },
            headerConfig: {
                // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle: {
                    unit: 'MINUTE',
                    increment: '30',
                    align: 'center',
                    dateFormat: 'i'
                },
                top: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'D, gA/d'
                }
            }
        },
        hourAndDay: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'DAY',
            defaultSpan: 24,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            headerConfig: {
                middle: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'G:i'
                },
                top: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d/m'
                }
            }
        },
        dayAndWeek: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d G:i',
            shiftUnit: 'DAY',
            shiftIncrement: 1,
            defaultSpan: 5,
            timeResolution: {
                unit: 'HOUR',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d M'
                },
                top: {
                    unit: 'WEEK',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Sch.util.Date.getShortNameOfUnit('WEEK') + '.' + Ext.Date.format(start, 'W M Y');
                    }
                }
            }
        },
        weekAndDay: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: 'DAY',
                    align: 'center',
                    increment: 1,
                    dateFormat: 'd/m'
                },
                middle: {
                    unit: 'WEEK',
                    dateFormat: 'D d M'
                }
            }
        },
        weekAndMonth: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 5,
            defaultSpan: 6,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Ext.Date.format(start, 'd M');
                    }
                },
                top: {
                    unit: 'MONTH',
                    align: 'center',
                    dateFormat: 'M Y'
                }
            }
        },
        monthAndYear: {
            timeColumnWidth: 110,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftIncrement: 3,
            shiftUnit: 'MONTH',
            defaultSpan: 12,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'MONTH',
                    align: 'center',
                    dateFormat: 'M Y'
                },
                top: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y'
                }
            }
        },
        year: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'YEAR',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'MONTH',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'QUARTER',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit('QUARTER').toUpperCase() + '{0}', Math.floor(start.getMonth() / 3) + 1);
                    }
                },
                top: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y'
                }
            }
        },
        manyYears: {
            timeColumnWidth: 50,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'YEAR',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'YEAR',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y',
                    increment: 5
                },
                // smallest zoom level looked back
                // we have to specify increments here since 'increment' in zoomLevel affects only bottom header
                bottom: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'y',
                    increment: 1
                }
            }
        },
        weekAndDayLetter: {
            timeColumnWidth: 20,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: 'DAY',
                    align: 'center',
                    renderer: function(start) {
                        return Ext.Date.dayNames[start.getDay()].substring(0, 1);
                    }
                },
                middle: {
                    unit: 'WEEK',
                    dateFormat: 'D d M Y'
                }
            }
        },
        weekDateAndMonth: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    dateFormat: 'd'
                },
                top: {
                    unit: 'MONTH',
                    dateFormat: 'Y F'
                }
            }
        },
        day: {
            timeRowHeight: 40,
            calendarColumnWidth: 200,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'DAY',
            defaultSpan: 1,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            headerConfig: {
                bottom: {
                    unit: 'HOUR',
                    align: 'center',
                    renderer: function(value) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span>' + '<span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
                    }
                },
                middle: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d/m',
                    splitUnit: 'DAY'
                }
            }
        },
        week: {
            timeRowHeight: 40,
            calendarColumnWidth: 164,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'WEEK',
            defaultSpan: 24,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            headerConfig: {
                bottom: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'H:i',
                    // will be overridden by renderer
                    renderer: function(value) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct">' + '<span class="sch-calendarcolumn-hours">{0}</span>' + '<span class="sch-calendarcolumn-minutes">{1}</span>' + '</div>', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
                    }
                },
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    dateFormat: 'D d',
                    splitUnit: 'DAY'
                }
            }
        },
        month: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'MONTH',
            defaultSpan: 4,
            timeResolution: {
                unit: 'HOUR',
                increment: 12
            },
            headerConfig: {
                bottom: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D',
                    splitUnit: 'WEEK'
                },
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    dateFormat: 'D d/m'
                },
                top: {
                    unit: 'MONTH',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Ext.Date.format(start, 'd/m') + ' - ' + Ext.Date.format(end, 'd/m, Y');
                    },
                    splitUnit: 'WEEK'
                }
            }
        }
    },
    constructor: function() {
        this.callParent(arguments);
        this.registerDefaults();
    },
    onLocalized: function() {
        var me = this;
        this.eachKey(function(name, preset) {
            if (me.l10n[name]) {
                var locale = me.L(name);
                locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
                locale.middleDateFormat && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
                locale.topDateFormat && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
                locale.bottomDateFormat && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
            }
        });
    },
    /**
    * Registers a new view preset to be used by any scheduler grid or tree on the page.
    * @param {String} name The unique name identifying this preset
    * @param {Object} config The configuration properties of the view preset (see {@link Sch.preset.ViewPreset} for more information)
    */
    registerPreset: function(name, cfg) {
        cfg.name = name;
        var preset = new Sch.preset.ViewPreset(cfg);
        if (preset.isValid()) {
            if (this.containsKey(name))  {
                this.removeAtKey(name);
            }
            
            this.add(name, preset);
        } else {
            throw 'Invalid preset, please check your configuration';
        }
    },
    /**
    * Fetches a view preset from the global cache
    * @param {String} name The name of the preset
    * @return {Object} The view preset, see {@link Sch.preset.ViewPreset} for more information
    */
    getPreset: function(name) {
        return this.get(name);
    },
    /**
    * Deletes a view preset
    * @param {String} name The name of the preset
    */
    deletePreset: function(name) {
        this.removeAtKey(name);
    },
    registerDefaults: function() {
        var pm = this,
            vp = this.defaultPresets;
        for (var p in vp) {
            pm.registerPreset(p, vp[p]);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.view.model.TimeAxis
@extends Ext.util.Observable
@private

This class is an internal view model class, describing the visual representation of a {@link Sch.data.TimeAxis timeaxis}.
The config for the header rows is described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
To calculate the widths of each cell in the time axis, this class requires:

- availableWidth  - The total width available for the rendering
- tickWidth     - The fixed width of each cell in the lowest header row. This value is normally read from the
{@link Sch.preset.ViewPreset viewPreset} but this can also be updated programmatically using {@link #setTickWidth}

Normally you should not interact with this class directly.

*/
Ext.define("Sch.view.model.TimeAxis", {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.Date',
        'Sch.util.Date',
        'Sch.preset.Manager'
    ],
    /**
     * @cfg {Sch.data.TimeAxis} timeAxis
     * The time axis providing the underlying data to be visualized
     */
    timeAxis: null,
    /**
     * @cfg {Number} availableWidth
     * The available width, this is normally not known by the consuming UI component using this model class until it has been fully rendered.
     * The consumer of this model should call {@link #setAvailableWidth} when its width has changed.
     */
    availableWidth: 0,
    /**
     * @cfg {Number} tickWidth
     * The "tick width" to use for the cells in the bottom most header row.
     * This value is normally read from the {@link Sch.preset.ViewPreset viewPreset}
     */
    tickWidth: 100,
    /**
     * @cfg {Boolean} snapToIncrement
     * true if there is a requirement to be able to snap events to a certain view resolution.
     * This has implications of the {@link #tickWidth} that can be used, since all widths must be in even pixels.
     */
    snapToIncrement: false,
    /**
     * @cfg {Boolean} forceFit
     * true if cells in the bottom-most row should be fitted to the {@link #availableWidth available width}.
     */
    forceFit: false,
    headerConfig: null,
    // cached linear version of `headerConfig` - array of levels, starting from top
    headers: null,
    mainHeader: 0,
    calendar: null,
    // the width of time axis column in vertical
    timeAxisColumnWidth: null,
    // the width of resource column in vertical
    resourceColumnWidth: null,
    // width of the columns in calendar view
    calendarColumnWidth: null,
    // array of columns start/end dates, because timeaxis may be filtered
    calendarColumnDates: null,
    // aka tickWidth in horizontal
    timeColumnWidth: null,
    rowHeightHorizontal: null,
    rowHeightVertical: null,
    mode: 'horizontal',
    // or 'vertical'
    //used for Exporting. Make sure the tick columns are not recalculated when resizing.
    suppressFit: false,
    // Since this model may be shared by multiple synced timelinePanels, we need to keep count of usage to know when we can destroy the view model.
    refCount: 0,
    // cache of the config currently used.
    columnConfig: {},
    // the view preset name to apply initially
    viewPreset: null,
    // The default header level to draw column lines for
    columnLinesFor: 'middle',
    eventStore: null,
    originalTickWidth: null,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        if (this.viewPreset) {
            if (this.viewPreset instanceof Sch.preset.ViewPreset) {
                this.consumeViewPreset(this.viewPreset);
            } else {
                var preset = Sch.preset.Manager.getPreset(this.viewPreset);
                preset && this.consumeViewPreset(preset);
            }
        }
        /**
         * @event update
         * Fires after the model has been updated.
         * @param {Sch.view.model.TimeAxis} model The model instance
         */
        // When time axis is changed, reconfigure the model
        me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);
        this.callParent(arguments);
    },
    destroy: function() {
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    },
    onTimeAxisReconfigure: function(timeAxis, suppressRefresh) {
        if (!suppressRefresh) {
            this.update();
        }
    },
    reconfigure: function(config) {
        // clear the cached headers
        this.headers = null;
        Ext.apply(this, config);
        switch (this.mode) {
            case 'horizontal':
                this.setTickWidth(this.timeColumnWidth);
                break;
            case 'vertical':
                this.setTickWidth(this.rowHeightVertical);
                break;
            case 'calendar':
                this.setTickWidth(this.rowHeightVertical);
                break;
        }
        this.fireEvent('reconfigure', this);
    },
    /**
     *  Returns a model object of the current timeAxis, containing an array representing the cells for each level in the header.
     *  This object will always contain a 'middle' array, and depending on the {@link Sch.preset.ViewPreset#headerConfig} it can also contain a 'top' and 'bottom' property.
     *  @return {Object} The model representing each cell (with start date and end date) in the timeline representation.
     */
    getColumnConfig: function() {
        return this.columnConfig;
    },
    /**
     *  Updates the view model current timeAxis configuration and available width.
     *  @param {Number} [availableWidth] The available width for the rendering of the axis (used in forceFit mode)
     */
    update: function(availableWidth, suppressEvent) {
        var timeAxis = this.timeAxis,
            headerConfig = this.headerConfig;
        this.availableWidth = Math.max(availableWidth || this.availableWidth, 0);
        if (!Ext.isNumber(this.availableWidth)) {
            throw 'Invalid available width provided to Sch.view.model.TimeAxis';
        }
        if (this.forceFit && this.availableWidth <= 0) {
            // No point in continuing
            return;
        }
        this.columnConfig = {};
        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
        for (var pos in headerConfig) {
            if (headerConfig[pos].cellGenerator) {
                this.columnConfig[pos] = headerConfig[pos].cellGenerator.call(this, timeAxis.getStart(), timeAxis.getEnd());
            } else {
                this.columnConfig[pos] = this.createHeaderRow(pos, headerConfig[pos]);
            }
        }
        // The "column width" is considered to be the width of each tick in the lowest header row and this width
        // has to be same for all cells in the lowest row.
        var tickWidth = this.calculateTickWidth(this.originalTickWidth);
        if (!Ext.isNumber(tickWidth) || tickWidth <= 0) {
            throw 'Invalid column width calculated in Sch.view.model.TimeAxis';
        }
        this.updateTickWidth(tickWidth);
        if (!suppressEvent)  {
            this.fireEvent('update', this);
        }
        
    },
    /**
     * Will update columns start/end dates to perform date/coordinate lookups
     * @param {Object[]} columns Array of column configs including start/end dates
     * @private
     */
    updateCalendarColumnDates: function(columns) {
        this.calendarColumnDates = [];
        for (var i = 0; i < columns.length; i++) {
            var obj = columns[i];
            this.calendarColumnDates.push([
                obj.start,
                obj.end
            ]);
        }
    },
    /**
     * Returns current column start/end dates array
     * @returns {Date[][]}
     * @private
     */
    getCalendarColumnDates: function() {
        return this.calendarColumnDates;
    },
    // private
    createHeaderRow: function(position, headerConfig) {
        var cells = [],
            me = this,
            align = headerConfig.align,
            today = Ext.Date.clearTime(new Date());
        me.forEachInterval(position, function(start, end, i) {
            var colConfig = {
                    align: align,
                    start: start,
                    end: end,
                    headerCls: ''
                };
            if (headerConfig.renderer) {
                colConfig.header = headerConfig.renderer.call(headerConfig.scope || me, start, end, colConfig, i, me.eventStore);
            } else {
                colConfig.header = Ext.Date.format(start, headerConfig.dateFormat);
            }
            // To be able to style individual day cells, weekends or other important days
            if (headerConfig.unit === Sch.util.Date.DAY && (!headerConfig.increment || headerConfig.increment === 1)) {
                colConfig.headerCls += ' sch-dayheadercell-' + start.getDay();
                if (this.calendar && this.calendar.isWeekend(start)) {
                    colConfig.headerCls += ' sch-dayheadercell-nonworking';
                }
                if (Ext.Date.clearTime(start, true) - today === 0) {
                    colConfig.headerCls += ' sch-dayheadercell-today';
                }
            }
            cells.push(colConfig);
        });
        return cells;
    },
    /**
     *  Returns the distance for a timespan with the given start and end date.
     *  @return {Number} The width of the time span
     */
    getDistanceBetweenDates: function(start, end) {
        return Math.round(this.getPositionFromDate(end, true) - this.getPositionFromDate(start));
    },
    /**
     *  Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
     *  @param {Date} date, the date to query for.
     *  @param {Boolean} [isEnd] true to return bottom coordinate for calendar view
     *  @returns {Number} the coordinate representing the date
     */
    getPositionFromDate: function(date, isEnd) {
        var result = -1;
        if (this.mode === 'calendar') {
            var rowHeight = this.rowHeightVertical;
            var headers = this.getHeaders();
            var startDate = this.timeAxis.getStart();
            var UD = Sch.util.Date;
            // calendar view inherits vertical view so this method should only return vertical coordinate
            var verticalDate = UD.mergeDates(startDate, date, headers[1].unit);
            result = UD.getDurationInUnit(startDate, verticalDate, headers[1].unit, true) * rowHeight;
            if (result === 0 && isEnd) {
                result = this.calendarRowsAmount * rowHeight;
            }
        } else {
            var tick = this.timeAxis.getTickFromDate(date);
            if (tick >= 0) {
                result = this.tickWidth * (tick - this.timeAxis.visibleTickStart);
            }
        }
        return Math.round(result);
    },
    /**
     * Gets the date for a position on the time axis
     * @param {Number} position The page X or Y coordinate
     * @param {String} roundingMethod The rounding method to use
     * @returns {Date} the Date corresponding to the xy coordinate
     */
    getDateFromPosition: function(position, roundingMethod) {
        if (this.mode === 'calendar') {
            var columns = this.getCalendarColumnDates();
            if (!columns) {
                return null;
            }
            // Last column width may differ in 1px, so we need to constrain columnIndex by array length
            var columnIndex = Math.min(Math.floor(Math.max(position[0], 0) / this.calendarColumnWidth), columns.length - 1),
                horizontalDate = columns[columnIndex][0],
                first = this.timeAxis.first(),
                millisecondsPerPixel = (first.get('end') - first.get('start')) / this.rowHeightVertical,
                UD = Sch.util.Date,
                result = UD.add(horizontalDate, UD.MILLI, Math.round(position[1] * millisecondsPerPixel));
            if (roundingMethod) {
                result = this.timeAxis[roundingMethod + 'Date'](result);
            }
            return result;
        } else {
            var tick = position / this.getTickWidth() + this.timeAxis.visibleTickStart,
                nbrTicks = this.timeAxis.getCount();
            if (tick < 0 || tick > nbrTicks) {
                return null;
            }
            return this.timeAxis.getDateFromTick(tick, roundingMethod);
        }
    },
    /**
     * Returns the amount of pixels for a single unit
     * @private
     * @return {Number} The unit in pixel
     */
    getSingleUnitInPixels: function(unit) {
        return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), unit) * this.tickWidth / this.timeAxis.increment;
    },
    /**
     * [Experimental] Returns the pixel increment for the current view resolution.
     * @return {Number} The width increment
     */
    getSnapPixelAmount: function() {
        if (this.snapToIncrement) {
            var resolution = this.timeAxis.getResolution();
            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
        } else {
            return 1;
        }
    },
    /**
     * Returns the current time column width (the width of a cell in the lowest header row)
     * @return {Number} The width
     */
    getTickWidth: function() {
        return this.tickWidth;
    },
    /**
     * Sets a new tick width (the width of a time cell in the bottom-most time axis row)
     * @param {Number} width The width
     */
    setTickWidth: function(width, suppressEvent) {
        this.originalTickWidth = width;
        this.updateTickWidth(width);
        this.update(null, suppressEvent);
    },
    updateTickWidth: function(value) {
        this.tickWidth = value;
        switch (this.mode) {
            case 'horizontal':
                this.timeColumnWidth = value;
                break;
            case 'vertical':
                this.rowHeightVertical = value;
                break;
            case 'calendar':
                this.rowHeightVertical = value;
                break;
        }
    },
    /**
     * Returns the total width of the time axis representation.
     * @return {Number} The width
     */
    getTotalWidth: function() {
        return Math.round(this.tickWidth * this.timeAxis.getVisibleTickTimeSpan());
    },
    // Calculates the time column width based on the value defined viewPreset "timeColumnWidth". It also checks for the forceFit view option
    // and the snapToIncrement, both of which impose constraints on the time column width configuration.
    calculateTickWidth: function(proposedWidth) {
        var forceFit = this.forceFit;
        var timeAxis = this.timeAxis;
        var width = 0,
            timelineUnit = timeAxis.getUnit(),
            ratio = Number.MAX_VALUE,
            DATE = Sch.util.Date;
        if (this.snapToIncrement) {
            var resolution = timeAxis.getResolution();
            ratio = DATE.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
        } else {
            var measuringUnit = DATE.getMeasuringUnit(timelineUnit);
            ratio = Math.min(ratio, DATE.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
        }
        if (!this.suppressFit) {
            var ticks = this.mode === 'calendar' ? timeAxis.endTime - timeAxis.startTime : timeAxis.getVisibleTickTimeSpan(),
                fittingWidth = Math[forceFit ? 'floor' : 'round'](this.getAvailableWidth() / ticks);
            width = (forceFit || proposedWidth < fittingWidth) ? fittingWidth : proposedWidth;
            if (ratio > 0 && (!forceFit || ratio < 1)) {
                // For touch, make sure we always fill the available space with forceFit (to not show edges of side-time-pickers)
                var method = Ext.versions.touch && forceFit ? 'ceil' : (forceFit ? 'floor' : 'round');
                width = Math.round(Math.max(1, Math[method](ratio * width)) / ratio);
            }
        } else {
            width = proposedWidth;
        }
        return width;
    },
    /**
     * Returns the available width for the time axis representation.
     * @return {Number} The available width
     */
    getAvailableWidth: function() {
        return this.availableWidth;
    },
    /**
     * Sets the available width for the model, which (if changed) will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Number} width The width
     */
    setAvailableWidth: function(width) {
        //        if (width && width != this.availableWidth) this.update(width);
        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't
        // occupy the available space - and gets stretched
        this.availableWidth = Math.max(0, width);
        var newTickWidth = this.calculateTickWidth(this.originalTickWidth);
        if (newTickWidth !== this.tickWidth) {
            this.update();
        }
    },
    /**
     * This function fits the time columns into the available space in the time axis column.
     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
     */
    fitToAvailableWidth: function(suppressEvent) {
        var proposedWidth = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());
        this.setTickWidth(proposedWidth, suppressEvent);
    },
    /**
     * Sets the forceFit value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Boolean} value
     */
    setForceFit: function(value) {
        if (value !== this.forceFit) {
            this.forceFit = value;
            this.update();
        }
    },
    /**
     * Sets the snapToIncrement value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Boolean} value
     */
    setSnapToIncrement: function(value) {
        if (value !== this.snapToIncrement) {
            this.snapToIncrement = value;
            this.update();
        }
    },
    getViewRowHeight: function() {
        var val = this.mode == 'horizontal' ? this.rowHeightHorizontal : this.rowHeightVertical;
        // Sanity check
        if (!val)  {
            throw 'rowHeight info not available';
        }
        
        return val;
    },
    setViewRowHeight: function(value, suppressEvent) {
        var isHorizontal = this.mode === 'horizontal';
        var property = 'rowHeight' + Ext.String.capitalize(this.mode);
        if (this[property] != value) {
            this[property] = value;
            if (isHorizontal) {
                if (!suppressEvent)  {
                    this.fireEvent('update', this);
                }
                
            } else {
                this.setTickWidth(value, suppressEvent);
            }
        }
    },
    setViewColumnWidth: function(value, suppressEvent) {
        switch (this.mode) {
            case 'horizontal':
                this.setTickWidth(value, suppressEvent);
                break;
            case 'vertical':
                this.resourceColumnWidth = value;
                break;
            case 'calendar':
                this.calendarColumnWidth = value;
                break;
        }
        if (!suppressEvent) {
            this.fireEvent('columnwidthchange', this, value);
        }
    },
    getHeaders: function() {
        if (this.headers)  {
            return this.headers;
        }
        
        var headerConfig = this.headerConfig;
        // main header is always `middle` (which is always requires to present in `headerConfig`)
        // `top` may absent, in this case `middle` will be on 0-th index
        this.mainHeader = headerConfig.top ? 1 : 0;
        return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    getMainHeader: function() {
        return this.getHeaders()[this.mainHeader];
    },
    getBottomHeader: function() {
        var headers = this.getHeaders();
        return headers[headers.length - 1];
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @param {String} position 'main' (middle), 'top' or 'bottom'
     * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachInterval: function(position, iteratorFn, scope) {
        scope = scope || this;
        var headerConfig = this.headerConfig;
        if (!headerConfig)  {
            return;
        }
        
        // Not initialized
        if (position === 'top' || (position === 'middle' && headerConfig.bottom)) {
            var header = headerConfig[position];
            this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, scope);
        } else {
            // This is the lowest header row, which should be fed the data in the tickStore
            this.timeAxis.each(function(r, index) {
                return iteratorFn.call(scope, r.data.start, r.data.end, index);
            });
        }
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @protected
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachMainInterval: function(iteratorFn, scope) {
        this.forEachInterval('middle', iteratorFn, scope);
    },
    getLowestHeader: function() {
        return 'bottom' in this.headerConfig ? 'bottom' : 'middle';
    },
    consumeViewPreset: function(preset) {
        // clear the cached headers
        this.headers = null;
        var isHorizontal = this.mode == 'horizontal';
        Ext.apply(this, {
            headerConfig: preset.headerConfig,
            columnLinesFor: preset.columnLinesFor || 'middle',
            rowHeightHorizontal: preset.rowHeight,
            tickWidth: isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeColumnWidth: preset.timeColumnWidth,
            // timeColumnWidth is also used for row height in vertical mode
            rowHeightVertical: preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeAxisColumnWidth: preset.timeAxisColumnWidth,
            resourceColumnWidth: preset.resourceColumnWidth || 100
        });
        this.originalTickWidth = this.tickWidth;
    },
    setEventStore: function(store) {
        this.eventStore = store;
    },
    setCalendar: function(cal) {
        this.calendar = cal;
        if (cal) {
            this.update();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.feature.AbstractTimeSpan
@extends Ext.AbstractPlugin

Plugin for visualizing "global" time span in the scheduler grid, these can by styled easily using just CSS. This is an abstract class not intended for direct use.

*/
Ext.define("Sch.feature.AbstractTimeSpan", {
    extend: 'Ext.AbstractPlugin',
    mixins: {
        observable: 'Ext.util.Observable'
    },
    lockableScope: 'top',
    schedulerView: null,
    timeAxis: null,
    // If lines/zones should stretch to fill the whole view container element in case the table does not fill it
    expandToFitView: false,
    disabled: false,
    /**
     * @property {String} cls An internal css class which is added to each rendered timespan element
     * @private
     */
    cls: null,
    /**
     * @cfg {String} clsField Name of field
     */
    clsField: 'Cls',
    /**
     * @cfg {Ext.XTemplate} template Template to render the timespan elements
     */
    template: null,
    /**
     * @cfg {Ext.data.Store} store A store with timespan data, or a string identifying a store.
     */
    store: null,
    renderElementsBuffered: false,
    /**
     * @cfg {Number} renderDelay Delay the zones rendering by this amount (in ms) to speed up the default rendering of rows and events.
     */
    renderDelay: 0,
    // true to refresh the sizes of the rendered elements when an item in the bound view changes
    // false to do a full refresh instead
    refreshSizeOnItemUpdate: true,
    _renderTimer: null,
    /**
     * @cfg {Boolean} showHeaderElements Set this to `true` to show indicators in the timeline header area.
     *
     * Header indicators are placed right above the corresponding element of the scheduling view. You can customize the HTML markup
     * for these indicators with the {@link #headerTemplate} config. Note that the indicators are rendered as a regular div element,
     * which will be styled differently in modern vs legacy browsers.
     *
     */
    showHeaderElements: false,
    /**
     * @private
     * @cfg {Ext.XTemplate} headerTemplate Template used to render the header elements
     */
    headerTemplate: null,
    /**
     * @cfg {String/Ext.XTemplate} innerHeaderTpl A template providing additional markup to render into each timespan header element
     */
    innerHeaderTpl: null,
    headerContainerCls: 'sch-header-secondary-canvas',
    headerContainerEl: null,
    // event to be fired, when rendering has completed (only fired when all elements are rendered, not single)
    renderingDoneEvent: null,
    constructor: function(cfg) {
        // unique css class to be able to identify only the zones belonging to this plugin instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        Ext.apply(this, cfg);
        this.mixins.observable.constructor.call(this);
        this.callParent(arguments);
    },
    init: function(scheduler) {
        // TODO COMMENT
        if (Ext.versions.touch && !scheduler.isReady()) {
            scheduler.on('viewready', function() {
                this.init(scheduler);
            }, this);
            return;
        }
        if (typeof this.innerHeaderTpl === 'string') {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        var innerHeaderTpl = this.innerHeaderTpl;
        if (!this.headerTemplate) {
            this.headerTemplate = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="{cls}" style="{side}:{position}px;">' + (innerHeaderTpl ? '{[this.renderInner(values)]}' : '') + '</div>', '</tpl>', {
                renderInner: function(values) {
                    return innerHeaderTpl.apply(values);
                }
            });
        }
        this.schedulerView = scheduler.getSchedulingView();
        this.panel = scheduler;
        this.timeAxis = scheduler.getTimeAxis();
        this.store = Ext.StoreManager.lookup(this.store);
        if (!this.store) {
            Ext.Error.raise("Error: You must define a store for this plugin");
        }
        this.panel.on({
            beforemodechange: this.onTimelinePanelBeforeModeChange,
            modechange: this.onTimelinePanelModeChange,
            horizontaltimeaxiscolumnrender: this.renderHeaderElements,
            scope: this
        });
        if (!this.schedulerView.getEl()) {
            this.schedulerView.on({
                viewready: this.onViewReady,
                scope: this
            });
        } else {
            this.onViewReady();
        }
    },
    /**
     * @param {Boolean} disabled Pass `true` to disable the plugin and remove all rendered elements.
     */
    setDisabled: function(disabled) {
        if (disabled) {
            this.removeElements();
        }
        this.disabled = disabled;
    },
    removeElements: function() {
        this.removeBodyElements();
        if (this.showHeaderElements) {
            this.removeHeaderElements();
        }
    },
    //Returns the currently rendered DOM elements of this plugin (if any), as a {@link Ext.CompositeElementLite} collection.
    getBodyElements: function() {
        var el = this.getContainerEl();
        if (el) {
            return el.select('.' + this.uniqueCls);
        }
        return null;
    },
    /**
     * Returns container to render header elements.
     *
     * @return {Ext.dom.Element|null}
     */
    getHeaderContainerEl: function() {
        var containerEl = this.headerContainerEl,
            prefix = Ext.baseCSSPrefix,
            parent;
        if (!containerEl || !containerEl.dom) {
            if (this.schedulerView.isHorizontal()) {
                var timeAxisColumn = this.panel.getHorizontalTimeAxisColumn();
                if (timeAxisColumn.headerView) {
                    // Column must be rendered first
                    parent = timeAxisColumn.headerView.containerEl;
                } else {
                    return null;
                }
            } else {
                parent = this.panel.el.down('.' + prefix + 'grid-inner-locked' + ' .' + prefix + 'panel-body' + ' .' + prefix + 'grid-view');
            }
            if (parent) {
                containerEl = parent.down('.' + this.headerContainerCls);
                if (!containerEl) {
                    containerEl = parent.appendChild({
                        cls: this.headerContainerCls
                    });
                }
                this.headerContainerEl = containerEl;
            }
        }
        return containerEl;
    },
    getHeaderElements: function() {
        var containerEl = this.getHeaderContainerEl();
        if (containerEl) {
            return containerEl.select('.' + this.uniqueCls);
        }
        return null;
    },
    // private
    removeBodyElements: function() {
        var els = this.getBodyElements();
        if (els) {
            els.each(function(el) {
                el.destroy();
            });
        }
    },
    removeHeaderElements: function() {
        var els = this.getHeaderElements();
        if (els) {
            els.each(function(el) {
                el.destroy();
            });
        }
    },
    /**
     * Returns id of element for data record.
     *
     * @param {Ext.data.Model} record
     *
     * @return {String}
     */
    getElementId: function(record) {
        return this.uniqueCls + '-' + record.internalId;
    },
    /**
     * Returns id of header element for data record.
     *
     * @param {Ext.data.Model} record
     *
     * @return {String}
     */
    getHeaderElementId: function(record) {
        return this.uniqueCls + '-header-' + record.internalId;
    },
    /**
     * Returns template data to render elements.
     *
     * @param {Ext.data.Model} record
     *
     * @return {Object}
     */
    getTemplateData: function(record) {
        return this.prepareTemplateData ? this.prepareTemplateData(record) : record.data;
    },
    /**
     * Return element class for a record.
     *
     * @param {Ext.data.Model} record Data record
     * @param {Object} data Template data
     *
     * @return {String}
     */
    getElementCls: function(record, data) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return this.cls + ' ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    /**
     * Return header element class for data record.
     *
     * @param {Ext.data.Model} record Data record
     * @param {Object} data
     *
     * @return {String}
     */
    getHeaderElementCls: function(record, data) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return 'sch-header-indicator ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    getContainerEl: function() {
        return this.schedulerView.getSecondaryCanvasEl();
    },
    onViewReady: function(scheduler) {
        var view = this.schedulerView;
        this.storeListeners = {
            load: this.renderElements,
            datachanged: this.renderElements,
            clear: this.renderElements,
            add: this.renderElements,
            remove: this.renderElements,
            update: this.refreshSingle,
            scope: this
        };
        this.store.on(this.storeListeners);
        this.viewListeners = {
            // In case we cannot guarantee that we control the GridView "empty the view procedure", where the node container it emptied,
            // we'll need this as a fallback. See GridViewCanvas override of the BufferedRenderer instance
            // bufferedrefresh     : function() {
            //     if (!view.isHorizontal() || this.getContainerEl().dom.childNodes.length === 0) {
            //         this.renderElements();
            //     }
            // },
            refresh: this.renderElements,
            scope: this
        };
        view.on(this.viewListeners);
        this.renderElements();
    },
    // Should not react to view refreshes until everything is fully setup in the new mode
    onTimelinePanelBeforeModeChange: function() {
        this.schedulerView.un(this.viewListeners);
    },
    // Re-enable view listeners and force a new render cycle
    onTimelinePanelModeChange: function() {
        this.schedulerView.on(this.viewListeners);
        this.forceNewRenderingTimeout();
    },
    forceNewRenderingTimeout: function() {
        this.renderElementsBuffered = false;
        clearTimeout(this._renderTimer);
        this.renderElements();
    },
    renderElements: function() {
        if (this.renderElementsBuffered || this.disabled)  {
            return;
        }
        
        this.renderElementsBuffered = true;
        clearTimeout(this._renderTimer);
        // Defer to make sure rendering is not delayed by this plugin
        // deferring on 15 because the cascade delay is 10 (cascading will trigger a view refresh)
        this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this);
    },
    /**
     * Sets element X-coordinate relative direction (rtl or ltr).
     *
     * @param {Ext.Element} el
     * @param {Number} x
     */
    setElementX: function(el, x) {
        if (this.panel.rtl) {
            el.setRight(x);
        } else {
            el.setLeft(x);
        }
    },
    /**
     * Returns position of header element by date.
     *
     * @param {Date} date
     *
     * @return {Number}
     */
    getHeaderElementPosition: function(date) {
        var viewModel = this.schedulerView.getTimeAxisViewModel();
        return Math.round(viewModel.getPositionFromDate(date));
    },
    renderBodyElementsInternal: function(records) {
        var start = this.timeAxis.getStart(),
            end = this.timeAxis.getEnd(),
            data = this.getElementData(start, end, records);
        this.template.append(this.getContainerEl(), data);
    },
    getHeaderElementData: function(records, isPrint) {
        throw 'Abstract method call';
    },
    renderHeaderElements: function(records) {
        var containerEl = this.getHeaderContainerEl();
        if (containerEl) {
            var data = this.getHeaderElementData(records);
            this.headerTemplate.append(containerEl, data);
        }
    },
    renderElementsInternal: function() {
        this.renderElementsBuffered = false;
        // component could be destroyed during the buffering time frame,                 // Skip rendering while main backing store is empty
        if (this.disabled || this.schedulerView.isDestroyed || !this.getContainerEl() || this.schedulerView.store.getCount() === 0)  {
            return;
        }
        
        this.removeElements();
        this.renderBodyElementsInternal();
        if (this.showHeaderElements) {
            this.headerContainerEl = null;
            this.renderHeaderElements();
        }
        if (this.renderingDoneEvent)  {
            this.fireEvent(this.renderingDoneEvent, this);
        }
        
    },
    getElementData: function(viewStart, viewEnd, records, isPrint) {
        throw 'Abstract method call';
    },
    updateBodyElement: function(record) {
        var el = Ext.get(this.getElementId(record));
        if (el) {
            var start = this.timeAxis.getStart(),
                end = this.timeAxis.getEnd(),
                data = this.getElementData(start, end, [
                    record
                ])[0];
            if (data) {
                // Reapply CSS classes
                el.dom.className = data.$cls;
                el.setTop(data.top);
                this.setElementX(el, data.left);
                el.setSize(data.width, data.height);
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderBodyElementsInternal` will only add markup for that record
            this.renderBodyElementsInternal([
                record
            ]);
        }
    },
    updateHeaderElement: function(record) {
        var el = Ext.get(this.getHeaderElementId(record));
        if (el) {
            var data = this.getHeaderElementData([
                    record
                ])[0];
            if (data) {
                // Reapply CSS classes
                el.dom.className = data.cls;
                if (this.schedulerView.isHorizontal()) {
                    this.setElementX(el, data.position);
                    el.setWidth(data.size);
                } else {
                    el.setTop(data.position);
                    el.setHeight(data.size);
                }
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderHeaderElements` will only add markup for that record
            this.renderHeaderElements([
                record
            ]);
        }
    },
    destroy: function() {
        clearTimeout(this._renderTimer);
        this.store.un(this.storeListeners);
        if (this.store.autoDestroy) {
            this.store.destroy();
        }
    },
    refreshSingle: function(store, records) {
        records = records instanceof Array ? records : [
            records
        ];
        Ext.Array.each(records, function(record) {
            this.updateBodyElement(record);
            if (this.showHeaderElements) {
                this.updateHeaderElement(record);
            }
        }, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.Lines
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_lines') for showing "global" time lines in the scheduler grid. It uses a store to populate itself, records in this store should have the following fields:

- `Date` The date of the line. This date is formatted based on what's configured in the {@link Sch.preset.ViewPreset#displayDateFormat} option of the current "viewPreset".
- `Text` The Text to show when hovering over the line (optional)
- `Cls`  A CSS class to add to the line (optional)

To add this plugin to scheduler:

    var dayStore    = new Ext.data.Store({
        fields  : [ 'Date', 'Text', 'Cls' ],

        data    : [
            {
                Date        : new Date(2011, 06, 19),
                Text        : 'Some important day'
            }
        ]
    });


    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Lines', { store : dayStore })
        ]
    });


*/
Ext.define("Sch.plugin.Lines", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: 'plugin.scheduler_lines',
    cls: 'sch-timeline',
    /**
     * @cfg {Boolean} showTip 'true' to include a native browser tooltip when hovering over the line.
     */
    showTip: true,
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    prepareTemplateData: null,
    side: null,
    init: function(scheduler) {
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        this.side = scheduler.rtl ? 'right' : 'left';
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ' : '') + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;width:{width}px">' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '</div>', '</tpl>', {
                getTipText: function(values) {
                    return scheduler.getSchedulingView().getFormattedDate(values.Date) + ' ' + (values.Text || "");
                },
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        this.callParent(arguments);
    },
    getElementData: function(viewStart, viewEnd, records) {
        var s = this.store,
            scheduler = this.schedulerView,
            isHorizontal = scheduler.isHorizontal(),
            isCalendar = scheduler.isCalendar(),
            rs = records || s.getRange(),
            region = scheduler.getTimeSpanRegion(viewStart, null, this.expandToFitView),
            data = [],
            height, width, record, date, templateData;
        for (var i = 0,
            l = rs.length; i < l; i++) {
            record = rs[i];
            date = record.get('Date');
            if (date && scheduler.timeAxis.dateInAxis(date)) {
                templateData = Ext.apply({}, this.getTemplateData(record));
                templateData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                templateData.$cls = this.getElementCls(record, templateData);
                if (isCalendar) {
                    region = scheduler.getTimeSpanRegion(date, date);
                    templateData.left = region.x;
                    templateData.top = region.y;
                    templateData.width = region.right - region.left;
                } else {
                    var pos = scheduler.getCoordinateFromDate(date);
                    if (isHorizontal) {
                        templateData.left = pos;
                    } else {
                        templateData.top = pos;
                    }
                }
                data.push(templateData);
            }
        }
        return data;
    },
    getHeaderElementData: function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            isHorizontal = this.schedulerView.isHorizontal(),
            data = [],
            record, date, position, templateData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            date = record.get('Date');
            if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
                position = this.getHeaderElementPosition(date);
                templateData = this.getTemplateData(record);
                templateData = Ext.apply({
                    side: isHorizontal ? this.side : 'top',
                    cls: this.getHeaderElementCls(record, templateData),
                    position: position
                }, templateData);
                // Overwrite id manually as it might exist in the record raw data
                templateData.id = this.getHeaderElementId(record);
                data.push(templateData);
            }
        }
        return data;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.feature.ColumnLines
 @extends Sch.plugin.Lines

 A simple feature adding column lines (to be used when using the SingleTimeAxis column).

 */
Ext.define("Sch.feature.ColumnLines", {
    extend: 'Sch.plugin.Lines',
    requires: [
        'Ext.data.JsonStore'
    ],
    cls: 'sch-column-line',
    showTip: false,
    timeAxisViewModel: null,
    renderingDoneEvent: 'columnlinessynced',
    useLowestHeader: null,
    init: function(panel) {
        this.timeAxis = panel.getTimeAxis();
        this.timeAxisViewModel = panel.timeAxisViewModel;
        this.panel = panel;
        this.store = new Ext.data.JsonStore({
            fields: [
                'Date'
            ]
        });
        this.callParent(arguments);
        panel.on({
            modechange: this.onModeChange,
            destroy: this.onHostDestroy,
            scope: this
        });
        this.timeAxisViewModel.on('update', this.populate, this);
        this.populate();
    },
    onHostDestroy: function() {
        this.timeAxisViewModel.un('update', this.populate, this);
    },
    onModeChange: function(sender, mode) {
        var disabled = mode !== 'horizontal';
        this.setDisabled(disabled);
        if (!disabled) {
            this.populate();
        }
    },
    populate: function() {
        this.store.setData(this.getData());
    },
    getData: function() {
        var panel = this.panel,
            ticks = [];
        if (panel.isHorizontal()) {
            var timeAxisViewModel = this.timeAxisViewModel;
            var linesForLevel = this.useLowestHeader ? timeAxisViewModel.getLowestHeader() : timeAxisViewModel.columnLinesFor;
            var hasGenerator = !!(timeAxisViewModel.headerConfig && timeAxisViewModel.headerConfig[linesForLevel].cellGenerator);
            if (hasGenerator) {
                var cells = timeAxisViewModel.getColumnConfig()[linesForLevel];
                for (var i = 1,
                    l = cells.length; i < l; i++) {
                    ticks.push({
                        Date: cells[i].start
                    });
                }
            } else {
                // Highlight column lines that match the next higher header row
                var nextLevelUp,
                    headerConfig = timeAxisViewModel.headerConfig,
                    colConfig = timeAxisViewModel.getColumnConfig(),
                    nextHigherLevelTicks, nextLevelCachedDates;
                if (linesForLevel === 'bottom')  {
                    nextLevelUp = "middle";
                }
                else if (linesForLevel === 'middle')  {
                    nextLevelUp = "top";
                }
                
                nextHigherLevelTicks = colConfig[nextLevelUp];
                if (nextHigherLevelTicks && Sch.util.Date.isUnitDivisibleIntoSubunit(headerConfig[nextLevelUp].unit, headerConfig[linesForLevel].unit) && (headerConfig[nextLevelUp].increment !== headerConfig[linesForLevel].increment || headerConfig[nextLevelUp].unit !== headerConfig[linesForLevel].unit)) {
                    nextLevelCachedDates = {};
                    Ext.Array.each(nextHigherLevelTicks, function(tick) {
                        nextLevelCachedDates[tick.start.getTime()] = 1;
                    });
                }
                timeAxisViewModel.forEachInterval(linesForLevel, function(start, end, i) {
                    if (i > 0) {
                        ticks.push({
                            Date: start,
                            Cls: nextLevelCachedDates && nextLevelCachedDates[start.getTime()] ? 'sch-column-line-solid' : ''
                        });
                    }
                });
            }
        }
        return ticks;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.mixin.Zoomable

A mixin for {@link Sch.mixin.TimelinePanel} class, providing "zooming" functionality to the consuming panel.

The zooming feature works by reconfiguring panel's time axis with the current zoom level values selected from the {@link #zoomLevels} array.
Zoom levels can be added and removed from the array to change the amount of available steps. Range of zooming in/out can be also
modified with {@link #maxZoomLevel} / {@link #minZoomLevel} properties.

This mixin adds additional methods to the timeline panel : {@link #setMaxZoomLevel}, {@link #setMinZoomLevel}, {@link #zoomToLevel}, {@link #zoomIn},
{@link #zoomOut}, {@link #zoomInFull}, {@link #zoomOutFull}.

* **Notice**: Zooming doesn't work properly when `forceFit` option is set to true for the panel or for filtered timeaxis.
*/
Ext.define('Sch.mixin.Zoomable', {
    /**
     * @cfg {Array} [zoomLevels=[]] Predefined map of zoom levels for each preset in the ascending order. Zoom level is basically a {@link Sch.preset.ViewPreset view preset},
     * which is based on another preset, with some values overriden.
     *
     * Each element is an {Object} with the following parameters :
     *
     * - `preset` (String)      - {@link Sch.preset.ViewPreset} to be used for this zoom level. This must be a valid preset name registered in {@link Sch.preset.Manager preset manager}.
     * - `width` (Int)          - {@link Sch.preset.ViewPreset#timeColumnWidth timeColumnWidth} time column width value from the preset
     * - `increment` (Int)      - {@link Sch.preset.ViewPresetHeaderRow#increment increment} value from the bottom header row of the preset
     * - `resolution` (Int)     - {@link Sch.preset.ViewPreset#timeResolution increment} part of the `timeResolution` object in the preset
     * - `resolutionUnit` (String) (Optional) - {@link Sch.preset.ViewPreset#timeResolution unit} part of the `timeResolution` object in the preset
     *
     *
     *  The `zoomLevels` config can be set in the scheduler like this:
     *

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            resourceStore : resourceStore,
            eventStore    : eventStore,
            viewPreset    : 'hourAndDay',
            zoomLevels: [
                { width: 50,    increment: 4,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 60,    increment: 3,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 80,    increment: 2,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 100,   increment: 1,   resolution: 15, preset: 'hourAndDay', resolutionUnit: 'MINUTE' }
            ]
        });

     * In the case above:
     *
     * - The `width` specifies the amount of space in pixels for the bottom cell.
     * - The `increment` specifies the number of hours between each bottom cell.
     * - The `resolution` specifies the size of the slots in the bottom cell accordingly to the defined `resolutionUnit`.
     *
     *  In the case above we have four zoomlevel steps within the `hourAndDay` preset. When zooming in we go up in the zoomlevel array, when zooming out we go down in the zoomlevel array.
     *  In this case the zoomlevel with `increment` set to 1 and `width` set to 100 is the most detailed level, the max level. While the first item in the array is the minimal zoomlevel.
     *  In a higher zoomlevel the `resolution` can be set lower to make the granularity of the cell smaller. That means smaller slots for the events to fit in.
     */
    zoomLevels: [
        //YEAR
        {
            width: 40,
            increment: 1,
            resolution: 1,
            preset: 'manyYears',
            resolutionUnit: 'YEAR'
        },
        {
            width: 80,
            increment: 1,
            resolution: 1,
            preset: 'manyYears',
            resolutionUnit: 'YEAR'
        },
        {
            width: 30,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 100,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 200,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        //MONTH
        {
            width: 100,
            increment: 1,
            resolution: 7,
            preset: 'monthAndYear',
            resolutionUnit: 'DAY'
        },
        {
            width: 30,
            increment: 1,
            resolution: 1,
            preset: 'weekDateAndMonth',
            resolutionUnit: 'DAY'
        },
        //WEEK
        {
            width: 35,
            increment: 1,
            resolution: 1,
            preset: 'weekAndMonth',
            resolutionUnit: 'DAY'
        },
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'weekAndMonth',
            resolutionUnit: 'DAY'
        },
        {
            width: 20,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDayLetter'
        },
        //DAY
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDay',
            resolutionUnit: 'HOUR'
        },
        {
            width: 100,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDay',
            resolutionUnit: 'HOUR'
        },
        //HOUR
        {
            width: 50,
            increment: 6,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 100,
            increment: 6,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 60,
            increment: 2,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 60,
            increment: 1,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        //MINUTE
        {
            width: 30,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 60,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 130,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 60,
            increment: 5,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 100,
            increment: 5,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 50,
            increment: 2,
            resolution: 1,
            preset: 'minuteAndHour'
        },
        //SECOND
        {
            width: 30,
            increment: 10,
            resolution: 5,
            preset: 'secondAndMinute'
        },
        {
            width: 60,
            increment: 10,
            resolution: 5,
            preset: 'secondAndMinute'
        },
        {
            width: 130,
            increment: 5,
            resolution: 5,
            preset: 'secondAndMinute'
        }
    ],
    /**
     * @cfg {Number} minZoomLevel Minimal zoom level to which {@link #zoomOut} will work.
     */
    minZoomLevel: null,
    /**
     * @cfg {Number} maxZoomLevel Maximal zoom level to which {@link #zoomIn} will work.
     */
    maxZoomLevel: null,
    /**
     * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
     * wider than the timeline area itself. Used in {@link #zoomToSpan} and {@link #zoomToLevel} functions.
     */
    visibleZoomFactor: 5,
    /**
     * @cfg {Boolean} zoomKeepsOriginalTimespan Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
     * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
     * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
     * to be rendered and affect performance. You can use {@link #minZoomLevel} and {@link #maxZoomLevel} config options for that.
     */
    zoomKeepsOriginalTimespan: false,
    initializeZooming: function() {
        //create instance-specific copy of zoomLevels
        this.zoomLevels = this.zoomLevels.slice();
        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);
    },
    getZoomLevelUnit: function(zoomLevel) {
        return Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
    },
    /*
     * @private
     * Returns number of milliseconds per pixel.
     * @param {Object} level Element from array of {@link #zoomLevels}.
     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.
     * Otherwise density will be calculated for actual tick width.
     * @return {Number} Return number of milliseconds per pixel.
     */
    getMilliSecondsPerPixelForZoomLevel: function(level, ignoreActualWidth) {
        var DATE = Sch.util.Date;
        // trying to convert the unit + increment to a number of milliseconds
        // this number is not fixed (month can be 28, 30 or 31 day), but at least this convertion
        // will be consistent (should be no DST changes at year 1)
        return Math.round((DATE.add(new Date(1, 0, 1), this.getZoomLevelUnit(level), level.increment) - new Date(1, 0, 1)) / // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)
        // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`
        (ignoreActualWidth ? level.width : level.actualWidth || level.width));
    },
    presetToZoomLevel: function(presetName) {
        var preset = Sch.preset.Manager.getPreset(presetName);
        return {
            preset: presetName,
            increment: preset.getBottomHeader().increment || 1,
            resolution: preset.timeResolution.increment,
            resolutionUnit: preset.timeResolution.unit,
            width: preset.timeColumnWidth
        };
    },
    calculateCurrentZoomLevel: function() {
        var zoomLevel = this.presetToZoomLevel(this.viewPreset),
            min = Number.MAX_VALUE,
            viewModel = this.timeAxisViewModel,
            actualWidth = viewModel.timeColumnWidth;
        zoomLevel.width = actualWidth;
        zoomLevel.increment = viewModel.getBottomHeader().increment || 1;
        // when calculating current zoom level we should use tick width from defined zoomLevels
        // otherwise levels might be skipped
        for (var i = 0,
            l = this.zoomLevels.length; i < l; i++) {
            var curentLevel = this.zoomLevels[i];
            // search for a zoom level having the same preset...
            if (curentLevel.preset !== zoomLevel.preset)  {
                
                continue;
            }
            
            // and the most close column width to the actual one
            var delta = Math.abs(curentLevel.width - actualWidth);
            if (delta < min) {
                min = delta;
                zoomLevel.actualWidth = curentLevel.actualWidth;
                zoomLevel.width = curentLevel.width;
            }
        }
        return zoomLevel;
    },
    getCurrentZoomLevelIndex: function() {
        var currentZoomLevel = this.calculateCurrentZoomLevel();
        var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
        var zoomLevels = this.zoomLevels;
        for (var i = 0; i < zoomLevels.length; i++) {
            var zoomLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i]);
            if (zoomLevelFactor == currentFactor)  {
                return i;
            }
            
            // current zoom level is outside of pre-defined zoom levels
            if (i === 0 && currentFactor > zoomLevelFactor)  {
                return -0.5;
            }
            
            if (i == zoomLevels.length - 1 && currentFactor < zoomLevelFactor)  {
                return zoomLevels.length - 1 + 0.5;
            }
            
            var nextLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i + 1]);
            if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor)  {
                return i + 0.5;
            }
            
        }
        throw "Can't find current zoom level index";
    },
    /**
    * Sets the {@link #maxZoomLevel} value.
    * @param {Number} level The level to limit zooming in to.
    */
    setMaxZoomLevel: function(level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }
        this.maxZoomLevel = level;
    },
    /**
    * Sets the {@link #minZoomLevel} value.
    * @param {Number} level The level to limit zooming out to.
    */
    setMinZoomLevel: function(level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }
        this.minZoomLevel = level;
    },
    /**
     * Allows zooming to certain level of {@link #zoomLevels} array. Automatically limits zooming between {@link #maxZoomLevel}
     * and {@link #minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Number} level Level to zoom to.
     * @param {Object} span The time frame. Used to set time axis timespan to the supplied start and end dates. If provided, the view
     * will be centered in this time interval
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @param {Object} [options] Object, containing options for this method
     * @param {Number} options.customWidth Lowest tick width. Might be increased automatically
     * @param {Date} options.scrollTo Date that should be scrolled to
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToLevel: function(level, span, options) {
        level = Ext.Number.constrain(level, this.minZoomLevel, this.maxZoomLevel);
        options = options || {};
        var currentZoomLevel = this.calculateCurrentZoomLevel();
        var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
        var nextZoomLevel = this.zoomLevels[level];
        var nextFactor = this.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);
        if (currentFactor == nextFactor && !span) {
            // already at requested zoom level
            return null;
        }
        var me = this;
        // this event is used to prevent sync suspend during zooming
        me.fireEvent('beforezoomchange', me, level);
        var view = this.getSchedulingView();
        var viewEl = view.getOuterEl();
        var isVertical = this.mode == 'vertical';
        var centerDate = options.centerDate || (span ? new Date((span.start.getTime() + span.end.getTime()) / 2) : this.getViewportCenterDateCached());
        var panelSize = isVertical ? viewEl.getHeight() : viewEl.getWidth();
        var presetCopy = Sch.preset.Manager.getPreset(nextZoomLevel.preset).clone();
        // clone doesn't copy the preset name
        presetCopy.name = nextZoomLevel.preset;
        var bottomHeader = presetCopy.getBottomHeader();
        span = this.calculateOptimalDateRange(centerDate, panelSize, nextZoomLevel, span);
        presetCopy[isVertical ? 'timeRowHeight' : 'timeColumnWidth'] = options.customWidth || nextZoomLevel.width;
        bottomHeader.increment = nextZoomLevel.increment;
        this.isZooming = true;
        presetCopy.increment = nextZoomLevel.increment;
        presetCopy.timeResolution.unit = Sch.util.Date.getUnitByName(nextZoomLevel.resolutionUnit || presetCopy.timeResolution.unit || bottomHeader.unit);
        presetCopy.timeResolution.increment = nextZoomLevel.resolution;
        this.setViewPreset(presetCopy, span.start || this.getStart(), span.end || this.getEnd(), false, {
            centerDate: centerDate
        });
        // after switching the view preset the `width` config of the zoom level may change, because of adjustments
        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method
        // will return the exact level index after zooming
        nextZoomLevel.actualWidth = this.timeAxisViewModel.getTickWidth();
        me.isZooming = false;
        /**
         * @event zoomchange
         *
         * Fires after zoom level has been changed
         *
         * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline object
         * @param {Number} level The index of the new zoom level
         */
        me.fireEvent('zoomchange', me, level);
        return level;
    },
    /*
     * Alias for {@link #zoomToLevel}
     */
    setZoomLevel: function() {
        this.zoomToLevel.apply(this, arguments);
    },
    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     *
     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis
     * will be extended in the same way as {@link #zoomToLevel} method does, to allow scrolling for user.
     *
     * @param {Object} span The time frame.
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToSpan: function(span, config) {
        config = config || {};
        if (config.leftMargin || config.rightMargin) {
            config.adjustStart = 0;
            config.adjustEnd = 0;
        }
        Ext.applyIf(config, {
            leftMargin: 0,
            rightMargin: 0
        });
        if (span.start && span.end) {
            var start = span.start,
                end = span.end,
                // this config enables old zoomToSpan behavior which we want o use for zoomToFit in Gantt
                needToAdjust = config.adjustStart >= 0 && config.adjustEnd >= 0;
            if (needToAdjust) {
                start = Sch.util.Date.add(start, this.timeAxis.mainUnit, -config.adjustStart);
                end = Sch.util.Date.add(end, this.timeAxis.mainUnit, config.adjustEnd);
            }
            if (start <= end) {
                // get scheduling view width
                var availableWidth = this.getSchedulingView().getTimeAxisViewModel().getAvailableWidth();
                // if potential width of col is less than col width provided by zoom level
                //   - we'll zoom out panel until col width fit into width from zoom level
                // and if width of column is more than width from zoom level
                //   - we'll zoom in until col width fit won't fit into width from zoom level
                var currLevel = Math.floor(this.getCurrentZoomLevelIndex());
                // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
                if (currLevel == -1)  {
                    currLevel = 0;
                }
                
                var zoomLevels = this.zoomLevels;
                var diffMS = end - start || 1,
                    msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[currLevel], true),
                    // increment to get next zoom level:
                    // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,
                    // so that more content will "fit" into 1 px
                    //
                    // +1 mean that given timespan will already fit into available width in the current zoom level, but,
                    // perhaps if we'll zoom in a bit more, the fitting will be better
                    inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableWidth ? -1 : 1,
                    candidateLevel = currLevel + inc;
                var zoomLevel,
                    levelToZoom = null;
                // loop over zoom levels
                while (candidateLevel >= 0 && candidateLevel <= zoomLevels.length - 1) {
                    // get zoom level
                    zoomLevel = zoomLevels[candidateLevel];
                    msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
                    var spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;
                    // if zooming out
                    if (inc == -1) {
                        // if columns fit into available space, then all is fine, we've found appropriate zoom level
                        if (spanWidth <= availableWidth) {
                            levelToZoom = candidateLevel;
                            // stop searching
                            break;
                        }
                    } else // if zooming in
                    {
                        // if columns still fits into available space, we need to remember the candidate zoom level as a potential
                        // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit
                        // into available view
                        if (spanWidth <= availableWidth) {
                            // if it's not currently active level
                            if (currLevel !== candidateLevel - inc) {
                                // remember this level as applicable
                                levelToZoom = candidateLevel;
                            }
                        } else {
                            // Sanity check to find the following case:
                            // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
                            // there is an edge case where we should actually just stop and use the currently selected zoomLevel
                            break;
                        }
                    }
                    candidateLevel += inc;
                }
                // If we didn't find a large/small enough zoom level, use the lowest/highest level
                levelToZoom = levelToZoom !== null ? levelToZoom : candidateLevel - inc;
                zoomLevel = zoomLevels[levelToZoom];
                var unitToZoom = Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
                if (config.leftMargin || config.rightMargin) {
                    // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly
                    start = new Date(start.getTime() - msPerPixel * config.leftMargin);
                    end = new Date(end.getTime() + msPerPixel * config.rightMargin);
                }
                var columnCount = Sch.util.Date.getDurationInUnit(start, end, unitToZoom, true) / zoomLevel.increment;
                if (columnCount === 0) {
                    return;
                }
                var customWidth = Math.floor(availableWidth / columnCount);
                var centerDate = new Date((start.getTime() + end.getTime()) / 2);
                var range;
                if (needToAdjust) {
                    range = {
                        start: start,
                        end: end
                    };
                } else {
                    range = this.calculateOptimalDateRange(centerDate, availableWidth, zoomLevel);
                }
                return this.zoomToLevel(levelToZoom, range, {
                    customWidth: customWidth,
                    centerDate: centerDate
                });
            }
        }
        return null;
    },
    /**
    * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom in
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomIn: function(levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels = levels || 1;
        var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
        if (currentZoomLevelIndex >= this.zoomLevels.length - 1)  {
            return null;
        }
        
        return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    },
    /**
    * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom out
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOut: function(levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels = levels || 1;
        var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
        if (currentZoomLevelIndex <= 0)  {
            return null;
        }
        
        return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    },
    /**
    * Zooms in the timeline to the {@link #maxZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomInFull: function() {
        return this.zoomToLevel(this.maxZoomLevel);
    },
    /**
    * Zooms out the timeline to the {@link #minZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOutFull: function() {
        return this.zoomToLevel(this.minZoomLevel);
    },
    /*
    * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,
    * as rendering too many columns takes noticeable amount of time so their number is limited.
    */
    calculateOptimalDateRange: function(centerDate, panelSize, zoomLevel, userProvidedSpan) {
        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming
        // (even in case when user has provided own interval)
        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing
        // (inifinte scrolling feature does)
        if (userProvidedSpan)  {
            return userProvidedSpan;
        }
        
        var timeAxis = this.timeAxis;
        if (this.zoomKeepsOriginalTimespan) {
            return {
                start: timeAxis.getStart(),
                end: timeAxis.getEnd()
            };
        }
        var schDate = Sch.util.Date;
        var unit = this.getZoomLevelUnit(zoomLevel);
        var difference = Math.ceil(panelSize / zoomLevel.width * zoomLevel.increment * this.visibleZoomFactor / 2);
        var startDate = schDate.add(centerDate, unit, -difference);
        var endDate = schDate.add(centerDate, unit, difference);
        return {
            start: timeAxis.floorDate(startDate, false, unit, zoomLevel.increment),
            end: timeAxis.ceilDate(endDate, false, unit, zoomLevel.increment)
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.mixin.AbstractTimelinePanel
@private

A base mixin giving the consuming panel "time line" functionality.
This means that the panel will be capable to display a list of "events", along a {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define('Sch.mixin.AbstractTimelinePanel', {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.model.TimeAxis',
        'Sch.feature.ColumnLines',
        'Sch.preset.Manager'
    ],
    mixins: [
        'Sch.mixin.Zoomable'
    ],
    /**
     * @cfg {String} orientation An initial orientation of the view - can be either `horizontal` or `vertical`. Default value is `horizontal`.
     * Options: ['horizontal', 'vertical']
     * @deprecated Use {@link #mode} instead
     */
    orientation: 'horizontal',
    /**
     * @cfg {String} mode An initial mode of the view - can be either `calendar`, `horizontal` or `vertical`. Default value is `horizontal`.
     * Please note, that view preset for vertical and horizontal mode is defined by {@link #viewPreset} and view preset for calendar is
     * defined by {@link #calendarViewPreset}
     *
     *
     * Options: ['calendar', 'horizontal', 'vertical']
     */
    /**
     * @cfg {Number} weekStartDay A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.
     * When omitted, the week start day is retrieved from the active locale class.
     */
    /**
     * @cfg {Boolean} snapToIncrement true to snap to resolution increment while interacting with scheduled events.
     */
    snapToIncrement: false,
    /**
     * @cfg {Boolean} readOnly true to disable editing.
     */
    readOnly: false,
    /**
     * @cfg {Boolean} forceFit Set to true to force the time columns to fit to the available horizontal space.
     */
    forceFit: false,
    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use for resizing events. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'both'
     */
    eventResizeHandles: 'both',
    /**
     * @cfg {Number} rowHeight The row height (used in horizontal mode only)
     */
    /**
     * @cfg {Sch.data.TimeAxis} timeAxis The backing store providing the input date data for the timeline panel.
     */
    timeAxis: null,
    /**
     * @cfg {Boolean} autoAdjustTimeAxis The value for the {@link Sch.data.TimeAxis#autoAdjust} config option, which will be used
     * when creating the time axis instance. You can set this option to `false` to make the timeline panel start and end on the exact provided
     * {@link #startDate}/{@link #endDate} w/o adjusting them.
     */
    autoAdjustTimeAxis: true,
    /**
     * @private
     * @cfg {Sch.view.model.TimeAxis/Object} timeAxisViewModel The backing view model for the visual representation of the time axis.
     * Either a real instance or a simple config object.
     */
    timeAxisViewModel: null,
    /**
     * @cfg {Object} validatorFnScope
     * The scope used for the different validator functions.
     */
    /**
     * @cfg {Sch.crud.AbstractManager} crudManager The CRUD manager holding all the project stores.
     */
    crudManager: null,
    /**
     * @cfg {String/Object} viewPreset
     * A string key used to lookup a predefined {@link Sch.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'), managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     * Or a config object for a viewPreset.
     * 
     * Options: ['secondAndMinute', 'minuteAndHour', 'hourAndDay', 'dayAndWeek', 'weekAndDay', 'weekAndMonth', 'monthAndYear', 'year', 'manyYears', 'weekAndDayLetter', 'weekDateAndMonth']
     *
     * If passed as a config object, the settings from the viewPreset with the provided 'name' property will be used along
     * with any overridden values in your object.
     *
     * To override:

     viewPreset       : {
                    name                : 'hourAndDay',
                    headerConfig        : {
                        middle          : {
                            unit       : "HOUR",
                            increment  : 12,
                            renderer   : function(startDate, endDate, headerConfig, cellIdx) {
                                return "";
                            }
                        }
                    }
                }

     * or set a new valid preset config if the preset is not registered in the {@link Sch.preset.Manager}.
     */
    viewPreset: 'weekAndDay',
    /**
     * @cfg {String} calendarViewPreset
     * @property {String} calendarViewPreset
     * A key used to lookup a predefined {@link Sch.preset.ViewPreset}, managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     * Default view preset for scheduler in calendar mode
     *
     *
     * Options: ['day', 'week']
     */
    calendarViewPreset: 'week',
    /**
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver: true,
    /**
     * @cfg {Date} startDate The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided {@link Sch.data.TimeAxis} will be used.
     * If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no date information exists in the event data
     * set, it defaults to the current date and time.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate The end date of the timeline. If omitted, it will be calculated based on the {@link #startDate} setting and
     * the 'defaultSpan' property of the current {@link #viewPreset}.
     */
    endDate: null,
    /**
     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime: 0,
    /**
     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime: 24,
    columnLines: true,
    /**
     * Returns dates that will constrain resize and drag operations. The method will be called with the Resource, and
     * for operations on existing events - the event. For drag create operation, the mousedown date will be passed as the second parameter
     * @return {Object} Constaining object
     * @return {Date} return.start Start date
     * @return {Date} return.end End date
     */
    getDateConstraints: Ext.emptyFn,
    /**
     * @cfg {Boolean} snapRelativeToEventStartDate Affects drag drop and resizing of events when {@link #snapToIncrement} is enabled. If set to `true`, dates will be snapped relative to event start.
     * e.g. for a zoom level with timeResolution = { unit: "s", increment: "20" }, an event that starts at 10:00:03 and is dragged would snap its start date to 10:00:23, 10:00:43 etc.
     * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start) - 10:00:03, 10:00:20, 10:00:40 etc.
     */
    snapRelativeToEventStartDate: false,
    trackMouseOver: false,
    // If user supplied a 'rowHeight' config or a panel subclass with such a value - skip reading this setting
    // from the viewpreset
    readRowHeightFromPreset: true,
    /**
     * @cfg {Number} eventBorderWidth
     * The width of the border of your event, needed to calculate the correct start/end positions
     */
    eventBorderWidth: 1,
    cachedCenterDate: null,
    /**
     * @event beforeviewchange
     * Fires before the current view changes to a new view type or a new time span. Return false to abort this action.
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     * @param {Sch.preset.ViewPreset} preset The new preset
     */
    /**
     * @event viewchange
     * Fires after current view preset or time span has changed
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     */
    cellBorderWidth: 1,
    cellTopBorderWidth: 1,
    // 0 since Ext JS 4.2.1
    cellBottomBorderWidth: 1,
    renderers: null,
    /**
    * Returns the orientation of this panel, "horizontal" or "vertical"
    * @return {String}
    * @deprecated
    */
    getOrientation: function() {
        return this.getMode.apply(this, arguments);
    },
    /**
    * Returns the mode of this panel, "horizontal", "vertical" or "calendar"
    * @return {String}
    */
    getMode: function() {
        return this.mode;
    },
    isHorizontal: function() {
        return this.getMode() === 'horizontal';
    },
    isVertical: function() {
        return this.getMode() === 'vertical';
    },
    isCalendar: function() {
        return this.getMode() === 'calendar';
    },
    // Must be called during initialization by consuming class
    _initializeTimelinePanel: function() {
        // this is an entry point to this mixin, so we should wrap 'mode' here
        this.mode = this.mode || this.orientation || 'horizontal';
        this.applyViewPreset(this.viewPreset);
        if (this.mode === 'calendar') {
            this.oldViewPreset = this.viewPreset;
            this.viewPreset = this.calendarViewPreset;
        }
        this.initializeZooming();
        this.on('viewchange', this.clearCenterDateCache, this);
        this.on('viewready', this.setupClearCenterDateCache, this);
        this.renderers = [];
        // Setting a rowHeight config on the panel should override any rowHeight value in the view presets
        if (this.readRowHeightFromPreset) {
            this.readRowHeightFromPreset = !this.rowHeight;
        }
        if (!(this.timeAxis instanceof Sch.data.TimeAxis)) {
            this.timeAxis = Ext.create(Ext.applyIf(this.timeAxis || {}, {
                xclass: 'Sch.data.TimeAxis',
                autoAdjust: this.autoAdjustTimeAxis,
                mode: this.mode === 'calendar' ? 'calendar' : 'plain'
            }));
        }
        if (!this.timeAxisViewModel || !(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            var config = Ext.apply({
                    mode: this.mode,
                    snapToIncrement: this.snapToIncrement,
                    forceFit: this.forceFit,
                    timeAxis: this.timeAxis,
                    eventStore: this.getEventStore(),
                    viewPreset: this.viewPreset
                }, this.timeAxisViewModel || {});
            this.timeAxisViewModel = new Sch.view.model.TimeAxis(config);
        }
        this.timeAxisViewModel.on('update', this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount++;
        this.on('destroy', this.onPanelDestroyed, this);
        var orientationClasses;
        switch (this.mode) {
            case 'horizontal':
                orientationClasses = [
                    'sch-horizontal'
                ];
                break;
            case 'vertical':
                orientationClasses = [
                    'sch-vertical',
                    'sch-vertical-resource'
                ];
                break;
            case 'calendar':
                orientationClasses = [
                    'sch-vertical',
                    'sch-calendar'
                ];
                break;
        }
        this.addCls([].concat.apply([
            'sch-timelinepanel'
        ], orientationClasses));
    },
    // private
    // applies preset config on the manager, only used at initialization time
    applyViewPreset: function(preset) {
        var viewPreset;
        if (Ext.isString(preset)) {
            viewPreset = Sch.preset.Manager.getPreset(preset);
            if (!viewPreset) {
                throw 'You must define a valid view preset object. See Sch.preset.Manager class for reference';
            }
        } else if (Ext.isObject(preset)) {
            var registeredPreset = preset.name && Sch.preset.Manager.getPreset(preset.name);
            if (registeredPreset) {
                this.viewPreset = new Sch.preset.ViewPreset(Ext.applyIf(preset, registeredPreset));
            } else {
                var name = preset.name || ('preset' + Sch.preset.Manager.getCount());
                Sch.preset.Manager.registerPreset(name, preset);
                this.viewPreset = Sch.preset.Manager.getPreset(name);
            }
        }
    },
    onTimeAxisViewModelUpdate: function() {
        var view = this.getSchedulingView();
        if (view && view.viewReady) {
            view.refreshKeepingScroll();
            this.fireEvent('viewchange', this);
        }
    },
    onPanelDestroyed: function() {
        var timeAxisViewModel = this.timeAxisViewModel;
        timeAxisViewModel.un('update', this.onTimeAxisViewModelUpdate, this);
        timeAxisViewModel.refCount--;
        if (timeAxisViewModel.refCount <= 0) {
            timeAxisViewModel.destroy();
        }
    },
    /**
     * @abstract
     *
     * @return {Sch.mixin.AbstractSchedulerView} A view consuming the {@link Sch.mixin.AbstractSchedulerView} mixin
     */
    getSchedulingView: function() {
        throw 'Abstract method call';
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        this.getSchedulingView().setReadOnly(readOnly);
    },
    /**
    * Returns true if the panel is currently read only.
    * @return {Boolean} readOnly
    */
    isReadOnly: function() {
        return this.getSchedulingView().isReadOnly();
    },
    setupClearCenterDateCache: function() {
        this.mon(this.getSchedulingView(), 'scroll', this.clearCenterDateCache, this);
    },
    // When switching to a preset we try to stay on the same central date.
    // The date is cleared after any user scroll operation
    /** @ignore */
    getViewportCenterDateCached: function() {
        if (this.cachedCenterDate)  {
            return this.cachedCenterDate;
        }
        
        return this.cachedCenterDate = this.getViewportCenterDate();
    },
    clearCenterDateCache: function(scrollable, left, top) {
        var isHorizontal = this.getMode() === 'horizontal',
            activeScroll = this.viewPresetActiveScroll;
        var scrollToIgnore = activeScroll && (isHorizontal ? left === activeScroll.left : top == activeScroll.top);
        if (!scrollToIgnore) {
            this.cachedCenterDate = null;
            this.viewPresetActiveScroll = null;
        }
    },
    /**
     * Alias for {@link setViewPreset}
     */
    switchViewPreset: function() {
        this.setViewPreset.apply(this, arguments);
    },
    /**
     * Sets the current view preset. See the {@link Sch.preset.Manager} class for details.
     * Calling it will first fire a {@link Sch.panel.SchedulerGrid#beforeviewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#beforeviewchange SchedulerTree} beforeviewchange event,
     * followed by a {@link Sch.panel.SchedulerGrid#viewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#viewchange SchedulerTree} viewchange event.
     * Returning `false` from any 'beforeviewchange' listener will cancel the operation.
     *
     * @param {String} preset The id of the new preset (see {@link Sch.preset.Manager} for details)
     * @param {Date} [startDate] A new start date for the time axis
     * @param {Date} [endDate] A new end date for the time axis
     */
    setViewPreset: function(preset, startDate, endDate, initial, options) {
        options = options || {};
        var centerDate = options.centerDate,
            timeAxis = this.timeAxis,
            view = this.getSchedulingView();
        // normalize preset
        if (typeof preset === 'string') {
            preset = Sch.preset.Manager.getPreset(preset);
        }
        if (!preset) {
            throw 'View preset not found';
        }
        if (this.fireEvent('beforeviewchange', this, preset, startDate, endDate) !== false) {
            this.viewPreset = preset.name;
            var isHorizontal = this.getMode() === 'horizontal',
                isVertical = this.getMode() === 'vertical';
            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it
            if (!(initial && timeAxis.isConfigured)) {
                var timeAxisCfg = {
                        // we use either provided "weekStartDay" value or the localized value
                        weekStartDay: this.weekStartDay !== undefined ? this.weekStartDay : (this.L ? this.L('weekStartDay') : 1),
                        startTime: this.startTime,
                        endTime: this.endTime
                    };
                if (initial) {
                    if (timeAxis.getCount() === 0 || startDate) {
                        timeAxisCfg.start = startDate || new Date();
                        timeAxisCfg.end = endDate;
                    }
                } else {
                    // if startDate is provided we use it and the provided endDate
                    if (startDate) {
                        timeAxisCfg.start = startDate;
                        timeAxisCfg.end = endDate;
                        // if both dates are provided we can calculate centerDate for the viewport
                        if (!centerDate && endDate) {
                            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                centerDate = view.cachedScrollDate;
                            } else {
                                centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                            }
                        }
                    } else // when no start/end dates are provided we use the current timespan
                    {
                        timeAxisCfg.start = timeAxis.getStart();
                        timeAxisCfg.end = endDate || timeAxis.getEnd();
                        if (!centerDate) {
                            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                centerDate = view.cachedScrollDate;
                            } else {
                                centerDate = this.getViewportCenterDateCached();
                            }
                        }
                    }
                }
                timeAxis.consumeViewPreset(preset);
                timeAxis.reconfigure(timeAxisCfg, true);
                this.timeAxisViewModel.reconfigure({
                    // update preset name in viewmodel to simplify zooming sync for partner panels
                    viewPreset: this.viewPreset,
                    headerConfig: preset.headerConfig,
                    columnLinesFor: preset.columnLinesFor || 'middle',
                    rowHeightHorizontal: this.readRowHeightFromPreset ? preset.rowHeight : (this.rowHeight || this.timeAxisViewModel.getViewRowHeight()),
                    tickWidth: isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeColumnWidth: preset.timeColumnWidth,
                    // timeColumnWidth is also used for row height in vertical mode
                    rowHeightVertical: preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeAxisColumnWidth: preset.timeAxisColumnWidth,
                    resourceColumnWidth: this.resourceColumnWidth || preset.resourceColumnWidth || 100
                });
            }
            view.setDisplayDateFormat(preset.displayDateFormat);
            if (isVertical) {
                view.setColumnWidth(this.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
            }
            var viewEl = view.getOuterEl();
            // if view is rendered and scroll is not disabled by "notScroll" option
            if (!options.notScroll && viewEl) {
                // and we have centerDate to scroll to
                if (centerDate) {
                    // remember the central date we scroll to (it gets reset after user scroll)
                    this.cachedCenterDate = centerDate;
                    var x = null,
                        y = null;
                    if (isVertical) {
                        y = Math.floor(view.getYFromDate(centerDate, true) - viewEl.getHeight() / 2);
                        this.viewPresetActiveScroll = {
                            top: y
                        };
                        view.scrollTo(null, y);
                    } else {
                        x = Math.floor(view.getCoordinateFromDate(centerDate, true) - viewEl.getWidth() / 2);
                        this.viewPresetActiveScroll = {
                            left: x
                        };
                        // there's a missync between header scroll and view scroll which can corrupt view center date
                        // also scrolling header first makes 210_zoom_to_fit more stable in IE9
                        view.headerCt.scrollTo(x);
                        view.scrollTo(x);
                    }
                } else // if we don't have a central date to scroll at we reset scroll (this is bw compatible behavior)
                {
                    if (isHorizontal) {
                        view.scrollHorizontallyTo(0);
                    } else {
                        view.scrollVerticallyTo(0);
                    }
                }
            }
        }
    },
    /**
     * Method to get the current view preset of the timeline panel.
     * @return {String} The name of the currently active view preset
     */
    getViewPreset: function() {
        return this.viewPreset;
    },
    /**
     * Method to get the current start date of the scheduler
     * @return {Date} The start date
     */
    getStart: function() {
        return this.getStartDate();
    },
    /**
     * Method to get the current start date of the scheduler
     * @return {Date} The start date
     */
    getStartDate: function() {
        return this.timeAxis.getStart();
    },
    /**
     * Method to get the current end date of the scheduler
     * @return {Date} The end date
     */
    getEnd: function() {
        return this.getEndDate();
    },
    /**
     * Method to get the current end date of the scheduler
     * @return {Date} The end date
     */
    getEndDate: function() {
        return this.timeAxis.getEnd();
    },
    /**
     * Updates the widths of all the time columns to the supplied value. Only applicable when {@link #forceFit} is set to false.
     * @param {Number} width The new time column width
     */
    setTimeColumnWidth: function(width, preventRefresh) {
        this.timeAxisViewModel.setTickWidth(width, preventRefresh);
    },
    /**
     * @return {Number} width The time column width
     */
    getTimeColumnWidth: function() {
        return this.timeAxisViewModel.getTickWidth();
    },
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight();
    },
    /**
    * Moves the time axis forward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function(amount) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftNext(amount);
        this.suspendLayouts && this.resumeLayouts(true);
    },
    /**
    * Moves the time axis backward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function(amount) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftPrevious(amount);
        this.suspendLayouts && this.resumeLayouts(true);
    },
    /**
    * Convenience method to go to current date.
    */
    goToNow: function() {
        this.setTimeSpan(new Date());
    },
    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end (Optional) The new end date. If not supplied, the {@link Sch.preset.ViewPreset#defaultSpan} property of the current view preset will be used to calculate the new end date.
    */
    setTimeSpan: function(start, end) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(start, end);
        }
    },
    /**
    * Changes the time axis start date to the supplied date.
    * @param {Date} amount The new start date
    */
    setStart: function(date) {
        this.setStartDate(date);
    },
    /**
    * Changes the time end start date to the supplied date.
    * @param {Date} amount The new end date
    */
    setEnd: function(date) {
        this.setEndDate(date);
    },
    /**
     * Changes the time axis start date to the supplied date.
     * @param {Date} amount The new start date
     */
    setStartDate: function(date) {
        this.setTimeSpan(date);
    },
    /**
     * Changes the time end start date to the supplied date.
     * @param {Date} amount The new end date
     */
    setEndDate: function(date) {
        this.setTimeSpan(null, date);
    },
    /**
    * Returns the {@link Sch.data.TimeAxis} instance in use.
    * @return {Sch.data.TimeAxis}
    */
    getTimeAxis: function() {
        return this.timeAxis;
    },
    /**
    * Scrolls the time line to the specified `date`.
    * @param {Date} date The date to which to scroll the time line
    */
    scrollToDate: function(date, animate) {
        var view = this.getSchedulingView();
        var coordinate = view.getCoordinateFromDate(date, true);
        this.scrollToCoordinate(coordinate, date, animate, false);
    },
    /**
    * Scrolls the time line so that specified `date` is in the center of the view.
    * @param {Date} date The date to which to scroll the time line
    * @param {Boolean} animate (optional) Whether or not scroll should be animated
    */
    scrollToDateCentered: function(date, animate) {
        var view = this.getSchedulingView();
        var delta = 0;
        if (view.isHorizontal()) {
            delta = view.getBox().width / 2;
        } else {
            delta = view.getBox().height / 2;
        }
        var coordinate = Math.round(view.getCoordinateFromDate(date, true) - delta);
        this.scrollToCoordinate(coordinate, date, animate, true);
    },
    //private
    scrollToCoordinate: function(coordinate, date, animate, centered) {
        var view = this.getSchedulingView();
        var me = this;
        // Not currently have this date in a timeaxis. Ignore negative scroll in calendar, it can be just 'filtered' with
        // startTime/endTime config
        if (coordinate < 0 && !view.isCalendar()) {
            if (this.infiniteScroll) {
                // for infinite scroll we have a special formula to calculate adjustment borders
                // shiftToDate() will perform adjustment and then recall scrollToDate() again
                view.shiftToDate(date, centered);
            } else {
                // adjust the timeaxis first
                var halfVisibleSpan = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;
                this.setTimeSpan(new Date(date.getTime() - halfVisibleSpan), new Date(date.getTime() + halfVisibleSpan));
                if (centered) {
                    me.scrollToDateCentered(date, animate);
                } else {
                    me.scrollToDate(date, animate);
                }
            }
            return;
        }
        if (this.mode === 'horizontal') {
            view.scrollHorizontallyTo(coordinate, animate);
        } else {
            view.scrollVerticallyTo(coordinate, animate);
        }
    },
    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function() {
        return this.getSchedulingView().getViewportCenterDate();
    },
    addCls: function() {
        throw 'Abstract method call';
    },
    removeCls: function() {
        throw 'Abstract method call';
    },
    registerRenderer: function(fn, scope) {
        this.renderers.push({
            fn: fn,
            scope: scope
        });
    },
    deregisterRenderer: function(fn, scope) {
        Ext.each(this.renderers, function(rend, i) {
            if (fn === rend) {
                Ext.Array.removeAt(this.renderers, i);
                return false;
            }
        });
    },
    /**
     * Returns the event store instance
     * @method getEventStore
     * @abstract
     * @return {Ext.data.AbstractStore}
     */
    getCrudManager: function() {
        return this.crudManager;
    },
    setCrudManager: function(cm) {
        this.crudManager = cm;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
* @class Sch.view.HorizontalTimeAxis
* @extends Ext.util.Observable
* @private
*
* A visual representation of the time axis described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
* Normally you should not interact with this class directly.
*/
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.XTemplate'
    ],
    /**
    * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
    */
    trackHeaderOver: true,
    /**
    * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class to the row (for special styling).
    *            Defaults to 15px.
    */
    compactCellWidthThreshold: 15,
    baseCls: 'sch-column-header',
    tableCls: 'sch-header-row',
    // a 2nd template for the 2nd mode, w/o `containerEl`
    headerHtmlRowTpl: '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}">' + '<thead>' + '<tr style="height:{rowHeight}px">' + '<tpl for="cells">' + '<td class="{{baseCls}} {headerCls} sch-header-cell-{align}" data-date="{[fm.date(values.start, \'Ymd_His\')]}" style="position : static; text-align: {align}; width: {width}px; {style}" tabIndex="0"' + 'headerPosition="{parent.position}" headerIndex="{[xindex-1]}">' + '<div class="sch-simple-timeheader">{header}</div>' + '</td>' + '</tpl>' + '</tr>' + '</thead>' + '</table>',
    // TODO DOCS
    model: null,
    // TODO DOCS
    hoverCls: '',
    // optional
    // this view class will work in 2 modes - one with provided `containerEl` and one w/o it
    containerEl: null,
    height: null,
    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event refresh
     * Fires after the view has been updated, (after the time axis has been reconfigured,
     * or as a result of time column width change or available schedule width change).
     * @param {Sch.view.HorizontalTimeAxis} timeAxisView The time axis view
     */
    constructor: function(config) {
        var me = this;
        var isTouch = !!Ext.versions.touch;
        Ext.apply(this, config);
        me.callParent(arguments);
        me.model.on('update', me.onModelUpdate, this, {
            priority: 5
        });
        me.containerEl = Ext.get(me.containerEl);
        if (!(me.headerHtmlRowTpl instanceof Ext.Template)) {
            me.headerHtmlRowTpl = me.headerHtmlRowTpl.replace('{{baseCls}}', this.baseCls).replace('{{tableCls}}', this.tableCls);
            me.headerHtmlRowTpl = new Ext.XTemplate(me.headerHtmlRowTpl);
        }
        if (me.trackHeaderOver && me.hoverCls) {
            me.containerEl.on({
                mousemove: me.highlightCell,
                delegate: '.sch-column-header',
                scope: me
            });
            me.containerEl.on({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }
        var listenerCfg = {
                scope: this,
                delegate: '.sch-column-header'
            };
        if (isTouch) {
            listenerCfg.tap = this.onElClick('tap');
            listenerCfg.doubletap = this.onElClick('doubletap');
        } else {
            listenerCfg.click = this.onElClick('click');
            listenerCfg.dblclick = this.onElClick('dblclick');
            listenerCfg.contextmenu = this.onElClick('contextmenu');
        }
        me._listenerCfg = listenerCfg;
        if (me.containerEl)  {
            me.containerEl.on(listenerCfg);
        }
        
    },
    destroy: function() {
        var me = this;
        if (me.containerEl) {
            me.containerEl.un(me._listenerCfg);
            me.containerEl.un({
                mousemove: me.highlightCell,
                delegate: '.sch-simple-timeheader',
                scope: me
            });
            me.containerEl.un({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }
        me.model.un('update', me.onModelUpdate, this, {
            priority: 5
        });
    },
    onModelUpdate: function() {
        // Header should be sized according to locking partner, that's why before rendering new header
        // we set height to null - to prevent time axis from stretching header container
        this.height = null;
        this.render();
    },
    getHTML: function() {
        var columnConfig = this.model.getColumnConfig();
        var totalWidth = this.model.getTotalWidth();
        var nbrRows = Ext.Object.getKeys(columnConfig).length;
        var rowHeight = this.height && Math.floor(this.height / nbrRows);
        var html = '';
        if (columnConfig.top) {
            this.embedCellWidths(columnConfig.top);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.top,
                position: 'top',
                tstyle: 'border-top : 0;',
                rowHeight: rowHeight
            });
        }
        if (columnConfig.middle) {
            this.embedCellWidths(columnConfig.middle);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.middle,
                position: 'middle',
                tstyle: columnConfig.top ? '' : 'border-top : 0;',
                rowHeight: rowHeight,
                cls: !columnConfig.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        if (columnConfig.bottom) {
            this.embedCellWidths(columnConfig.bottom);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.bottom,
                position: 'bottom',
                rowHeight: rowHeight,
                cls: this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        return html;
    },
    // Outputs the tables and cells based on the header row config in the active viewPreset
    render: function() {
        if (!this.containerEl)  {
            return;
        }
        
        var innerCt = this.containerEl,
            ctDom = innerCt.dom,
            oldDisplay = ctDom.style.display,
            columnConfig = this.model.getColumnConfig(),
            parent = ctDom.parentNode;
        ctDom.style.display = 'none';
        parent.removeChild(ctDom);
        // Remove header table els manually, keeping secondary canvas element intact
        Ext.fly(ctDom).select('table').remove();
        ctDom.insertAdjacentHTML('afterbegin', this.getHTML());
        if (!columnConfig.top && !columnConfig.middle) {
            this.containerEl.addCls('sch-header-single-row');
        } else {
            this.containerEl.removeCls('sch-header-single-row');
        }
        parent && parent.appendChild(ctDom);
        ctDom.style.display = oldDisplay;
        this.fireEvent('refresh', this);
    },
    embedCellWidths: function(cells) {
        // For desktop only, flags such as Ext.isSafari only exist in Ext JS (in touch it's set in Ext.os)
        var widthAdjust = (Ext.isIE7 || (Ext.isSafari && !Ext.supports.Touch)) ? 1 : 0;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            var width = this.model.getDistanceBetweenDates(cell.start, cell.end);
            if (width) {
                cell.width = width - (i ? widthAdjust : 0);
            } else {
                cell.width = 0;
                cell.style = 'display: none';
            }
        }
    },
    // private
    onElClick: function(eventName) {
        return function(event, target) {
            // Normalize ST vs Ext JS (Ext passes the delegated target as the target argument, ST passes the clicked DOM node)
            target = event.delegatedTarget || target;
            var position = Ext.fly(target).getAttribute('headerPosition'),
                index = Ext.fly(target).getAttribute('headerIndex'),
                headerConfig = this.model.getColumnConfig()[position][index];
            this.fireEvent('timeheader' + eventName, this, headerConfig.start, headerConfig.end, event);
        };
    },
    highlightCell: function(e, cell) {
        var me = this;
        if (cell !== me.highlightedCell) {
            me.clearHighlight();
            me.highlightedCell = cell;
            Ext.fly(cell).addCls(me.hoverCls);
        }
    },
    clearHighlight: function() {
        var me = this,
            highlighted = me.highlightedCell;
        if (highlighted) {
            Ext.fly(highlighted).removeCls(me.hoverCls);
            delete me.highlightedCell;
        }
    }
});
/* EOF Proxied model methods */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Sch.column.timeAxis.Horizontal
 * @extends Ext.grid.column.Column
 *
 *
 * A simple grid column providing a visual representation of the time axis. This class does not produce any real Ext JS grid columns, instead it just renders a Sch.view.HorizontalTimeAxis inside its element.
 * This class can represent up to three different axes, that are defined in the view preset config object.
 */
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.timeaxiscolumn',
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    resizable: false,
    menuDisabled: true,
    cls: 'sch-simple-timeaxis',
    tdCls: 'sch-timetd',
    enableLocking: false,
    locked: false,
    requires: [
        'Sch.view.HorizontalTimeAxis'
    ],
    timeAxisViewModel: null,
    headerView: null,
    // Disable Ext JS default header hover highlight
    hoverCls: '',
    ownHoverCls: 'sch-column-header-over',
    /*
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver: true,
    /*
     * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact',
     * which adds a special CSS class to the header row.
     */
    compactCellWidthThreshold: (Ext.theme && Ext.theme.name.toLowerCase() === 'classic') ? 15 : 35,
    afterRender: function() {
        var me = this;
        // HACK relying on private accessor 'titleEl'
        var ct = me.titleEl.createChild({
                cls: 'sch-horizontaltimeaxis-ct'
            });
        me.headerView = new Sch.view.HorizontalTimeAxis({
            model: me.timeAxisViewModel,
            containerEl: ct,
            hoverCls: me.ownHoverCls,
            trackHeaderOver: me.trackHeaderOver,
            compactCellWidthThreshold: me.compactCellWidthThreshold
        });
        me.headerView.on('refresh', me.onTimeAxisViewRefresh, me);
        me.ownerCt.on('afterlayout', function() {
            // column can be rendered after grid was reconfigured
            if (!me.ownerCt) {
                return;
            }
            // If the container of this column changes size, we need to re-evaluate the size for the
            // time axis view
            me.mon(me.ownerCt, "resize", me.onHeaderContainerResize, me);
            if (this.getWidth() > 0) {
                // set height for horizontal time axis to make it calculate height properly
                me.headerView.height = me.getHeight();
                // In case the timeAxisViewModel is shared, no need to update it
                if (me.getAvailableWidthForSchedule() === me.timeAxisViewModel.getAvailableWidth()) {
                    me.headerView.render();
                } else {
                    me.timeAxisViewModel.update(me.getAvailableWidthForSchedule());
                }
                me.setWidth(me.timeAxisViewModel.getTotalWidth());
            }
        }, null, {
            single: true
        });
        this.enableBubble('timeheaderclick', 'timeheaderdblclick', 'timeheadercontextmenu', 'horizontaltimeaxiscolumnrender');
        me.relayEvents(me.headerView, [
            'timeheaderclick',
            'timeheaderdblclick',
            'timeheadercontextmenu'
        ]);
        me.callParent(arguments);
        // we don't need timeline to be focusble, it messes 'timeheader*' events and looses scroll in IE
        me.focusable = false;
        this.fireEvent('horizontaltimeaxiscolumnrender', this);
    },
    initRenderData: function() {
        var me = this;
        me.renderData.headerCls = me.renderData.headerCls || me.headerCls;
        return me.callParent(arguments);
    },
    destroy: function() {
        if (this.headerView) {
            this.headerView.destroy();
            this.headerView = null;
        }
        this.callParent(arguments);
    },
    onTimeAxisViewRefresh: function() {
        // Make sure we don't create an infinite loop
        this.headerView.un('refresh', this.onTimeAxisViewRefresh, this);
        this.setWidth(this.timeAxisViewModel.getTotalWidth());
        this.headerView.on('refresh', this.onTimeAxisViewRefresh, this);
    },
    getAvailableWidthForSchedule: function() {
        // When applying state to rendered scheduler, ext will remove content from normal and locked headers keeping
        // instances alive (#2580)
        if (!this.ownerCt) {
            return 0;
        }
        // In case owner container is hidden then it and it's items will return zero width, if so we fallback to
        // lastBox private property of Ext.AbstractComponent
        var available = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : (this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0),
            items = this.ownerCt.items,
            item;
        // substracting the widths of all columns starting from 2nd ("right" columns)
        for (var i = 1; i < items.length; i++) {
            item = items.get(i);
            if (!item.hidden) {
                available -= item.isVisible(true) ? item.getWidth() : (item.lastBox && item.lastBox.width || 0);
            }
        }
        return available - Ext.getScrollbarSize().width - 1;
    },
    onResize: function() {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
    },
    onHeaderContainerResize: function(header, width, height, oldWidth, oldHeight) {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        if (height !== oldHeight) {
            this.headerView.height = height;
            this.headerView.render();
        }
    },
    /*
     * Refreshes the column header contents. Useful if you have some extra meta data in your timeline header that
     * depends on external data such as the EventStore or ResourceStore.
     */
    refresh: function() {
        if (this.rendered) {
            // Update the model, but don't fire any events which will fully redraw view
            this.timeAxisViewModel.update(null, true);
            // Now the model state has been refreshed so headers can be rerendered
            this.headerView.render();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Locked panel cannot be collapsed, sencha provided override to fix this, but unfortunately it doesn't work nice
// with grids, syncing row height (syncRowHeights: true)
// https://www.sencha.com/forum/showthread.php?310933
// https://fiddle.sencha.com/#fiddle/1ak8
Ext.define('Sch.layout.TableLayout', {
    extend: 'Ext.view.TableLayout',
    alias: 'layout.timeline_tablelayout',
    beginLayout: function(ownerContext) {
        var me = this,
            owner = me.owner,
            ownerGrid = owner.ownerGrid,
            partner = owner.lockingPartner,
            // BUG: need to test whether partner is not collapsed as well as visible.
            // ======================================================================
            partnerVisible = partner && partner.grid.isVisible() && !partner.grid.collapsed,
            context = ownerContext.context;
        // Flag whether we need to do row height synchronization.
        // syncRowHeightOnNextLayout is a one time flag used when some code knows it has changed data height
        // and that the upcoming layout must sync row heights even if the grid is configured not to for
        // general row rendering.
        ownerContext.doSyncRowHeights = partnerVisible && (ownerGrid.syncRowHeight || ownerGrid.syncRowHeightOnNextLayout);
        if (!me.columnFlusherId) {
            me.columnFlusherId = me.id + '-columns';
            me.rowHeightFlusherId = me.id + '-rows';
        }
        if (me.owner.bufferedRenderer) {
            me.owner.bufferedRenderer.beforeTableLayout(ownerContext);
        }
        // We do not want to call method on extended class, otherwise exception will be raised
        me.superclass.superclass.beginLayout.apply(this, [
            ownerContext
        ]);
        // If we are in a twinned grid (locked view) then set up bidirectional links with
        // the other side's layout context. If the locked or normal side is hidden then
        // we should treat it as though we were laying out a single grid, so don't setup the partners.
        // This is typically if a grid is configured with locking but starts with no locked columns.
        if (partnerVisible && partner.componentLayout.isRunning()) {
            // BUG: if partner is not running, don't look at them
            if (!ownerContext.lockingPartnerContext) {
                (ownerContext.lockingPartnerContext = context.getCmp(partner)).lockingPartnerContext = ownerContext;
            }
            if (ownerContext.doSyncRowHeights) {
                ownerContext.rowHeightSynchronizer = me.owner.syncRowHeightBegin();
            }
        }
        // Grab a ContextItem for the header container (and make sure the TableLayout can
        // reach us as well):
        (ownerContext.headerContext = context.getCmp(me.headerCt)).viewContext = ownerContext;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 Internal class syncing size/state of the locked grid in two Timeline panels.
 */
Ext.define('Sch.mixin.PartnerTimelinePanel', {
    extend: 'Ext.Mixin',
    setupPartnerTimelinePanel: function(panel) {
        // Sync locked grids by listening for splitter resize events of both locked grids.
        var otherPanel = this.partnerTimelinePanel;
        var otherLockedGrid = otherPanel.lockedGrid;
        var ourLockedGrid = this.lockedGrid;
        otherLockedGrid.mon(ourLockedGrid, 'resize', this.onLockedGridResize, otherLockedGrid);
        ourLockedGrid.mon(otherLockedGrid, 'resize', this.onLockedGridResize, ourLockedGrid);
        var lockedWidth = otherPanel.isVisible() ? otherPanel.lockedGrid.getWidth() : otherPanel.lockedGrid.width;
        // Ext doesn't support initially collapsed locked grid, exception will be raised.
        if (otherLockedGrid.getCollapsed()) {
            // after locked grid is initially expanded we can sync width
            this.mon(otherLockedGrid, 'viewready', function(panel) {
                ourLockedGrid.setWidth(panel.getWidth());
            });
        } else {
            ourLockedGrid.setWidth(lockedWidth);
        }
        // if we change collapse state in process of layout update
        // component won't be collapsible/expandable anymore
        this.on('afterlayout', function() {
            if (otherLockedGrid.getCollapsed()) {
                ourLockedGrid.collapse();
            } else {
                ourLockedGrid.expand();
                ourLockedGrid.setWidth(lockedWidth);
            }
        }, this, {
            single: true
        });
        otherLockedGrid.on({
            collapse: this.onPartnerCollapseExpand,
            expand: this.onPartnerCollapseExpand,
            scope: this
        });
        ourLockedGrid.on({
            collapse: this.onPartnerCollapseExpand,
            expand: this.onPartnerCollapseExpand,
            scope: otherPanel
        });
        this.setupScrollSync();
        /* HACK

         Ext.scroll.Scroller is responsible for sharing scroll position between partners. Partnership is a two-way
         binding between two scrollables, who are aware of own scroll and propagate it to another. While scroll on one
         is changing, other is told to stop sharing scroll.
         For example (refer to the picture below): view1 and header1 are partners. When view1 change left scroll it
         tells header1 to suspend, pass it new scroll value and start buffered callback with 100 ms interval. That
         callback will resume header1. When browser scroll event happen on header1 it tries to sync position with
         partner (view1), but it is told not to - here and after EXT-SYNC.

         Our partner panels also share scroll (here and after SCH-SYNC) between views - view1 and view2 on scheme.

         This lead to a following zooming scenario:
         1) view1 is zoomed and start throwing scroll events
         2) view2 is scrolled by SCH-SYNC
         3) header2 is scrolled by EXT-SYNC, because view2 scroll changed.
         4) view1 is scrolled to correct coordinate by zoomable mixin
         5) view2 is scrolled to correct coordinate by SCH-SYNC
         6) view2 tries to sync scroll with header2 - EXT-SYNC - but header2 at some point started scrolling and
         suspended view2 from sharing it's sync. In result header1, view1 and view2 have new, correct scroll and header2
         contain scroll position that was before zoom.
         |------------|   |------------|
         |   header1  |   |   header2  |
         |------------|   |------------|
         |    view1   |   |    view2   |
         |------------|   |------------|

         Idea to fix is simple - avoid suspending partner scroll. Works well for case with 2 partners. We also need this
         hack only with zooming, this is why beforezoomchange event is required.
         */
        otherPanel.mon(this, 'beforezoomchange', this.onBeforeZoomChange, this);
        otherPanel.mon(this, 'viewchange', this.onViewChange, this);
        this.mon(otherPanel, 'beforezoomchange', this.onBeforeZoomChange, this);
        this.mon(otherPanel, 'viewchange', this.onViewChange, this);
    },
    // Scope of 'this' is set to the other panel in the listener
    onLockedGridResize: function(cmp, width) {
        this.setWidth(width);
    },
    onPartnerCollapseExpand: function(panel) {
        if (panel.getCollapsed()) {
            this.lockedGrid.collapse();
        } else {
            this.lockedGrid.expand();
        }
    },
    setupScrollSync: function() {
        // sync scrolling with external timeline panel
        var otherView = this.partnerTimelinePanel.getSchedulingView(),
            otherScrollSource = otherView.getScrollable(),
            ownView = this.getSchedulingView(),
            ownScrollSource = ownView.getScrollable(),
            activeScrollSource,
            resetFn = Ext.Function.createBuffered(function() {
                activeScrollSource = null;
            }, 300);
        // Need to prevent the view being scrolled by user from updating itself based on its partner also firing 'scroll' events
        var syncScroll = function(scrollable, left) {
                var source = scrollable === ownScrollSource ? ownScrollSource : otherScrollSource;
                var target = scrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
                if (!activeScrollSource) {
                    activeScrollSource = source;
                }
                resetFn();
                if (target !== activeScrollSource) {
                    target.component.headerCt.scrollTo(left);
                    target.scrollTo(left);
                }
            };
        /*
         This scroll sync can be implemented with reliable mechanism of partners in Ext.scroll.Scrollable#addPartner.
         But in this case center date will change during zooming.
         */
        otherView.mon(ownScrollSource, 'scroll', syncScroll);
        ownView.mon(otherScrollSource, 'scroll', syncScroll);
    },
    // Update the 'viewPreset' property manually since it's a public property of the TimelinePanel.
    onViewChange: function(panel) {
        // Both panels associated with timeaxis viewmodel will fire viewchange event, but partner will do it last. We
        // need to sync viewPreset but we cannot know here which one is correct. Thus we get it from viewmodel which
        // will store value passed to setViewPreset method of panel
        if (panel === this) {
            this.partnerTimelinePanel.viewPreset = this.viewPreset = this.timeAxisViewModel.viewPreset;
        }
    },
    onBeforeZoomChange: function() {
        var otherPanel = this.partnerTimelinePanel;
        var scrollable = otherPanel.getSchedulingView().getScrollable(),
            old = scrollable.suspendPartnerSync;
        scrollable.suspendPartnerSync = Ext.emptyFn;
        scrollable.on('scrollend', function() {
            scrollable.suspendPartnerSync = old;
        }, null, {
            single: true
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Sch.mixin.TimelinePanel
 @extends Sch.mixin.AbstractTimelinePanel
 A base mixin for {@link Ext.panel.Panel} classes, giving to the consuming panel the "time line" functionality.
 This means that the panel will be capabale to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

 */
Ext.define('Sch.mixin.TimelinePanel', {
    extend: 'Sch.mixin.AbstractTimelinePanel',
    requires: [
        'Sch.column.timeAxis.Horizontal',
        'Sch.preset.Manager',
        'Sch.data.Calendar',
        'Sch.layout.TableLayout'
    ],
    uses: [
        // TableView also fixes some problems in scheduler grid, usecase here:
        // http://www.bryntum.com/forum/viewtopic.php?f=35&t=7315&p=41646#p41646
        'Sch.patches.TableView',
        'Sch.patches.TableView_6_0_2',
        'Sch.patches.TableView2',
        'Sch.patches.TablePanel',
        'Sch.patches.BufferedRenderer',
        'Sch.patches.CellContext',
        'Sch.patches.RowSynchronizer',
        'Sch.patches.Explorer',
        'Sch.patches.DomScroller',
        'Sch.patches.TimelineGridView',
        'Sch.patches.TimelinePanel'
    ],
    mixins: [
        'Sch.mixin.Zoomable',
        'Sch.mixin.PartnerTimelinePanel'
    ],
    /**
     *  @cfg {Boolean} destroyStore True to delete all stores used by this component when it's destroyed (including the global CalendarManager)
     */
    destroyStores: false,
    /**
     * @cfg {Object} lockedGridConfig A custom config object used to initialize the left (locked) grid panel.
     */
    /**
     * @cfg {Object} schedulerConfig A custom config object used to initialize the right (schedule) grid panel.
     */
    /**
     * @cfg {String/Ext.Template} tooltipTpl
     * Template used to show a tooltip over a scheduled item, null by default (meaning no tooltip). The tooltip will be populated with the data in
     * record corresponding to the hovered element. See also {@link #tipCfg} and to provide your own custom data object for this
     * template, please see {@link Sch.mixin.TimelineView#getDataForTooltipTpl}.
     */
    /**
     * @cfg {Sch.mixin.TimelinePanel/String} partnerTimelinePanel A reference to another timeline panel (or a component id) that this panel should be 'partner' with.
     * If this config is supplied, this panel will:
     *
     * - Share and use the {@link Sch.data.TimeAxis} timeAxis from the partner panel.
     * - Synchronize the width of the two locked grid panels (after a drag of the splitter).
     * - Synchronize horizontal scrolling between two panels.
     */
    /**
     * @cfg {Number} bufferCoef
     *
     * This config defines the width of the left and right invisible parts of the timespan when {@link #infiniteScroll} set to `true`.
     *
     * It should be provided as a coefficient, which will be multiplied by the width of the scheduling area.
     *
     * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to
     * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting
     * in 2200px of totally rendered content.
     *
     * The timespan gets recalculated when the scroll position reaches the limits defined by the {@link #bufferThreshold} option.
     *
     */
    bufferCoef: 5,
    /**
     * @cfg {Number} bufferThreshold
     *
     * This config defines the horizontal scroll limit, which, when exceeded will cause a timespan shift.
     * The limit is calculated as the `panelWidth * {@link #bufferCoef} * bufferThreshold`. During scrolling, if the left or right side
     * has less than that of the rendered content - a shift is triggered.
     *
     * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan
     * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.
     */
    bufferThreshold: 0.2,
    /**
     * @cfg {Boolean} infiniteScroll
     *
     * True to automatically adjust the panel timespan during horizontal scrolling, when the scroller comes close to the left/right edges.
     *
     * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based
     * on the {@link #bufferCoef} option. The moment when the timespan shift happens is determined by the {@link #bufferThreshold} value.
     */
    infiniteScroll: false,
    /**
     * @cfg {Boolean} showCrudManagerMask set this to true to display a load mask during CRUD manager server requests. Note: works only if {@link #crudManager} is specified.
     */
    showCrudManagerMask: true,
    /**
     * @cfg {Boolean} highlightWeekends
     * True (default) to highlight weekends and holidays, using the {@link Sch.plugin.NonWorkingTime} plugin.
     */
    highlightWeekends: false,
    /**
     * @cfg {Boolean} showTodayLine
     * True to show a line indicating current time.
     */
    showTodayLine: false,
    /**
     * @cfg {Sch.data.Calendar} calendar a {@link Sch.data.Calendar calendar} instance for this timeline panel.
     */
    calendar: null,
    waitingForAutoTimeSpan: false,
    columnLinesFeature: null,
    renderWaitListener: null,
    schedulePinchThreshold: 30,
    pinchStartDistanceX: null,
    pinchStartDistanceY: null,
    pinchDistanceX: null,
    pinchDistanceY: null,
    horizontalColumns: null,
    forceDefineTimeSpanByStore: false,
    workingTimePlugin: null,
    // Split the left / right grid and add a draggable splitter
    split: true,
    /**
     * @property {Object} viewRefreshRequested Contain views for which refresh was suspended and triggered
     * @private
     */
    viewRefreshRequested: null,
    /**
     * @cfg {Object} tipCfg
     * The {@link Ext.Tooltip} config object used to configure a tooltip (only applicable if tooltipTpl is set).
     */
    tipCfg: {
        cls: 'sch-tip',
        showDelay: 400,
        hideDelay: 0,
        autoHide: true,
        anchor: 'b'
    },
    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinchstart
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinch
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinchend
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The pinched date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading, please wait...'
     - savingText : 'Saving changes, please wait...'
     */
    inheritables: function() {
        return {
            // Configuring underlying table panel
            columnLines: true,
            enableLocking: true,
            lockable: true,
            stateEvents: [
                'viewchange'
            ],
            syncRowHeight: false,
            // EOF: Configuring underlying table panel
            cellTopBorderWidth: 0,
            // private
            initComponent: function() {
                if (this.partnerTimelinePanel) {
                    // Allow a cmp id to be passed in
                    if (typeof this.partnerTimelinePanel === 'string') {
                        this.partnerTimelinePanel = Ext.getCmp(this.partnerTimelinePanel);
                    }
                    this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                    this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
                    this.startDate = this.timeAxis.getStart();
                    this.endDate = this.timeAxis.getEnd();
                }
                this._initializeTimelinePanel();
                this.configureChildGrids();
                // Now the time axis view model is configured using the forceFit setting.
                // We never want the native Ext JS grid implementation of forceFit - disable it
                this.forceFit = false;
                var columns = this.columns || [];
                // The 'columns' config can also be a config object for Ext.grid.header.Container
                if (columns.items) {
                    // If columns config not specified, this.columns will be taken from prototype and following code will change
                    // it. Covered by 1114_memory and 1109_orientation
                    this.columns = Ext.apply({}, this.columns);
                    // Clone it to make sure we handle the case of a column array object put on the class prototype
                    columns = this.columns.items = columns.items.slice();
                } else {
                    // Clone it to make sure we handle the case of a column array object put on the class prototype
                    columns = this.columns = columns.slice();
                }
                this.configureColumns(columns);
                if (Ext.getVersion().equals('6.0.2.437')) {
                    this.viewConfig = Ext.apply(this.viewConfig || {}, {
                        componentLayout: 'timeline_tablelayout'
                    });
                }
                var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
                var id = this.getId();
                // Copy some properties to the view instance
                Ext.apply(this.normalViewConfig, {
                    id: id + '-timelineview',
                    eventPrefix: this.autoGenId ? null : id,
                    timeAxisViewModel: this.timeAxisViewModel,
                    eventBorderWidth: this.eventBorderWidth,
                    timeAxis: this.timeAxis,
                    readOnly: this.readOnly,
                    mode: this.mode,
                    rtl: this.rtl,
                    cellBorderWidth: this.cellBorderWidth,
                    cellTopBorderWidth: this.cellTopBorderWidth,
                    cellBottomBorderWidth: this.cellBottomBorderWidth,
                    infiniteScroll: this.infiniteScroll,
                    bufferCoef: this.bufferCoef,
                    bufferThreshold: this.bufferThreshold
                });
                // TODO: replace with Ext.copyTo() when ExtJS 6.0.0 support is dropped
                Ext.Array.each([
                    "eventRendererScope",
                    "eventRenderer",
                    "dndValidatorFn",
                    "resizeValidatorFn",
                    "createValidatorFn",
                    "tooltipTpl",
                    "validatorFnScope",
                    "eventResizeHandles",
                    "enableEventDragDrop",
                    "enableDragCreation",
                    "resizeConfig",
                    "createConfig",
                    "tipCfg",
                    "getDateConstraints"
                ], function(prop) {
                    if (prop in this)  {
                        viewConfig[prop] = this[prop];
                    }
                    
                }, this);
                this.callParent(arguments);
                if (this.rtl) {
                    // Locked column in RTL positioned incorrectly by EXT
                    // https://www.sencha.com/forum/showthread.php?299582-RTL-locking-grid-bug
                    // https://www.sencha.com/forum/showthread.php?304826-Locked-column-content-is-misaligned-with-RTL-ext
                    this.lockedGrid.view.addCls('sch-locked-column-fixer');
                    this.addCls('sch-rtl');
                } else {
                    this.addCls('sch-ltr');
                }
                var plugins = this.plugins = [].concat(this.plugins || []);
                if (this.highlightWeekends) {
                    var calendar = this.getCalendar();
                    calendar = calendar && Ext.StoreMgr.lookup(calendar) || new Sch.data.Calendar();
                    this.workingTimePlugin = Ext.create("Sch.plugin.NonWorkingTime", {
                        calendar: calendar
                    });
                    this.timeAxisViewModel.setCalendar(calendar);
                    plugins.push(this.workingTimePlugin);
                    this.addCls('sch-timelinepanel-highlightweekends');
                }
                if (this.showTodayLine) {
                    this.todayLinePlugin = new Sch.plugin.CurrentTimeLine();
                    plugins.push(this.todayLinePlugin);
                }
                this.patchNavigationModel(this);
                if (Ext.supports.Touch) {
                    // During zooming operation header container sometimes cannot be scrolled to required position
                    // because touchscroller on header will return wrong size. Refresh it when header is updated
                    // https://www.assembla.com/spaces/bryntum/tickets/2690
                    // covered by several zooming tests on touch device
                    this.timeAxisViewModel.on('update', this.refreshHeaderContainerScrollable, this);
                }
                this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);
                // if no start/end dates specified let's get them from event store
                if (!this.startDate) {
                    var crud = this.crudManager;
                    // If crud manager is provided, we should listen to it's loading status
                    if (crud && !crud.loaded) {
                        this.bindAutoTimeSpanListeners();
                    } else {
                        var store = this.getTimeSpanDefiningStore();
                        // if events already loaded
                        if (store.isTreeStore ? store.getRoot().childNodes.length : store.getCount()) {
                            this.applyStartEndDatesFromStore();
                        }
                        // if timespan defining store is in state of loading
                        // or forceDefineTimeSpanByStore enabled
                        // we wait till the store gets loaded and only then refresh view
                        else if (store.isLoading() || this.forceDefineTimeSpanByStore) {
                            this.bindAutoTimeSpanListeners();
                        }
                    }
                }
                var columnLines = this.columnLines;
                if (columnLines) {
                    this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(columnLines) ? columnLines : undefined);
                    this.columnLinesFeature.init(this);
                    this.columnLines = true;
                }
                this.relayEvents(this.getSchedulingView(), [
                    /**
                 * @event beforetooltipshow
                 * Fires before the event tooltip is shown, return false to suppress it.
                 * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
                 * @param {Sch.model.Event} eventRecord The event record of the clicked record
                 */
                    'beforetooltipshow',
                    'scheduleclick',
                    'scheduledblclick',
                    'schedulecontextmenu',
                    'schedulepinch',
                    'schedulepinchstart',
                    'schedulepinchend'
                ]);
                // HACK, required since Ext has an async scroll sync mechanism setup which won't play nice with our "sync scroll" above.
                this.on('zoomchange', function() {
                    // After a zoom, the header is resized and Ext JS TablePanel reacts to the size change.
                    // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                    this.normalGrid.scrollTask.cancel();
                });
                if (this.crudManager) {
                    // if we have CrudManager instance assigned, we should show and hide a load mask
                    // But not with autoSync enabled, since that'll be a terrible user experience
                    if (!this.crudManager.autoSync && this.showCrudManagerMask) {
                        this.mon(this.crudManager, {
                            beforesend: this.beforeCrudOperationStart,
                            synccanceled: this.onCrudOperationComplete,
                            loadcanceled: this.onCrudOperationComplete,
                            load: this.onCrudOperationComplete,
                            sync: this.onCrudOperationComplete,
                            requestfail: this.onCrudOperationComplete,
                            scope: this
                        });
                        // User might already have triggered a load operation
                        if (this.crudManager.isLoading()) {
                            this.beforeCrudOperationStart(this.crudManager, null, 'load');
                        }
                    }
                    // prevent multiple refreshes on crud manager load
                    // #2494 - View is refreshed twice during crud manager load
                    this.mon(this.crudManager, {
                        beforeloadapply: this.onCrudBeforeLoad,
                        load: this.onCrudLoad,
                        scope: this
                    });
                }
                this.afterInitComponent();
            },
            refreshHeaderContainerScrollable: function() {
                var scrollable = this.getSchedulingView().headerCt.getScrollable();
                // If panel is not yet rendered there is no scrollable
                if (!scrollable)  {
                    return;
                }
                
                if (Ext.getVersion().isLessThan('6.0.1')) {
                    var old = scrollable.isConfiguring;
                    // Without this hack view will continuously scroll to 0 and reconfigure until exception is raised
                    scrollable.isConfiguring = true;
                    // Refresh current scrollable size or it will constrain requested scroll
                    scrollable.doRefresh();
                    // This call will update max position for scrollable, if we don't do that, header won't be
                    // scrollable anymore
                    scrollable.refreshAxes();
                    scrollable.isConfiguring = old;
                } else {
                    scrollable.doRefresh();
                }
            },
            getState: function() {
                var me = this,
                    state = me.callParent(arguments);
                Ext.apply(state, {
                    viewPreset: me.viewPreset,
                    startDate: me.getStart(),
                    endDate: me.getEnd(),
                    zoomMinLevel: me.zoomMinLevel,
                    zoomMaxLevel: me.zoomMaxLevel,
                    currentZoomLevel: me.currentZoomLevel
                });
                return state;
            },
            applyState: function(state) {
                var me = this;
                me.callParent(arguments);
                if (state && state.viewPreset) {
                    me.setViewPreset(state.viewPreset, state.startDate, state.endDate);
                }
                if (state && state.currentZoomLevel) {
                    me.zoomToLevel(state.currentZoomLevel);
                }
            },
            setTimeSpan: function() {
                this.callParent(arguments);
                if (this.waitingForAutoTimeSpan) {
                    // we pass false to not refresh views inside of unbindAutoTimeSpanListeners()
                    // since we do it manually in the next line
                    this.unbindAutoTimeSpanListeners(false);
                    // If we unbind autotimespan listeners, that means refresh was prevented
                    // and now it's required. Normally it would be called inside 'callParent', but
                    // in 5.1.1 that call produces layout issue. This action seem to be similar
                    this.getView().refresh();
                }
                // if view was not initialized due to our refresh stopper the onTimeAxisViewModelUpdate method will not do a refresh
                // if that happened we do refresh manually
                if (!this.normalGrid.getView().viewReady) {
                    this.getView().refresh();
                }
            },
            onBoxReady: function() {
                var me = this;
                me.callParent(arguments);
                if (me.partnerTimelinePanel) {
                    if (me.partnerTimelinePanel.rendered) {
                        me.setupPartnerTimelinePanel(me.partnerTimelinePanel);
                    } else {
                        me.partnerTimelinePanel.on('boxready', me.setupPartnerTimelinePanel, me);
                    }
                }
                me.normalGrid.on({
                    collapse: me.onNormalGridCollapse,
                    expand: me.onNormalGridExpand,
                    scope: me
                });
                me.lockedGrid.on({
                    collapse: me.onLockedGridCollapse,
                    expand: me.onLockedGridExpand,
                    scope: me
                });
                me.lockedGrid.on({
                    itemdblclick: me.onLockedGridItemDblClick,
                    scope: me
                });
                if (Ext.supports.Touch) {
                    this.getSchedulingView().on({
                        schedulepinchstart: this.onSchedulePinchStart,
                        schedulepinch: this.onSchedulePinch,
                        schedulepinchend: this.onSchedulePinchEnd,
                        scope: this
                    });
                }
            }
        };
    },
    // https://www.assembla.com/spaces/bryntum/tickets/2190
    scrollToDate: function(date, animate) {
        var view = this.getSchedulingView();
        if (view.isCalendar()) {
            var column = view.calendar.getColumnsBy(function(column) {
                    return column.start <= date && column.end > date;
                })[0];
            if (column) {
                view.scrollHorizontallyTo(column.getLocalX());
                view.scrollVerticallyTo(view.getCoordinateFromDate(date, true));
            }
        } else {
            return this.callParent(arguments);
        }
    },
    bindAutoTimeSpanListeners: function() {
        var store = this.getTimeSpanDefiningStore();
        this.waitingForAutoTimeSpan = true;
        // prevent panel refresh till eventStore gets loaded
        this.suspendViewsRefresh();
        this.mon(store, 'load', this.applyStartEndDatesFromStore, this);
        if (store.isTreeStore) {
            this.mon(store, 'rootchange', this.applyStartEndDatesFromStore, this);
            this.mon(store, 'nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            this.mon(store, 'add', this.applyStartEndDatesFromStore, this);
        }
    },
    refreshStopper: function(view) {
        this.viewRefreshRequested = this.viewRefreshRequested || {};
        this.viewRefreshRequested[view.isLockedView ? 'locked' : 'normal'] = true;
        return false;
    },
    /**
     * Will prevent locked/normal views refresh via refresh or refreshView call
     * @private
     */
    suspendViewsRefresh: function() {
        // prevent refresh calls
        var normalView = this.normalGrid.view;
        var lockedView = this.lockedGrid.view;
        normalView.on('beforerefresh', this.refreshStopper, this);
        lockedView.on('beforerefresh', this.refreshStopper, this);
        // prevent low level refreshView calls (e.g. from refreshKeepingScroll)
        normalView.blockRefresh = true;
        lockedView.blockRefresh = true;
    },
    /**
     * This method will resume view refreshing and perform refresh in case it was cancelled by
     * pairing {@link #suspendViewsRefresh}
     * @param {Boolean} [doRefresh] Pass false to avoid refreshing view
     * @private
     */
    resumeViewsRefresh: function(doRefresh) {
        doRefresh = doRefresh !== false;
        var normalView = this.normalGrid.view;
        var lockedView = this.lockedGrid.view;
        normalView.un('beforerefresh', this.refreshStopper, this);
        lockedView.un('beforerefresh', this.refreshStopper, this);
        normalView.blockRefresh = false;
        lockedView.blockRefresh = false;
        var refreshRequested = this.viewRefreshRequested || {};
        // Refresh request could originate in 2 ways:
        // 1) 'refresh' event - is cancelled by our refreshStopper listener
        // 2) refreshView() calls - is stopped by blockRefresh (ExtJS flag) on a view. In that case refreshNeeded flag (generic ExtJS one) is set on the view.
        refreshRequested.locked = refreshRequested.locked || lockedView.refreshNeeded;
        refreshRequested.normal = refreshRequested.normal || normalView.refreshNeeded;
        if (doRefresh) {
            // both views tried to refresh
            if (refreshRequested.locked && refreshRequested.normal) {
                // without suspend/flush ext will throw layout run fail
                Ext.suspendLayouts();
                this.refreshViews(false);
                Ext.resumeLayouts(true);
            } else if (refreshRequested.locked) {
                lockedView.refreshView();
            } else if (refreshRequested.normal) {
                normalView.refreshView();
            }
        }
        // reset refresh attempts counters
        this.viewRefreshRequested = null;
    },
    getTimeSpanDefiningStore: function() {
        throw "Abstract method called";
    },
    unbindAutoTimeSpanListeners: function(doRefresh) {
        this.waitingForAutoTimeSpan = false;
        var store = this.getTimeSpanDefiningStore();
        // allow panel refresh back
        this.resumeViewsRefresh(doRefresh);
        // unbind listener
        store.un('load', this.applyStartEndDatesFromStore, this);
        if (store.isTreeStore) {
            store.un('rootchange', this.applyStartEndDatesFromStore, this);
            store.un('nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            store.un('add', this.applyStartEndDatesFromStore, this);
        }
    },
    applyStartEndDatesAfterTreeAppend: function() {
        var store = this.getTimeSpanDefiningStore();
        // Need to block the reading of the total store timespan until the store is done loading
        // With CRUD manager, we need the __loading flag since multiple append events are fired during load
        if (!store.isSettingRoot && !store.__loading) {
            this.applyStartEndDatesFromStore();
        }
    },
    applyStartEndDatesFromStore: function() {
        var store = this.getTimeSpanDefiningStore();
        var span = store.getTotalTimeSpan();
        // If event store contains events without duration, add a 1 mainUnit buffer to each side
        if (span.end && span.start && span.end - span.start === 0) {
            span.start = Sch.util.Date.add(span.start, this.timeAxis.mainUnit, -1);
            span.end = Sch.util.Date.add(span.end, this.timeAxis.mainUnit, 1);
        }
        this.setTimeSpan(span.start || new Date(), span.end);
    },
    onLockedGridItemDblClick: function(grid, record, el, rowIndex, event) {
        if (this.mode === 'vertical' && record) {
            this.fireEvent('timeheaderdblclick', this, record.get('start'), record.get('end'), rowIndex, event);
        }
    },
    /**
     * Returns the view which renders the schedule and time columns. This method should be used instead of the usual `getView`,
     * since `getView` will return an instance of a special "locking" grid view, which has no scheduler-specific features.
     *
     * @return {Sch.mixin.SchedulerView} view A view implementing the {@link Sch.mixin.SchedulerView} mixin
     */
    getSchedulingView: function() {
        return this.normalGrid && this.normalGrid.view;
    },
    getHorizontalTimeAxisColumn: function() {
        return this.getSchedulingView().getHorizontalTimeAxisColumn();
    },
    configureColumns: function(columns) {
        var lockedColumns = [];
        var normalColumns = [];
        // Split locked and normal columns first
        Ext.Array.each(columns, function(column) {
            if (column.position === 'right' || column.locked === false) {
                if (!Ext.isNumber(column.width)) {
                    Ext.Error.raise('"Right" columns must have a fixed width');
                }
                column.locked = false;
                normalColumns.push(column);
            } else {
                column.locked = true;
                lockedColumns.push(column);
            }
            column.lockable = false;
        });
        // No splitter if there are no locked columns
        if (columns.length === 0) {
            this.split = false;
        }
        Ext.Array.erase(columns, 0, columns.length);
        Ext.Array.insert(columns, 0, lockedColumns.concat(// Don't inject timeaxiscolumn if it's already in place (if cloning existing panel)
        Ext.Array.findBy(normalColumns, function(cfg) {
            return cfg.xtype === 'timeaxiscolumn';
        }) ? [] : {
            xtype: 'timeaxiscolumn',
            timeAxisViewModel: this.timeAxisViewModel,
            trackHeaderOver: this.trackHeaderOver,
            renderer: this.mainRenderer,
            variableRowHeight: this.variableRowHeight,
            scope: this
        }).concat(normalColumns));
        // Save reference to original set of columns
        this.horizontalColumns = columns.slice();
    },
    mainRenderer: function(val, meta, rowRecord, rowIndex, colIndex) {
        var renderers = this.renderers,
            resource = this.mode === 'horizontal' || this.mode === 'calendar' ? rowRecord : this.getResourceStore().getAt(colIndex),
            retVal = '&nbsp;';
        // To ensure cells always consume correct height
        // Ext doesn't clear the meta object between cells
        meta.rowHeight = null;
        for (var i = 0; i < renderers.length; i++) {
            retVal += renderers[i].fn.call(renderers[i].scope || this, val, meta, resource, rowIndex, colIndex) || '';
        }
        if (this.variableRowHeight) {
            // Set row height
            var view = this.getSchedulingView();
            var defaultRowHeight = this.getRowHeight();
            meta.style = 'height:' + ((meta.rowHeight || defaultRowHeight) - view.cellTopBorderWidth - view.cellBottomBorderWidth) + 'px';
        }
        return retVal;
    },
    onNormalGridCollapse: function() {
        var me = this;
        //Hack for Gantt to prevent creating second expander when normal grid initially collapsed
        if (!me.normalGrid.reExpander) {
            me.normalGrid.reExpander = me.normalGrid.placeholder;
        }
        if (!me.lockedGrid.rendered) {
            me.lockedGrid.on('render', me.onNormalGridCollapse, me, {
                delay: 1
            });
        } else {
            me.lockedGrid.savedWidth = me.lockedGrid.getWidth();
            if (me.lockedGrid.collapsed) {
                me.lockedGrid.expand();
            }
            me.lockedGrid.setWidth(me.getWidth() - me.normalGrid.getPlaceholder().getWidth());
            // Show a vertical scrollbar in locked grid if normal grid is collapsed
            me.addCls('sch-normalgrid-collapsed');
        }
    },
    onNormalGridExpand: function() {
        this.removeCls('sch-normalgrid-collapsed');
    },
    onLockedGridCollapse: function() {
        var me = this;
        if (me.normalGrid.collapsed) {
            me.normalGrid.expand();
        }
    },
    onLockedGridExpand: function() {
        if (this.lockedGrid.savedWidth) {
            this.lockedGrid.setWidth(this.lockedGrid.savedWidth);
        }
    },
    beforeCrudOperationStart: function(manager, params, type) {
        if (this.rendered) {
            this.setLoading({
                msg: type === 'load' ? this.L('loadingText') : this.L('savingText')
            });
        } else {
            Ext.destroy(this.renderWaitListener);
            this.renderWaitListener = this.on('render', Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {
                delay: 1,
                destroyable: true
            });
        }
    },
    onCrudBeforeLoad: function() {
        this.suspendViewsRefresh();
    },
    onCrudLoad: function() {
        this.resumeViewsRefresh();
    },
    onCrudOperationComplete: function() {
        Ext.destroy(this.renderWaitListener);
        this.setLoading(false);
    },
    onSchedulePinchStart: function(view, e) {
        this.pinchStartDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchStartDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },
    onSchedulePinch: function(view, e) {
        this.pinchDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },
    onSchedulePinchEnd: function(view) {
        var xDistance = this.pinchDistanceX;
        var yDistance = this.pinchDistanceY;
        var isHorizontal = this.getMode()[0] === 'h';
        if (Math.abs(xDistance - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
            var scaleX = Math.abs(xDistance / this.pinchStartDistanceX);
            if (isHorizontal) {
                scaleX > 1 ? this.zoomIn() : this.zoomOut();
            } else {
                this.timeAxisViewModel.setViewColumnWidth(scaleX * this.timeAxisViewModel.resourceColumnWidth);
            }
        }
        if (Math.abs(yDistance - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
            var scaleY = Math.abs(yDistance / this.pinchStartDistanceY);
            view.setRowHeight(view.getRowHeight() * scaleY);
        }
        this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null;
    },
    // Patches navigation model to skip undesired programmatic row focusing if timeline row is about to be focused.
    // This prevents timeline view scrolling to the top/left when clicking a non-focused timeline view row.
    // https://www.assembla.com/spaces/bryntum/tickets/1795
    patchNavigationModel: function(me) {
        me.getView().getNavigationModel().focusItem = function(item) {
            item.addCls(this.focusCls);
            if (((Ext.isIE || Ext.isEdge) && !item.hasCls('sch-timetd')) || // For IE, avoid focus when clicking on any schedule cell
            (!(Ext.isIE || Ext.isEdge) && me.getOrientation() === 'horizontal')) // For non-IE: in vertical or calendar view, skip scroll to top
            {
                item.focus();
            }
        };
        // https://www.sencha.com/forum/showthread.php?301110-Last-focused-item-is-not-synced-which-causes-scroll-jump
        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();
        lockedView.on('rowclick', function(view, record, tr, rowIndex) {
            if (normalView.lastFocused) {
                normalView.lastFocused.rowIdx = rowIndex;
                normalView.lastFocused.record = record;
            } else if (Ext.isIE) {
                normalView.lastFocused = this.lastFocused;
            }
        });
        normalView.on('rowclick', function(view, record, tr, rowIndex) {
            if (lockedView.lastFocused) {
                lockedView.lastFocused.rowIdx = rowIndex;
                lockedView.lastFocused.record = record;
            } else if (Ext.isIE) {
                lockedView.lastFocused = this.lastFocused;
            }
        });
    },
    configureChildGrids: function() {
        var me = this;
        // Make local copies of these configs in case someone puts them on the prototype of a subclass.
        me.lockedGridConfig = Ext.apply({}, me.lockedGridConfig || {});
        me.normalGridConfig = Ext.apply({}, me.schedulerConfig || me.normalGridConfig || {});
        var lockedGrid = me.lockedGridConfig,
            normalGrid = me.normalGridConfig;
        if (me.lockedXType) {
            lockedGrid.xtype = me.lockedXType;
        }
        if (me.normalXType) {
            normalGrid.xtype = me.normalXType;
        }
        // Configure the child grids
        Ext.applyIf(lockedGrid, {
            useArrows: true,
            animCollapse: false,
            collapseDirection: 'left',
            trackMouseOver: false
        });
        Ext.applyIf(normalGrid, {
            viewType: me.viewType,
            enableColumnMove: false,
            enableColumnResize: false,
            enableColumnHide: false,
            trackMouseOver: false,
            collapseDirection: 'right',
            collapseMode: 'placeholder',
            animCollapse: false
        });
        if (me.mode === 'vertical') {
            lockedGrid.store = normalGrid.store = me.timeAxis;
        }
        if (lockedGrid.width) {
            // User has specified a fixed width for the locked section, disable the syncLockedWidth method
            me.syncLockedWidth = Ext.emptyFn;
            // Enable scrollbars for locked section
            lockedGrid.scroll = Ext.supports.Touch ? 'both' : 'horizontal';
            lockedGrid.scrollerOwner = true;
        }
    },
    afterInitComponent: function() {
        var me = this;
        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();
        var isTree = Ext.data.TreeStore && me.store instanceof Ext.data.TreeStore;
        if (me.normalGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.normalGrid.collapsed = false;
            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            normalView.on('boxready', function() {
                me.normalGrid.collapse();
            }, me, {
                delay: 10
            });
        }
        if (me.lockedGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.lockedGrid.collapsed = false;
            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            lockedView.on('boxready', function() {
                me.lockedGrid.collapse();
            }, me, {
                delay: 10
            });
            if (lockedView.bufferedRenderer)  {
                lockedView.bufferedRenderer.disabled = true;
            }
            
        }
        if (isTree) {
            this.setupLockableFilterableTree();
        }
        // HACK, no sane way of getting rid of grid column menu items (as of 4.2.1).
        // Grouping view overwrites showMenuBy property
        // http://www.sencha.com/forum/showthread.php?269612-Config-to-get-rid-of-Lock-Unlock-column-options&p=987653#post987653
        this.on('afterrender', function() {
            var showMenuBy = this.lockedGrid.headerCt.showMenuBy;
            this.lockedGrid.headerCt.showMenuBy = function() {
                showMenuBy.apply(this, arguments);
                me.showMenuBy.apply(this, arguments);
            };
        });
        var splitter = this.getSplitter();
        if (splitter) {
            splitter.addCls('sch-timelinepanel-splitter');
            splitter.setVisible(this.mode === 'horizontal');
        }
        // we keep listening for a "true" mousemove event and remove the touch-specific adaptions in this case
        var mouseMoveChecker = function(e, t) {
                if (!("TouchEvent" in window && (e.parentEvent && e.parentEvent.type.match(/touch/i)))) {
                    Ext.getBody().un('mousemove', mouseMoveChecker, this);
                    this.setTouchEnhancementsEnabled(false);
                }
            };
        // For monitors with both touch and mouse: If there is a mouse attached, remove the touch-specific CSS
        // https://www.assembla.com/spaces/bryntum/tickets/1922#/activity/ticket:
        Ext.getBody().on('mousemove', mouseMoveChecker, this);
        this.setTouchEnhancementsEnabled(true);
    },
    getSplitter: function() {
        return this.child('splitter');
    },
    setTouchEnhancementsEnabled: function(enabled) {
        if (enabled) {
            this.addCls('sch-touch-only');
        } else {
            this.removeCls('sch-touch-only');
        }
    },
    setupLockableFilterableTree: function() {
        var me = this;
        var lockedView = me.lockedGrid.getView();
        // enable filtering support for trees
        var filterableProto = Sch.mixin.FilterableTreeView.prototype;
        lockedView.initTreeFiltering = filterableProto.initTreeFiltering;
        lockedView.onFilterChangeStart = filterableProto.onFilterChangeStart;
        lockedView.onFilterChangeEnd = filterableProto.onFilterChangeEnd;
        lockedView.onFilterCleared = filterableProto.onFilterCleared;
        lockedView.onFilterSet = filterableProto.onFilterSet;
        lockedView.initTreeFiltering();
    },
    showMenuBy: function(t, header) {
        var menu = this.getMenu(),
            unlockItem = menu.down('#unlockItem'),
            lockItem = menu.down('#lockItem'),
            sep = unlockItem.prev();
        sep.hide();
        unlockItem.hide();
        lockItem.hide();
    },
    /**
     * Changes the timeframe of the scheduling chart to fit all the events in it.
     * @param {Object} [options] Options object for the zooming operation.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date
     */
    zoomToFit: function(options) {
        options = Ext.apply({
            adjustStart: 1,
            adjustEnd: 1
        }, options);
        var eventStore = this.getEventStore();
        var span = this.getEventStore().getTotalTimeSpan();
        if (this.zoomToSpan(span, options) === null) {
            // if no zooming was performed - fit columns to view space
            this.getSchedulingView().fitColumns();
        }
    },
    refreshViews: function(keepScrollPosition) {
        if (!this.rendered)  {
            return;
        }
        
        var refreshed = false;
        var schedulingViewListener = function() {
                refreshed = true;
            };
        var schedulingView = this.normalGrid.getView();
        var lockedView = this.lockedGrid.getView(),
            scroll = {
                left: lockedView.getScrollX(),
                top: lockedView.getScrollY()
            };
        schedulingView.on('refresh', schedulingViewListener);
        lockedView.refreshView();
        // this could trigger a normal view refresh, out of our control
        schedulingView.un('refresh', schedulingViewListener);
        if (keepScrollPosition !== false) {
            !refreshed && this.getSchedulingView().refreshKeepingScroll();
            lockedView.setScrollX(scroll.left);
            lockedView.setScrollY(scroll.top);
        } else if (!refreshed) {
            this.getSchedulingView().refreshView();
        }
    },
    getCalendar: function() {
        return this.calendar;
    },
    /**
     * Toggles the weekend highlighting on or off
     * @param {Boolean} disabled
     */
    disableWeekendHighlighting: function(disabled) {
        this.workingTimePlugin.setDisabled(disabled);
        if (disabled) {
            this.removeCls('sch-timelinepanel-highlightweekends');
        } else {
            this.addCls('sch-timelinepanel-highlightweekends');
        }
    }
}, function() {
    var MIN_EXT_VERSION = '6.0.0';
    Ext.apply(Sch, {
        VERSION: '4.2.7'
    });
    // DELETE THIS CHECK IF YOU WANT TO RUN AGAINST AN OLDER UNSUPPORTED EXT JS VERSION
    if (Ext.versions.extjs.isLessThan(MIN_EXT_VERSION)) {
        var c = console;
        c && c.log('The Ext JS version you are using needs to be updated to at least ' + MIN_EXT_VERSION);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Sch.panel.TimelineTreePanel
 @extends Ext.tree.Panel
 @mixin Sch.mixin.TimelinePanel

 Internal class.

 */
Ext.define("Sch.panel.TimelineTreePanel", {
    extend: "Ext.tree.Panel",
    requires: [
        // need to require grid panel too here, because one of the sub-grids will be a normal grid
        'Ext.grid.Panel',
        'Ext.data.TreeStore',
        // will be used in the `setupLockableTree` of lockable mixin
        'Sch.mixin.FilterableTreeView',
        'Sch.patches.TreeNavigationModel'
    ],
    mixins: [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],
    alias: [
        'widget.timelinetree'
    ],
    useArrows: true,
    rootVisible: false,
    lockedXType: 'treepanel',
    isTimelineTreePanel: true,
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin is a helper for Scheduler grid/tree panels. It adds Dependency view instance management methods to
 * those panels.
 */
Ext.define('Sch.view.dependency.Mixin', {
    extend: 'Ext.Mixin',
    uses: [
        'Sch.view.dependency.View'
    ],
    mixinConfig: {
        after: {
            initComponent: 'initComponent',
            destroy: 'destroy'
        }
    },
    /**
     * @cfg {Object} dependencyViewConfig
     *
     * Dependency view config. Use `type` property to create different type of dependency views.
     */
    dependencyViewConfig: null,
    // Private, dependency view instance
    dependencyView: null,
    // Private, dependency view relay detacher
    dependencyViewRelayDetacher: null,
    initComponent: function() {
        var me = this;
        // Locked grid relays this event from normal grid which is the grid showing scheduler events, i.e. the one
        // which has scheduling view
        me.on('viewready', function() {
            me.setupDependencyView(me.getDependencyViewConfig(), me.getSchedulingView());
        });
    },
    /**
     * Gets current dependency view config
     *
     * @return {Object|Null}
     */
    getDependencyViewConfig: function() {
        return this.dependencyViewConfig;
    },
    /**
     * Sets current dependency view config.
     *
     * If dependency view is already created and config has different view `type` set then the view
     * might be destroyed and re-created as the side-effect of this method call.
     *
     * @param {Object} config
     */
    setDependencyViewConfig: function(config) {
        var me = this;
        if (me.dependencyViewConfig !== config) {
            me.dependencyViewConfig = config;
            if (me.dependencyView) {
                // In this case we are to re-create painter instance since painter type is changed
                if (config && 'type' in config && config.type !== me.dependencyView.type) {
                    me.setupDependencyView(config, me.getSchedulingView());
                } else // In this case we just update current painter configuration
                {
                    me.dependencyView.setConfig(config);
                }
            }
        }
    },
    /**
     * Checks if a component has a dependency view created.
     *
     * @return {Boolean}
     */
    hasDependencyView: function() {
        return !!this.dependencyView;
    },
    /**
     * Returns dependency view instance.
     *
     * @return {Sch.view.Dependency}
     */
    getDependencyView: function() {
        return this.dependencyView;
    },
    /**
     * Create dependency view instance.
     *
     * @protected
     */
    createDependencyView: function(config, primaryView) {
        return Sch.view.dependency.View.create(Ext.applyIf({
            primaryView: primaryView
        }, config));
    },
    /**
     * Destroys dependency view instance. The method is called after component's `destroy` method.
     *
     * @protected
     */
    destroy: function() {
        Ext.destroyMembers(this, 'dependencyViewRelayDetacher', 'dependencyView');
    },
    /**
     * Creates, stores and setups dependency view
     *
     * @protected
     */
    setupDependencyView: function(config, primaryView) {
        var me = this;
        Ext.destroy(me.dependencyView);
        me.dependencyView = me.createDependencyView(config, primaryView);
        me.setupDependencyViewRelay();
        me.fireEvent('dependencyviewready', me, me.dependencyView);
        if (me.dependencyView.canDrawDependencies()) {
            me.dependencyView.scheduleAllDependenciesRendering();
        }
    },
    /**
     * Setups dependency view events relaying
     *
     * @protected
     */
    setupDependencyViewRelay: function() {
        var me = this;
        Ext.destroy(me.dependencyViewRelayDetacher);
        me.dependencyViewRelayDetacher = me.relayEvents(me.getDependencyView(), [
            'dependencyclick',
            'dependencydblclick',
            'dependencycontextmenu',
            'dependencymouseover',
            'dependencymouseout'
        ]);
    }
});
/**
     * @event dependencyviewready
     *
     * Fires after dependency view creation
     *
     * @param {Ext.Component} A component instance this mixin is mixed into
     * @param {Sch.view.Dependency} Dependency view instance
     */
/**
     * @event dependencyclick
     *
     * Fires after clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencycontextmenu
     *
     * Fires after right clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencydblclick
     *
     * Fires after double clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencymouseover
     *
     * Fires when hovering over a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */
/**
     * @event dependencymouseout
     *
     * Fires when leaving a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin is a helper for Gantt panel. It adds Dependency view instance management methods.
 */
Ext.define('Gnt.view.dependency.Mixin', {
    extend: 'Sch.view.dependency.Mixin',
    uses: [
        'Gnt.view.dependency.View',
        'Gnt.feature.DependencyDragDrop'
    ],
    /**
     * @cfg {Object} dependencyViewConfig
     *
     * A config object to apply to internal instance of the {@link Gnt.view.Dependency}.
     *
     * Support two deprecated since v.4.2 properties:
     *  - dragZoneConfig
     *  - dropZoneConfig
     * please use:
     *  - dependencyDragZoneConfig
     *  - dependencyDropZoneConfig
     * instead
     */
    dependencyViewConfig: null,
    /**
     * @cfg {Boolean} enableDependencyDragDrop
     *
     * `True` to allow creation of dependencies by using drag and drop between task terminals (defaults to `true`)
     */
    enableDependencyDragDrop: true,
    /**
     * @cfg {Object} dragZoneConfig
     *
     * A custom config object to pass on to configure the Ext.dd.DragZone instance used when creating
     * new dependencies
     */
    dependencyDragZoneConfig: null,
    /**
     * @cfg {Object} dropZoneConfig
     *
     * A custom config object to pass on to configure the Ext.dd.DropZone instance used when creating
     * new dependencies
     */
    dependencyDropZoneConfig: null,
    // private
    dependencyDnd: null,
    dependencyViewDeprecatedRelayDetacher: null,
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'dependencyDnd', 'dependencyViewDeprecatedRelayDetacher');
        me.callParent();
    },
    // TODO: remove this method after 4.2 when scheduling view `dependencyViewConfig` is finally unsupported
    getDependencyViewConfig: function() {
        var me = this;
        return Ext.applyIf(me.callParent() || me.getSchedulingView().dependencyViewConfig || {}, {
            drawDependencies: me.getSchedulingView().drawDependencies !== undefined ? me.getSchedulingView().drawDependencies : true
        });
    },
    // TODO: simplify this method after Gnt.view.dependency.dragZoneConfig is finialy removed
    getDependencyDragZoneConfig: function() {
        var me = this,
            result = me.dependencyDragZoneConfig,
            depViewConfig;
        if (!result) {
            depViewConfig = me.getDependencyViewConfig();
            if (depViewConfig) {
                result = depViewConfig.dragZoneConfig || null;
            }
        }
        return result;
    },
    // TODO: simplify this method after Gnt.view.dependency.dropZoneConfig is finally removed
    getDependencyDropZoneConfig: function() {
        var me = this,
            result = me.dependencyDragZoneConfig,
            depViewConfig;
        if (!result) {
            depViewConfig = me.getDependencyViewConfig();
            if (depViewConfig) {
                result = depViewConfig.dropZoneConfig || null;
            }
        }
        return result;
    },
    createDependencyView: function(config, primaryView) {
        return Sch.view.dependency.View.create(Ext.apply({}, config, {
            primaryView: primaryView,
            type: 'basegantt'
        }));
    },
    setupDependencyView: function(config, primaryView) {
        var me = this;
        me.callParent([
            config,
            primaryView
        ]);
        if (me.enableDependencyDragDrop) {
            me.dependencyDnd = Ext.create('Gnt.feature.DependencyDragDrop', {
                el: primaryView.getEl(),
                rtl: primaryView.rtl,
                ganttView: primaryView,
                dragZoneConfig: me.getDependencyDragZoneConfig(),
                dropZoneConfig: me.getDependencyDropZoneConfig(),
                dependencyStore: me.getDependencyStore(),
                listeners: {
                    'beforednd': me.onBeforeDependencyDrag,
                    'dndstart': me.onDependencyDragStart,
                    'drop': me.onDependencyDrop,
                    'afterdnd': me.onAfterDependencyDragDrop,
                    scope: me
                }
            });
        }
    },
    // TODO: remove this method after 4.4 when dependency related events of Gnt.view.Gantt are finally unsupported
    setupDependencyViewRelay: function() {
        var me = this;
        me.callParent();
        Ext.destroy(me.dependencyViewDeprecatedRelayDetacher);
        me.dependencyViewDeprecatedRelayDetacher = me.getSchedulingView().relayEvents(me.getDependencyView(), [
            'dependencyclick',
            'dependencydblclick',
            'dependencycontextmenu'
        ]);
    },
    onBeforeDependencyDrag: function(dm, sourceTask) {
        var me = this,
            myResult, schedViewResult, depViewResult;
        // TODO: we do way too much relaying, it should be simplified, firing from dependency view should be enough.
        myResult = me.fireEvent('beforedependencydrag', me, sourceTask);
        depViewResult = me.getDependencyView().fireEvent('beforednd', me.getDependencyView(), sourceTask);
        // TODO: remove firing from scheduling view after 4.4 when dependency related events are finally unsupported
        //       on the scheduling view
        schedViewResult = me.getSchedulingView().fireEvent('beforedependencydrag', me.getSchedulingView(), sourceTask);
        return myResult !== false && depViewResult !== false && schedViewResult !== false;
    },
    onDependencyDragStart: function(dm) {
        var me = this;
        // TODO: we do way too much relaying, it should be simplified, firing from dependency view should be enough.
        me.fireEvent('dependencydragstart', this);
        me.getDependencyView().fireEvent('dndstart', me.getDependencyView());
        // TODO: remove firing from scheduling view after 4.4 when dependency related events are finally unsupported
        //       on the scheduling view
        me.getSchedulingView().fireEvent('dependencydragstart', me.getSchedulingView());
        if (me.tip) {
            me.tip.disable();
        }
        me.preventOverCls = true;
    },
    onDependencyDrop: function(dm, fromId, toId, type) {
        var me = this,
            taskStore = me.getTaskStore(),
            fromTask = taskStore.getModelById(fromId),
            toTask = taskStore.getModelById(toId);
        fromTask && fromTask.linkTo(toId, type);
        // TODO: we do way too much relaying, it should be simplified, firing from dependency view should be enough.
        me.fireEvent('dependencydrop', me, fromTask, toTask, type);
        me.getDependencyView().fireEvent('drop', me.getDependencyView(), fromTask, toTask, type);
        // TODO: remove firing from scheduling view after 4.4 when dependency related events are finally unsupported
        //       on the scheduling view
        me.getSchedulingView().fireEvent('dependencydrop', me.getSchedulingView(), fromTask, toTask, type);
    },
    onAfterDependencyDragDrop: function() {
        var me = this;
        // TODO: we do way too much relaying, it should be simplified, firing from dependency view should be enough.
        me.fireEvent('afterdependencydragdrop', me);
        me.getDependencyView().fireEvent('afterdnd', me.getDependencyView());
        // TODO: remove firing from scheduling view after 4.4 when dependency related events are finally unsupported
        //       on the scheduling view
        me.getSchedulingView().fireEvent('afterdependencydragdrop', me.getSchedulingView());
        // Enable tooltip after drag again
        if (me.tip) {
            me.tip.enable();
        }
        me.preventOverCls = false;
    }
});
/**
     * @event beforedependencydrag
     *
     * Fires before a dependency drag operation starts (from a "task terminal"). Return false to prevent this operation
     * from starting.
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The source task record
     */
/**
     * @event dependencydragstart
     *
     * Fires when a dependency drag operation starts
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     */
/**
     * @event dependencydrop
     *
     * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} fromRecord The source task record
     * @param {Gnt.model.Task} toRecord The destination task record
     * @param {Number} type The dependency type
     */
/**
     * @event afterdependencydragdrop
     *
     * Always fires after a dependency drag-drop operation
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.Zones
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_zones') for showing "global" zones in the scheduler grid, these can by styled easily using just CSS.
To populate this plugin you need to pass it a store having `Sch.model.Range` as the model.

{@img scheduler/images/scheduler-grid-horizontal.png}

To add this plugin to scheduler:

    var zonesStore = Ext.create('Ext.data.Store', {
        model   : 'Sch.model.Range',
        data    : [
            {
                StartDate   : new Date(2011, 0, 6),
                EndDate     : new Date(2011, 0, 7),
                Cls         : 'myZoneStyle'
            }
        ]
    });

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Zones', { store : zonesStore })
        ]
    });


*/
Ext.define("Sch.plugin.Zones", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_zones",
    requires: [
        'Sch.model.Range'
    ],
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    cls: 'sch-zone',
    side: null,
    init: function(scheduler) {
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        this.side = scheduler.rtl ? 'right' : 'left';
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">' + '<div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '</div>' + '</tpl>', {
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        if (typeof this.innerHeaderTpl === 'string') {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        this.callParent(arguments);
    },
    getElementData: function(viewStart, viewEnd, records, isPrint) {
        var schedulerView = this.schedulerView,
            data = [];
        var region = schedulerView.getTimeSpanRegion(viewStart, viewEnd, this.expandToFitView);
        var record, spanStart, spanEnd, zoneData, width, templateData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            spanStart = record.getStartDate();
            spanEnd = record.getEndDate();
            templateData = this.getTemplateData(record);
            if (spanStart && spanEnd && Sch.util.Date.intersectSpans(spanStart, spanEnd, viewStart, viewEnd)) {
                zoneData = Ext.apply({}, templateData);
                zoneData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                zoneData.$cls = this.getElementCls(record, templateData);
                var mode = schedulerView.getMode();
                if (mode === 'calendar') {
                    var timeSpanRegion = schedulerView.getTimeSpanRegion(spanStart, spanEnd);
                    zoneData.left = timeSpanRegion.left;
                    zoneData.top = timeSpanRegion.top;
                    zoneData.height = timeSpanRegion.bottom - timeSpanRegion.top;
                    zoneData.width = timeSpanRegion.right - timeSpanRegion.left;
                } else {
                    var startPos = schedulerView.getCoordinateFromDate(Sch.util.Date.max(spanStart, viewStart));
                    var endPos = schedulerView.getCoordinateFromDate(Sch.util.Date.min(spanEnd, viewEnd));
                    if (mode === 'horizontal') {
                        zoneData.left = startPos;
                        zoneData.top = region.top;
                        zoneData.width = isPrint ? 0 : endPos - startPos;
                        zoneData.style = isPrint ? ('border-left-width:' + (endPos - startPos) + 'px') : "";
                    } else {
                        zoneData.left = region.left;
                        zoneData.top = startPos;
                        zoneData.height = isPrint ? 0 : endPos - startPos;
                        zoneData.style = isPrint ? ('border-top-width:' + (endPos - startPos) + 'px') : "";
                    }
                }
                data.push(zoneData);
            }
        }
        return data;
    },
    getHeaderElementId: function(record, isStart) {
        return this.callParent([
            record
        ]) + (isStart ? '-start' : '-end');
    },
    /**
     * Return header element class for data record.
     * 
     * @param {Sch.model.Range} record Data record
     * @param {Object} data
     * @param {Boolean} isStart
     * 
     * @return {String}
     */
    getHeaderElementCls: function(record, data, isStart) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return 'sch-header-indicator sch-header-indicator-' + (isStart ? 'start ' : 'end ') + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    getZoneHeaderElementData: function(startDate, endDate, record, isStart) {
        var date = isStart ? record.getStartDate() : record.getEndDate(),
            data = null,
            position, isHorizontal, templateData;
        if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
            position = this.getHeaderElementPosition(date);
            isHorizontal = this.schedulerView.isHorizontal();
            templateData = this.getTemplateData(record);
            data = Ext.apply({
                id: this.getHeaderElementId(record, isStart),
                cls: this.getHeaderElementCls(record, templateData, isStart),
                isStart: isStart,
                side: isHorizontal ? this.side : 'top',
                position: position
            }, templateData);
        }
        return data;
    },
    getHeaderElementData: function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            data = [],
            record, startData, endData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true);
            if (startData) {
                data.push(startData);
            }
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
            if (endData) {
                data.push(endData);
            }
        }
        return data;
    },
    updateZoneHeaderElement: function(el, data) {
        // Reapply CSS classes
        el.dom.className = data.cls;
        if (this.schedulerView.isHorizontal()) {
            this.setElementX(el, data.position);
        } else {
            el.setTop(data.position);
        }
    },
    updateHeaderElement: function(record) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            startEl = Ext.get(this.getHeaderElementId(record, true)),
            endEl = Ext.get(this.getHeaderElementId(record, false)),
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true),
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
        if (!(startEl && endData) || !(endEl && endData)) {
            Ext.destroy(startEl, endEl);
            this.renderHeaderElements([
                record
            ]);
        } else {
            if (startEl) {
                if (!startData) {
                    Ext.destroy(startEl);
                } else {
                    this.updateZoneHeaderElement(startEl, startData);
                }
            }
            if (endEl) {
                if (!endData) {
                    Ext.destroy(endEl);
                } else {
                    this.updateZoneHeaderElement(endEl, endData);
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.NonWorkingTime
@extends Sch.plugin.Zones

A simple subclass of the {@link Sch.plugin.Zones} which highlights holidays/weekends on the timeline.
Generally, there's no need to instantiate it manually, it can be activated with the {@link Sch.mixin.TimelinePanel#highlightWeekends} configuration option.

{@img gantt/images/plugin-working-time.png}

Note, that the holidays/weekends will only be shown when the resolution of the time axis is weeks or less.

*/
Ext.define("Sch.plugin.NonWorkingTime", {
    extend: 'Sch.plugin.Zones',
    alias: 'plugin.scheduler_nonworkingtime',
    alternateClassName: 'Gnt.feature.WorkingTime',
    requires: [
        'Ext.data.Store',
        'Sch.model.Range'
    ],
    expandToFitView: true,
    /**
     * @cfg {Sch.data.Calendar} calendar The calendar to extract the holidays from
     */
    calendar: {
        type: 'calendar'
    },
    timeAxis: null,
    init: function(timelinePanel) {
        this.calendar = this.calendar && Ext.StoreMgr.lookup(this.calendar);
        if (!this.calendar) {
            Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Sch.plugin.NonWorkingTime'");
        }
        this.store = new Ext.data.Store({
            model: 'Sch.model.Range',
            autoDestroy: true
        });
        this.timeAxis = timelinePanel.getTimeAxis();
        this.callParent(arguments);
        timelinePanel.on('viewchange', this.onViewChange, this);
        this.bindCalendar(this.calendar);
    },
    bindCalendar: function(calendar) {
        var listeners = {
                datachanged: this.refresh,
                update: this.refresh,
                scope: this,
                delay: 1
            };
        if (this.calendar) {
            this.calendar.un(listeners);
        }
        if (calendar) {
            calendar.on(listeners);
        }
        this.calendar = calendar;
        this.refresh();
    },
    onViewChange: function() {
        var DATE = Sch.util.Date;
        var disabled = DATE.isUnitGreater(this.timeAxis.unit, DATE.WEEK);
        this.setDisabled(disabled);
        if (!disabled) {
            this.refresh();
        }
    },
    setDisabled: function(disabled) {
        var wasDisabled = this.disabled;
        this.callParent(arguments);
        if (wasDisabled && !disabled) {
            this.refresh();
        }
    },
    refresh: function() {
        if (this.store && !this.store.destroyed) {
            this.store.removeAll(true);
            if (this.calendar) {
                this.store.add(this.calendar.getHolidaysRanges(this.timeAxis.getStart(), this.timeAxis.getEnd(), true));
            }
        }
    },
    destroy: function() {
        this.bindCalendar(null);
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// http://www.sencha.com/forum/showthread.php?295802-5.1-Knightly-Picker-collapses-on-ENTER-key&p=1080010#post1080010
Ext.define('Gnt.patches.CellEditor', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellEditor',
    minVersion: '6.0.0',
    maxVersion: '6.0.2',
    overrides: {
        destroy: function() {
            clearTimeout(this.restoreTimer);
            this.callParent(arguments);
        },
        // 1017_duration_editor_place in IE9, Ext6.0.0
        // Sencha fixed this in 6.0.1
        onViewRefresh: function(view) {
            var me = this,
                dom = me.el && me.el.dom,
                cell,
                context = me.context;
            if (dom) {
                // Update the context with the possibly new contextual data
                // (refresh might have been caused by a sort or column move etc)
                cell = view.getCellByPosition(context, true);
                // If the refresh was caused by eg column removal, the cell will not exist.
                // In this case, terminate the edit.
                if (!cell) {
                    me.allowBlur = me.wasAllowBlur;
                    me.completeEdit();
                    Ext.getDetachedBody().dom.appendChild(dom);
                    return;
                }
                context.node = view.getNode(context.record);
                context.row = view.getRow(context.record);
                context.cell = cell;
                context.rowIdx = view.indexOf(context.row);
                cell.insertBefore(dom, cell.firstChild);
                me.boundEl = me.container = Ext.get(cell);
                me.realign(true);
                // If the view was refreshed while we were editing, replace it.
                // On IE, the blur event will fire asynchronously, so we must leave
                // allowBlur as false for a very short while longer.
                // After which we reset it, and refocus the field.
                if (me.editing) {
                    if (Ext.isIE) {
                        me.restoreTimer = Ext.defer(function() {
                            // May have been destroyed immediately after refreshing!?
                            if (!me.destroyed) {
                                me.allowBlur = me.wasAllowBlur;
                                // PATCH: only enable defered focus if current editor is active one,
                                // otherwise it'll lead to stopped editing.
                                // Covered by 1002_tabbing_4
                                me.editingPlugin.getActiveEditor() === me && me.field.focus();
                            }
                        }, 10);
                    } else {
                        me.allowBlur = me.wasAllowBlur;
                        me.field.focus();
                    }
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?301772-Wrong-value-selected-in-combobox-editor
// IMPORTANT: this bug still exists in Ext6, but this fix doesn't work and tests seem to be green.
// Do not remove unless you're 100% sure
Ext.define('Gnt.patches.CellEditing', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.CellEditing',
    minVersion: '5.1.1',
    maxVersion: '6.0.1.250',
    overrides: {
        showEditor: function(ed, context, value) {
            // clean lastSelectedRecords cache for combobox if record was changed
            if (ed.context && ed.context.record !== context.record && ed.field instanceof Ext.form.field.ComboBox) {
                ed.field.lastSelectedRecords = null;
            }
            this.callParent(arguments);
        },
        cancelEdit: function(activeEd) {
            var me = this,
                context = me.context;
            // This is in response to the CellEditor firing a canceledit event.
            if (activeEd && activeEd.isCellEditor) {
                me.context.value = activeEd.context.value = ('editedValue' in activeEd) ? activeEd.editedValue : activeEd.getValue();
                // Editing flag cleared in superclass.
                // canceledit event fired in superclass.
                // PATCH
                // canceledit is fired with wrong context
                // https://fiddle.sencha.com/#fiddle/19jr
                // 1002_tabbing_4
                var currentContext = me.context;
                me.context = activeEd.context;
                me.callParent(arguments);
                me.context = currentContext;
                // PATCH END
                // Clear our current editing context.
                // We only do this if we have not already started editing a new context.
                if (activeEd.context === context) {
                    me.setActiveEditor(null);
                    me.setActiveColumn(null);
                    me.setActiveRecord(null);
                } else // Re-instate editing flag after callParent
                {
                    me.editing = true;
                }
            } else // This is a programmatic call to cancel any active edit
            {
                activeEd = me.getActiveEditor();
                if (activeEd && activeEd.field) {
                    activeEd.cancelEdit();
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?305782-TreeViewDragDrop-cannot-be-disabled
Ext.define('Gnt.patches.TreeViewDragDrop', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tree.plugin.TreeViewDragDrop',
    minVersion: '6.0.0',
    overrides: {
        disable: function() {
            this.callParent(arguments);
            this.dragZone && this.dragZone.lock();
            this.dropZone && this.dropZone.lock();
        },
        enable: function() {
            this.callParent(arguments);
            this.dragZone && this.dragZone.unlock();
            this.dropZone && this.dropZone.unlock();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?305782-TreeViewDragDrop-cannot-be-disabled
Ext.define('Gnt.patches.SpreadsheetModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                privates: {
                    // prevent selecting cells in normal view
                    onMouseMove: function(e, target) {
                        // if mouse is moving over scheduling view - do nothing
                        if (!Ext.fly(target).up('.sch-ganttview')) {
                            this.callParent(arguments);
                        }
                    },
                    // do not start drag selection on click in dragdrop column
                    handleMouseDown: function(view, cellNode, cellIndex, record) {
                        // prevent selection start on click in normal view
                        if (!(view instanceof Gnt.view.Gantt)) {
                            var isRowReorderCell = cellNode.className.indexOf('sch-gantt-column-dragdrop') >= 0;
                            if (isRowReorderCell) {
                                // dragdrop plugin need a selection to work on, also
                                this.selectRows([
                                    record
                                ], this.isSelected(record));
                            } else {
                                this.callParent(arguments);
                            }
                        }
                    }
                }
            };
        if (Ext.getVersion().isLessThan('6.0.2')) {
            overrides.select = function(records, keepExisting, suppressEvent) {
                // API docs are inherited
                var me = this,
                    sel = me.selected,
                    view = me.view,
                    store = view.dataSource,
                    len, i, record,
                    changed = false;
                // Ensure selection object is of the correct type
                if (!sel || !sel.isRows || sel.view !== view) {
                    me.resetSelection(true);
                    sel = me.selected = new Ext.grid.selection.Rows(view);
                } else if (!keepExisting) {
                    sel.clear();
                }
                if (!Ext.isArray(records)) {
                    records = [
                        records
                    ];
                }
                len = records.length;
                for (i = 0; i < len; i++) {
                    record = records[i];
                    if (typeof record === 'number') {
                        record = store.getAt(record);
                    }
                    if (!sel.contains(record)) {
                        sel.add(record);
                        changed = true;
                    }
                }
                if (changed) {
                    me.updateHeaderState();
                    // here was a bug in ext prior to 6.0.2
                    if (!suppressEvent) {
                        me.fireSelectionChange();
                    }
                }
            };
        }
        Ext.override(Ext.grid.selection.SpreadsheetModel, overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?308916-Crash-when-hiding-columns-spreadsheet-model&p=1128276#post1128276
Ext.define('Gnt.patches.LockingView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.locking.View',
    minVersion: '6.0.0',
    overrides: {
        getCellByPosition: function(pos, returnDom) {
            if (pos && !pos.column)  {
                return null;
            }
            
            return this.callParent(arguments);
        },
        onCellDeselect: function(cellContext) {
            if (cellContext && !cellContext.column)  {
                return;
            }
            
            return this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.view.Horizontal
 * @private
 *
 * An internal view mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView}.
 * This class is consumed by the scheduling view and provides the horizontal implementation of certain methods.
 */
Ext.define("Sch.view.Horizontal", {
    requires: [
        'Ext.util.Region',
        'Ext.Element',
        'Ext.Array',
        'Sch.util.Date'
    ],
    // Provided by creator, in the config object
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    translateToScheduleCoordinate: function(x) {
        var view = this.view;
        var pos;
        if (view.shouldAdjustForRtl()) {
            pos = view.getEl().getRight() - x;
        } else {
            pos = x - view.getEl().getX();
        }
        return pos + view.getScroll().left;
    },
    translateToPageCoordinate: function(x) {
        var view = this.view;
        return x + view.getEl().getX() - view.getScroll().left;
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy[0];
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event) {
        var eventStart = event.getStartDate(),
            eventEnd = event.getEndDate() || eventStart,
            // Allow events to be rendered even they are missing an end date
            view = this.view,
            viewStart = view.timeAxis.getStart(),
            viewEnd = view.timeAxis.getEnd(),
            M = Math,
            startX = view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)),
            endX = view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd)),
            data = {
                event: event
            };
        if (this.view.rtl) {
            data.right = M.min(startX, endX);
        } else {
            data.left = M.min(startX, endX);
        }
        data.width = M.max(1, M.abs(endX - startX)) - view.eventBorderWidth;
        if (view.managedEventSizing) {
            data.top = M.max(0, (view.barMargin - ((Ext.isIE && !Ext.isStrict) ? 0 : view.eventBorderWidth - view.cellTopBorderWidth)));
            data.height = view.timeAxisViewModel.rowHeightHorizontal - (2 * view.barMargin) - view.eventBorderWidth;
        }
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    /**
    * Gets the Ext.util.Region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to
    * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region = resourceRecord ? Ext.fly(view.getRowNode(resourceRecord)).getRegion() : view.getTableRegion(),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {
                start: taStart,
                end: taEnd
            },
            startX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),
            top = region.top + view.barMargin,
            bottom = region.bottom - view.barMargin - view.eventBorderWidth;
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },
    /**
    * Gets the Ext.util.Region, relative to the scheduling view element, representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            rowNode = view.getRowNode(resourceRecord),
            offsets = Ext.fly(rowNode).getOffsetsTo(view.getEl()),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startX = view.getCoordinateFromDate(start),
            endX = view.getCoordinateFromDate(end),
            top = offsets[1] + view.cellTopBorderWidth,
            bottom = offsets[1] + Ext.fly(rowNode).getHeight() - view.cellBottomBorderWidth;
        if (!Ext.versions.touch) {
            var ctElScroll = view.getScroll();
            top += ctElScroll.top;
            bottom += ctElScroll.top;
        }
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, function(event) {
                return view.timeAxis.isRangeInAxis(event);
            });
        if (resourceEvents.length === 0) {
            return;
        }
        // Iterate events belonging to current row
        var eventsTplData = Ext.Array.map(resourceEvents, function(event) {
                return view.generateTplData(event, resourceRecord, rowIndex);
            });
        // Event data is now gathered, calculate layout properties for each event (if dynamicRowHeight is used)
        if (view.dynamicRowHeight) {
            var layout = view.eventLayout.horizontal;
            var nbrOfBandsRequired = layout.applyLayout(eventsTplData, resourceRecord, this.layoutEventVertically, this);
            meta.rowHeight = (nbrOfBandsRequired * view.timeAxisViewModel.rowHeightHorizontal) - ((nbrOfBandsRequired - 1) * view.barMargin);
        }
        return view.eventTpl.apply(eventsTplData);
    },
    layoutEventVertically: function(bandIndex, eventRecord) {
        var view = this.view;
        var eventTop = bandIndex === 0 ? view.barMargin : (bandIndex * view.timeAxisViewModel.rowHeightHorizontal - (bandIndex - 1) * view.barMargin);
        if (eventTop >= view.cellBottomBorderWidth) {
            eventTop -= view.cellBottomBorderWidth;
        }
        return eventTop;
    },
    // private
    resolveResource: function(node) {
        var me = this,
            view = me.view,
            eventNode, result;
        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        } else {
            // Not that fast case
            // I'm not sure if it's really needed, the method documentation doesn't state that node must be
            // within event node. If node might be outside of event node then yes, this branch is needed, otherwise
            // it is not.
            node = view.findRowByChild(node);
            result = node && view.getRecordForRowNode(node) || null;
        }
        return result;
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate, useViewSize) {
        var view = this.view,
            startX = view.getCoordinateFromDate(startDate),
            endX = endDate ? view.getCoordinateFromDate(endDate) : startX,
            height, region;
        region = view.getTableRegion();
        if (useViewSize) {
            height = Math.max(region ? region.bottom - region.top : 0, view.getEl().dom.clientHeight);
        } else // fallback in case grid is not rendered (no rows/table)
        {
            height = region ? region.bottom - region.top : 0;
        }
        return new Ext.util.Region(0, Math.max(startX, endX), height, Math.min(startX, endX));
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var view = this.view;
        var leftDate = view.getDateFromCoordinate(region.left, roundingMethod),
            rightDate = view.getDateFromCoordinate(region.right, roundingMethod);
        if (leftDate && rightDate) {
            return {
                start: Sch.util.Date.min(leftDate, rightDate),
                end: Sch.util.Date.max(leftDate, rightDate)
            };
        }
        return null;
    },
    // private
    onEventAdd: function(s, events) {
        var view = this.view,
            affectedResources = {},
            event, startDate, endDate, resources, resource, i, l, j, k;
        for (i = 0 , l = events.length; i < l; i++) {
            event = events[i];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                // repaint row only if event is in time axis
                resources = events[i].getResources(view.getEventStore());
                for (j = 0 , k = resources.length; j < k; j++) {
                    resource = resources[j];
                    affectedResources[resource.getId()] = resource;
                }
            }
        }
        Ext.Object.each(affectedResources, function(id, resource) {
            view.repaintEventsForResource(resource);
        });
    },
    // private
    onEventRemove: function(s, eventRecords) {
        var me = this,
            view = me.view,
            eventStore = view.getEventStore(),
            resources, nodes;
        resources = Ext.Array.unique(Ext.Array.reduce(eventRecords, function(result, r) {
            // It's important to use event store's method here, instead just
            // r.getResources(). r.getResources() will always return empty array here
            // since r is already removed from the event store.
            return result.concat(eventStore.getResourcesForEvent(r));
        }, []));
        nodes = Ext.Array.reduce(eventRecords, function(result, r) {
            return result.concat(view.getElementsFromEventRecord(r, null, null, true));
        }, []);
        nodes = new Ext.CompositeElementLite(nodes);
        nodes.fadeOut({
            callback: function(resource) {
                Ext.Array.forEach(resources, function(resource) {
                    if (view && !view.isDestroyed) {
                        view.store.indexOf(resource) >= 0 && view.repaintEventsForResource(resource);
                    }
                });
            }
        });
    },
    // private
    onEventUpdate: function(eventStore, model) {
        var previous = model.previous || {};
        var view = this.view;
        var timeAxis = view.timeAxis;
        var newStartDate = model.getStartDate();
        var newEndDate = model.getEndDate();
        var startDate = previous.StartDate || newStartDate;
        var endDate = previous.EndDate || newEndDate;
        // event was visible or visible now
        var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
        var resource;
        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (model.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new row, refresh old row first
            resource = eventStore.getResourceStore().getById(previous[model.resourceIdField]);
            resource && view.repaintEventsForResource(resource, true);
        }
        // also resource has to be repainted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            Ext.Array.each(model.getResources(), function(resource) {
                view.repaintEventsForResource(resource, true);
            });
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.getEl()) {
            return null;
        }
        var tableRegion = view.getTableRegion(),
            startDate = view.timeAxis.getStart(),
            endDate = view.timeAxis.getEnd(),
            width = view.getWidth();
        if ((tableRegion.right - tableRegion.left) < width) {
            return {
                startDate: startDate,
                endDate: endDate
            };
        }
        var scroll = view.getScroll();
        var result = {
                startDate: view.getDateFromCoordinate(scroll.left, null, true),
                endDate: view.getDateFromCoordinate(scroll.left + width, null, true) || view.timeAxis.getEnd()
            };
        // because of the vertical scrollbar endDate can be resolved to null in the right-most position
        if (!result.endDate) {
            result.endDate = view.timeAxis.getEnd();
        }
        return result;
    },
    /**
     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)
     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible
     * top row or below currently visible bottom row) will be calculated approximately.
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/null}
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @protected
     */
    getItemBox: function(eventRecord) {
        var me = this;
        return Ext.Array.map(eventRecord.getResources(), function(resourceRecord) {
            return me.getResourceEventBox(eventRecord, resourceRecord);
        });
    },
    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)
    isRowVisible: function(resourceRecord) {
        var hidden = Ext.isFunction(resourceRecord.isVisible) && !resourceRecord.isVisible();
        if (!hidden && this.view.groupingFeature && !this.view.groupingFeature.disabled) {
            var groups = this.view.resourceStore.getGroups();
            if (groups) {
                var group = groups.getByKey(resourceRecord.get(this.view.resourceStore.groupField));
                hidden = group && !this.view.groupingFeature.isExpanded(group);
            }
        }
        return !hidden;
    },
    getResourceEventBox: function(eventRecord, resourceRecord) {
        var SUD = Sch.util.Date,
            me = this,
            result = null,
            view = me.view,
            viewStartDate = view.timeAxis.getStart(),
            // WARNING: timeaxis is a private property of Sch.mixin.AbstractTimelineView
            viewEndDate = view.timeAxis.getEnd(),
            // WARNING: timeaxis is a private property of Sch.mixin.AbstractTimelineView
            eventStartDate = eventRecord.getStartDate(),
            eventEndDate = eventRecord.getEndDate(),
            eventLayout, rowEventsLayoutData, eventRecordData, rowEl, rowIndex, rowTop, rowHeight, rowNbrOfBands, eventEls, eventEl, eventElOffsets, eventElBox, firstRowIndex, lastRowIndex, firstRowRecord;
        // Checking if event record is within current time axis timespan and is visible, i.e. it's not rendered
        // within a collapsed row (scheduler supports resource tree store as well as flat resource store).
        if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate) && this.isRowVisible(resourceRecord)) {
            rowEl = view.getRowNode(resourceRecord);
            // If resource row is rendered
            if (rowEl) {
                // Managed event sizing means that the view is responsible for event height setting, the oposite case
                // is when event height is controlled by CSS's top and height properties.
                // Fast case: managed event sizing on, querying the view for box position and dimensions
                if (view.managedEventSizing) {
                    eventLayout = view.eventLayout.horizontal;
                    var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
                    // Preparing events layout data for event layout instance to process
                    rowEventsLayoutData = Ext.Array.map(resourceEvents, me.getEventRenderData, me);
                    // Processing event layout data injecting event vertical position into each item of `rowEventsLayoutData`
                    // This layout application takes into account view's `dynamicRowHeight` property
                    eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);
                    // Now we are to find our particular event data inside all events data for the given row record
                    eventRecordData = Ext.Array.findBy(rowEventsLayoutData, function(eventData) {
                        return eventData.event == eventRecord;
                    });
                    // We must find our event record corresponding layout data object here, but just to make sure
                    if (eventRecordData) {
                        // We have event record data with coordinates within the row node, but we need
                        // those coordinates to be translated relative to view's viewport top.
                        rowTop = Ext.fly(rowEl).getOffsetsTo(view.getNodeContainer())[1];
                        // Finally we have all the data needed to calculated the event record box
                        result = {
                            rendered: true,
                            start: (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right),
                            // it depends on view's `rtl` configuration
                            end: (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right) + eventRecordData.width,
                            top: rowTop + eventRecordData.top,
                            bottom: rowTop + eventRecordData.top + eventRecordData.height
                        };
                    }
                } else // Slow case: managed event sizing off, querying the DOM for box position and dimensions
                {
                    eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
                    // We must have at one and only one element here, but just to make sure
                    if (eventEls.length) {
                        eventEl = eventEls[0];
                        eventElOffsets = eventEl.getOffsetsTo(view.getEl());
                        eventElBox = eventEl.getBox();
                        result = {
                            rendered: true,
                            start: eventElOffsets[0],
                            end: eventElOffsets[0] + eventElBox.width,
                            top: eventElOffsets[1],
                            bottom: eventElOffsets[1] + eventElBox.height
                        };
                    }
                }
            } else // Resource row is not rendered, and it's not collapsed. We are to calculate event record box approximately.
            {
                result = {
                    rendered: false,
                    start: view.getCoordinateFromDate(SUD.max(eventStartDate, viewStartDate)),
                    end: view.getCoordinateFromDate(SUD.min(eventEndDate, viewEndDate))
                };
                // top and bottom to go
                // WARNING: view.all is a private property
                firstRowIndex = view.all.startIndex;
                firstRowRecord = view.getRecord(view.getNode(firstRowIndex));
                rowHeight = view.getRowHeight();
                if (resourceRecord.isAbove(firstRowRecord)) {
                    result.top = -2 * rowHeight;
                    result.relPos = 'before';
                } else {
                    // WARNING: view.all is a private property
                    lastRowIndex = view.all.endIndex;
                    // Rows can be stretched, use last row's real coordinates
                    rowEl = Ext.get(view.getNode(lastRowIndex));
                    result.top = rowEl.getOffsetsTo(view.getNodeContainer())[1] + rowEl.getHeight();
                    result.relPos = 'after';
                }
                result.bottom = result.top + rowHeight;
            }
            // Some boxes might need special adjustments
            if (result) {
                result = me.adjustItemBox(eventRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Sch.model.Event} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(eventRecord, eventRecordBox) {
        return eventRecordBox;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'left';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'right';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.mixin.AbstractTimelineView
@private

A base mixin for giving to the consuming view "time line" functionality.
This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.Horizontal'
    ],
    uses: [
        'Ext.dom.Query'
    ],
    /**
    * @cfg {String} selectedEventCls
    * A CSS class to apply to an event in the view on mouseover (defaults to 'sch-event-selected').
    */
    selectedEventCls: 'sch-event-selected',
    // private
    readOnly: false,
    horizontalViewClass: 'Sch.view.Horizontal',
    //    can not "declare" it here, because will conflict with the default value from  SchedulerView
    //    verticalViewClass   : null,
    timeCellCls: 'sch-timetd',
    timeCellSelector: '.sch-timetd',
    eventBorderWidth: 1,
    timeAxis: null,
    timeAxisViewModel: null,
    eventPrefix: null,
    rowHeight: null,
    //    can not "declare" it here, because will conflict with the default value from  SchedulerView
    //    barMargin           : null,
    // deprecated
    orientation: 'horizontal',
    mode: 'horizontal',
    horizontal: null,
    vertical: null,
    panel: null,
    displayDateFormat: null,
    // Accessor to the Ext.Element for this view
    el: null,
    constructor: function(config) {
        if (config && config.orientation) {
            config.mode = this.mode = config.orientation;
        }
        this.callParent([
            config
        ]);
    },
    _initializeTimelineView: function() {
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, {
                view: this
            });
        }
        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, {
                view: this
            });
        }
        if (this.calendarViewClass) {
            this.calendar = Ext.create(this.calendarViewClass, {
                view: this
            });
        }
        this.eventPrefix = (this.eventPrefix || this.getId()) + '-';
    },
    getTimeAxisViewModel: function() {
        return this.timeAxisViewModel;
    },
    /**
    * Method to get a formatted display date
    * @private
    * @param {Date} date The date
    * @return {String} The formatted date
    */
    getFormattedDate: function(date) {
        return Ext.Date.format(date, this.getDisplayDateFormat());
    },
    /**
    * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
    * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,
    * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).
    * @private
    * @param {Date} endDate The date to format
    * @param {Date} startDate The start date
    * @return {String} The formatted date
    */
    getFormattedEndDate: function(endDate, startDate) {
        var format = this.getDisplayDateFormat();
        if (// If time is midnight,
        endDate.getHours() === 0 && endDate.getMinutes() === 0 && // and end date is greater then start date
        (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) && // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
        !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))) {
            // format the date inclusively as 'the whole previous day'.
            endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
        }
        return Ext.Date.format(endDate, format);
    },
    // private
    getDisplayDateFormat: function() {
        return this.displayDateFormat;
    },
    // private
    setDisplayDateFormat: function(format) {
        this.displayDateFormat = format;
    },
    /**
    * This function fits the schedule area columns into the available space in the grid.
    * @param {Boolean} preventRefresh `true` to prevent a refresh of view
    */
    fitColumns: function(preventRefresh) {
        // TODO test
        if (this.mode === 'horizontal') {
            this.getTimeAxisViewModel().fitToAvailableWidth(preventRefresh);
        } else {
            var w = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(w, preventRefresh);
        }
    },
    /**
     * Returns the Ext.Element representing an event record.
     *
     * @param {Sch.model.Event} eventRecord An event record
     * @param {Sch.model.Resource} [resourceRecord] A resource record
     *
     * @return {Ext.Element|null} The Ext.Element representing the event record
     * @deprecated Please use {@link #getElementsFromEventRecord}.
     */
    getElementFromEventRecord: function(eventRecord, resourceRecord) {
        var me = this,
            result;
        result = me.getElementsFromEventRecord(eventRecord, resourceRecord);
        if (result.length === 0) {
            result = null;
        } else if (result.length == 1) {
            result = result[0];
        }
        // We return Ext.Element as given in the method documentation
        // TODO: Get rid of this else if branch, backward compatible behaviour
        else if (me.mode == 'calendar') {
            result = result[0];
        } else {
            Ext.Error.raise("The method getElementFromEventRecord() is deprecated, it can't handle the situation when several DOM elements correspond to a single event record, please use getElementsFromEventRecord() method instead!");
        }
        return result;
    },
    /**
     * Returns all the Ext.Element(s) representing an event record.
     *
     * @param {Sch.model.Event} eventRecord An event record
     * @param {Sch.model.Resource} [resourceRecord] A resource record
     *
     * @privateparam {Number} [index] Index used to distinguish DOM nodes corresponding to same event/resource but rendered on different columns inside calendar view.
     * @privateparam {Boolean [raw=false] Whether to return HTMLElements instead of Ext.Element
     *
     * @return {[Ext.Element|HTMLElement]} The Ext.Element(s) representing the event record
     */
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        var me = this,
            query;
        raw = raw || false;
        if (resourceRecord && (index !== null && index !== undefined)) {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-' + index + ']';
        } else if (resourceRecord) {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
        } else {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-]';
        }
        return me.getEl().query(query, raw);
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        return this[this.mode].getStartEndDatesFromRegion(region, roundingMethod);
    },
    /**
    * Returns the current time resolution object, which contains a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    getTimeResolution: function() {
        return this.timeAxis.getResolution();
    },
    /**
    * Sets the current time resolution, composed by a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    setTimeResolution: function(unit, increment) {
        this.timeAxis.setResolution(unit, increment);
        // View will have to be updated to support snap to increment
        if (this.getTimeAxisViewModel().snapToIncrement) {
            this.refreshKeepingScroll();
        }
    },
    /**
    * <p>Returns the event id for a DOM id </p>
    * @private
    * @param {String} id The id of the DOM node
    * @return {String} An event record (internal) id
    */
    getEventIdFromDomNodeId: function(id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[0];
    },
    /**
     * Returns a resource id for a DOM id
     * @private
     * @param {String} id An id of an event DOM node
     * @return {String} A resource record (internal) id
     */
    getResourceIdFromDomNodeId: function(id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[1];
    },
    /**
    *  Gets the time for a DOM event such as 'mousemove' or 'click'
    *  @param {Ext.event.Event} e, the EventObject instance
    *  @param {String} roundingMethod (optional), 'floor' to floor the value or 'round' to round the value to nearest increment
    *  @returns {Date} The date corresponding to the EventObject x coordinate
    */
    getDateFromDomEvent: function(e, roundingMethod) {
        return this.getDateFromXY(e.getXY(), roundingMethod);
    },
    /**
    * [Experimental] Returns the pixel increment for the current view resolution.
    * @return {Number} The width increment
    */
    getSnapPixelAmount: function() {
        return this.getTimeAxisViewModel().getSnapPixelAmount();
    },
    /**
    * Controls whether the scheduler should snap to the resolution when interacting with it.
    * @param {Boolean} enabled true to enable snapping when interacting with events.
    */
    setSnapEnabled: function(enabled) {
        this.getTimeAxisViewModel().setSnapToIncrement(enabled);
    },
    /**
    * Sets the readonly state which limits the interactivity (resizing, drag and drop etc).
    * @param {Boolean} readOnly The new readOnly state
    */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this[readOnly ? 'addCls' : 'removeCls'](this._cmpCls + '-readonly');
    },
    /**
    * Returns true if the view is currently readOnly.
    * @return {Boolean} readOnly
    */
    isReadOnly: function() {
        return this.readOnly;
    },
    /**
    * Sets the current orientation.
    * @param {String} orientation Either 'horizontal' or 'vertical'
    * @deprecated
    */
    setOrientation: function() {
        this.setMode.apply(this, arguments);
    },
    /**
    * Sets the current mode.
    * @param {String} mode Either 'horizontal', 'vertical' or 'calendar'
    */
    setMode: function(mode) {
        this.mode = mode;
        this.timeAxisViewModel.mode = mode;
    },
    /**
    * Returns the current view orientation
    * @return {String} The view orientation ('horizontal' or 'vertical')
    * @deprecated
    */
    getOrientation: function() {
        return this.getMode.apply(this, arguments);
    },
    /**
    * Returns the current view mode
    * @return {String} The view mode ('horizontal', 'vertical' or 'calendar')
    */
    getMode: function() {
        return this.mode;
    },
    isHorizontal: function() {
        return this.getMode() === 'horizontal';
    },
    isVertical: function() {
        return this.getMode() === 'vertical';
    },
    isCalendar: function() {
        return this.getMode() === 'calendar';
    },
    /**
    * Gets the date for an XY coordinate
    * @param {Array} xy The page X and Y coordinates
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromXY: function(xy, roundingMethod, local) {
        return this[this.mode].getDateFromXY(xy, roundingMethod, local);
    },
    /**
    * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
    * @param {Number} coordinate The X or Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromCoordinate: function(coord, roundingMethod, local) {
        if (!local) {
            coord = this[this.mode].translateToScheduleCoordinate(coord);
        }
        return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    /**
    * Gets the date for the passed X coordinate.
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} x The X coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the x coordinate
    * @abstract
    */
    getDateFromX: function(x, roundingMethod) {
        return this.getDateFromCoordinate(x, roundingMethod);
    },
    /**
    * Gets the date for the passed Y coordinate
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} y The Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the y coordinate
    * @abstract
    */
    getDateFromY: function(y, roundingMethod) {
        return this.getDateFromCoordinate(y, roundingMethod);
    },
    /**
    *  Gets the x or y coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  If the coordinate is not in the currently rendered view, -1 will be returned.
    *  @param {Date} date the date to query for
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element (defaults to true)
    *  @returns {Number} the x or y position representing the date on the time axis
    */
    getCoordinateFromDate: function(date, local) {
        var pos = this.timeAxisViewModel.getPositionFromDate(date);
        if (local === false) {
            pos = this[this.mode].translateToPageCoordinate(pos);
        }
        return pos;
    },
    /**
    *  Gets the x coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  @param {Date} date the date to query for
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element (defaults to false)
    *  @returns {Array} the XY coordinates representing the date
    */
    getXFromDate: function(date, local) {
        return this.getCoordinateFromDate(date, local);
    },
    /**
    *  Gets xy coordinates relative to the scheduling view element, or page coordinates (based on the 'local' flag)
    *  @param {Date} xy the page X and Y coordinates
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element
    *  @returns {Array} the XY coordinates representing the date
    */
    getYFromDate: function(date, local) {
        return this.getCoordinateFromDate(date, local);
    },
    /**
    *  Returns the distance in pixels the for time span in the view.
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Number} The distance in pixels
    */
    getTimeSpanDistance: function(startDate, endDate) {
        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate) {
        return this[this.mode].getTimeSpanRegion(startDate, endDate);
    },
    /**
    * Gets the Ext.util.Region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for
    * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function(resourceRecord, eventRecord) {
        return this[this.mode].getScheduleRegion(resourceRecord, eventRecord);
    },
    // Returns the region of the table element containing the rows of the schedule
    getTableRegion: function() {
        throw 'Abstract method call';
    },
    // Returns the table element containing the rows of the schedule
    getRowNode: function(resourceRecord) {
        throw 'Abstract method call';
    },
    getRecordForRowNode: function(node) {
        throw 'Abstract method call';
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        return this[this.mode].getVisibleDateRange();
    },
    /**
     * Method to set the new columnWidth. The new width is passed in the case of a horizontal mode as tickWidth, resourceColumnWidth in the case of a vertical mode
     * and as calendarColumnWidth in the case of a calendar mode.
     * @param {Number} width The new width value
     * @param {Boolean} preventRefresh true to skip refreshing the view
     */
    setColumnWidth: function(width, preventRefresh) {
        this[this.mode].setColumnWidth(width, preventRefresh);
    },
    findRowByChild: function(t) {
        throw 'Abstract method call';
    },
    /**
    * Sets the amount of margin to keep between bars and rows.
    * @param {Number} margin The new margin value
    * @param {Boolean} preventRefresh true to skip refreshing the view
    */
    setBarMargin: function(margin, preventRefresh) {
        this.barMargin = margin;
        if (!preventRefresh) {
            this.refreshKeepingScroll();
        }
    },
    /**
     * Returns the current row height used by the view (only applicable in a horizontal view)
     * @return {Number} The row height
     */
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight();
    },
    /**
    * Sets the row height of the timeline
    * @param {Number} height The height to set
    * @param {Boolean} preventRefresh `true` to prevent view refresh
    */
    setRowHeight: function(height, preventRefresh) {
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },
    /**
    * Refreshes the view and maintains the scroll position.
    */
    refreshKeepingScroll: function() {
        throw 'Abstract method call';
    },
    /**
     * Scrolls the view vertically
     * @param {Number} y The Y coordinate to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollVerticallyTo: function(y, animate) {
        throw 'Abstract method call';
    },
    /**
     * Scrolls the view horizontally
     * @param {Number} x The X coordinate to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollHorizontallyTo: function(x, animate) {
        throw 'Abstract method call';
    },
    /**
     * Returns the current vertical scroll value
     */
    getVerticalScroll: function() {
        throw 'Abstract method call';
    },
    /**
     * Returns the current horizontal scroll value
     */
    getHorizontalScroll: function() {
        throw 'Abstract method call';
    },
    // This method should be implemented by the consuming class
    getEl: Ext.emptyFn,
    /**
     * Returns the current viewport scroll position as an object with left/top properties.
     */
    getScroll: function() {
        throw 'Abstract method call';
    },
    getOuterEl: function() {
        return this.getEl();
    },
    getRowContainerEl: function() {
        return this.getEl();
    },
    getScheduleCell: function(row, col) {
        return this.getCellByPosition({
            row: row,
            column: col
        });
    },
    getScrollEventSource: function() {
        return this.getEl();
    },
    getViewportHeight: function() {
        return this.getEl().getHeight();
    },
    getViewportWidth: function() {
        return this.getEl().getWidth();
    },
    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function() {
        var scroll = this.getScroll(),
            xy;
        if (this.getMode() === 'vertical') {
            xy = [
                0,
                scroll.top + this.getViewportHeight() / 2
            ];
        } else {
            xy = [
                scroll.left + this.getViewportWidth() / 2,
                0
            ];
        }
        return this.getDateFromXY(xy, null, true);
    },
    getDateConstraints: Ext.emptyFn,
    /**
     * Return a box representing the item associated with the event record. If there are several boxes displayed for the given
     * item, the method returns all of them
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     */
    getItemBox: function(eventRecord) {
        return this[this.mode].getItemBox(eventRecord);
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return this[this.mode].getConnectorStartSide(eventRecord);
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return this[this.mode].getConnectorEndSide(eventRecord);
    }
});
Ext.apply(Sch, {
    VERSION: '4.2.7'
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Sencha scrolls cell
Ext.define('Sch.patches.NavigationModel6_0_2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '6.0.2',
    overrides: {
        focusPosition: function(position) {
            var me = this,
                view, row, scroller;
            me.item = me.cell = null;
            if (position && position.record && position.column) {
                view = position.view;
                // If the position is passed from a grid event, the rowElement will be stamped into it.
                // Otherwise, select it from the indicated item.
                if (position.rowElement) {
                    row = me.item = position.rowElement;
                } else {
                    // Get the dataview item for the position's record
                    row = view.getRowByRecord(position.record);
                }
                // If there is no item at that index, it's probably because there's buffered rendering.
                // This is handled below.
                if (row) {
                    // If the position is passed from a grid event, the cellElement will be stamped into it.
                    // Otherwise, select it from the row.
                    me.cell = position.cellElement || Ext.fly(row).down(position.column.getCellSelector(), true);
                    // Maintain the cell as a Flyweight to avoid transient elements ending up in the cache as full Ext.Elements.
                    if (me.cell) {
                        me.cell = new Ext.dom.Fly(me.cell);
                        // Maintain lastFocused in the view so that on non-specific focus of the View, we can focus the view's correct descendant.
                        view.lastFocused = me.lastFocused = me.position.clone();
                        // Use explicit scrolling rather than relying on the browser's focus behaviour.
                        // Scroll on focus overscrolls. scrollIntoView scrolls exatly correctly.
                        scroller = view.getScrollable();
                        // PATCH Do not scroll into view cells from timeline view (gantt, scheduler, etc.)
                        if (scroller && !view.mixins['Sch.mixin.TimelineView']) {
                            // END PATCH
                            scroller.scrollIntoView(me.cell);
                        }
                        me.focusItem(me.cell);
                        view.focusEl = me.cell;
                    } else // Cell no longer in view. Clear current position.
                    {
                        me.position.setAll();
                        me.record = me.column = me.recordIndex = me.columnIndex = null;
                    }
                } else // View node no longer in view. Clear current position.
                // Attempt to scroll to the record if it is in the store, but out of rendered range.
                {
                    row = view.dataSource.indexOf(position.record);
                    me.position.setAll();
                    me.record = me.column = me.recordIndex = me.columnIndex = null;
                    // The reason why the row could not be selected from the DOM could be because it's
                    // out of rendered range, so scroll to the row, and then try focusing it.
                    if (row !== -1 && view.bufferedRenderer) {
                        me.lastKeyEvent = null;
                        view.bufferedRenderer.scrollTo(row, false, me.afterBufferedScrollTo, me);
                    }
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
//http://www.sencha.com/forum/showthread.php?296703-iOS-devices-Crash-in-TouchScroller&p=1083470#post1083470
Ext.define('Sch.patches.TouchScroll', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.TouchScroller',
    minVersion: '5.1.0',
    maxVersion: '6.2.0',
    overrides: {
        privates: {
            onEvent: function(e) {
                var me = this;
                if (!me[me.listenerMap[e.type]])  {
                    return;
                }
                
                return this.callParent(arguments);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
//http://www.sencha.com/forum/showthread.php?295892-Ext-JS-5.1-Post-GA-Patches&p=1080371&viewfull=1#post1080371
Ext.define('Sch.patches.View', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.View',
    minVersion: '5.1.0',
    overrides: {
        handleEvent: function(e) {
            var me = this,
                isKeyEvent = me.keyEventRe.test(e.type),
                nm = me.getNavigationModel();
            e.view = me;
            // 1002_tabbing
            if (isKeyEvent) {
                e.item = e.getTarget(me.itemSelector);
                e.record = nm.getRecord(e.item);
            }
            // If the key event was fired programatically, it will not have triggered the focus
            // so the NavigationModel will not have this information.
            if (!e.item) {
                // In Ext6 editor is moved from outside of grid to cell, so now getTarget
                // will resolve item for event, which will trigger view events. Major implications are
                // selection triggered, editor is collapsed when view dragdrop plugin is active.
                // Here we check if target element lies inside active editor, if so - no item should be
                // resolved for event
                // covered by 1017_duration_editor_place
                var editing = me.editingPlugin && me.editingPlugin.getActiveEditor && me.editingPlugin.getActiveEditor();
                if (!(editing && editing.getEl().contains(e.getTarget()))) {
                    e.item = e.getTarget(me.itemSelector);
                }
            }
            if (e.item && !e.record) {
                e.record = me.getRecord(e.item);
            }
            if (me.processUIEvent(e) !== false) {
                me.processSpecialEvent(e);
            }
            // We need to prevent default action on navigation keys
            // that can cause View element scroll unless the event is from an input field.
            // We MUST prevent browser's default action on SPACE which is to focus the event's target element.
            // Focusing causes the browser to attempt to scroll the element into view.
            if (isKeyEvent && !Ext.fly(e.target).isInputField()) {
                if (e.getKey() === e.SPACE || e.isNavKeyPress(true)) {
                    e.preventDefault();
                }
            }
            e.view = null;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Applied override provided by sencha
// https://www.sencha.com/forum/showthread.php?310677
Ext.define('Sch.patches.Scroller', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.Scroller',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    applyFn: function() {
        var overrides = {
                destroy: function() {
                    clearTimeout(this.restoringTimer);
                    this.callParent(arguments);
                },
                privates: {
                    restoreState: function() {
                        var me = this,
                            el = me.getScrollElement(),
                            dom;
                        if (el) {
                            dom = el.dom;
                            // Only restore state if has been previously captured! For example,
                            // floaters probably have not been hidden before initially shown.
                            if (me.trackingScrollTop !== undefined) {
                                // If we're restoring the scroll position, we don't want to publish
                                // scroll events since the scroll position should not have changed
                                // at all as far as the user is concerned, so just do it silently
                                // while ensuring we maintain the correct internal state. 50ms is
                                // enough to capture the async scroll events, anything after that
                                // we re-enable.
                                me.restoring = true;
                                me.restoringTimer = Ext.defer(function() {
                                    me.restoring = false;
                                }, 50);
                                dom.scrollTop = me.trackingScrollTop;
                                dom.scrollLeft = me.trackingScrollLeft;
                            }
                        }
                    }
                }
            };
        // https://www.sencha.com/forum/showthread.php?312703
        // Using method from 6.0.1
        if (Ext.isIE9m) {
            overrides.privates.updateSpacerXY = function(pos) {
                var spacer = this.getSpacer();
                if (this.getRtl && this.getRtl()) {
                    spacer.rtlSetLocalXY(pos.x, pos.y);
                } else {
                    spacer.setLocalXY(pos.x, pos.y);
                }
            };
        }
        Ext.ClassManager.get(this.target).override(overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Override provided by sencha
// https://www.sencha.com/forum/showthread.php?310675-Layout-run-failed-with-syncRowHeight-false
Ext.define('Sch.patches.Queue', {
    extend: 'Sch.util.Patch',
    target: 'Ext.util.Queue',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    overrides: {
        add: function(obj, replace) {
            var me = this,
                key = me.getKey(obj),
                prevEntry;
            if (!(prevEntry = me.map[key])) {
                ++me.length;
                me.items.push(obj);
                me.map[key] = obj;
            } else if (replace) {
                me.map[key] = obj;
                me.items[Ext.Array.indexOf(me.items, prevEntry)] = obj;
            }
            return obj;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Override provided by sencha
// https://www.sencha.com/forum/showthread.php?310675-Layout-run-failed-with-syncRowHeight-false
Ext.define('Sch.patches.LayoutContext', {
    extend: 'Sch.util.Patch',
    target: 'Ext.layout.Context',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    overrides: {
        queueFlush: function(item, replace) {
            this.flushQueue.add(item, replace);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Override provided by sencha
// https://www.sencha.com/forum/showthread.php?310675-Layout-run-failed-with-syncRowHeight-false
Ext.define('Sch.patches.TableLayout', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.TableLayout',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    overrides: {
        calculate: function(ownerContext) {
            var me = this,
                context = ownerContext.context,
                lockingPartnerContext = ownerContext.lockingPartnerContext,
                headerContext = ownerContext.headerContext,
                ownerCtContext = ownerContext.ownerCtContext,
                owner = me.owner,
                columnsChanged = headerContext.getProp('columnsChanged'),
                state = ownerContext.state,
                columnFlusher, otherSynchronizer, synchronizer, rowHeightFlusher,
                bodyDom = owner.body.dom,
                bodyHeight, ctSize, overflowY, normalView, lockedViewHorizScrollBar, normalViewHorizScrollBar;
            // Shortcut when empty grid - let the base handle it.
            // EXTJS-14844: Even when no data rows (all.getCount() === 0) there may be summary rows to size.
            if (!owner.all.getCount() && (!bodyDom || !owner.body.child('table'))) {
                ownerContext.setProp('viewOverflowY', false);
                me.callParent([
                    ownerContext
                ]);
                return;
            }
            if (columnsChanged === undefined) {
                // We cannot proceed when we have rows but no columnWidths determined...
                me.done = false;
                return;
            }
            if (columnsChanged) {
                if (!(columnFlusher = state.columnFlusher)) {
                    // Since the columns have changed, we need to write the widths to the DOM.
                    // Queue (and possibly replace) a pseudo ContextItem, who's flush method
                    // routes back into this class.
                    context.queueFlush(state.columnFlusher = columnFlusher = {
                        ownerContext: ownerContext,
                        columnsChanged: columnsChanged,
                        layout: me,
                        id: me.columnFlusherId,
                        flush: me.flushColumnWidths
                    }, true);
                }
                if (!columnFlusher.flushed) {
                    // We have queued the columns to be written, but they are still pending, so
                    // we cannot proceed.
                    me.done = false;
                    return;
                }
            }
            // They have to turn row height synchronization on, or there may be variable row heights
            // Either no columns changed, or we have flushed those changes.. which means the
            // column widths in the DOM are correct. Now we can proceed to syncRowHeights (if
            // we are locking) or wrap it up by determining our vertical overflow.
            if (ownerContext.doSyncRowHeights) {
                if (!(rowHeightFlusher = state.rowHeightFlusher)) {
                    // When we are locking, both sides need to read their row heights in a read
                    // phase (i.e., right now).
                    if (!(synchronizer = state.rowHeights)) {
                        state.rowHeights = synchronizer = ownerContext.rowHeightSynchronizer;
                        me.owner.syncRowHeightMeasure(synchronizer);
                        ownerContext.setProp('rowHeights', synchronizer);
                    }
                    if (!(otherSynchronizer = lockingPartnerContext.getProp('rowHeights'))) {
                        me.done = false;
                        return;
                    }
                    // Queue (and possibly replace) a pseudo ContextItem, who's flush method
                    // routes back into this class.
                    context.queueFlush(state.rowHeightFlusher = rowHeightFlusher = {
                        ownerContext: ownerContext,
                        synchronizer: synchronizer,
                        otherSynchronizer: otherSynchronizer,
                        layout: me,
                        id: me.rowHeightFlusherId,
                        flush: me.flushRowHeights
                    }, true);
                }
                if (!rowHeightFlusher.flushed) {
                    me.done = false;
                    return;
                }
            }
            me.callParent([
                ownerContext
            ]);
            if (!ownerContext.heightModel.shrinkWrap) {
                // If the grid is shrink wrapping, we can't be overflowing
                overflowY = false;
                if (!ownerCtContext.heightModel.shrinkWrap) {
                    // We are placed in a fit layout of the gridpanel (our ownerCt), so we need to
                    // consult its containerSize when we are not shrink-wrapping to see if our
                    // content will overflow vertically.
                    ctSize = ownerCtContext.target.layout.getContainerSize(ownerCtContext);
                    if (!ctSize.gotHeight) {
                        me.done = false;
                        return;
                    }
                    bodyHeight = bodyDom.offsetHeight;
                    overflowY = bodyHeight > ctSize.height;
                }
                ownerContext.setProp('viewOverflowY', overflowY);
            }
            // Adjust the presence of X scrollability depending upon whether the headers
            // overflow, and scrollbars take up space.
            // This has two purposes.
            //
            // For lockable assemblies, if there is horizontal overflow in the normal side,
            // The locked side (which shrinkwraps the columns) must be set to overflow: scroll
            // in order that it has acquires a matching horizontal scrollbar.
            //
            // If no locking, then if there is no horizontal overflow, we set overflow-x: hidden
            // This avoids "pantom" scrollbars which are only caused by the presence of another scrollbar.
            if (me.done && Ext.getScrollbarSize().height) {
                if (lockingPartnerContext && owner.isLockedView) {
                    normalView = owner.lockingPartner;
                    lockedViewHorizScrollBar = owner.scrollFlags.x && ownerContext.headerContext.state.boxPlan.tooNarrow;
                    normalViewHorizScrollBar = normalView.scrollFlags.x && lockingPartnerContext.headerContext.state.boxPlan.tooNarrow;
                    if (lockedViewHorizScrollBar !== normalViewHorizScrollBar) {
                        if (normalViewHorizScrollBar) {
                            lockingPartnerContext.setProp('overflowX', true);
                            ownerContext.setProp('overflowX', 'scroll');
                        } else {
                            ownerContext.setProp('overflowX', true);
                            lockingPartnerContext.setProp('overflowX', 'scroll');
                        }
                    } else {
                        ownerContext.setProp('overflowX', normalViewHorizScrollBar);
                        lockingPartnerContext.setProp('overflowX', lockedViewHorizScrollBar);
                    }
                    ownerContext.setProp('overflowY', 'scroll');
                }
                // No locking sides, ensure X scrolling is on if there is overflow, but not if there is no overflow
                // This eliminates "phantom" scrollbars which are only caused by other scrollbars
                else if (!owner.isAutoTree) {
                    ownerContext.setProp('overflowX', !!ownerContext.headerContext.state.boxPlan.tooNarrow);
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Sch.patches.ColumnLayout', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.ColumnLayout',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    overrides: {
        calculate: function(ownerContext) {
            var me = this,
                grid = me.owner.grid,
                // Our TableLayout buddy sets this in its beginLayout so we can work this
                // out together:
                viewContext = ownerContext.viewContext,
                state = ownerContext.state,
                context = ownerContext.context,
                lockingPartnerContext, lockingPartnerGrid, ownerGrid, columnsChanged, columns, len, i, column, scrollbarAdjustment, viewOverflowY;
            me.callSuper([
                ownerContext
            ]);
            if (grid && state.parallelDone) {
                lockingPartnerContext = viewContext.lockingPartnerContext;
                // BUG: lockingPartnerContext must be nulled if partner grid is collapsed or hidden.
                // ==================================================================================
                if (lockingPartnerContext) {
                    lockingPartnerGrid = lockingPartnerContext.target.ownerCt;
                    if (!lockingPartnerGrid.isVisible() || lockingPartnerGrid.collapsed) {
                        lockingPartnerContext = null;
                    }
                }
                ownerGrid = grid.ownerGrid;
                // A force-fit needs to be "reflexed" so check that now. If we have to reflex
                // the items, we need to re-cacheFlexes and invalidate ourselves.
                if (ownerGrid.forceFit && !state.reflexed) {
                    if (me.convertWidthsToFlexes(ownerContext)) {
                        me.cacheFlexes(ownerContext);
                        me.done = false;
                        ownerContext.invalidate({
                            state: {
                                reflexed: true,
                                scrollbarAdjustment: me.getScrollbarAdjustment(ownerContext)
                            }
                        });
                        return;
                    }
                }
                // Once the parallelDone flag goes up, we need to pack up the changed column
                // widths for our TableLayout partner.
                if ((columnsChanged = state.columnsChanged) === undefined) {
                    columns = ownerContext.target.getVisibleGridColumns();
                    columnsChanged = false;
                    for (i = 0 , len = columns.length; i < len; i++) {
                        column = context.getCmp(columns[i]);
                        // Since we are parallelDone, all of the children should have width,
                        // so we can
                        if (!column.lastBox || column.props.width !== column.lastBox.width) {
                            (columnsChanged || (columnsChanged = []))[i] = column;
                        }
                    }
                    state.columnsChanged = columnsChanged;
                    // This will trigger our TableLayout partner and allow it to proceed.
                    ownerContext.setProp('columnsChanged', columnsChanged);
                }
                if (ownerContext.manageScrollbar) {
                    // If we changed the column widths, we need to wait for the TableLayout to
                    // return whether or not we have overflowY... well, that is, if we are
                    // needing to tweak the scrollbarAdjustment...
                    scrollbarAdjustment = me.getScrollbarAdjustment(ownerContext);
                    if (scrollbarAdjustment) {
                        // Since we start with the assumption that we will need the scrollbar,
                        // we now need to wait to see if our guess was correct.
                        viewOverflowY = viewContext.getProp('viewOverflowY');
                        if (viewOverflowY === undefined) {
                            // The TableLayout has not determined this yet, so park it.
                            me.done = false;
                            return;
                        }
                        if (!viewOverflowY) {
                            // We have our answer, and it turns out the view did not overflow
                            // (even with the reduced width we gave it), so we need to remove
                            // the scrollbarAdjustment and go again.
                            if (lockingPartnerContext) {
                                // In a locking grid, only the normal side plays this game,
                                // so now that we know the resolution, we need to invalidate
                                // the locking view and its headerCt.
                                lockingPartnerContext.invalidate();
                                lockingPartnerContext.headerContext.invalidate();
                            }
                            viewContext.invalidate();
                            ownerContext.invalidate({
                                state: {
                                    // Pass a 0 adjustment on into our next life. If this is
                                    // the invalidate that resets ownerContext then this is
                                    // put onto the new state. If not, it will reset back to
                                    // undefined and we'll have to begin again (which is the
                                    // correct thing to do in that case).
                                    scrollbarAdjustment: 0
                                }
                            });
                        }
                    }
                }
            }
        }
    }
});
// else {
// We originally assumed we would need the scrollbar and since we do
// not now, we must be on the second pass, so we can move on...
// }

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?310238-Tooltip-should-not-ignore-mouseover-event-on-touch-devices
Ext.define('Sch.patches.ToolTip', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tip.ToolTip',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                setTarget: function(target) {
                    var me = this,
                        t = Ext.get(target),
                        tg;
                    if (me.target) {
                        tg = Ext.get(me.target);
                        me.mun(tg, {
                            mouseover: me.onTargetOver,
                            tap: me.onTargetOver,
                            mouseout: me.onTargetOut,
                            mousemove: me.onMouseMove,
                            scope: me
                        });
                    }
                    me.target = t;
                    if (t) {
                        me.mon(t, {
                            mouseover: me.onTargetOver,
                            tap: me.onTargetOver,
                            mouseout: me.onTargetOut,
                            mousemove: me.onMouseMove,
                            scope: me
                        });
                    }
                    if (me.anchor) {
                        me.anchorTarget = me.target;
                    }
                }
            };
        if (Ext.getVersion().isLessThan('6.0.2')) {
            overrides.afterSetPosition = function(x, y) {
                var me = this;
                me.callParent(arguments);
                if (me.anchor) {
                    if (!me.anchorEl.isVisible()) {
                        me.anchorEl.show();
                    }
                    // Sync anchor after it's visible, otherwise it'll be misplaced. Fixed in 6.0.2
                    // 1202_dragcreator
                    me.syncAnchor();
                } else {
                    me.anchorEl.hide();
                }
            };
        }
        Ext.ClassManager.get(this.target).override(overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.mixin.TimelineView

 A base mixin for {@link Ext.view.View} classes, giving to the consuming view the "time line" functionality.
 This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

 By itself this mixin is not enough for correct rendering. The class, consuming this mixin, should also consume one of the
 {@link Sch.view.Horizontal}, {@link Sch.view.Vertical} or {@link Sch.view.Calendar} mixins, which provides the implementation of some mode-specfic methods.

 Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

 */
Ext.define("Sch.mixin.TimelineView", {
    extend: 'Sch.mixin.AbstractTimelineView',
    requires: [
        'Ext.tip.ToolTip',
        'Sch.patches.NavigationModel6_0_2',
        'Sch.patches.TouchScroll',
        'Sch.patches.View',
        'Sch.patches.Scroller',
        'Sch.patches.Queue',
        'Sch.patches.LayoutContext',
        'Sch.patches.TableLayout',
        'Sch.patches.ColumnLayout',
        'Sch.patches.ToolTip'
    ],
    tip: null,
    /**
     * @cfg {String} overScheduledEventClass
     * A CSS class to apply to each event in the view on mouseover (defaults to 'sch-event-hover').
     */
    overScheduledEventClass: 'sch-event-hover',
    ScheduleBarEvents: [
        "mousedown",
        "mouseup",
        "click",
        "dblclick",
        "longpress",
        "contextmenu"
    ],
    ResourceRowEvents: [
        "keydown",
        "keyup"
    ],
    // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations
    preventOverCls: false,
    // The last hovered over event bar HTML node
    hoveredEventNode: null,
    /**
     * @event beforetooltipshow
     * Fires before the event tooltip is shown, return false to suppress it.
     * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
     * @param {Sch.model.Event} eventRecord The event record corresponding to the rendered event
     */
    /**
     * @event columnwidthchange
     * @private
     * Fires after the column width has changed
     */
    _initializeTimelineView: function() {
        this.callParent(arguments);
        this.on('destroy', this._onDestroy, this);
        this.on('afterrender', this._onAfterRender, this);
        this.setMode(this.mode);
        this.enableBubble('columnwidthchange');
        this.addCls("sch-timelineview");
        if (this.readOnly) {
            this.addCls(this._cmpCls + '-readonly');
        }
        this.addCls(this._cmpCls);
        if (this.eventAnimations) {
            this.addCls('sch-animations-enabled');
        }
    },
    handleScheduleBarEvent: function(e, eventBarNode) {
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecord(eventBarNode), e);
    },
    handleResourceRowEvent: function(e, resourceRowNode) {
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecordFromResourceRow(resourceRowNode), e);
    },
    // private, clean up
    _onDestroy: function() {
        if (this.tip) {
            this.tip.destroy();
        }
    },
    _onAfterRender: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
        if (this.tooltipTpl) {
            if (typeof this.tooltipTpl === 'string') {
                this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl);
            }
            this.el.on('mousemove', this.setupTooltip, this, {
                single: true
            });
        }
        var bufferedRenderer = this.bufferedRenderer;
        if (bufferedRenderer) {
            this.patchBufferedRenderingPlugin(bufferedRenderer);
            this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer);
        }
        // this.on('bufferedrefresh', this.onBufferedRefresh, this, { buffer : 10 });
        this.setupTimeCellEvents();
        var eventBarListeners = {
                delegate: this.eventSelector,
                scope: this
            };
        var resourceRowListeners = {
                delegate: this.rowSelector,
                scope: this
            };
        Ext.Array.each(this.ScheduleBarEvents, function(name) {
            eventBarListeners[name] = this.handleScheduleBarEvent;
        }, this);
        Ext.Array.each(this.ResourceRowEvents, function(name) {
            resourceRowListeners[name] = this.handleResourceRowEvent;
        }, this);
        this.el.on(eventBarListeners);
        this.el.on(resourceRowListeners);
    },
    patchBufferedRenderingPlugin: function(plugin) {
        var me = this;
        var oldSetBodyTop = plugin.setBodyTop;
        // @OVERRIDE Overriding buffered renderer plugin
        plugin.setBodyTop = function(bodyTop, calculatedTop) {
            var val = oldSetBodyTop.apply(this, arguments);
            me.fireEvent('bufferedrefresh', this);
            return val;
        };
    },
    // onBufferedRefresh : function () {
    //     var me = this,
    //         bodyDom = me.body.dom,
    //         secondaryCanvasDom,
    //         bodyStyle,
    //         bodyStyleTransform,
    //         match;
    //
    //     if (bodyDom) {
    //
    //         bodyStyle = bodyDom.style;
    //         secondaryCanvasDom = me.getSecondaryCanvasEl().dom;
    //
    //         if (Ext.isIE9m) {
    //             secondaryCanvasDom.style.top = bodyStyle.top;
    //         }
    //         else {
    //             bodyStyleTransform = bodyStyle.transform || bodyStyle.msTransform || bodyStyle.webkitTransform;
    //
    //             if (bodyStyleTransform) {
    //
    //                 match = /\(-?\d+px,\s*(-?\d+px),\s*(-?\d+)px\)/.exec(bodyStyleTransform);
    //
    //                 if (match && match.length > 0) {
    //                     secondaryCanvasDom.style.top = match[1];
    //                 }
    //                 else {
    //                     secondaryCanvasDom.style.top = bodyStyle.top;
    //                 }
    //             }
    //         }
    //     }
    // },
    setMouseOverEnabled: function(enabled) {
        this[enabled ? "mon" : "mun"](this.el, {
            mouseover: this.onEventMouseOver,
            mouseout: this.onEventMouseOut,
            delegate: this.eventSelector,
            scope: this
        });
    },
    // private
    onEventMouseOver: function(e, t) {
        if (t !== this.hoveredEventNode && !this.preventOverCls) {
            this.hoveredEventNode = t;
            Ext.fly(t).addCls(this.overScheduledEventClass);
            var eventModel = this.resolveEventRecord(t);
            // do not fire this event if model cannot be found
            // this can be the case for "sch-dragcreator-proxy" elements for example
            if (eventModel)  {
                this.fireEvent('eventmouseenter', this, eventModel, e);
            }
            
        }
    },
    // private
    onEventMouseOut: function(e, t) {
        if (this.hoveredEventNode) {
            if (!e.within(this.hoveredEventNode, true, true)) {
                Ext.fly(this.hoveredEventNode).removeCls(this.overScheduledEventClass);
                this.fireEvent('eventmouseleave', this, this.resolveEventRecord(this.hoveredEventNode), e);
                this.hoveredEventNode = null;
            }
        }
    },
    // Overridden since locked grid can try to highlight items in the unlocked grid while it's loading/empty
    highlightItem: function(item) {
        if (item) {
            var me = this;
            me.clearHighlight();
            me.highlightedItem = item;
            Ext.fly(item).addCls(me.overItemCls);
        }
    },
    // private
    setupTooltip: function() {
        var me = this,
            tipCfg = Ext.apply({
                delegate: me.eventSelector,
                target: me.el,
                anchor: 'b',
                rtl: me.rtl,
                show: function() {
                    Ext.ToolTip.prototype.show.apply(this, arguments);
                    // Some extra help required to correct alignment (in cases where event is in part outside the scrollable area
                    // https://www.assembla.com/spaces/bryntum/tickets/626#/activity/ticket:
                    if (this.triggerElement && me.getMode() === 'horizontal') {
                        var taskBox = Ext.fly(this.triggerElement).getBox();
                        var viewportWidth = Ext.dom.Element.getViewportWidth();
                        // Constrain the tip to the viewport
                        var x = Math.min(Math.max(this.targetXY[0] - 10, 0), viewportWidth - this.getWidth() - 10);
                        // if tip won't be fully visible, move it to bottom edge
                        var y = taskBox.top - this.getHeight() - 7;
                        this.setY(y < 0 ? taskBox.bottom + 10 : y);
                        this.setX(x);
                    }
                }
            }, me.tipCfg);
        me.tip = new Ext.ToolTip(tipCfg);
        me.tip.on({
            beforeshow: function(tip) {
                if (!tip.triggerElement || !tip.triggerElement.id) {
                    return false;
                }
                // All visible modal windows on the page.
                var modalVisibleWindows = Ext.all('window[modal=true]{isVisible()}');
                // First modal window that is not a scheduler and doesn't contain scheduler inside.
                var foundWindow = Ext.Array.findBy(modalVisibleWindows, function(modalWindow) {
                        return this !== modalWindow && !this.isDescendantOf(modalWindow);
                    }, this);
                // Tooltip should not be shown above task editor or other modal windows
                if (foundWindow)  {
                    return false;
                }
                
                var record = this.resolveEventRecord(tip.triggerElement);
                if (!record || this.fireEvent('beforetooltipshow', this, record) === false) {
                    return false;
                }
                var dataForTip = this.getDataForTooltipTpl(record, tip.triggerElement),
                    tooltipString;
                if (!dataForTip)  {
                    return false;
                }
                
                tooltipString = this.tooltipTpl.apply(dataForTip);
                if (!tooltipString)  {
                    return false;
                }
                
                tip.update(tooltipString);
            },
            scope: this
        });
        if (Ext.supports.Touch) {
            // https://www.sencha.com/forum/showthread.php?301307-single-event-listener-isn-t-unbound
            me.el.un({
                touchmove: me.setupTooltip,
                mousemove: me.setupTooltip,
                scope: me
            });
        }
    },
    getHorizontalTimeAxisColumn: function() {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down('timeaxiscolumn');
            if (this.timeAxisColumn) {
                this.timeAxisColumn.on('destroy', function() {
                    this.timeAxisColumn = null;
                }, this);
            }
        }
        return this.timeAxisColumn;
    },
    /**
     * Template method to allow you to easily provide data for your {@link Sch.mixin.TimelinePanel#tooltipTpl} template.
     * @param {Sch.model.Range} event The event record corresponding to the HTML element that triggered the tooltip to show.
     * @param {HTMLElement} triggerElement The HTML element that triggered the tooltip.
     * @return {Object} The data to be applied to your template, typically any object or array.
     */
    getDataForTooltipTpl: function(record, triggerElement) {
        return Ext.apply({
            _record: record
        }, record.data);
    },
    /**
     * Refreshes the view and maintains the scroll position.
     */
    refreshKeepingScroll: function() {
        Ext.suspendLayouts();
        this.saveScrollState();
        this.refreshView();
        // we have to resume layouts before scroll in order to let element receive its new width after refresh
        Ext.resumeLayouts(true);
        // If el is not scrolled, skip setting scroll state (can be a costly DOM operation)
        // This speeds up initial rendering
        // HACK: reading private scrollState property in Ext JS superclass
        // infinite scroll requires the restore scroll state always
        if (this.scrollState.left !== 0 || this.scrollState.top !== 0 || this.infiniteScroll) {
            this.restoreScrollState();
        }
    },
    setupTimeCellEvents: function() {
        this.mon(this.el, {
            // `handleScheduleEvent` is an abstract method, defined in "SchedulerView" and "GanttView"
            click: this.handleScheduleEvent,
            dblclick: this.handleScheduleEvent,
            contextmenu: this.handleScheduleEvent,
            pinch: this.handleScheduleEvent,
            pinchstart: this.handleScheduleEvent,
            pinchend: this.handleScheduleEvent,
            scope: this
        });
    },
    getTableRegion: function() {
        var tableEl = this.el.down('.' + Ext.baseCSSPrefix + 'grid-item-container');
        // Also handle odd timing cases where the table hasn't yet been inserted into the dom
        return (tableEl || this.el).getRegion();
    },
    // Returns the row element for a given row record
    getRowNode: function(resourceRecord) {
        return this.getNodeByRecord(resourceRecord);
    },
    findRowByChild: function(t) {
        return this.findItemByChild(t);
    },
    getRecordForRowNode: function(node) {
        return this.getRecord(node);
    },
    /**
     * Refreshes the view and maintains the resource axis scroll position.
     */
    refreshKeepingResourceScroll: function() {
        var scroll = this.getScroll();
        this.refreshView();
        if (this.getMode() === 'horizontal') {
            this.scrollVerticallyTo(scroll.top);
        } else {
            this.scrollHorizontallyTo(scroll.left);
        }
    },
    scrollHorizontallyTo: function(x, animate) {
        this.scrollTo(x, null, animate);
    },
    scrollVerticallyTo: function(y, animate) {
        this.scrollTo(null, y, animate);
    },
    getVerticalScroll: function() {
        return this.getScrollY();
    },
    getHorizontalScroll: function() {
        return this.getScrollX();
    },
    getScroll: function() {
        var me = this;
        return {
            top: me.getScrollY(),
            left: me.getScrollX()
        };
    },
    handleScheduleEvent: function() {},
    // A slightly modified Ext.Element#scrollIntoView method using an offset for the edges
    scrollElementIntoView: function(el, hscroll, animate, highlight, edgeOffset, callback, scope) {
        var me = this,
            dom = el.dom,
            container = Ext.getDom(me.getEl()),
            offsets = el.getOffsetsTo(container),
            scroll = me.getScroll(),
            left = offsets[0] + scroll.left,
            top = offsets[1] + scroll.top,
            bottom = top + dom.offsetHeight,
            right = left + dom.offsetWidth,
            ctClientHeight = container.clientHeight,
            ctScrollTop = parseInt(scroll.top, 10),
            ctScrollLeft = parseInt(scroll.left, 10),
            ctBottom = ctScrollTop + ctClientHeight,
            ctRight = ctScrollLeft + container.clientWidth,
            newPosX, newPosY;
        edgeOffset = edgeOffset === null || edgeOffset === undefined ? 20 : edgeOffset;
        if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) {
            newPosY = top - edgeOffset;
        } else if (bottom > ctBottom) {
            newPosY = bottom - ctClientHeight + edgeOffset;
        }
        if (hscroll !== false && dom.offsetWidth > container.clientWidth || left < ctScrollLeft) {
            newPosX = left - edgeOffset;
        } else if (hscroll !== false && right > ctRight) {
            newPosX = right - container.clientWidth + edgeOffset;
        }
        animate = animate === true && {} || animate;
        highlight = highlight === true && {} || highlight;
        scope = scope || me;
        if (animate && highlight) {
            animate.listeners = Ext.apply(animate.listeners || {}, {
                'afteranimate': function() {
                    highlight.listeners = Ext.apply(highlight.listeners || {}, {
                        'afteranimate': function() {
                            callback && callback.call(scope);
                            callback = null;
                        }
                    });
                    Ext.fly(dom).highlight(null, highlight);
                }
            });
        } else if (animate) {
            animate.listeners = Ext.apply(animate.listeners, {
                'afteranimate': function() {
                    callback && callback.call(scope);
                    callback = null;
                }
            });
        } else if (highlight) {
            highlight.listeners = Ext.apply(highlight.listeners || {}, {
                'afteranimate': function() {
                    callback && callback.call(scope);
                    callback = null;
                }
            });
        }
        newPosY !== undefined && me.setScrollY(newPosY, animate);
        newPosX !== undefined && me.setScrollX(newPosX, animate);
        !animate && highlight && Ext.fly(dom).highlight(null, highlight);
        !animate && !highlight && callback && callback.call(scope);
    },
    disableViewScroller: function(disabled) {
        var scroller = this.getScrollable();
        if (scroller) {
            scroller.setDisabled(disabled);
        }
    },
    // Since Ext JS has different internal RTL behavior depending on presence of a Viewport,
    // we use this method to check if we need to adjust for RTL or if it's done internally in Ext
    shouldAdjustForRtl: function() {
        return this.rtl && !Ext.rootInheritedState.rtl;
    },
    // Decides whether to use 'left' or 'right' based on RTL mode
    getHorizontalPositionSide: function() {
        return this.rtl ? 'right' : 'left';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.view.TimelineGridView
@extends Ext.grid.View
@mixin Sch.mixin.TimelineView

A grid view class, that consumes the {@link Sch.mixin.TimelineView} mixin. Used internally.

*/
Ext.define('Sch.view.TimelineGridView', {
    extend: 'Ext.grid.View',
    mixins: [
        'Sch.mixin.TimelineView'
    ],
    infiniteScroll: false,
    bufferCoef: 5,
    bufferThreshold: 0.2,
    // the scrolLeft position, as Date (not as pixels offset)
    cachedScrollDate: null,
    boxIsReady: false,
    ignoreNextHorizontalScroll: false,
    constructor: function(config) {
        this.callParent(arguments);
        // setup has to happen in the "afterrender" event, because at that point, the view is not "ready" yet
        // so we can freely change the start/end dates of the timeaxis and no refreshes will happen
        if (this.infiniteScroll) {
            this.on('boxready', this.setupInfiniteScroll, this);
        }
        if (this.timeAxisViewModel) {
            this.relayEvents(this.timeAxisViewModel, [
                'columnwidthchange'
            ]);
        }
    },
    setupInfiniteScroll: function() {
        var planner = this.panel.ownerCt;
        this.cachedScrollDate = planner.startDate || this.timeAxis.getStart();
        // check if it's touch microsoft
        if (Ext.getVersion().isLessThan('6.0.1') && Ext.supports.Touch && Ext.os.is.Windows) {
            var headerScroll = this.panel.headerCt.getScrollable();
            var viewScroll = this.getScrollable();
            // When scroll is done, Ext throws special event called 'idle'
            // Touch scroller handles that event and performs scroll to [0, 0]
            // Our 'scroll' event handler remembers new view start date and keeps it in memory
            // Disabling this handler seemingly doesn't break anything in case of infinite scroll enabled
            headerScroll.onIdle && Ext.GlobalEvents.un('idle', headerScroll.onIdle, headerScroll);
            viewScroll.onIdle && Ext.GlobalEvents.un('idle', viewScroll.onIdle, viewScroll);
        }
        var me = this;
        planner.calculateOptimalDateRange = function(centerDate, panelSize, nextZoomLevel, span) {
            if (span) {
                return span;
            }
            var preset = Sch.preset.Manager.getPreset(nextZoomLevel.preset);
            return me.calculateInfiniteScrollingDateRange(// me.ol.dom.scrollLeft can differ for obvious reasons thus method can return different result for same arguments
            // better user centerDate
            //me.getDateFromCoordinate(me.el.dom.scrollLeft, null, true),
            centerDate, preset.getBottomHeader().unit, nextZoomLevel.increment, nextZoomLevel.width, true);
        };
        // setup scroll/resize listeners
        this.bindInfiniteScrollListeners();
    },
    bindInfiniteScrollListeners: function() {
        this.getScrollable().on('scroll', this.onHorizontalScroll, this);
    },
    unbindInfiniteScrollListeners: function() {
        this.getScrollable().un('scroll', this.onHorizontalScroll, this);
        this.infiniteScroll = false;
    },
    onHorizontalScroll: function(scrollable, scrollLeft, scrollTop) {
        if (this.ignoreNextHorizontalScroll || this.cachedScrollDate) {
            this.ignoreNextHorizontalScroll = false;
            return;
        }
        var scrollbarSize = Ext.getScrollbarSize(),
            width = this.getWidth(),
            limit = width * this.bufferThreshold * this.bufferCoef,
            scrollWidth = this.getScrollable().getMaxPosition().x;
        // we cannot do: scrollWidth = this.getScrollable().getMaxPosition().x - scrollbarSize.width;
        // since it'll cause false failing of unscoped css rules test ..because minified ".x-scroll..." looks similar to hardcoded extjs selector
        scrollWidth -= scrollbarSize.width;
        // if scroll violates limits let's shift timespan
        if ((scrollWidth - scrollLeft < limit) || scrollLeft < limit) {
            this.shiftToDate(this.getDateFromCoordinate(scrollLeft, null, true));
            // Make sure any scrolling which could have been triggered by the Bryntum ScrollManager (drag drop of task),
            // is cancelled
            this.el.stopAnimation();
        }
    },
    // TODO: investigate if we need this method now when we use refreshView instead
    refresh: function() {
        this.callParent(arguments);
        // `scrollStateSaved` will mean that refresh happens as part of `refreshKeepingScroll`,
        // which already does `restoreScrollState`, which includes `restoreScrollToCachedDate`
        if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
            this.restoreScrollToCachedDate();
        }
    },
    onResize: function(width, height, oldWidth, oldHeight) {
        this.boxIsReady = true;
        this.callParent(arguments);
        // TODO this should be optimized to not perform any operations as long as view size doesn't increase
        // enough to pass the buffer limits
        if (this.infiniteScroll && width > 0 && width !== oldWidth) {
            // When size increases - we should maintain the left visible date in the component to not confuse the user
            this.shiftToDate(this.cachedScrollDate || this.getVisibleDateRange().startDate, this.cachedScrollDateIsCentered);
        }
    },
    restoreScrollToCachedDate: function() {
        if (this.cachedScrollDate && this.boxIsReady) {
            this.ignoreNextHorizontalScroll = true;
            this.scrollToDate(this.cachedScrollDate);
            this.cachedScrollDate = null;
        }
    },
    scrollToDate: function(toDate) {
        this.cachedScrollDate = toDate;
        if (this.cachedScrollDateIsCentered) {
            this.panel.ownerCt.scrollToDateCentered(toDate);
        } else {
            this.panel.ownerCt.scrollToDate(toDate);
        }
        var scrollLeft = this.getScrollX();
        // the `onRestoreHorzScroll` method in Ext.panel.Table is called during Ext.resumeLayouts(true) (in the `refreshKeepingScroll`)
        // and messes up the scrolling position (in the called `syncHorizontalScroll` method).
        // Overwrite the property `syncHorizontalScroll` is using to read the scroll position, so that no actual change will happen
        this.panel.scrollLeftPos = scrollLeft;
        // the previous line however, breaks the header sync, doing that manually
        this.headerCt.setScrollX(scrollLeft);
    },
    saveScrollState: function() {
        this.scrollStateSaved = this.boxIsReady;
        this.callParent(arguments);
    },
    restoreScrollState: function() {
        this.scrollStateSaved = false;
        // if we have scroll date then let's calculate left-coordinate by this date
        // and top-coordinate we'll get from the last saved scroll state
        if (this.infiniteScroll && this.cachedScrollDate) {
            this.restoreScrollToCachedDate();
            this.setScrollY(this.scrollState.top);
            return;
        }
        this.callParent(arguments);
    },
    // `calculateOptimalDateRange` already exists in Zoomable plugin
    calculateInfiniteScrollingDateRange: function(date, unit, increment, tickWidth, centered) {
        var timeAxis = this.timeAxis,
            viewWidth = this.getWidth(),
            result;
        tickWidth = tickWidth || this.timeAxisViewModel.getTickWidth();
        increment = increment || timeAxis.increment || 1;
        unit = unit || timeAxis.unit;
        var DATE = Sch.util.Date;
        var bufferedTicks = Math.ceil(viewWidth * this.bufferCoef / tickWidth);
        // if provided date is the central point on the timespan
        if (centered) {
            var halfSpan = Math.ceil((viewWidth * (1 + this.bufferCoef)) / (2 * tickWidth)) * increment;
            result = {
                start: timeAxis.floorDate(DATE.add(date, unit, -halfSpan), false, unit, increment),
                end: timeAxis.ceilDate(DATE.add(date, unit, halfSpan), false, unit, increment)
            };
        } else // if provided date is the left coordinate of the visible timespan area
        {
            result = {
                start: timeAxis.floorDate(DATE.add(date, unit, -bufferedTicks * increment), false, unit, increment),
                end: timeAxis.ceilDate(DATE.add(date, unit, Math.ceil((viewWidth / tickWidth + bufferedTicks) * increment)), false, unit, increment)
            };
        }
        return result;
    },
    shiftToDate: function(date, centered) {
        var newRange = this.calculateInfiniteScrollingDateRange(date, null, null, null, centered);
        // we set scroll date here since it will be required during timeAxis.setTimeSpan() call
        this.cachedScrollDate = date;
        this.cachedScrollDateIsCentered = centered;
        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position
        this.timeAxis.setTimeSpan(newRange.start, newRange.end);
    },
    destroy: function() {
        if (this.infiniteScroll && this.rendered)  {
            this.unbindInfiniteScrollListeners();
        }
        
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?306315-DragDrop-on-touch-monitor-doesn-t-work-when-page-is-scrolled
Ext.define('Sch.patches.DragDropManager', {
    extend: 'Sch.util.Patch',
    requires: [
        'Ext.dd.ScrollManager'
    ],
    target: 'Ext.dd.DragDropManager',
    minVersion: '6.0.0',
    applyFn: function() {
        Ext.override(Ext.dd.DragDropManager, {
            fireEvents: function(e, isDrop) {
                var me = this,
                    isTouch = Ext.supports.Touch,
                    dragCurrent = me.dragCurrent,
                    mousePoint = me.currentPoint,
                    currentX = mousePoint.x,
                    currentY = mousePoint.y,
                    allTargets = [],
                    oldOvers = [],
                    // cache the previous dragOver array
                    outEvts = [],
                    overEvts = [],
                    dropEvts = [],
                    enterEvts = [],
                    zoom = isTouch ? document.documentElement.clientWidth / window.innerWidth : 1,
                    dragEl, overTarget, overTargetEl, needsSort, i, len, sGroup, overDragEl;
                // If the user did the mouse up outside of the window, we could
                // get here even though we have ended the drag.
                if (!dragCurrent || dragCurrent.isLocked()) {
                    return;
                }
                // Touch's delegated event system means that the mousemove (which will be a touchmove really) target will be the element that the listener was requested for, NOT the actual lowest
                // level target . So we have to use elementFromPoint to find the target which we are currently over.
                //
                // If we need to use the current mousemove target to find the over el,
                // but pointer-events is not supported, AND the delta position does not place the mouse outside of the dragEl,
                // temporarily move the dragEl away, and fake the mousemove target by using document.elementFromPoint
                // while it's out of the way.
                // The pointer events implementation is bugged in IE9/10 and opera, so fallback even if they report that they support it.
                // IE8m do not support it so they will auto fall back
                overDragEl = !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0);
                if (isTouch || (!me.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && overDragEl)) {
                    dragEl = dragCurrent.getDragEl();
                    // Temporarily hide the dragEl instead of moving it off the page. Moving the el off the page can cause
                    // problems when in an iframe with IE8 standards. See EXTJSIV-11728.
                    if (overDragEl) {
                        dragEl.style.visibility = 'hidden';
                    }
                    // PATCH
                    // we need to take vertical scroll into account
                    var bodyScroll = Ext.getBody().getScroll();
                    e.target = document.elementFromPoint(currentX - bodyScroll.left / zoom, currentY - bodyScroll.top / zoom);
                    if (overDragEl) {
                        dragEl.style.visibility = 'visible';
                    }
                }
                // END PATCH
                // Check to see if the object(s) we were hovering over is no longer
                // being hovered over so we can fire the onDragOut event
                for (i in me.dragOvers) {
                    overTarget = me.dragOvers[i];
                    delete me.dragOvers[i];
                    // Check to make sure that the component hasn't been destroyed in the middle of a drag operation.
                    if (!me.isTypeOfDD(overTarget) || overTarget.destroyed) {
                        
                        continue;
                    }
                    // If notifyOccluded set, we use mouse position
                    if (me.notifyOccluded) {
                        if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
                            outEvts.push(overTarget);
                        }
                    } else // Otherwise we use event source of the mousemove event
                    {
                        if (!e.within(overTarget.getEl())) {
                            outEvts.push(overTarget);
                        }
                    }
                    oldOvers[i] = true;
                }
                // Collect all targets which are members of the same ddGoups that the dragCurrent is a member of, and which may recieve mouseover and drop notifications.
                // This is preparatory to seeing which one(s) we are currently over
                // Begin by iterating through the ddGroups of which the dragCurrent is a member
                for (sGroup in dragCurrent.groups) {
                    if ("string" !== typeof sGroup) {
                        
                        continue;
                    }
                    // Loop over the registered members of each group, testing each as a potential target
                    for (i in me.ids[sGroup]) {
                        overTarget = me.ids[sGroup][i];
                        // The target is valid if it is a DD type
                        // And it's got a DOM element
                        // And it's configured to be a drop target
                        // And it's not locked
                        // And the DOM element is fully visible with no hidden ancestors
                        // And it's either not the dragCurrent, or, if it is, tha dragCurrent is configured to not ignore itself.
                        if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && (overTarget.isTarget) && (!overTarget.isLocked()) && (Ext.fly(overTargetEl).isVisible(true)) && ((overTarget !== dragCurrent) || (dragCurrent.ignoreSelf === false))) {
                            // If notifyOccluded set, we use mouse position
                            if (me.notifyOccluded) {
                                // Only sort by zIndex if there were some which had a floating zIndex value
                                if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
                                    needsSort = true;
                                }
                                allTargets.push(overTarget);
                            } else // Otherwise we use event source of the mousemove event
                            {
                                if (e.within(overTarget.getEl())) {
                                    allTargets.push(overTarget);
                                    break;
                                }
                            }
                        }
                    }
                }
                // If there were floating targets, sort the highest zIndex to the top
                if (needsSort) {
                    Ext.Array.sort(allTargets, me.byZIndex);
                }
                // Loop through possible targets, notifying the one(s) we are over.
                // Usually we only deliver events to the topmost.
                for (i = 0 , len = allTargets.length; i < len; i++) {
                    overTarget = allTargets[i];
                    // If we are over the overTarget, queue it up to recieve an event of whatever type we are handling
                    if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
                        // look for drop interactions
                        if (isDrop) {
                            dropEvts.push(overTarget);
                        } else // look for drag enter and drag over interactions
                        {
                            // initial drag over: dragEnter fires
                            if (!oldOvers[overTarget.id]) {
                                enterEvts.push(overTarget);
                            } else // subsequent drag overs: dragOver fires
                            {
                                overEvts.push(overTarget);
                            }
                            me.dragOvers[overTarget.id] = overTarget;
                        }
                        // Unless this DragDropManager has been explicitly configured to deliver events to multiple targets, then we are done.
                        if (!me.notifyOccluded) {
                            break;
                        }
                    }
                }
                if (me.mode) {
                    if (outEvts.length) {
                        dragCurrent.b4DragOut(e, outEvts);
                        dragCurrent.onDragOut(e, outEvts);
                    }
                    if (enterEvts.length) {
                        dragCurrent.onDragEnter(e, enterEvts);
                    }
                    if (overEvts.length) {
                        dragCurrent.b4DragOver(e, overEvts);
                        dragCurrent.onDragOver(e, overEvts);
                    }
                    if (dropEvts.length) {
                        dragCurrent.b4DragDrop(e, dropEvts);
                        dragCurrent.onDragDrop(e, dropEvts);
                    }
                } else {
                    // fire dragout events
                    for (i = 0 , len = outEvts.length; i < len; ++i) {
                        dragCurrent.b4DragOut(e, outEvts[i].id);
                        dragCurrent.onDragOut(e, outEvts[i].id);
                    }
                    // fire enter events
                    for (i = 0 , len = enterEvts.length; i < len; ++i) {
                        // dc.b4DragEnter(e, oDD.id);
                        dragCurrent.onDragEnter(e, enterEvts[i].id);
                    }
                    // fire over events
                    for (i = 0 , len = overEvts.length; i < len; ++i) {
                        dragCurrent.b4DragOver(e, overEvts[i].id);
                        dragCurrent.onDragOver(e, overEvts[i].id);
                    }
                    // fire drop events
                    for (i = 0 , len = dropEvts.length; i < len; ++i) {
                        dragCurrent.b4DragDrop(e, dropEvts[i].id);
                        dragCurrent.onDragDrop(e, dropEvts[i].id);
                    }
                }
                // notify about a drop that did not find a target
                if (isDrop && !dropEvts.length) {
                    dragCurrent.onInvalidDrop(e);
                }
            }
        });
        // We just overrode fireEvents method that is used in createSequense in scroll manager
        // so sequence was dropped and we need to create new. Check constructor in Ext.dd.ScrollManager
        var sm = Ext.dd.ScrollManager;
        var ddm = Ext.dd.DragDropManager;
        ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, sm.onFire, sm);
        ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, sm.onStop, sm);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// We patched grid navigation model to not focus rows in normal view in order to save scroll in IE
// this is why under some conditions keyevent contain wrong view and target. This can break navigation
// 2117_key_navigation
Ext.define('Sch.patches.NavigationModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '6.0.0',
    overrides: {
        setPosition: function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
            var me = this;
            // We need to only handle pageup/pagedown keys, because they call setPosition(record, null,...) which trigger
            // special path that leads to error when there's lastFocused property that holds
            // column from normal view and current view is locked
            // #2428
            if (Ext.isIE && keyEvent && (keyEvent.getKey() === keyEvent.PAGE_DOWN || keyEvent.getKey() === keyEvent.PAGE_UP)) {
                var lastFocused = me.lastFocused;
                if (keyEvent.view.isLockedView && lastFocused && keyEvent.view.getVisibleColumnManager().indexOf(lastFocused.column) === -1) {
                    keyEvent.view = keyEvent.view.lockingPartner;
                }
            }
            // TODO: get rid of this when 6.0.1 support is dropped
            // https://www.assembla.com/spaces/bryntum/tickets/2657
            // setPosition now will also set actionableMode to false if we changed position
            if (Ext.getVersion().equals('6.0.1.250')) {
                me.patchedSetPosition.apply(this, arguments);
            } else {
                return me.callParent(arguments);
            }
        },
        // TODO: get rid of this when 6.0.1 support is dropped
        // #2657 - Cannot edit locked cell after click in normal view
        patchedSetPosition: function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
            var me = this,
                view, scroller, selModel, dataSource, columnManager, newRecordIndex, newColumnIndex, newRecord, newColumn,
                clearing = recordIndex == null && columnIndex == null,
                isClear = me.record == null && me.recordIndex == null && me.item == null;
            // Work out the view we are operating on.
            // If they passed a CellContext, use the view from that.
            // Otherwise, use the view injected into the event by Ext.view.View#processEvent.
            // Otherwise, use the last focused view.
            // Failing that, use the view we were bound to.
            if (recordIndex && recordIndex.isCellContext) {
                view = recordIndex.view;
            } else if (keyEvent && keyEvent.view) {
                view = keyEvent.view;
            } else if (me.lastFocused) {
                view = me.lastFocused.view;
            } else {
                view = me.view;
            }
            // In case any async focus was requested before this call.
            view.getFocusTask().cancel();
            // Return if the view was destroyed between the deferSetPosition call and now, or if the call is a no-op
            // or if there are no items which could be focused.
            if (view.destroyed || !view.refreshCounter || !view.ownerCt || clearing && isClear || !view.all.getCount()) {
                return;
            }
            selModel = view.getSelectionModel();
            dataSource = view.dataSource;
            columnManager = view.getVisibleColumnManager();
            // If a CellContext is passed, use it.
            // Passing null happens on blur to remove focus class.
            if (recordIndex && recordIndex.isCellContext) {
                newRecord = recordIndex.record;
                newRecordIndex = recordIndex.rowIdx;
                newColumnIndex = Math.min(recordIndex.colIdx, columnManager.getColumns().length - 1);
                newColumn = columnManager.getColumns()[newColumnIndex];
                // If the record being focused is not available (eg, after a removal), then go to the same position
                if (dataSource.indexOf(newRecord) === -1) {
                    scroller = view.getScrollable();
                    // Change recordIndex so that the "No movement" test is bypassed if the record is not found
                    me.recordIndex = -1;
                    // If the view will not jump upwards to bring the next row under the mouse as expected
                    // because it's at the end, focus the previous row
                    if (scroller.getPosition().y >= scroller.getMaxPosition().y - view.all.last(true).offsetHeight) {
                        recordIndex.rowIdx--;
                    }
                    newRecordIndex = Math.min(recordIndex.rowIdx, dataSource.getCount() - 1);
                    newRecord = dataSource.getAt(newRecordIndex);
                }
            } else {
                // Both axes are null, we defocus
                if (clearing) {
                    newRecord = newRecordIndex = null;
                } else {
                    // AbstractView's default behaviour on focus is to call setPosition(0);
                    // A call like this should default to the last column focused, or column 0;
                    if (columnIndex == null) {
                        columnIndex = me.lastFocused ? me.lastFocused.column : 0;
                    }
                    if (typeof recordIndex === 'number') {
                        newRecordIndex = Math.max(Math.min(recordIndex, dataSource.getCount() - 1), 0);
                        newRecord = dataSource.getAt(recordIndex);
                    }
                    // row is a Record
                    else if (recordIndex.isEntity) {
                        newRecord = recordIndex;
                        newRecordIndex = dataSource.indexOf(newRecord);
                    }
                    // row is a grid row
                    else if (recordIndex.tagName) {
                        newRecord = view.getRecord(recordIndex);
                        newRecordIndex = dataSource.indexOf(newRecord);
                        if (newRecordIndex === -1) {
                            newRecord = null;
                        }
                    } else {
                        if (isClear) {
                            return;
                        }
                        clearing = true;
                        newRecord = newRecordIndex = null;
                    }
                }
                // Record position was successful
                if (newRecord) {
                    // If the record being focused is not available (eg, after a sort), then go to 0,0
                    if (newRecordIndex === -1) {
                        // Change recordIndex so that the "No movement" test is bypassed if the record is not found
                        me.recordIndex = -1;
                        newRecord = dataSource.getAt(0);
                        newRecordIndex = 0;
                        columnIndex = null;
                    }
                    // No columnIndex passed, and no previous column position - default to column 0
                    if (columnIndex == null) {
                        if (!(newColumn = me.column)) {
                            newColumnIndex = 0;
                            newColumn = columnManager.getColumns()[0];
                        }
                    } else if (typeof columnIndex === 'number') {
                        newColumn = columnManager.getColumns()[columnIndex];
                        newColumnIndex = columnIndex;
                    } else {
                        newColumn = columnIndex;
                        newColumnIndex = columnManager.indexOf(columnIndex);
                    }
                } else {
                    clearing = true;
                    newColumn = newColumnIndex = null;
                }
            }
            // If we are in actionable mode and focusing a cell, exit actionable mode at the requested position
            if (view.actionableMode && !clearing) {
                var newPosition = new Ext.grid.CellContext(view).setPosition(newRecord, newColumn);
                // in 6.0.2, where this fix is originating, pressing ENTER in editor doesn't make it to loose focus
                // in versions prior to 6.0.2 it does, so we need to focus current position again so exiting
                // actionable mode would save focused position and could restore it
                // https://www.assembla.com/spaces/bryntum/tickets/2716
                // covered by 090_cell_editing in gantt
                me.focusPosition(newPosition);
                return view.ownerGrid.setActionableMode(false, newPosition);
            }
            // No movement; just ensure the correct item is focused and return early.
            // Do not push current position into previous position, do not fire events.
            if (newRecordIndex === me.recordIndex && newColumnIndex === me.columnIndex && view === me.position.view) {
                return me.focusPosition(me.position);
            }
            if (me.cell) {
                me.cell.removeCls(me.focusCls);
            }
            // Track the last position.
            // Used by SelectionModels as the navigation "from" position.
            me.previousRecordIndex = me.recordIndex;
            me.previousRecord = me.record;
            me.previousItem = me.item;
            me.previousCell = me.cell;
            me.previousColumn = me.column;
            me.previousColumnIndex = me.columnIndex;
            me.previousPosition = me.position.clone();
            // Track the last selectionStart position to correctly track ranges (i.e., SHIFT + selection).
            me.selectionStart = selModel.selectionStart;
            // Set our CellContext to the new position
            me.position.setAll(view, me.recordIndex = newRecordIndex, me.columnIndex = newColumnIndex, me.record = newRecord, me.column = newColumn);
            if (clearing) {
                me.item = me.cell = null;
            } else {
                me.focusPosition(me.position, preventNavigation);
            }
            // Legacy API is that the SelectionModel fires focuschange events and the TableView fires rowfocus and cellfocus events.
            if (!suppressEvent) {
                selModel.fireEvent('focuschange', selModel, me.previousRecord, me.record);
                view.fireEvent('rowfocus', me.record, me.item, me.recordIndex);
                view.fireEvent('cellfocus', me.record, me.cell, me.position);
            }
            // If we have moved, fire an event
            if (keyEvent && !preventNavigation && me.cell !== me.previousCell) {
                me.fireNavigateEvent(keyEvent);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.template.Template
@extends Ext.XTemplate

Base class of all UI task templates. Subclass this class to implement your own UI template.
*/
Ext.define("Gnt.template.Template", {
    extend: 'Ext.XTemplate',
    disableFormats: true,
    isLegacyIE: Ext.isIE8m,
    getInnerTpl: Ext.emptyFn,
    innerTpl: null,
    dependencyTerminalMarkup: '<div class="sch-gantt-terminal sch-gantt-terminal-start"></div><div class="sch-gantt-terminal sch-gantt-terminal-end"></div>',
    constructor: function(cfg) {
        Ext.apply(this, cfg);
        var side = cfg.rtl ? 'right' : 'left';
        var inner = this.getInnerTpl(cfg) || '';
        this.callParent([
            '<div class="sch-event-wrap {ctcls} ' + Ext.baseCSSPrefix + 'unselectable" style="' + side + ':{offset}px">',
            '<tpl if="isRollup">',
            inner,
            '<tpl else>',
            (cfg.leftLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{leftLabel}</label></div>' : ''),
            (cfg.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : ''),
            (cfg.topLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-top"><label class="sch-gantt-label sch-gantt-label-top">{topLabel}</label></div>' : ''),
            inner,
            (cfg.bottomLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-bottom"><label class="sch-gantt-label sch-gantt-label-bottom">{bottomLabel}</label></div>' : ''),
            '</tpl>',
            '</div>'
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.template.Task
@extends Ext.XTemplate

Template class used to render a regular leaf task.
*/
Ext.define("Gnt.template.Task", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}" unselectable="on">&#160;</div>',
    getInnerTpl: function(cfg) {
        var side = cfg.rtl ? 'right' : 'left';
        return '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-task-bar {cls}" unselectable="on" style="width:{width}px;{style}">' + '<tpl if="isRollup">' + '<tpl else>' + '<tpl if="segments">' + '<div class="sch-gantt-segment-connector"></div>' + '</tpl>' + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'left') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-start"></div>' : '') + '<tpl for="segments">' + '<div id="' + cfg.prefix + '{parent.Id}-segment-{[xindex-1]}" class="sch-gantt-task-segment {cls}" style="' + side + ':{left}px;width:{width}px;{style}"' + ' data-segmentIndex="{[xindex-1]}">' + this.innerTpl + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : '') + '</div>' + '</tpl>' + this.innerTpl + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : '') + (cfg.enableProgressBarResize ? '<div style="' + side + ':{progressBarWidth}px" class="sch-gantt-progressbar-handle"></div>' : '') + // Left / Right terminals
        (cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') + '</tpl>' + '</div>';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.template.ParentTask
@extends Ext.XTemplate

Class used to render a parent task.
*/
Ext.define("Gnt.template.ParentTask", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}">&#160;</div>' + '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-leftarrow"></div>' + '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-rightarrow"></div>',
    getInnerTpl: function(cfg) {
        return '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-parenttask-bar {cls}" style="width:{width}px; {style}">' + this.innerTpl + // Left / Right terminals
        ((cfg.enableDependencyDragDrop && cfg.allowParentTaskDependencies) ? this.dependencyTerminalMarkup : '') + '</div>';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.template.Milestone
@extends Ext.XTemplate

Class used to render a milestone task.
*/
Ext.define("Gnt.template.Milestone", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the milestone task.
     * Please note that this markup may be different depending on the browser used.
     */
    innerTpl: (Ext.isIE8m ? ('<div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-top {cls}" unselectable="on"></div>' + '<div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-bottom {cls}" unselectable="on"></div>') : ('<img style="{[values.print ? "height:" + values.side + "px;border-left-width:" + values.side + "px" : ""]};{style}" src="' + Ext.BLANK_IMAGE_URL + '" class="sch-gantt-milestone-diamond {cls}" unselectable="on"/>')),
    getInnerTpl: function(cfg) {
        return '<div ' + (this.isLegacyIE ? 'style="width:{[Math.floor(values.side*0.7)]}px"' : '') + ' id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-milestone-diamond-ct">' + this.innerTpl + '<tpl if="isRollup">' + '<tpl else>' + // Milestone diamond, 2 elements for old IE
        // Dependency terminals
        (cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') + '</tpl>' + '</div>';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define("Gnt.template.RollupTask", {
    extend: 'Ext.XTemplate',
    text: '<div class="sch-rollup-wrap">' + '<tpl for=".">' + '{[values.tpl.apply(values)]}' + '</tpl>' + '</div>',
    constructor: function(cfg) {
        this.callParent([
            this.text
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.template.Deadline
 @extends Ext.XTemplate

 Template class rendering deadline markers.
 */
Ext.define("Gnt.template.Deadline", {
    extend: 'Ext.XTemplate',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    disableFormats: true,
    markup: '<div data-qtip="__DEADLINE__:  {date}" data-qalign="b-tl" class="gnt-deadline-indicator {cls}" style="{dir}:{offset}px"></div>',
    constructor: function() {
        this.markup = this.markup.replace(/__DEADLINE__/, this.L('deadline'));
        this.callParent([
            this.markup
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This mixin provides a grid view component with more canvases it can draw onto.
 *
 * There're two kinds of canvases provided:
 *  - secondary canvases which are created once and are outside of a node container
 *  - items canvases which might be deleted by the grid's original view and thus might be constantly recreated when
 *    requested, items canvases are created within node container, i.e. somewhere alongside item corresponding
 *    HTML elements
 *
 * NOTE: regardles of a canvas type a canvas consummer shall not store canvas reference, it shall always re-request
 *       a canvas.
 */
Ext.define('Sch.mixin.GridViewCanvas', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        after: {
            'onRender': 'afterOnRender'
        }
    },
    secondaryCanvasCls: 'sch-secondary-canvas',
    secondaryCanvasLayerCls: 'sch-secondary-canvas-layer',
    itemsCanvasEl: null,
    itemsCanvasCls: 'sch-item-canvas',
    itemsCanvasLayerCls: 'sch-item-canvas-layer',
    /**
     * Returns a sub canvas el - the el to be used for drawing column lines, zones etc
     *
     * @param {Number} layer
     * @param {Object|Function|String} layerCreationSpecification
     * @return {Ext.dom.Element}
     */
    getSecondaryCanvasEl: function() {
        var el = null;
        if (this.isItemCanvasAvailable()) {
            el = this.getItemCanvasEl(-1, {
                tag: 'div',
                role: 'presentation',
                cls: this.secondaryCanvasCls
            });
        }
        return el;
    },
    /**
     * Returns true if canvas is available.
     *
     * @param {Number} [layer]  Use this to fine grain the query to the presence of a specific layer
     *
     * @return {Boolean}
     */
    isItemCanvasAvailable: function(layer) {
        var me = this;
        return me.rendered && !me.isDestroyed && me.getNodeContainer() && (layer === undefined || me.itemsCanvasEl && me.itemsCanvasEl[layer] && !Ext.isGarbage(me.itemsCanvasEl[layer]));
    },
    /**
     * Returns a sub canvas element or it's child layer. This canvas element is attached to view's node
     * container, the canvas is volatile since node container contents are built using a template which has no
     * information about canvas element attached as node container's child. Thus one shouldn't cache the element instance
     * returned.
     *
     * @param {Number} layer
     * @param {Object|Function|String} layerCreationSpecification
     * @return {Ext.dom.Element}
     */
    getItemCanvasEl: function(layer, layerCreationSpecification) {
        var me = this,
            canvasEl = me.itemsCanvasEl,
            layerEl = canvasEl;
        Ext.Assert && Ext.Assert.truthy(me.isItemCanvasAvailable(), "Can't get sub canvas element, view's node container isn't rendered yet");
        if (!canvasEl || !canvasEl.dom || !canvasEl.dom.parentNode || !canvasEl.dom.parentNode.parentNode) {
            layerEl = canvasEl = me.itemsCanvasEl = Ext.fly(me.getNodeContainer()).insertFirst({
                cls: me.itemsCanvasCls
            });
        }
        if (arguments.length > 0) {
            layer = layer || 0;
            layerEl = canvasEl[layer] || Ext.dom.Query.selectNode('[data-sch-secondary-canvas-layer="' + layer + '"]', canvasEl.dom);
            // Make sure the element has not been wiped out of the DOM by the Ext JS buffered rendering
            if (!layerEl || !layerEl.dom || !layerEl.dom.parentNode.parentNode) {
                layerEl = canvasEl.createChild((Ext.isFunction(layerCreationSpecification) ? layerCreationSpecification() : layerCreationSpecification) || {
                    tag: 'div'
                });
                layerEl.set({
                    'data-sch-secondary-canvas-layer': layer
                });
                layerEl.setStyle('zIndex', layer);
                layerEl.addCls(me.itemsCanvasLayerCls);
                canvasEl[layer] = layerEl;
            }
        }
        return layerEl;
    },
    afterOnRender: function() {
        if (this.bufferedRenderer) {
            this.on('viewready', this.myOnReady, this);
        }
    },
    // Prevent Ext JS from destroying our item canvas element, which would mean we had to re-render its contents
    // constantly when scrolling fast which kills the frame rate
    myOnReady: function() {
        var buff = this.bufferedRenderer;
        var oldOnRangeFetched = buff.onRangeFetched;
        var me = this;
        buff.onRangeFetched = function() {
            var itemCanvas = me.getItemCanvasEl().dom;
            var nodeContainer = me.getNodeContainer();
            nodeContainer.removeChild(itemCanvas);
            var retVal = oldOnRangeFetched.apply(this, arguments);
            nodeContainer.insertBefore(itemCanvas, nodeContainer.firstChild);
            return retVal;
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.view.Gantt
@extends Sch.view.TimelineGridView

A view of the gantt panel. Use the {@link Gnt.panel.Gantt#getSchedulingView} method to get its instance from gantt panel.

*/
Ext.define("Gnt.view.Gantt", {
    extend: "Sch.view.TimelineGridView",
    alias: [
        'widget.ganttview'
    ],
    requires: [
        'Ext.dd.ScrollManager',
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Gnt.model.Task',
        'Gnt.template.Task',
        'Gnt.template.ParentTask',
        'Gnt.template.Milestone',
        'Gnt.template.RollupTask',
        'Gnt.template.Deadline',
        'Gnt.feature.TaskDragDrop',
        'Gnt.feature.ProgressBarResize',
        'Gnt.feature.TaskResize',
        'Sch.view.Horizontal'
    ],
    uses: [
        'Gnt.feature.LabelEditor',
        'Gnt.patches.LabelEditor',
        'Gnt.feature.DragCreator'
    ],
    mixins: [
        'Sch.mixin.GridViewCanvas',
        'Sch.mixin.FilterableTreeView'
    ],
    _cmpCls: 'sch-ganttview',
    scheduledEventName: 'task',
    trackOver: false,
    toggleOnDblClick: false,
    // private
    eventSelector: '.sch-gantt-item',
    eventWrapSelector: '.sch-event-wrap',
    barMargin: 4,
    progressBarResizer: null,
    taskResizer: null,
    taskDragDrop: null,
    dragCreator: null,
    resizeConfig: null,
    createConfig: null,
    dragDropConfig: null,
    progressBarResizeConfig: null,
    /**
     * @cfg {Object} dependencyViewConfig
     *
     * A config object to apply to internal instance of the {@link Gnt.view.Dependency}. Inner properties like {@link Gnt.view.Dependency#dragZoneConfig} and {@link Gnt.view.Dependency#dropZoneConfig}
     * will be applied to the dependency drag- and dropzone instances respectively.
     *
     * @deprecated 4.2 use {@link Gnt.view.dependency.Mixin#dependencyViewConfig} instead
     */
    externalGetRowClass: null,
    /**
     * @cfg {Number} outsideLabelsGatherWidth Defines width of special zone outside (before and after) of visible area within which tasks will be still rendered into DOM.
     * This is used to render partially visible labels of invisible tasks bordering with visible area.
     *
     * Increase this value to see long labels, set to 0 if you want to hide labels of invisible tasks completely.
     */
    outsideLabelsGatherWidth: 200,
    // Task click-events --------------------------
    /**
     * @event taskclick
     * Fires when a task is clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskdblclick
     * Fires when a task is double clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskcontextmenu
     * Fires when contextmenu is activated on a task
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    // Resizing events start --------------------------
    /**
     * @event beforetaskresize
     * Fires before a resize starts, return false to stop the execution
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskresizestart
     * Fires when resize starts
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     */
    /**
     * @event partialtaskresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The start date of the task
     * @param {Date} endDate The end date of the task
     * @param {Ext.Element} element The element being resized
     */
    /**
     * @event aftertaskresize
     * Fires after a succesful resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task that has been resized
     */
    // Task progress bar resizing events start --------------------------
    /**
     * @event beforeprogressbarresize
     * Fires before a progress bar resize starts, return false to stop the execution
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */
    /**
     * @event progressbarresizestart
     * Fires when a progress bar resize starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */
    /**
     * @event afterprogressbarresize
     * Fires after a succesful progress bar resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord record The updated record
     */
    // Dnd events start --------------------------
    /**
     * @event beforetaskdrag
     * Fires before a task drag drop is initiated, return false to cancel it
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskdragstart
     * Fires when a dnd operation starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record being dragged
     */
    /**
     * @event beforetaskdropfinalize
     * Fires before a succesful drop operation is finalized. Return false to finalize the drop at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} dragContext An object containing 'record', 'start', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event beforetaskresizefinalize
     * Fires before a succesful resize operation is finalized. Return false to finalize the resize at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} resizeContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event beforedragcreatefinalize
     * Fires before a succesful create operation is finalized. Return false to finalize creating at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} createContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskdrop
     * Fires after a succesful drag and drop operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The dropped record
     */
    /**
     * @event aftertaskdrop
     * Fires after a drag and drop operation, regardless if the drop valid or invalid
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     */
    // Label editors events --------------------------
    /**
     * @event labeledit_beforestartedit
     * Fires before editing is started for a field
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     */
    /**
     * @event labeledit_beforecomplete
     * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */
    /**
     * @event labeledit_complete
     * Fires after editing is complete and any changed value has been written to the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */
    // Drag create events start --------------------------
    /**
     * @event beforedragcreate
     * Fires before a drag create operation starts, return false to prevent the operation
     * @param {Gnt.view.Gantt} gantt The gantt view
     * @param {Gnt.model.Task} task The task record being updated
     * @param {Date} date The date of the drag start point
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event dragcreatestart
     * Fires before a drag starts, return false to stop the operation
     * @param {Gnt.view.Gantt} view The gantt view
     */
    /**
     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     * @param {Gnt.model.Task} task The updated task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     */
    // Drag create events end --------------------------
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    constructor: function(config) {
        config = config || {};
        if (config) {
            this.externalGetRowClass = config.getRowClass;
            delete config.getRowClass;
        }
        this.callParent(arguments);
        this.on({
            itemupdate: this.onRowUpdate,
            scope: this
        });
        this.mon(this.taskStore, {
            update: this.onTaskStoreUpdate,
            scope: this
        });
        this.initTreeFiltering();
    },
    onBeforeIndentationChange: function() {
        var position = this.getNavigationModel().getPosition();
        if (position && position.record) {
            this._lastNavigatedRecord = position.record;
        }
    },
    onIndentationChange: function() {
        this._lastNavigatedRecord && this.getNavigationModel().setPosition(this._lastNavigatedRecord);
        delete this._lastNavigatedRecord;
    },
    onRender: function() {
        // 213_indent
        // save navigation position during indenting
        this.mon(this.getTaskStore(), {
            beforeindentationchange: this.onBeforeIndentationChange,
            indentationchange: this.onIndentationChange,
            scope: this
        });
        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments);
    },
    /**
     * Returns the associated dependency store
     * @return {Gnt.data.TaskStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    configureFeatures: function() {
        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create("Gnt.feature.ProgressBarResize", Ext.apply({
                ganttView: this
            }, this.progressBarResizeConfig || {}));
            this.on({
                beforeprogressbarresize: this.onBeforeTaskProgressBarResize,
                progressbarresizestart: this.onTaskProgressBarResizeStart,
                afterprogressbarresize: this.onTaskProgressBarResizeEnd,
                scope: this
            });
        }
        if (this.taskResizeHandles !== 'none') {
            this.taskResizer = Ext.create("Gnt.feature.TaskResize", Ext.apply({
                ganttView: this,
                validatorFn: this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.resizeConfig || {}));
            this.on({
                beforedragcreate: this.onBeforeDragCreate,
                beforetaskresize: this.onBeforeTaskResize,
                taskresizestart: this.onTaskResizeStart,
                aftertaskresize: this.onTaskResizeEnd,
                progressbarresizestart: this.onTaskResizeStart,
                afterprogressbarresize: this.onTaskResizeEnd,
                scope: this
            });
        }
        if (this.enableTaskDragDrop) {
            this.taskDragDrop = Ext.create("Gnt.feature.TaskDragDrop", this.getEl(), Ext.apply({
                gantt: this,
                taskSelector: this.eventSelector,
                deadlineSelector: '.gnt-deadline-indicator',
                validatorFn: this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope: this,
                skipWeekendsDuringDragDrop: this.taskStore.skipWeekendsDuringDragDrop
            }, this.dragDropConfig));
            this.on({
                beforetaskdrag: this.onBeforeTaskDrag,
                taskdragstart: this.onDragDropStart,
                aftertaskdrop: this.onDragDropEnd,
                scope: this
            });
        }
        if (this.enableDragCreation) {
            this.dragCreator = Ext.create("Gnt.feature.DragCreator", Ext.apply({
                ganttView: this,
                validatorFn: this.createValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.createConfig));
        }
    },
    /**
     * Returns the template for the task. Override this template method to supply your own custom UI template for a certain type of task.
     *
     * @template
     * @protected
     * @param {Gnt.model.Task} task The task to get template for.
     * @param {Boolean} isBaseline True to return the template for a baseline version of the task.
     * @return {Gnt.template.Template} Template for the task.
     */
    getTemplateForTask: function(task, isBaseline) {
        if (task.isMilestone(isBaseline)) {
            return this.milestoneTemplate;
        }
        if (task.isLeaf()) {
            return this.eventTemplate;
        }
        // return baseline templates
        return this.parentEventTemplate;
    },
    refreshNotReadOnlyChildNodes: function(record) {
        record.cascadeBy({
            // if a child is explicitly marked as readonly then parent readonly change
            // doesn't affect the child state so we don't cascade it or its children
            before: function(child) {
                return child == record || !child.getReadOnly();
            },
            after: function(child) {
                if (child !== record) {
                    this.refreshNode(child);
                }
            },
            scope: this
        });
    },
    setShowRollupTasks: function(show) {
        this.showRollupTasks = show;
        var parentNodes = {};
        this.taskStore.getRootNode().cascadeBy(function(node) {
            if (node.getRollup()) {
                var parentNode = node.parentNode;
                parentNodes[parentNode.internalId] = parentNode;
            }
        });
        for (var id in parentNodes) {
            var index = this.store.indexOf(parentNodes[id]);
            if (index >= 0) {
                this.refreshNode(index);
            }
        }
    },
    //Todo combine generic parts this function with columnRenderer
    getRollupRenderData: function(parentModel) {
        var rollupData = [];
        var ta = this.timeAxis,
            viewStart = ta.getStart(),
            viewEnd = ta.getEnd();
        for (var i = 0; i < parentModel.childNodes.length; i++) {
            var taskModel = parentModel.childNodes[i];
            var taskStart = taskModel.getStartDate();
            var taskEnd = taskModel.getEndDate() || taskStart && Sch.util.Date.add(taskStart, taskModel.getDurationUnit() || Sch.util.Date.DAY, 1);
            if (taskModel.getRollup() && taskStart && taskEnd) {
                if (Sch.util.Date.intersectSpans(taskStart, taskEnd, viewStart, viewEnd)) {
                    var data = {},
                        isMileStone = taskModel.isMilestone();
                    data.isRollup = true;
                    data.id = 'rollup_' + taskModel.getId();
                    var endsOutsideView = taskEnd > viewEnd,
                        startsInsideView = Sch.util.Date.betweenLesser(taskStart, viewStart, viewEnd),
                        taskStartX = this.getCoordinateFromDate(startsInsideView ? taskStart : viewStart),
                        taskEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskEnd),
                        itemWidth = isMileStone ? 0 : taskEndX - taskStartX;
                    data.offset = (isMileStone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX);
                    data.tpl = isMileStone ? this.milestoneTemplate : this.eventTemplate;
                    data.cls = taskModel.getCls();
                    data.ctcls = '';
                    data.record = taskModel;
                    if (isMileStone) {
                        data.side = Ext.isIE8m ? Math.round(0.3 * this.getRowHeight()) : Math.round(0.5 * this.getRowHeight());
                        data.ctcls += ' sch-gantt-milestone';
                    } else {
                        data.width = Math.max(1, itemWidth);
                        if (endsOutsideView) {
                            data.ctcls += ' sch-event-endsoutside ';
                        }
                        if (!startsInsideView) {
                            data.ctcls += ' sch-event-startsoutside ';
                        }
                        data.ctcls += ' sch-gantt-task';
                    }
                    if (taskModel.isReadOnly()) {
                        data.ctcls += ' sch-gantt-task-readonly';
                    }
                    if (taskModel.isProject) {
                        data.ctcls += ' sch-gantt-project-task';
                    }
                    data.cls += ' sch-rollup-task';
                    rollupData.push(data);
                }
            }
        }
        return rollupData;
    },
    getLabelRenderData: function(taskModel) {
        var left = this.leftLabelField,
            right = this.rightLabelField,
            top = this.topLabelField,
            bottom = this.bottomLabelField,
            value,
            renderData = {};
        if (left) {
            value = left.dataIndex ? taskModel.data[left.dataIndex] : undefined;
            renderData.leftLabel = left.renderer ? left.renderer.call(left.scope || this, value, taskModel) : Ext.util.Format.htmlEncode(value);
        }
        if (right) {
            value = right.dataIndex ? taskModel.data[right.dataIndex] : undefined;
            renderData.rightLabel = right.renderer ? right.renderer.call(right.scope || this, value, taskModel) : Ext.util.Format.htmlEncode(value);
        }
        if (top) {
            value = top.dataIndex ? taskModel.data[top.dataIndex] : undefined;
            renderData.topLabel = top.renderer ? top.renderer.call(top.scope || this, value, taskModel) : Ext.util.Format.htmlEncode(value);
        }
        if (bottom) {
            value = bottom.dataIndex ? taskModel.data[bottom.dataIndex] : undefined;
            renderData.bottomLabel = bottom.renderer ? bottom.renderer.call(bottom.scope || this, value, taskModel) : Ext.util.Format.htmlEncode(value);
        }
        return renderData;
    },
    // private
    columnRenderer: function(value, meta, taskModel) {
        var taskStart = taskModel.getStartDate(),
            ta = this.timeAxis,
            D = Sch.util.Date,
            tplData = {},
            cellResult = '',
            ctcls = '',
            viewStart = ta.getStart(),
            viewEnd = ta.getEnd(),
            isMilestone = taskModel.isMilestone(),
            labelsRenderDataPrepared = false,
            userData, startsInsideView, endsOutsideView;
        if (taskStart) {
            var taskEnd = taskModel.getEndDate() || D.add(taskStart, taskModel.getDurationUnit() || D.DAY, 1),
                tick = ta.getAt(0),
                // milliseconds per pixel ratio
                msPerPx = (tick.getEndDate() - tick.getStartDate()) / this.timeAxisViewModel.getTickWidth(),
                timeDelta = msPerPx * this.outsideLabelsGatherWidth,
                // if task belongs to the visible time span
                doRender = D.intersectSpans(taskStart, taskEnd, viewStart, viewEnd),
                renderBuffer = this.outsideLabelsGatherWidth > 0,
                // if task belongs to the buffered zone before/after visible time span
                renderAfter = renderBuffer && D.intersectSpans(taskStart, taskEnd, viewEnd, new Date(viewEnd.getTime() + timeDelta)),
                renderBefore = renderBuffer && D.intersectSpans(taskStart, taskEnd, new Date(viewStart.getTime() - timeDelta), viewStart);
            // if task belongs to the visible time span
            // or belongs to the buffered zone before/after visible time span
            if (doRender || renderAfter || renderBefore) {
                endsOutsideView = taskEnd > viewEnd;
                startsInsideView = D.betweenLesser(taskStart, viewStart, viewEnd);
                var taskStartX, taskEndX, itemWidth;
                // regular case ..task intersects visible time span
                if (doRender) {
                    taskStartX = this.getCoordinateFromDate(startsInsideView ? taskStart : viewStart);
                    taskEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskEnd);
                    itemWidth = isMilestone ? 0 : taskEndX - taskStartX;
                } else // task belongs to the buffered zone before/after visible time span
                {
                    startsInsideView = true;
                    itemWidth = 0;
                    if (renderAfter) {
                        taskStartX = Math.floor(this.getCoordinateFromDate(viewEnd) + (taskStart - viewEnd) / msPerPx);
                    } else {
                        taskStartX = Math.floor(this.getCoordinateFromDate(viewStart) - (viewStart - taskEnd) / msPerPx);
                    }
                }
                var taskOffset = isMilestone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX;
                // if task is partially hidden progress bar should be rendered accordingly
                // eg. task is halfway done and rendered only half of the task
                // progress bar in this case should be hidden (width is 0)
                var percentDone = Math.min(taskModel.getPercentDone() || 0, 100) / 100,
                    percentDoneAtDate, percentDoneX, progressBarWidth;
                var parts = taskModel.getSegments(),
                    segments;
                // if task is split
                if (parts) {
                    var percentDoneDuration = 0,
                        partsNumber = parts.length,
                        i, part;
                    // since task is fragmented we cannot use just: (taskEnd - taskStart) * percentDone
                    // we have to get sum of all parts instead
                    for (i = 0; i < partsNumber; i++) {
                        part = parts[i];
                        percentDoneDuration += (part.getEndDate() - part.getStartDate()) * percentDone;
                    }
                    segments = [];
                    var partStartX, partEndX, partStartDate, partEndDate;
                    for (i = 0; i < partsNumber; i++) {
                        part = parts[i];
                        var segment = {},
                            segmentCls = part.getCls() || '';
                        partEndDate = part.getEndDate() || taskModel.getStartDate();
                        partStartDate = part.getStartDate();
                        // if this segment starts in the visible area
                        if (D.betweenLesser(partStartDate, viewStart, viewEnd)) {
                            partStartX = this.getCoordinateFromDate(partStartDate);
                            // if it ends in visible area as well
                            if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                                partEndX = this.getCoordinateFromDate(partEndDate);
                            } else {
                                partEndX = this.getCoordinateFromDate(viewEnd);
                            }
                        } else // if its start is invisible
                        {
                            partStartX = this.getCoordinateFromDate(viewStart);
                            // if end is visible
                            if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                                partEndX = this.getCoordinateFromDate(partEndDate);
                            }
                            // if both ends are invisible lets move them outside of visible area
                            else if (partStartDate > viewEnd && partEndDate > viewEnd) {
                                partStartX = partEndX = this.getCoordinateFromDate(viewEnd) + 100;
                            } else if (partStartDate < viewStart && partEndDate < viewStart) {
                                partStartX = partEndX = this.getCoordinateFromDate(viewStart) - 100;
                            } else // if segment start before view start and ends after view end
                            {
                                partEndX = this.getCoordinateFromDate(viewEnd);
                            }
                        }
                        segment.left = partStartX - taskStartX;
                        segment.width = partEndX - partStartX;
                        if (!percentDoneAtDate) {
                            percentDoneDuration -= (partEndDate - partStartDate);
                            if (percentDoneDuration <= 0) {
                                percentDoneAtDate = D.add(partEndDate, D.MILLI, percentDoneDuration);
                                // mark part that has progress bar slider
                                segmentCls += ' sch-segment-in-progress';
                                percentDoneX = this.getCoordinateFromDate(percentDoneAtDate);
                                // get progress bar size for this part
                                segment.progressBarWidth = Math.min(Math.abs(percentDoneX - partStartX), segment.width);
                            } else // all parts before the time span that has "percentDoneAtDate" have 100% percent done
                            {
                                segment.progressBarWidth = part.width;
                            }
                        } else // all parts after the time span that has "percentDoneAtDate" have zero percent done
                        {
                            segment.progressBarWidth = 0;
                        }
                        segment.percentDone = percentDone * 100;
                        Ext.apply(segment, part.data);
                        segment.cls = segmentCls;
                        segment.SegmentIndex = i;
                        segments.push(segment);
                    }
                    segments[0].cls += ' sch-gantt-task-segment-first';
                    segments[partsNumber - 1].cls += ' sch-gantt-task-segment-last';
                } else // if task is NOT split
                {
                    // picks date between task start and end according to percentDone value
                    percentDoneAtDate = new Date((taskEnd - taskStart) * percentDone + taskStart.getTime());
                    if (percentDoneAtDate < viewStart) {
                        percentDoneAtDate = viewStart;
                    } else if (percentDoneAtDate > viewEnd) {
                        percentDoneAtDate = viewEnd;
                    }
                }
                percentDoneX = this.getCoordinateFromDate(percentDoneAtDate);
                // what if rtl?
                // in case task is rendered outside of view and has width 0, we should also set progress bar
                // width to 0 or progress bar will be visible as a 1px width vertical lines
                progressBarWidth = Math.min(Math.abs(percentDoneX - taskStartX), itemWidth);
                // Data provided to the Task XTemplate is composed in these steps
                //
                // 1. Get the default data from the Task Model
                // 2. Apply internal rendering properties: id, sizing, position etc
                // 3. Allow user to add extra properties at runtime using the eventRenderer template method
                tplData = {
                    // Core properties
                    id: taskModel.internalId + '-x-x',
                    offset: taskOffset,
                    width: Math.max(1, itemWidth),
                    ctcls: '',
                    cls: '',
                    print: this._print,
                    record: taskModel,
                    percentDone: percentDone * 100,
                    progressBarWidth: Math.max(0, progressBarWidth - 2 * this.eventBorderWidth),
                    segments: segments
                };
                // Get data from user "renderer"
                userData = this.eventRenderer && this.eventRenderer.call(this.eventRendererScope || this, taskModel, tplData, taskModel.store) || {};
                // Labels
                Ext.apply(tplData, this.getLabelRenderData(taskModel));
                labelsRenderDataPrepared = true;
                if (userData) {
                    Ext.apply(tplData, userData);
                }
                var dataCls = ' sch-event-resizable-' + taskModel.getResizable();
                if (isMilestone) {
                    tplData.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.getRowHeight());
                    ctcls += " sch-gantt-milestone";
                } else {
                    tplData.width = Math.max(1, itemWidth);
                    if (endsOutsideView) {
                        ctcls += ' sch-event-endsoutside ';
                    }
                    if (!startsInsideView) {
                        ctcls += ' sch-event-startsoutside ';
                    }
                    if (taskModel.isLeaf()) {
                        ctcls += " sch-gantt-task";
                    } else {
                        ctcls += " sch-gantt-parent-task";
                    }
                }
                if (taskModel.isReadOnly()) {
                    ctcls += " sch-gantt-task-readonly";
                }
                if (taskModel.isProject) {
                    ctcls += " sch-gantt-project-task";
                }
                if (taskModel.dirty)  {
                    dataCls += ' sch-dirty ';
                }
                
                if (taskModel.isDraggable() === false)  {
                    dataCls += ' sch-event-fixed ';
                }
                
                dataCls += taskModel.isSegmented() ? ' sch-event-segmented ' : ' sch-event-notsegmented ';
                tplData.cls = (tplData.cls || '') + (taskModel.getCls() || '') + dataCls;
                tplData.ctcls += ' ' + ctcls;
                if (this.showRollupTasks) {
                    var rollupData = this.getRollupRenderData(taskModel);
                    if (rollupData.length > 0) {
                        cellResult += this.rollupTemplate.apply(rollupData);
                    }
                }
                cellResult += this.getTemplateForTask(taskModel).apply(tplData);
            }
        }
        // if baselines enabled
        if (this.enableBaseline) {
            // userData might be not initialized if we do not render the task bar (unscheduled or out of visible span)
            if (!userData) {
                userData = this.eventRenderer && this.eventRenderer.call(this, taskModel, tplData, taskModel.store) || {};
            }
            // render baseline bar
            cellResult += this.baselineRenderer(taskModel, userData, viewStart, viewEnd, labelsRenderDataPrepared);
        }
        var deadline = taskModel.getDeadlineDate();
        if (deadline) {
            cellResult += this.deadlineTemplate.apply({
                dir: this.rtl ? 'right' : 'left',
                offset: this.getCoordinateFromDate(deadline),
                date: this.getFormattedEndDate(deadline),
                cls: (new Date() > deadline && !taskModel.isCompleted()) ? 'gnt-deadline-indicator-late' : ''
            });
        }
        return cellResult;
    },
    baselineRenderer: function(taskModel, userData, viewStart, viewEnd, labelsRenderDataPrepared) {
        var D = Sch.util.Date,
            taskBaselineStart = taskModel.getBaselineStartDate(),
            taskBaselineEnd = taskModel.getBaselineEndDate();
        if (taskBaselineStart && taskBaselineEnd && D.intersectSpans(taskBaselineStart, taskBaselineEnd, viewStart, viewEnd)) {
            var endsOutsideView = taskBaselineEnd > viewEnd;
            var startsInsideView = D.betweenLesser(taskBaselineStart, viewStart, viewEnd);
            userData = userData || {};
            var isBaselineMilestone = taskModel.isBaselineMilestone(),
                baseStartX = this.getCoordinateFromDate(startsInsideView ? taskBaselineStart : viewStart),
                baseEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskBaselineEnd),
                baseWidth = Math.max(1, isBaselineMilestone ? 0 : baseEndX - baseStartX),
                baseTpl = this.getTemplateForTask(taskModel, true),
                data = {
                    progressBarStyle: userData.baseProgressBarStyle || '',
                    // Putting 'base-' as suffix ('-base') conflicts with task element id creating rules where
                    // task element id is [commonprefix]-(task.internalId)-(resource.internalId)-(partnum)
                    id: 'base-' + taskModel.internalId,
                    // TODO: this should use same rendering as the regular task
                    progressBarWidth: Math.min(100, taskModel.getBaselinePercentDone()) * baseWidth / 100,
                    percentDone: taskModel.getBaselinePercentDone(),
                    offset: isBaselineMilestone ? (baseEndX || baseStartX) - this.getXOffset(taskModel, true) : baseStartX,
                    print: this._print,
                    width: Math.max(1, baseWidth),
                    baseline: true
                };
            var ctcls = '';
            if (isBaselineMilestone) {
                data.side = Math.round(0.4 * this.getRowHeight());
                ctcls = "sch-gantt-milestone-baseline sch-gantt-baseline-item";
            } else if (taskModel.isLeaf()) {
                ctcls = "sch-gantt-task-baseline sch-gantt-baseline-item";
            } else {
                ctcls = "sch-gantt-parenttask-baseline sch-gantt-baseline-item";
            }
            if (endsOutsideView) {
                ctcls += ' sch-event-endsoutside ';
            }
            if (!startsInsideView) {
                ctcls += ' sch-event-startsoutside ';
            }
            // HACK, a bit inconsistent. 'basecls' should probably end up on the task el instead of the wrapper.
            data.ctcls = ctcls + ' ' + (userData.basecls || '');
            if (!labelsRenderDataPrepared) {
                Ext.apply(data, this.getLabelRenderData(taskModel));
            }
            return baseTpl.apply(data);
        }
        return '';
    },
    setupTemplates: function() {
        var tplCfg = {
                leftLabel: this.leftLabelField,
                rightLabel: this.rightLabelField,
                topLabel: this.topLabelField,
                bottomLabel: this.bottomLabelField,
                prefix: this.eventPrefix,
                taskResizeHandles: this.taskResizeHandles,
                enableDependencyDragDrop: this.enableDependencyDragDrop !== false,
                allowParentTaskDependencies: this.allowParentTaskDependencies !== false,
                enableProgressBarResize: this.enableProgressBarResize,
                rtl: this.rtl
            };
        var config;
        if (!this.eventTemplate) {
            config = this.taskBodyTemplate ? Ext.apply({
                innerTpl: this.taskBodyTemplate
            }, tplCfg) : tplCfg;
            this.eventTemplate = Ext.create("Gnt.template.Task", config);
        }
        if (!this.parentEventTemplate) {
            config = this.parentTaskBodyTemplate ? Ext.apply({
                innerTpl: this.parentTaskBodyTemplate
            }, tplCfg) : tplCfg;
            this.parentEventTemplate = Ext.create("Gnt.template.ParentTask", config);
        }
        if (!this.milestoneTemplate) {
            config = this.milestoneBodyTemplate ? Ext.apply({
                innerTpl: this.milestoneBodyTemplate
            }, tplCfg) : tplCfg;
            this.milestoneTemplate = Ext.create("Gnt.template.Milestone", config);
        }
        if (!this.rollupTemplate) {
            this.rollupTemplate = Ext.create("Gnt.template.RollupTask");
        }
        if (!this.deadlineTemplate) {
            this.deadlineTemplate = Ext.create("Gnt.template.Deadline");
        }
    },
    /**
     * Wrapper function returning the dependency manager instance
     *
     * @return {Gnt.view.Dependency} dependencyManager The dependency manager instance
     *
     * @deprecated 4.2 Use {Gnt.view.dependency.Mixin#getDependencyView} instead
     */
    getDependencyView: function() {
        return this.ownerGrid.getDependencyView();
    },
    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    // To be compatible with Sch.view.dependency.View
    getEventStore: function() {
        return this.getTaskStore();
    },
    // private
    setupGanttEvents: function() {
        var me = this,
            taskStore = this.taskStore;
        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick: function(view, model) {
                    if (!model.isLeaf() && (!taskStore.isTreeFiltered() || taskStore.allowExpandCollapseWhileFiltered)) {
                        // Since row is being repainted in the DOM, no native 'dblclick' event will be fired
                        // We need to detect this case and fake it
                        var dblClickHandler = function() {
                                me.fireEvent.apply(this, [
                                    'taskdblclick'
                                ].concat(Array.prototype.slice.apply(arguments)));
                            };
                        me.on('taskclick', dblClickHandler);
                        // Remove listener after 300ms
                        me.unbindListenerTimer = setTimeout(function() {
                            me.un('taskclick', dblClickHandler);
                        }, 300);
                        model.isExpanded() ? model.collapse() : model.expand();
                    }
                }
            });
        }
    },
    // private
    configureLabels: function() {
        Ext.Array.each([
            'left',
            'right',
            'top',
            'bottom'
        ], function(pos) {
            var field = this[pos + 'LabelField'];
            if (field) {
                if (Ext.isString(field)) {
                    field = this[pos + 'LabelField'] = {
                        dataIndex: field
                    };
                }
                // Initialize editor (if defined)
                if (field.editor) {
                    field.editor = Ext.create("Gnt.feature.LabelEditor", this, {
                        labelPosition: pos,
                        field: field.editor,
                        dataIndex: field.dataIndex
                    });
                }
            }
        }, this);
        this.on('labeledit_beforestartedit', this.onBeforeLabelEdit, this);
    },
    // private
    onBeforeTaskDrag: function(p, record) {
        return !this.readOnly && record.isDraggable() !== false && (this.allowParentTaskMove || record.isLeaf());
    },
    onDragDropStart: function() {
        if (this.tip) {
            // HACK tip disable doesn't work in Ext 5.1
            // http://www.sencha.com/forum/showthread.php?296286-Ext.Tooltip-disable-doesn-t-work-in-5.1&p=1081931#post1081931
            this.tip.on('beforeshow', this.falseReturningFn);
        }
    },
    falseReturningFn: function() {
        return false;
    },
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.un('beforeshow', this.falseReturningFn);
        }
    },
    onTaskProgressBarResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },
    onTaskProgressBarResizeEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
    },
    onTaskResizeStart: function() {
        var scrollable = this.getScrollable();
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        // While resizing a task, we don't want the scroller to interfere
        scrollable.setDisabled && scrollable.setDisabled(true);
    },
    onTaskResizeEnd: function() {
        var scrollable = this.getScrollable();
        if (this.tip) {
            this.tip.enable();
        }
        // While resizing a task, we don't want the scroller to interfere
        scrollable.setDisabled && scrollable.setDisabled(false);
    },
    // private
    onBeforeDragCreate: function() {
        return !this.readOnly;
    },
    // private
    onBeforeTaskResize: function(view, task) {
        return !this.readOnly && task.getSchedulingMode() !== 'EffortDriven';
    },
    onBeforeTaskProgressBarResize: function() {
        return !this.readOnly;
    },
    onBeforeLabelEdit: function() {
        return !this.readOnly;
    },
    afterRender: function() {
        this.callParent(arguments);
        this.getEl().on('mousemove', this.configureFeatures, this, {
            single: true
        });
        Ext.dd.ScrollManager.register(this.el);
    },
    resolveTaskRecord: function(el) {
        var node = this.findItemByChild(el);
        if (node) {
            return this.getRecord(node);
        }
        return null;
    },
    resolveEventRecord: function(el) {
        return this.resolveTaskRecord(el);
    },
    resolveEventRecordFromResourceRow: function(el) {
        return this.resolveTaskRecord(el);
    },
    /**
     * Highlights a task and optionally any dependent tasks. Highlighting will add the `sch-gantt-task-highlighted`
     * class to the task row element.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} highlightDependentTasks `true` to highlight the depended tasks. Defaults to `true`
     *
     */
    highlightTask: function(task, highlightDependentTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getModelById(task);
        }
        if (task) {
            task.isHighlighted = true;
            var el = this.getRow(task);
            if (el) {
                Ext.fly(el).addCls('sch-gantt-task-highlighted');
            }
            if (highlightDependentTasks !== false) {
                for (var i = 0,
                    l = task.successors.length; i < l; i++) {
                    var dep = task.successors[i];
                    this.highlightDependency(dep);
                    this.highlightTask(dep.getTargetTask(), highlightDependentTasks);
                }
            }
        }
    },
    /**
     * Un-highlights a task and optionally any dependent tasks.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} includeSuccessorTasks `true` to also highlight successor tasks. Defaults to `true`
     *
     */
    unhighlightTask: function(task, includeSuccessorTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getModelById(task);
        }
        if (task) {
            task.isHighlighted = false;
            var el = this.getRow(task);
            if (el) {
                Ext.fly(el).removeCls('sch-gantt-task-highlighted');
            }
            if (includeSuccessorTasks !== false) {
                for (var i = 0,
                    l = task.successors.length; i < l; i++) {
                    var dep = task.successors[i];
                    this.unhighlightDependency(dep);
                    this.unhighlightTask(dep.getTargetTask(), includeSuccessorTasks);
                }
            }
        }
    },
    getRowClass: function(task) {
        var cls = '';
        if (task.isHighlighted)  {
            cls = 'sch-gantt-task-highlighted';
        }
        
        if (this.externalGetRowClass)  {
            cls += ' ' + (this.externalGetRowClass.apply(this, arguments) || '');
        }
        
        return cls;
    },
    // private
    clearSelectedTasksAndDependencies: function() {
        this.ownerGrid.getDependencyView().clearSelectedDependencies();
        this.el.select('.sch-gantt-task-highlighted').removeCls('sch-gantt-task-highlighted');
        this.taskStore.getRootNode().cascadeBy(function(task) {
            task.isHighlighted = false;
        });
    },
    /**
     * Returns the critical path(s) that can affect the end date of the project
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths: function() {
        return this.taskStore.getCriticalPaths();
    },
    /**
     * Highlights the critical path(s) that can affect the end date of the project.
     */
    highlightCriticalPaths: function() {
        // First clear any selected tasks/dependencies
        this.clearSelectedTasksAndDependencies();
        var paths = this.getCriticalPaths(),
            dm = this.getDependencyView(),
            t, i, l, depRecord;
        Ext.Array.each(paths, function(tasks) {
            for (i = 0 , l = tasks.length; i < l; i++) {
                t = tasks[i];
                this.highlightTask(t, false);
                if (i < l - 1) {
                    for (var j = 0,
                        m = t.predecessors.length; j < m; j++) {
                        if (t.predecessors[j].getSourceId() == tasks[i + 1].getId()) {
                            depRecord = t.predecessors[j];
                            break;
                        }
                    }
                    dm.highlightDependency(depRecord);
                }
            }
        }, this);
        this.addCls('sch-gantt-critical-chain');
    },
    /**
     * Removes the highlighting of the critical path(s).
     */
    unhighlightCriticalPaths: function() {
        this.removeCls('sch-gantt-critical-chain');
        this.clearSelectedTasksAndDependencies();
    },
    //private
    getXOffset: function(task, isBaseline) {
        var offset = 0;
        if (task.isMilestone(isBaseline)) {
            // For milestones, the offset should be half the square diagonal (Math.sqrt(2) / 4)
            offset = Math.floor(this.getRowHeight() * 0.3535533905932738) - 2;
        }
        return offset;
    },
    //private
    onDestroy: function() {
        if (this.rendered) {
            Ext.dd.ScrollManager.unregister(this.el);
        }
        clearTimeout(this.scrollTimer);
        clearTimeout(this.unbindListenerTimer);
        this.callParent(arguments);
    },
    /**
     * Convenience method wrapping the dependency manager method which highlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    highlightDependency: function(record) {
        this.ownerGrid.getDependencyView().highlightDependency(record);
    },
    /**
     * Convenience method wrapping the dependency manager method which unhighlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    unhighlightDependency: function(record) {
        this.ownerGrid.getDependencyView().unhighlightDependency(record);
    },
    /**
     * Returns the editor defined for the left task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getLeftEditor: function() {
        return this.leftLabelField && this.leftLabelField.editor;
    },
    /**
     * Returns the editor defined for the right task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getRightEditor: function() {
        return this.rightLabelField && this.rightLabelField.editor;
    },
    /**
     * Returns the editor defined for the top task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getTopEditor: function() {
        return this.topLabelField && this.topLabelField.editor;
    },
    /**
     * Returns the editor defined for the bottom task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getBottomEditor: function() {
        return this.bottomLabelField && this.bottomLabelField.editor;
    },
    /**
     * Programmatically activates the editor for the left label
     * @param {Gnt.model.Task} record The task record
     */
    editLeftLabel: function(record) {
        var ed = this.getLeftEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the right label
     * @param {Gnt.model.Task} record The task record
     */
    editRightLabel: function(record) {
        var ed = this.getRightEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the top label
     * @param {Gnt.model.Task} record The task record
     */
    editTopLabel: function(record) {
        var ed = this.getTopEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the bottom label
     * @param {Gnt.model.Task} record The task record
     */
    editBottomLabel: function(record) {
        var ed = this.getBottomEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * @private
     * @deprecated 4.0
     */
    getDependenciesForTask: function(record) {
        window.console && console.warn && console.warn('`Gnt.view.Gantt::getDependenciesForTask()` is deprecated, use `task.getAllDependencies()` instead');
        return record.getAllDependencies();
    },
    // Repaint parents of rollup tasks and readonly child tasks
    onRowUpdate: function(store, index) {
        var record = this.store.getAt(index);
        var prev = record.previous;
        if (prev) {
            // The code below will handle the redraw when user does "setRollup" on some task
            // However generally the parent tasks are refreshed at the end of the cascading in the `onAfterCascade` method
            // of the Gnt.panel.Gantt
            if (record.parentNode && (record.rollupField in prev || record.getRollup())) {
                this.refreshNode(record.parentNode);
            }
            // refresh the task child nodes when the task readOnly status changes
            if (record.readOnlyField in prev) {
                this.refreshNotReadOnlyChildNodes(record);
            }
        }
    },
    // Repaint parents of rollup tasks if such tasks are hidden due to collapsed parent and update is done
    // via undo-redo (though there might be other cases when rollup task is changed and those changes might
    // not propagate to a parent task, if, for example, recalculate parents or cascade changes are off)
    onTaskStoreUpdate: function(taskStore, task, operation, modifiedFieldNames, details) {
        var prev = task.previous;
        if (prev && task.getRollup() && task.parentNode && !task.parentNode.expanded && taskStore.isUndoingOrRedoing()) {
            this.refreshNode(task.parentNode);
        }
    },
    handleScheduleEvent: function(e) {
        var t = e.getTarget('.' + this.timeCellCls, 3);
        if (t) {
            var rowNode = this.findRowByChild(t);
            if (e.type.indexOf('pinch') >= 0) {
                this.fireEvent('schedule' + e.type, this, e);
            } else {
                this.fireEvent('schedule' + e.type, this, this.getDateFromDomEvent(e, 'floor'), this.indexOf(rowNode), e);
            }
        }
    },
    /**
     *  Scrolls a task record into the viewport.
     *  This method will also expand all relevant parent nodes to locate the event.
     *
     *  @param {Gnt.model.Task} taskRec, the task record to scroll into view
     *  @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     *  @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     */
    scrollEventIntoView: function(taskRec, highlight, animate, callback, scope) {
        scope = scope || this;
        var me = this;
        var taskStore = this.taskStore;
        var basicScroll = function(el, scrollHorizontally) {
                // HACK
                // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
                // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                me.up('panel').scrollTask.cancel();
                me.scrollElementIntoView(el, scrollHorizontally, animate);
                if (highlight) {
                    if (typeof highlight === "boolean") {
                        el.highlight();
                    } else {
                        el.highlight(null, highlight);
                    }
                }
                // XXX callback will be called too early, need to wait for scroll & highlight to complete
                callback && callback.call(scope);
            };
        // Make sure the resource is expanded all the way up first.
        if (!taskRec.isVisible()) {
            taskRec.bubble(function(node) {
                node.expand();
            });
        }
        var targetEl;
        var startDate = taskRec.getStartDate();
        var endDate = taskRec.getEndDate();
        var isScheduled = Boolean(startDate && endDate);
        if (isScheduled) {
            var timeAxis = this.timeAxis;
            // If task is not in the currently viewed time span, change time span
            if (!timeAxis.dateInAxis(startDate) || !timeAxis.dateInAxis(endDate)) {
                var range = timeAxis.getEnd() - timeAxis.getStart();
                timeAxis.setTimeSpan(new Date(startDate.getTime() - range / 2), new Date(endDate.getTime() + range / 2));
            }
            targetEl = this.getElementFromEventRecord(taskRec);
        } else {
            // No date information in the task, scroll to row element instead
            targetEl = this.getNode(taskRec);
            if (targetEl) {
                targetEl = Ext.fly(targetEl).down(this.getCellSelector());
            }
        }
        if (targetEl) {
            basicScroll(targetEl, isScheduled);
        } else {
            if (this.bufferedRenderer) {
                this.scrollTimer = Ext.Function.defer(function() {
                    me.bufferedRenderer.scrollTo(taskRec, false, function() {
                        // el should be present now
                        var targetEl = me.getElementFromEventRecord(taskRec);
                        if (targetEl) {
                            basicScroll(targetEl, true);
                        } else {
                            callback && callback.call(scope);
                        }
                    });
                }, 10);
            }
        }
    },
    /**
     * Gets the task box of the given task.
     *
     * @param {Sch.model.Event} taskRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximately calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     */
    getItemBox: function(taskRecord) {
        var DATE = Sch.util.Date,
            me = this,
            result = null,
            viewStartDate = me.timeAxis.getStart(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            viewEndDate = me.timeAxis.getEnd(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            // For milestones we tend to use end date since there might be a milestone having non-zero duration and in such case
            // no full length task bar is rendered, we just render a "diamond" on the end date
            taskStartDate = taskRecord.isMilestone() && taskRecord.getEndDate() || taskRecord.getStartDate(),
            taskEndDate = taskRecord.getEndDate(),
            taskStore = me.getTaskStore(),
            taskStartX, taskEndX, rowEl, rowIndex, rowTop, rowHeight, firstRowIndex, lastRowIndex, firstRowRecord;
        // Checking if task record is:
        result = // scheduled;
        (taskStartDate && taskEndDate && // - visible, i.e. it's not within a collapsed row
        // - actually rendered or might be filtered out by Sencha's filters
        me.store.indexOf(taskRecord) >= 0 && // - not filtered out
        (!taskStore.isTreeFiltered() || taskStore.lastTreeFilter.filter.call(taskStore.lastTreeFilter.scope || taskStore, taskRecord))) || null;
        if (result) {
            rowEl = me.getNode(taskRecord);
            // If task row is rendered
            if (rowEl) {
                var taskNodeTop, taskNodeBottom;
                var nodeContainer = me.getNodeContainer();
                var OUTSIDE_VIEW_OFFSET = 40;
                // To make sure non-relevant dependency lines aren't seen
                if (taskRecord.isMilestone()) {
                    var verticalMargin = me.getRowHeight() * 0.16;
                    rowTop = Ext.fly(rowEl).getOffsetsTo(nodeContainer)[1];
                    taskNodeTop = rowTop + verticalMargin;
                    taskNodeBottom = rowTop + me.getRowHeight() - verticalMargin;
                } else {
                    // task bar node might be outside visible time axis
                    var taskNode = Ext.fly(rowEl).down('.' + Ext.baseCSSPrefix + 'grid-cell-inner > .sch-event-wrap .sch-gantt-item', true) || rowEl;
                    taskNodeTop = Ext.fly(taskNode).getOffsetsTo(nodeContainer)[1];
                    taskNodeBottom = taskNodeTop + Ext.fly(taskNode).getHeight();
                }
                taskStartX = me.getCoordinateFromDate(DATE.min(DATE.max(taskStartDate, viewStartDate), viewEndDate));
                taskEndX = me.getCoordinateFromDate(DATE.max(DATE.min(taskEndDate, viewEndDate), viewStartDate));
                // Make sure start/end points are not in view
                if (viewStartDate > taskStartDate)  {
                    taskStartX -= OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewStartDate > taskEndDate)  {
                    taskEndX -= OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewEndDate < taskStartDate)  {
                    taskStartX += OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewEndDate < taskEndDate)  {
                    taskEndX += OUTSIDE_VIEW_OFFSET;
                }
                
                // Finally we have all the data needed to calculate the task record box
                result = {
                    rendered: true,
                    start: taskStartX,
                    end: taskEndX,
                    top: Math.round(taskNodeTop),
                    bottom: Math.round(taskNodeBottom)
                };
            } else // Resource row is not rendered and it's not collapsed. We calculate a task box approximately.
            {
                result = {
                    rendered: false,
                    start: me.getCoordinateFromDate(DATE.max(taskStartDate, viewStartDate)),
                    end: me.getCoordinateFromDate(DATE.min(taskEndDate, viewEndDate))
                };
                // top and bottom to go
                // WARNING: view.all is a private property
                firstRowIndex = me.all.startIndex;
                firstRowRecord = me.getRecord(firstRowIndex);
                if (firstRowRecord) {
                    rowHeight = me.getRowHeight();
                    if (taskRecord.isAbove(firstRowRecord)) {
                        result.top = -2 * rowHeight;
                        result.relPos = 'before';
                    } else {
                        // WARNING: view.all is the private property
                        lastRowIndex = me.all.endIndex;
                        rowEl = Ext.get(me.getNode(lastRowIndex));
                        result.top = rowEl.getOffsetsTo(me.getNodeContainer())[1] + rowEl.getHeight();
                        result.relPos = 'after';
                    }
                    result.bottom = result.top + rowHeight;
                } else {
                    result = null;
                }
            }
            // Milestone boxes need special adjustments
            if (result) {
                result = me.adjustItemBox(taskRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Gnt.model.Task} taskRecord
     * @param {Object} taskBox
     * @return {Number} taskBox.top
     * @return {Number} taskBox.bottom
     * @return {Number} taskBox.start
     * @return {Number} taskBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(taskRecord, taskBox) {
        var result = taskBox;
        if (taskRecord.isMilestone()) {
            result = {
                rendered: taskBox.rendered,
                top: taskBox.top,
                bottom: taskBox.bottom + 1,
                start: taskBox.start - 8,
                end: taskBox.end + 8,
                relPos: taskBox.relPos
            };
        }
        return result;
    },
    getDataForTooltipTpl: function(record, triggerElement) {
        var match = triggerElement.id.match(/rollup_(.*)$/);
        // If hovering a rollup miniature, we should show the rolled up task info
        if (match && match[1]) {
            var rolledUpRecord = this.getTaskStore().getNodeById(match[1]);
            if (rolledUpRecord) {
                record = rolledUpRecord;
            }
        }
        var data = this.callParent([
                record,
                triggerElement
            ]);
        data._useBaselineData = Boolean(Ext.fly(triggerElement).up('.sch-gantt-baseline-item'));
        return data;
    }
});
// Deprecated dependency related events
// NOTE: remove it after 4.4
/**
     * @event beforedependencydrag
     *
     * Fires before a dependency drag operation starts (from a "task terminal"). Return false to prevent this operation
     * from starting.
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The source task record
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#beforedependencydrag} instead
     */
/**
     * @event dependencydragstart
     *
     * Fires when a dependency drag operation starts
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#dependencydragstart} instead
     */
/**
     * @event dependencydrop
     *
     * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} fromRecord The source task record
     * @param {Gnt.model.Task} toRecord The destination task record
     * @param {Number} type The dependency type
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#dependencydrop} instead
     */
/**
     * @event afterdependencydragdrop
     *
     * Always fires after a dependency drag-drop operation
     *
     * @param {Gnt.panel.Gantt} gantt The gantt view instance
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#afterdependencydragdrop} instead
     */
/**
     * @event dependencyclick
     *
     * Fires after clicking on a dependency line/arrow
     *
     * @param {Gnt.view.Dependency} view The dependency view instance
     * @param {Gnt.model.Dependency} record The dependency record
     * @param {Ext.EventObject} event The event object
     * @param {HTMLElement} target The target of this event
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#dependencyclick} instead
     */
/**
     * @event dependencycontextmenu
     *
     * Fires after right clicking on a dependency line/arrow
     *
     * @param {Gnt.view.Dependency} view The dependency view instance
     * @param {Gnt.model.Dependency} record The dependency record
     * @param {Ext.EventObject} event The event object
     * @param {HTMLElement} target The target of this event
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#dependencycontextmenu} instead
     */
/**
     * @event dependencydblclick
     *
     * Fires after double clicking on a dependency line/arrow
     *
     * @param {Gnt.view.Dependency} view The dependency view instance
     * @param {Gnt.model.Dependency} record The dependency record
     * @param {Ext.EventObject} event The event object
     * @param {HTMLElement} target The target of this event
     *
     * @deprecated 4.2 Use {@link Gnt.panel.Gantt#dependencydblclick} instead
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2127
// https://www.sencha.com/forum/showthread.php?296729
Ext.define('Gnt.patches.RightClick', {
    extend: 'Sch.util.Patch',
    target: 'Gnt.view.Gantt',
    maxVersion: '6.0.1',
    // Open in 6.0.0, Fixed in 6.0.1
    overrides: {
        handleScheduleBarEvent: function(e) {
            // FF in windows and mac throws click event on right button click, while it shouldn't
            if (Ext.isGecko && e.type === 'click' && e.button === 2) {
                return false;
            }
            return this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class   Gnt.widget.ConstraintResolutionForm
 * @extend  Ext.form.Panel
 */
Ext.define("Gnt.widget.ConstraintResolutionForm", {
    extend: "Ext.form.Panel",
    requires: [
        'Ext.form.RadioGroup',
        'Ext.form.field.Display'
    ],
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    alias: 'widget.constraintresolutionform',
    /**
     * @cfg {Object} l10n Object containing localication strings
     * An object, purposed for the class localization. Contains the following keys/values:

            - "Constraint violation" : "Constraint violation"
            - dateFormat           : "m/d/Y",
            - "OK"                 : 'OK',
            - "Cancel"             : 'Cancel',
            - "Resolution options" : "Resolution options",
            - "Don't ask again"    : "Don't ask again",
            - "Task {0} violates constraint {1}"     : "Task {0} violates constraint {1}",
            - "Task {0} violates constraint {1} {2}" : "Task {0} violates constraint {1} {2}"
     */
    legacyMode: false,
    // That's for localizable mixin
    config: {
        /**
         * @cfg {Object} resolutionContext Object containing a set of possible resolutions provided by {@link Gnt.constraint.Base#getResolution()}.
         */
        resolutionContext: null,
        /**
         * @cfg {String} [dateFormat=null] Date format string to use in vialotion description string. If none is given then 
         * the one from {@link #l10n} will be used otherwise {@link Ext.Date#defaultFormat}.
         */
        dateFormat: null
    },
    bodyPadding: 5,
    autoScroll: true,
    initComponent: function() {
        var me = this;
        Ext.isObject(me.resolutionContext) || Ext.Error.raise("Can't initialize constration resolution form, resolution context is not given!");
        me.setupItemsFromResolutionContext(me.resolutionContext);
        me.setupFooterFromResolutionContext(me.resolutionContext);
        me.callParent(arguments);
    },
    setupItemsFromResolutionContext: function(resolutionContext) {
        var me = this,
            resolutions;
        Ext.isObject(resolutionContext) && Ext.isArray(resolutionContext.resolutions) && Ext.isFunction(resolutionContext.getCancelActionOption) || Ext.Error.raise("Invalid resolution context provided!");
        resolutions = Ext.Array.map(resolutionContext.resolutions, function(r, index) {
            return {
                xtype: 'radio',
                boxLabel: me.getResolutionOptionDescription(r.title, resolutionContext),
                name: 'resolutionOption',
                checked: r === resolutionContext.getCancelActionOption(),
                inputValue: index,
                tabIndex: index
            };
        });
        me.items = [
            {
                xtype: 'displayfield',
                itemId: 'description',
                value: me.getConstraintViolationDescription(resolutionContext),
                anchor: "-0"
            },
            {
                xtype: 'radiogroup',
                itemId: 'options',
                columns: 1,
                title: me.L("Resolution options"),
                allowBlank: false,
                items: resolutions,
                anchor: "-0"
            }
        ];
    },
    setupFooterFromResolutionContext: function(resolutionContext) {
        var me = this;
        Ext.isObject(resolutionContext) && Ext.isArray(resolutionContext.resolutions) || Ext.Error.raise("Invalid resolution context provided!");
        me.fbar = {
            itemId: 'footer-tb',
            items: [
                {
                    xtype: 'checkbox',
                    itemId: 'dont-ask-cb',
                    boxLabel: me.L("Don't ask again"),
                    tabIndex: resolutionContext.resolutions.length + 1
                },
                '->',
                {
                    text: me.L("OK"),
                    itemId: 'ok-btn',
                    formBind: true,
                    tabIndex: resolutionContext.resolutions.length + 2,
                    handler: me.onUserActionOk,
                    scope: me
                },
                {
                    text: me.L("Cancel"),
                    itemId: 'cancel-btn',
                    tabIndex: resolutionContext.resolutions.length + 3,
                    handler: me.onUserActionCancel,
                    scope: me
                }
            ]
        };
    },
    getDontAskValue: function() {
        var me = this;
        return me.down('#dont-ask-cb').getValue();
    },
    getConstraintViolationDescription: function(resolutionContext) {
        var me = this,
            constraintTitle, constraintDate, constraintClass, task, taskName, dateFormat;
        Ext.isObject(resolutionContext) && Ext.isDefined(resolutionContext.title) && Ext.isDefined(resolutionContext.task) || Ext.Error.raise("Invalid resolution context provided!");
        constraintTitle = resolutionContext.title;
        task = resolutionContext.task;
        taskName = task.getName() || '';
        constraintClass = task.getConstraintClass();
        dateFormat = me.dateFormat || me.L("dateFormat") || Ext.Date.defaultFormat;
        constraintDate = constraintClass && constraintClass.getDisplayableConstraintDateForFormat(resolutionContext.date, dateFormat, task) || resolutionContext.date;
        return constraintDate ? Ext.String.format(me.L("Task {0} violates constraint {1} {2}"), taskName, constraintTitle, Ext.Date.format(constraintDate, dateFormat)) : Ext.String.format(me.L("Task {0} violates constraint {1}"), taskName, constraintTitle);
    },
    getResolutionOptionDescription: function(rawDescription, resolutionContext) {
        var me = this,
            task, constraintDate, constraintClass, dateFormat;
        Ext.isObject(resolutionContext) || Ext.Error.raise("Invalid resolution context provided!");
        task = resolutionContext.task;
        constraintClass = task.getConstraintClass();
        dateFormat = me.dateFormat || me.L("dateFormat") || Ext.Date.defaultFormat;
        constraintDate = constraintClass && constraintClass.getDisplayableConstraintDateForFormat(resolutionContext.date, dateFormat, task) || resolutionContext.date;
        return constraintDate ? Ext.String.format(rawDescription, Ext.Date.format(constraintDate, dateFormat)) : Ext.String.format(rawDescription, '');
    },
    onUserActionOk: function(btn) {
        var me = this,
            result;
        result = me.getValues();
        result.dontAsk = me.getDontAskValue();
        me.fireEvent('ok', me, result);
    },
    onUserActionCancel: function(btn) {
        var me = this;
        me.fireEvent('cancel', me);
    },
    getOptimalHeight: function(width) {
        var me = this,
            originalPos, originalWidth, radioGroup, radioGroupOffsets, optimalHeight, footerBar;
        if (width) {
            originalPos = me.getXY();
            originalWidth = me.getWidth();
            me.setXY([
                -10000,
                -10000
            ]);
            me.setWidth(width);
        }
        radioGroup = me.getComponent('options');
        radioGroupOffsets = radioGroup.getEl().getOffsetsTo(me.body);
        footerBar = me.getDockedComponent('footer-tb');
        optimalHeight = radioGroupOffsets[1] + Ext.getDom(radioGroup.getEl()).scrollHeight + 2 * me.bodyPadding + footerBar.getHeight() + 10;
        /* scroll safety */
        if (width) {
            me.setWidth(originalWidth);
            me.setXY(originalPos);
        }
        return optimalHeight;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class   Gnt.widget.ConstraintResolutionWindow
 * @extends Ext.window.Window
 */
Ext.define("Gnt.widget.ConstraintResolutionWindow", {
    extend: "Ext.window.Window",
    alias: "widget.constraintresolutionwindow",
    requires: [
        "Gnt.widget.ConstraintResolutionForm"
    ],
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    modal: true,
    closable: true,
    resizable: true,
    collapsible: false,
    border: false,
    bodyBorder: false,
    /**
     * @cfg {Object} l10n Object containing localication strings
     * An object, purposed for the class localization. Contains the following keys/values:

            - "Constraint violation" : "Constraint violation"
     */
    config: {
        /**
         * @cfg {Object} resolutionContext Object containing a set of possible resolutions provided by {@link Gnt.constraint.Base#getResolution()}.
         */
        resolutionContext: null,
        /**
         * @cfg {String} dateFormat
         *
         * Date format to pass to {@link Gnt.widget.ConstraintResolutionForm}
         */
        dateFormat: null
    },
    form: null,
    initComponent: function() {
        var me = this;
        me.title = me.L("Constraint violation");
        me.setupItems();
        me.height = Math.round(Ext.dom.Element.getViewportHeight() / 3);
        me.width = Math.round(Ext.dom.Element.getViewportWidth() / 4);
        me.callParent(arguments);
        me.on('afterlayout', me.onAfterOptimalLayout, me, {
            single: true
        });
    },
    setupItems: function() {
        var me = this;
        me.layout = 'fit';
        me.form = new Gnt.widget.ConstraintResolutionForm({
            resolutionContext: me.getResolutionContext(),
            dateFormat: me.getDateFormat(),
            bubbleEvents: [
                'ok',
                'cancel'
            ]
        });
        me.items = me.form;
    },
    onAfterOptimalLayout: function() {
        var me = this,
            originalHeight, originalFormHeight, formOptimalHeight, optimalHeight;
        originalHeight = me.getHeight();
        originalFormHeight = me.form.getHeight();
        formOptimalHeight = me.form.getOptimalHeight();
        optimalHeight = formOptimalHeight + originalHeight - originalFormHeight;
        originalHeight != optimalHeight && me.setHeight(optimalHeight);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class   Gnt.plugin.ConstraintResolutionGui
 * @extends Ext.AbstractPlugin
 */
Ext.define("Gnt.plugin.ConstraintResolutionGui", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.constraintresolutiongui",
    requires: [
        "Gnt.widget.ConstraintResolutionWindow"
    ],
    config: {
        /**
         * @cfg {String} dateFormat
         *
         * Date format to pass to {@link Gnt.widget.ConstraintResolutionWindow}
         */
        dateFormat: null
    },
    cmpDetacher: null,
    storeDetacher: null,
    storedResolutions: null,
    init: function(cmp) {
        var me = this;
        me.callParent(arguments);
        if (!me.disabled) {
            me.enable();
        }
    },
    enable: function() {
        var me = this,
            cmp = me.getCmp();
        me.callParent();
        // This is a GUI class, let's wait for the Gantt view to render first
        if (cmp.rendered) {
            me.attachToTaskStore();
        } else {
            me.cmpDetacher = cmp.on('afterrender', function() {
                me.attachToTaskStore();
            }, null, {
                destroyable: true,
                single: true
            });
        }
    },
    disable: function() {
        var me = this,
            cmp = me.getCmp();
        me.callParent();
        if (cmp.rendered) {
            me.detachFromTaskStore();
        } else {
            me.cmpDetacher && Ext.destroy(me.cmpDetacher);
            me.cmpDetacher = null;
        }
    },
    attachToTaskStore: function() {
        var me = this,
            cmp, store;
        if (!me.storeDetacher) {
            cmp = me.getCmp();
            store = cmp.getTaskStore();
            me.storeDetacher = cmp.mon(store, 'constraintconflict', me.onConstraintConflict, me, {
                destroyable: true
            });
        }
    },
    detachFromTaskStore: function() {
        var me = this;
        me.storeDetacher && Ext.destroy(me.storeDetacher);
        me.storeDetacher = null;
    },
    onConstraintConflict: function(task, resolutionContext) {
        var me = this,
            ganttPanel = me.getCmp(),
            lockedView = ganttPanel.lockedGrid.getView(),
            normalView = ganttPanel.normalGrid.getView(),
            depView = ganttPanel.getDependencyView(),
            taskIdx = normalView.indexOf(task),
            wnd, detacher,
            detacherWrapper = {
                destroy: function() {
                    Ext.destroy(detacher);
                }
            };
        // Redrawing the conflicting task row and dependencies
        function redrawTask() {
            if (taskIdx != -1) {
                lockedView.refreshNode(taskIdx);
                normalView.refreshNode(taskIdx);
                depView.updateDependencies(task.getAllDependencies());
            }
        }
        redrawTask();
        if (!me.hasStoredResolutionForContext(resolutionContext)) {
            wnd = new Gnt.widget.ConstraintResolutionWindow({
                dateFormat: me.getDateFormat(),
                resolutionContext: resolutionContext
            });
            detacher = wnd.on({
                'ok': Ext.Function.bind(me.onUserActionOk, me, [
                    resolutionContext,
                    redrawTask,
                    wnd,
                    detacherWrapper
                ], true),
                'cancel': Ext.Function.bind(me.onUserActionCancel, me, [
                    resolutionContext,
                    redrawTask,
                    wnd,
                    detacherWrapper
                ], true),
                'close': Ext.Function.bind(me.onUserActionClose, me, [
                    resolutionContext,
                    redrawTask,
                    detacherWrapper
                ], true),
                destroyable: true
            });
            ganttPanel.completeEdit();
            wnd.show();
        } else {
            me.resolveSilently(resolutionContext, redrawTask);
        }
    },
    getStoredResolutions: function() {
        var me = this;
        if (!me.storedResolutions) {
            me.storedResolutions = {};
        }
        return me.storedResolutions;
    },
    getStoredResolutionKeyForContext: function(resolutionContext) {
        Ext.isObject(resolutionContext) && Ext.isString(resolutionContext.title) && Ext.isArray(resolutionContext.resolutions) || Ext.Error.raise("Can't get stored resolution key for context, invalid context is given!");
        return resolutionContext.title + resolutionContext.resolutions.length;
    },
    hasStoredResolutionForContext: function(resolutionContext) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.getStoredResolutions();
        return Ext.isDefined(storedResolutions[key]);
    },
    getStoredResolutionForContext: function(resolutionContext) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.getStoredResolutions();
        Ext.isDefined(storedResolutions[key]) || Ext.Error.raise("Can't get resolution for context, no resolutions has been stored previously!");
        return storedResolutions[key];
    },
    storeResolutionForContext: function(resolutionContext, optionIndex) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.storedResolutions;
        me.storedResolutions[key] = optionIndex;
    },
    resolveSilently: function(resolutionContext, redrawTaskFn) {
        var me = this,
            optionIndex = me.getStoredResolutionForContext(resolutionContext);
        Ext.isObject(resolutionContext) && Ext.isArray(resolutionContext.resolutions) && Ext.isDefined(resolutionContext.resolutions[optionIndex]) || Ext.Error.raise("Can't resolve constraint confict silently, stored resolution is inconsistent to the context given!");
        resolutionContext.resolutions[optionIndex].resolve();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionOk: function(form, userChoice, eOpts, resolutionContext, redrawTaskFn, wnd, detacher) {
        var me = this;
        Ext.isObject(userChoice) && Ext.isDefined(userChoice.resolutionOption) && Ext.isDefined(userChoice.dontAsk) || Ext.Error.raise("Can't resolve constraint conflict according to user choice, user choice is invalid!");
        Ext.isObject(resolutionContext) && Ext.isArray(resolutionContext.resolutions) && Ext.isDefined(resolutionContext.resolutions[userChoice.resolutionOption]) || Ext.Error.raise("Can't resolve constraint conflict according to user choice, resolution context is inconsistent to user choice!");
        Ext.destroy(detacher);
        wnd.close();
        if (userChoice.dontAsk) {
            me.storeResolutionForContext(resolutionContext, userChoice.resolutionOption);
        }
        resolutionContext.resolutions[userChoice.resolutionOption].resolve();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionCancel: function(form, eOpts, resolutionContext, redrawTaskFn, wnd, detacher) {
        var me = this;
        Ext.isObject(resolutionContext) && Ext.isFunction(resolutionContext.cancelAction) || Ext.Error.raise("Invalid resolution context given!");
        Ext.destroy(detacher);
        wnd.close();
        resolutionContext.cancelAction();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionClose: function(wnd, eOpts, resolutionContext, redrawTaskFn, detacher) {
        var me = this;
        resolutionContext && Ext.isFunction(resolutionContext.cancelAction) || Ext.Error.raise("Invalid resolution context given!");
        Ext.destroy(detacher);
        resolutionContext.cancelAction();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.plugin.ProjectLines
@extends Sch.plugin.Lines

A simple subclass of the {@link Sch.plugin.Lines} which sets project lines on the gantt chart.
Generally, there's no need to instantiate it manually, it can be activated with the {@link Gnt.panel.Gantt#showProjectLines} configuration option.
 */
Ext.define("Gnt.plugin.ProjectLines", {
    extend: 'Sch.plugin.Lines',
    alias: 'plugin.gantt_projectlines',
    requires: [
        'Ext.data.Store'
    ],
    innerTpl: '<span class="sch-gantt-project-line-text" style="{Style}">{Text}</span>',
    // Some number to use to make sure labels don't overlap if project labels are rendered near each other.
    labelHeight: 25,
    showHeaderElements: true,
    /**
     * @cfg {Gnt.data.taskStore} taskStore The task store to extract projects from
     */
    taskStore: null,
    /**
     * @cfg {String} linesFor
     * Specifies what project dates should be used to build lines. Might be:
     *
     * - `start` - to build lines for project start dates
     * - `end` - to build lines for project end dates
     * - `both` - to build lines for both project start and end dates
     */
    linesFor: 'both',
    init: function(ganttPanel) {
        this.taskStore = this.taskStore || ganttPanel.getTaskStore();
        this.bindTaskStore(this.taskStore);
        if (!this.store) {
            this.store = new Ext.data.Store({
                fields: [
                    {
                        name: 'Id'
                    },
                    {
                        name: 'ProjectId'
                    },
                    {
                        name: 'Date',
                        type: 'date'
                    },
                    {
                        name: 'Cls',
                        type: 'string'
                    },
                    {
                        name: 'Text',
                        type: 'string'
                    }
                ]
            });
        }
        this.callParent(arguments);
        this.onTaskStoreLoad();
    },
    bindTaskStore: function(taskStore) {
        var listeners = {
                nodeappend: this.onTaskStoreNodeAppend,
                noderemove: this.onTaskStoreNodeRemove,
                update: this.onUpdate,
                load: this.onTaskStoreLoad,
                scope: this
            };
        if (this.taskStore) {
            this.taskStore.un(listeners);
        }
        if (taskStore) {
            taskStore.on(listeners);
        }
        this.taskStore = taskStore;
    },
    onUpdate: function(store, record, operation, modified) {
        // Can't trust "modified" to be an array :/
        // https://www.sencha.com/forum/showthread.php?314319-TreeStore-update-event-doesn-t-always-provide-an-array.&p=1142195#post1142195
        modified = modified || [];
        if (record && record.isProject && operation == Ext.data.Model.EDIT) {
            var update = Ext.Array.some([
                    record.startDateField,
                    record.endDateField,
                    record.nameField
                ], function(item) {
                    return Ext.Array.indexOf(modified, item) !== -1;
                });
            if (update) {
                var projectId = record.modified && record.modified.Id || record.getId();
                // re-create the project related lines
                this.store.remove(this.getProjectLines(projectId));
                this.store.add(this.retrieveProjectLines(record));
            }
        }
    },
    onTaskStoreNodeAppend: function(parent, node) {
        if (node && node.isProject && !this.taskStore.isSettingRoot) {
            this.store.add(this.retrieveProjectLines(node));
        }
    },
    onTaskStoreNodeRemove: function(parent, node) {
        if (node && node.isProject) {
            this.store.remove(this.getProjectLines(node.getId()));
        }
    },
    onTaskStoreLoad: function() {
        this.refreshAllProjects();
    },
    refreshAllProjects: function() {
        this.store.removeAll(true);
        this.store.add(this.retrieveProjectLines());
    },
    getProjectLines: function(projectId) {
        var result = [];
        this.store.each(function(line) {
            if (line.get('ProjectId') == projectId)  {
                result.push(line);
            }
            
        });
        return result;
    },
    /**
     * @protected
     * @method prepareProjectStartLine Prepares a record that corresponds to a project start date.
     * @param  {Gnt.model.Project} project Project
     * @return {Object} Object representing the record to be added to the store
     */
    prepareProjectStartLine: function(project, index) {
        return {
            Date: project.getStartDate(),
            Text: 'Start of: ' + project.getName(),
            Cls: 'sch-gantt-project-line-start sch-gantt-project-line-' + project.getId(),
            ProjectId: project.getId(),
            Style: 'margin-top:' + (index * this.labelHeight) + 'px'
        };
    },
    /**
     * @protected
     * @method prepareProjectEndLine Prepares a record that corresponds to a project end date.
     * @param  {Gnt.model.Project} project Project
     * @return {Object} Object representing the record to be added to the store
     */
    prepareProjectEndLine: function(project, index) {
        return {
            Date: project.getEndDate(),
            Text: 'End of: ' + project.getName(),
            Cls: 'sch-gantt-project-line-end sch-gantt-project-line-' + project.getId(),
            ProjectId: project.getId(),
            Style: 'margin-top:' + (index * this.labelHeight) + 'px'
        };
    },
    retrieveProjectLines: function(project) {
        var me = this,
            projects = Ext.isArray(project) ? project : project && [
                project
            ] || this.taskStore.getProjects(),
            projectLines = [],
            linesFor = me.linesFor;
        for (var i = 0; i < projects.length; i++) {
            linesFor != 'end' && projectLines.push(me.prepareProjectStartLine(projects[i], i));
            linesFor != 'start' && projectLines.push(me.prepareProjectEndLine(projects[i], i));
        }
        return projectLines;
    },
    destroy: function() {
        this.bindTaskStore(null);
        this.store.destroy();
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.plugin.Replicator
 * @extends Ext.grid.selection.Replicator
 *
 * This class provides selection replication feature to gantt panel and should be used instead of Ext.grid.selection.Replicator.
 * In addition to simple columns like {@link Gnt.column.Name}, it will also copy complex values like dependencies and resource
 * assignments. Following columns will be ignored:
 *
 * - {@link Gnt.column.LateEndDate}
 * - {@link Gnt.column.LateStartDate}
 * - {@link Gnt.column.Milestone}
 * - {@link Gnt.column.Sequence}
 * - {@link Gnt.column.Slack}
 * - {@link Gnt.column.WBS}
 *
 */
Ext.define('Gnt.plugin.Replicator', {
    extend: 'Ext.grid.selection.Replicator',
    alias: 'plugin.gantt_selectionreplicator',
    init: function(gantt) {
        this.gantt = gantt;
        this.callParent(arguments);
    },
    /**
     * This is the method which is called when the {@link Ext.grid.selection.SpreadsheetModel} selection model's extender
     * handle is dragged and released. It is passed contextual information about the selection and the extension area.
     * By default, the selection is extended to encompass the selection area, return false to prevent that.
     * @param {Gnt.panel.Gantt} ownerGrid
     * @param {Ext.grid.selection.Selection} sel
     * @param {Object} extension
     */
    replicateSelection: function(ownerGrid, sel, extension) {
        var me = this;
        if (extension.columns || sel.isColumns || this.gantt.isReadOnly()) {
            return;
        }
        var selFirstRowIdx = sel.getFirstRowIndex(),
            selLastRowIdx = sel.getLastRowIndex(),
            selectedRowCount = selLastRowIdx - selFirstRowIdx + 1,
            store = sel.view.dataSource,
            startIdx, endIdx, increment, record,
            columns = me.columns,
            colCount = columns.length,
            column, values, lastTwoRecords, prevValues, prevValue, x, y, i, j;
        // Single row, just duplicate values into extension
        if (selectedRowCount === 1) {
            values = me.getColumnValues(store.getAt(selFirstRowIdx));
        } else // Multiple rows, take the numeric values from the closest two rows, calculate an array of differences and propagate it
        {
            values = new Array(colCount);
            if (extension.rows < 0) {
                lastTwoRecords = [
                    store.getAt(selFirstRowIdx + 1),
                    store.getAt(selFirstRowIdx)
                ];
            } else {
                lastTwoRecords = [
                    store.getAt(selLastRowIdx - 1),
                    store.getAt(selLastRowIdx)
                ];
            }
            lastTwoRecords[0] = me.getColumnValues(lastTwoRecords[0]);
            lastTwoRecords[1] = me.getColumnValues(lastTwoRecords[1]);
            // The values array will be the differences between all numeric columns in the selection of the
            // closet two records.
            for (j = 0; j < colCount; j++) {
                x = lastTwoRecords[1][j];
                y = lastTwoRecords[0][j];
                if (!isNaN(x) && !isNaN(y)) {
                    values[j] = Number(x) - Number(y);
                }
            }
        }
        // Loop from end to start of extension area
        if (extension.rows < 0) {
            startIdx = extension.end.rowIdx;
            endIdx = extension.start.rowIdx - 1;
            increment = -1;
        } else {
            startIdx = extension.start.rowIdx;
            endIdx = extension.end.rowIdx + 1;
            increment = 1;
        }
        // When we copy complex values like dependencies or assignments, we will trigger view refresh
        // that is going to clear selection. In fact we don't need to clear selection, because nothing really
        // changed in locked view when we do it, so we unbind this private listener to prevent clearing the selection
        me.gantt.lockedGrid.view.un('beforerefresh', me.gantt.selModel.onBeforeViewRefresh, me.gantt.selModel);
        me.gantt.normalGrid.view.un('beforerefresh', me.gantt.selModel.onBeforeViewRefresh, me.gantt.selModel);
        // Replicate single selected row
        if (selectedRowCount === 1) {
            for (i = startIdx; i !== endIdx; i += increment) {
                record = store.getAt(i);
                if (record.isReadOnly())  {
                    
                    continue;
                }
                
                for (j = 0; j < colCount; j++) {
                    column = columns[j];
                    if (column.putRawData) {
                        column.putRawData(Ext.clone(values[j]), record);
                    } else if (column.dataIndex) {
                        record.set(column.dataIndex, values[j]);
                    }
                }
            }
        } else // Add differences from closest two rows
        {
            for (i = startIdx; i !== endIdx; i += increment) {
                record = store.getAt(i);
                if (record.isReadOnly())  {
                    
                    continue;
                }
                
                prevValues = me.getColumnValues(store.getAt(i - increment));
                for (j = 0; j < colCount; j++) {
                    column = columns[j];
                    if (column.dataIndex) {
                        prevValue = prevValues[j];
                        if (!isNaN(prevValue)) {
                            if (prevValue instanceof Date) {
                                record.set(column.dataIndex, Sch.util.Date.add(prevValue, 'ms', values[j]));
                            } else if (!Ext.isEmpty(prevValue)) {
                                record.set(column.dataIndex, Ext.coerce(Number(prevValue) + values[j], prevValue));
                            }
                        }
                    }
                }
            }
        }
        me.gantt.lockedGrid.view.on('beforerefresh', me.gantt.selModel.onBeforeViewRefresh, me.gantt.selModel);
        me.gantt.normalGrid.view.on('beforerefresh', me.gantt.selModel.onBeforeViewRefresh, me.gantt.selModel);
    },
    getColumnValues: function(record) {
        return Ext.Array.map(this.columns, function(column) {
            if (column.getRawData) {
                return column.getRawData(record);
            } else if (column.dataIndex) {
                return record.get(column.dataIndex);
            }
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.template.TaskTooltip
 @extends Ext.XTemplate

 Template class for rendering the task tooltip.
 */
Ext.define("Gnt.template.TaskTooltip", {
    extend: 'Ext.XTemplate',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    disableFormats: true,
    dateFormat: null,
    /**
     * @cfg {String} markup The tpl markup that will be passed to the XTemplate. Default `_startText_`, `_endText_`, `_percentText` and `_format_` will be localised in the constructor.
     */
    markup: '<h2 class="sch-task-tip-header">{Name}</h2>' + '<table class="sch-task-tip">' + '<tr><td>_startText_:</td> <td align="right">{[this.getStartDateString(values)]}</td></tr>' + '<tr><td>_endText_:</td> <td align="right">{[this.getEndDateString(values)]}</td></tr>' + '<tr><td>_percentText_:</td><td align="right">{[this.getPercentDoneString(values)]}%</td></tr>' + '</table>',
    constructor: function(markup) {
        this.markup = markup || this.markup;
        this.markup = this.markup.replace(/_startText_/, this.L('startText'));
        this.markup = this.markup.replace(/_endText_/, this.L('endText'));
        this.markup = this.markup.replace(/_percentText_/, this.L('percentText'));
        this.dateFormat = this.L('format');
        this.callParent([
            this.markup
        ]);
    },
    getStartDateString: function(data) {
        var task = data._record;
        var date = data._useBaselineData ? task.getBaselineStartDate() : task.getStartDate();
        return data._record.getDisplayStartDate(this.dateFormat, true, date, false, data._useBaselineData);
    },
    getEndDateString: function(data) {
        var task = data._record;
        var date = data._useBaselineData ? task.getBaselineEndDate() : task.getEndDate();
        return data._record.getDisplayEndDate(this.dateFormat, true, date, false, data._useBaselineData);
    },
    getPercentDoneString: function(data) {
        var task = data._record;
        var value = data._useBaselineData ? task.getBaselinePercentDone() : task.getPercentDone();
        return Math.round(value);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.panel.Gantt
 @extends Sch.panel.TimelineTreePanel

 A gantt panel, which allows you to visualize and manage tasks and their dependencies.

 Please refer to the <a href="#!/guide/gantt_getting_started">getting started guide</a> for a detailed introduction.

 {@img gantt/images/gantt-panel.png}

 */
Ext.define("Gnt.panel.Gantt", {
    extend: "Sch.panel.TimelineTreePanel",
    alias: [
        'widget.ganttpanel'
    ],
    alternateClassName: [
        'Sch.gantt.GanttPanel'
    ],
    mixins: [
        'Gnt.view.dependency.Mixin'
    ],
    requires: [
        'Ext.layout.container.Border',
        'Ext.tree.plugin.TreeViewDragDrop',
        'Ext.util.CSS',
        'Sch.plugin.NonWorkingTime',
        'Gnt.patches.CellEditor',
        'Gnt.patches.CellEditing',
        'Gnt.patches.TreeViewDragDrop',
        'Gnt.patches.SpreadsheetModel',
        'Gnt.patches.LockingView',
        'Gnt.data.ResourceStore',
        'Gnt.data.AssignmentStore',
        'Gnt.data.Calendar',
        'Gnt.data.TaskStore',
        'Gnt.data.DependencyStore',
        'Gnt.view.Gantt',
        'Gnt.patches.RightClick',
        'Gnt.plugin.ConstraintResolutionGui',
        'Gnt.plugin.ProjectLines',
        'Gnt.plugin.Replicator',
        'Gnt.template.TaskTooltip'
    ],
    uses: [
        'Sch.plugin.CurrentTimeLine'
    ],
    viewType: 'ganttview',
    layout: 'border',
    rowLines: true,
    syncRowHeight: false,
    rowHeight: 24,
    rowHeightStyleSheetNode: null,
    /**
     * @cfg {Boolean/String/Ext.Template} tooltipTpl
     * Template used to show a tooltip over a scheduled item, true by default (Gnt.template.TaskTooltip). Feel free to extend Gnt.template.TaskTooltip and set the instance directly on the property.  
     * The tooltip will be populated with the data in record corresponding to the hovered element. See also {@link #tipCfg} and to provide your own custom data object for this
     * template, please see {@link Sch.mixin.TimelineView#getDataForTooltipTpl}.
     */
    tooltipTpl: true,
    // holds instance of row numberer column
    rowNumberColumn: null,
    /**
     * @cfg {String/Object} topLabelField
     * A configuration used to show/edit the field to the top of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    topLabelField: null,
    /**
     * @cfg {String/Object} leftLabelField
     * A configuration used to show/edit the field to the left of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    leftLabelField: null,
    /**
     * @cfg {String/Object} bottomLabelField
     * A configuration used to show/edit the field to the bottom of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    bottomLabelField: null,
    /**
     * @cfg {String/Object} rightLabelField
     * A configuration used to show/edit the field to the right of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    rightLabelField: null,
    /**
     * @cfg {Boolean} weekendsAreWorkdays
     * Set to `true` to treat *all* days as working, effectively removing the concept of non-working time from gantt. Defaults to `false`.
     * This option just will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop
     * True to skip the weekends/holidays during drag&drop operations (moving/resizing) and also during cascading. Default value is `true`.
     *
     * Note, that holidays will still be excluded from the duration of the tasks. If you need to completely disable holiday skipping you
     * can do that on the gantt level with the {@link #weekendsAreWorkdays} option, or on the task level with the `SchedulingMode` field.
     *
     *
     * This option just will be translated to the {@link Gnt.data.TaskStore#skipWeekendsDuringDragDrop corresponding option} of the task store
     */
    skipWeekendsDuringDragDrop: true,
    /**
     * @cfg {Boolean} enableTaskDragDrop
     * True to allow drag drop of tasks (defaults to `true`). To customize the behavior of drag and drop, you can use {@link #dragDropConfig} option
     */
    enableTaskDragDrop: true,
    /**
     * @cfg {Boolean} enableProgressBarResize
     * True to allow resizing of the progress bar indicator inside tasks (defaults to `false`)
     */
    enableProgressBarResize: false,
    /**
     * @cfg {Boolean} toggleParentTasksOnClick
     * True to toggle the collapsed/expanded state when clicking a parent task bar (defaults to `true`)
     */
    toggleParentTasksOnClick: true,
    /**
     * @cfg {Boolean} addRowOnTab
     * True to automatically insert a new row when tabbing out of the last cell of the last row. Defaults to true.
     */
    addRowOnTab: true,
    /**
     * @cfg {Boolean} recalculateParents
     * True to update parent start/end dates after a task has been updated (defaults to `true`). This option just will be translated
     * to the {@link Gnt.data.TaskStore#recalculateParents corresponding option} of the task store
     */
    recalculateParents: true,
    /**
     * @cfg {Boolean} cascadeChanges
     * True to cascade changes to dependent tasks (defaults to `false`). This option just will be translated
     * to the {@link Gnt.data.TaskStore#cascadeChanges corresponding option} of the task store
     */
    cascadeChanges: false,
    /**
     * @cfg {Boolean} enableBaseline
     * True to enable showing a base lines for tasks. Baseline information should be provided as the `BaselineStartDate`, `BaselineEndDate` and `BaselinePercentDone` fields.
     * Default value is `false`.
     */
    enableBaseline: false,
    /**
     * @cfg {Boolean} baselineVisible
     * True to show the baseline in the initial rendering. You can show and hide the baseline programmatically via {@link #showBaseline} and {@link #hideBaseline}.
     * Default value is `false`.
     */
    baselineVisible: false,
    enableAnimations: false,
    animate: false,
    /**
     * If the {@link #highlightWeekends} option is set to true, you can access the created zones plugin through this property.
     * @property {Sch.plugin.Zones} workingTimePlugin
     */
    workingTimePlugin: null,
    todayLinePlugin: null,
    highlightWeekends: true,
    /**
     * @cfg {Boolean} allowParentTaskMove True to allow moving parent tasks. Please note, that when moving a parent task, the
     * {@link Gnt.data.TaskStore#cascadeDelay cascadeDelay} option will not be used and cascading will happen synchronously (if enabled).
     *
     * Also, its possible to move the parent task as a group (along with its child tasks) or as individual task. This can be controlled with
     * {@link Gnt.data.TaskStore#moveParentAsGroup} option.
     */
    allowParentTaskMove: true,
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `false` to exclude parent tasks from the list of possible predecessors/successors.
     */
    allowParentTaskDependencies: true,
    /**
     * @cfg {Boolean} enableDragCreation
     * True to allow dragging to set start and end dates
     */
    enableDragCreation: true,
    /**
     * @cfg {Function} eventRenderer
     * Provided so that you can override the rendering attributes provided to the various task HTML templates at runtime. This function is called each time a task
     * is rendered into the gantt grid. The function should return an object with properties that will be applied to the relevant task template.
     * By default, the task templates include placeholders for :
     *
     * - `cls` - CSS class which will be added to the task bar element
     * - `ctcls` - CSS class which will be added to the 'root' element containing the task bar and labels
     * - `style` - inline style declaration for the task bar element
     * - `progressBarStyle` - an inline CSS style to be applied to the progress bar of this task
     * - `leftLabel` - the content for the left label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#leftLabelField leftLabelField} option.
     *   You still need to provide some value for the `leftLabelField` to activate the label rendering
     * - `rightLabel` - the content for the right label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#rightLabelField rightLabelField} option
     *   You still need to provide a value for the `rightLabelField` to activate the label rendering
     * - `topLabel` - the content for the top label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#topLabelField topLabelField} option
     *   You still need to provide a value for the `topLabelField` to activate the label rendering
     * - `bottomLabel` - the content for the bottom label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#bottomLabelField bottomLabelField} option
     *   You still need to provide some value for the `bottomLabelField` to activate the label rendering
     * - `basecls` - a CSS class to be add to the baseline DOM element, only applicable when the {@link Gnt.panel.Gantt#baselineVisible baselineVisible} option is true and the task contains baseline information
     * - `baseProgressBarStyle` - an inline CSS style to be applied to the baseline progress bar element
     *
     * Here is a sample usage of eventRenderer:

     eventRenderer : function (taskRec) {
            return {
                style : 'background-color:white',        // You can use inline styles too.
                cls   : taskRec.get('Priority'),         // Read a property from the task record, used as a CSS class to style the event
                foo   : 'some value'                     // Some custom value in your own template
            };
        }
     *
     * @param {Gnt.model.Task} taskRecord The task about to be rendered
     * @param {Gnt.data.TaskStore} ds The task store
     * @return {Object} The data which will be applied to the task template, creating the actual HTML
     */
    eventRenderer: null,
    /**
     * @cfg {Object} eventRendererScope The scope (the "this" object)to use for the `eventRenderer` function
     */
    eventRendererScope: null,
    /**
     * @cfg {Ext.XTemplate} eventTemplate The template used to render leaf tasks in the gantt view.
     * See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Task} for the definition.
     */
    eventTemplate: null,
    /**
     * @cfg {Ext.XTemplate} parentEventTemplate The template used to render parent tasks in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.ParentTask} for the definition
     */
    parentEventTemplate: null,
    /**
     * @cfg {Ext.XTemplate} rollupTemplate The template used to rollup tasks to the parent in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.RollupTask} for the definition
     */
    rollupTemplate: null,
    /**
     * @cfg {Ext.XTemplate} milestoneTemplate The template used to render milestone tasks in the gantt view.
     * See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Milestone} for the definition.
     */
    milestoneTemplate: null,
    /**
     * @cfg {String} taskBodyTemplate The markup making up the body of leaf tasks in the gantt view. See also {@link Gnt.template.Task#innerTpl} for the definition.
     */
    taskBodyTemplate: null,
    /**
     * @cfg {String} parentTaskBodyTemplate The markup making up the body of parent tasks in the gantt view. See also {@link Gnt.template.ParentTask#innerTpl} for the definition.
     */
    parentTaskBodyTemplate: null,
    /**
     * @cfg {String} milestoneBodyTemplate The markup making up the body of milestone tasks in the gantt view. See also {@link Gnt.template.Milestone#innerTpl} for the definition.
     */
    milestoneBodyTemplate: null,
    /**
     * @cfg {Boolean} autoHeight Always hardcoded to null, the `true` value is not yet supported (by Ext JS).
     */
    autoHeight: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar a {@link Gnt.data.Calendar calendar} instance for this gantt panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.CrudManager} crudManager The CRUD manager instance controling all the gantt related stores
     *
        var taskStore   = new Gnt.data.TaskStore({
            ...
        });

        var crudManager = new Gnt.data.CrudManager({
            autoLoad    : true,
            taskStore   : taskStore,
            transport   : {
                load    : {
                    url     : 'load.php'
                },
                sync    : {
                    url     : 'save.php'
                }
            }
        });

        var gantt       = new Gnt.panel.Gantt({
            // CRUD manager instance having references to all the related stores
            crudManager : crudManager

            height      : 300,
            width       : 500,
            renderTo    : Ext.getBody(),
            columns     : [
                {
                    xtype : 'namecolumn'
                },
                {
                    xtype : 'startdatecolumn'
                },
                {
                    xtype : 'enddatecolumn'
                }
            ]
        });

     */
    crudManager: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks to be rendered into the gantt chart (required).
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore The {@link Gnt.data.DependencyStore store} holding the dependency information (optional).
     * See also {@link Gnt.model.Dependency}
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources that can be assigned to the tasks in the task store(optional).
     * See also {@link Gnt.model.Resource}
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore: null,
    columnLines: false,
    /**
     * @cfg {Function} dndValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * the task being dragged. This function is called during the drag and drop process and also after the drop is made.
     *
     * @param {Gnt.model.Task} taskRecord The task record being dragged
     * @param {Date} date The new start date
     * @param {Number} duration The duration of the item being dragged, in minutes
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    dndValidatorFn: Ext.emptyFn,
    /**
     * @cfg {Function} createValidatorFn
     * An empty function by default, but provided so that you can perform custom validation when a new task is being scheduled using drag and drop.
     * To indicate the newly scheduled dates of a task are invalid, simply return false from this method.
     *
     * @param {Gnt.model.Task} taskRecord the task
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {Event} e The browser event object
     * @return {Boolean} true if the creation event is valid, else false
     */
    createValidatorFn: Ext.emptyFn,
    /**
     * @cfg {String} eventResizeHandles
     * @hide
     */
    /**
     * @deprecated Use {@link #taskResizeHandles} instead
     * @cfg {String} resizeHandles A string containing one of the following values
     *
     * - `none` - to disable resizing of tasks
     * - `left` - to enable changing of start date only
     * - `right` - to enable changing of end date only
     * - `both` - to enable changing of both start and end dates
     *
     * Default value is `both`. Resizing is performed with the {@link Gnt.feature.TaskResize} plugin.
     * You can customize it with the {@link #resizeConfig} and {@link #resizeValidatorFn} options
     */
    resizeHandles: 'both',
    /**
     * @cfg {String} taskResizeHandles A string containing one of the following values
     *
     * - `none` - to disable resizing of tasks
     * - `left` - to enable changing of start date only
     * - `right` - to enable changing of end date only
     * - `both` - to enable changing of both start and end dates
     *
     * Default value is `both`. Resizing is performed with the {@link Gnt.feature.TaskResize} plugin.
     * You can customize it with the {@link #resizeConfig} and {@link #resizeValidatorFn} options
     */
    taskResizeHandles: 'both',
    /**
     * @cfg {Function} resizeValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * a task being resized. Simply return false from your function to indicate that the new duration is invalid.
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the resize state is valid, else false to cancel
     */
    resizeValidatorFn: Ext.emptyFn,
    /**
     *  @cfg {Object} resizeConfig A custom config object to pass to the {@link Gnt.feature.TaskResize} feature.
     */
    resizeConfig: null,
    /**
     *  @cfg {Object} progressBarResizeConfig A custom config object to pass to the {@link Gnt.feature.ProgressBarResize} feature.
     */
    progressBarResizeConfig: null,
    /**
     *  @cfg {Object} dragDropConfig A custom config object to pass to the {@link Gnt.feature.TaskDragDrop} feature.
     */
    dragDropConfig: null,
    /**
     *  @cfg {Object} createConfig A custom config to pass to the {@link Gnt.feature.DragCreator} instance
     */
    createConfig: null,
    /**
     *  @cfg {Boolean/Object} autoFitOnLoad True to change the timeframe of the gantt to fit all the tasks in it after every task store load.
     * Also accepts a config object passed as 'options' to the zoomToFit method
     * See also {@link #zoomToFit}.
     */
    autoFitOnLoad: false,
    /**
     *  @cfg {Boolean} showRollupTasks True to rollup information of tasks to their parent task bar.
     *  Only tasks with the `Rollup` field set to true will rollup.
     */
    showRollupTasks: false,
    /**
     * @cfg {Boolean} enableConstraintsResolutionGui `true` to enable the plugin, providing the constraint resolution popup window.
     * Enabled by default.
     */
    enableConstraintsResolutionGui: true,
    /**
     * @cfg {Boolean}
     * `True` to mark project start/end dates with vertical lines using {@link Gnt.plugin.ProjectLines} plugin.
     * Use {@link #projectLinesConfig} to configure the plugin.
     */
    showProjectLines: true,
    /**
     * @cfg {Object} projectLinesConfig
     * Config to use for {@link Gnt.plugin.ProjectLines} plugin.
     */
    projectLinesConfig: null,
    /**
     * @cfg {Object} constraintResolutionGuiConfig Config to use for {@link Gnt.plugin.ConstraintResolutionGui} plugin.
     */
    constraintResolutionGuiConfig: null,
    /**
     * @cfg {Boolean}
     * `True` to scroll tasks horizontally into view when clicking a task row.
     */
    scrollTaskIntoViewOnClick: false,
    /**
     * @cfg {Boolean/Object}
     * `True` to scroll tasks to be reordered in the left table section of the Gantt chart. Adds a Ext.tree.plugin.TreeViewDragDrop plugin
     * to the Gantt chart. You can configure this plugin by passing an Object instead of a boolean.
     *
     */
    enableTaskReordering: true,
    refreshLockedTreeOnDependencyUpdate: false,
    _lockedDependencyListeners: null,
    // when gantt is configured to keep selection this property will hold return value of selectionModel.getSelected()
    _lastSpreadsheetSelection: null,
    earlyStartColumn: null,
    earlyEndColumn: null,
    lateStartColumn: null,
    lateEndColumn: null,
    earlyDatesListeners: null,
    lateDatesListeners: null,
    slackListeners: null,
    refreshTimeout: 100,
    //A reference to the editing plugin, if it exists
    ganttEditingPlugin: null,
    /**
     * @cfg {Number} simpleCascadeThreshold If number of tasks affected during cascading (see {@link Gnt.data.TaskStore} for details on __cascading__ term)
     * is below this number, the panel does a per-row update instead of a full refresh.
     */
    simpleCascadeThreshold: 30,
    forceDefineTimeSpanByStore: true,
    /**
     * @cfg {Boolean} keepSelection Set this to true to keep selection in view after removing records
     */
    keepSelection: true,
    /**
     * This method shows or hides the visual presentation of task's rollups in the view.
     *
     * @param {Boolean} show A boolean value indicating whether the visual presentation of task's rollups should be visible or not.
     */
    setShowRollupTasks: function(show) {
        this.showRollupTasks = show;
        this.getSchedulingView().setShowRollupTasks(show);
    },
    onCalendarSet: function(store, calendar) {
        if (this.needToTranslateOption('weekendsAreWorkdays')) {
            // may trigger a renormalization of all tasks - need all stores to be defined
            calendar.setWeekendsAreWorkDays(this.weekendsAreWorkdays);
        }
        if (this.workingTimePlugin) {
            this.workingTimePlugin.bindCalendar(calendar);
            this.timeAxisViewModel.setCalendar(calendar);
        }
    },
    initStores: function() {
        // if we have CrudManager instance assigned we can grab stores from it
        if (this.crudManager) {
            if (this.crudManager && !(this.crudManager instanceof Gnt.data.CrudManager)) {
                this.crudManager = new Gnt.data.CrudManager(Ext.clone(this.crudManager));
            }
            if (!this.taskStore)  {
                this.taskStore = this.crudManager.getTaskStore();
            }
            
            if (!this.dependencyStore)  {
                this.dependencyStore = this.crudManager.getDependencyStore();
            }
            
            if (!this.resourceStore)  {
                this.resourceStore = this.crudManager.getResourceStore();
            }
            
            if (!this.assignmentStore)  {
                this.assignmentStore = this.crudManager.getAssignmentStore();
            }
            
        }
        if (!this.taskStore) {
            Ext.Error.raise("You must specify a taskStore config.");
        }
        var taskStore = Ext.StoreMgr.lookup(this.taskStore);
        if (!taskStore) {
            Ext.Error.raise("You have provided an incorrect taskStore identifier");
        }
        if (!(taskStore instanceof Gnt.data.TaskStore)) {
            Ext.Error.raise("A `taskStore` should be an instance of `Gnt.data.TaskStore` (or of a subclass)");
        }
        this.mon(taskStore, {
            calendarset: this.onCalendarSet,
            scope: this
        });
        this.mon(taskStore, {
            beforeindentationchange: this.onBeforeBatchStoreUpdate,
            indentationchange: this.onBatchStoreUpdate,
            beforebatchremove: this.onBeforeBatchStoreUpdate,
            batchremove: this.onBatchStoreUpdate,
            scope: this
        });
        Ext.apply(this, {
            store: taskStore,
            // For the grid panel API
            taskStore: taskStore
        });
        var calendar = taskStore.calendar;
        if (this.dependencyStore) {
            this.dependencyStore = Ext.StoreMgr.lookup(this.dependencyStore);
            taskStore.setDependencyStore(this.dependencyStore);
        } else {
            this.dependencyStore = taskStore.dependencyStore;
        }
        this.dependencyStore.allowParentTaskDependencies = this.allowParentTaskDependencies;
        if (!(this.dependencyStore instanceof Gnt.data.DependencyStore)) {
            Ext.Error.raise("The Gantt dependency store should be a Gnt.data.DependencyStore, or a subclass thereof.");
        }
        // this resource store will be assigned to the task store in the "bindResourceStore" method
        var resourceStore = this.resourceStore ? Ext.StoreMgr.lookup(this.resourceStore) : taskStore.getResourceStore();
        if (!(resourceStore instanceof Gnt.data.ResourceStore)) {
            Ext.Error.raise("A `ResourceStore` should be an instance of `Gnt.data.ResourceStore` (or of a subclass)");
        }
        // this assignment store will be assigned to the task store in the "bindAssignmentStore" method
        var assignmentStore = this.assignmentStore ? Ext.StoreMgr.lookup(this.assignmentStore) : taskStore.getAssignmentStore();
        if (!(assignmentStore instanceof Gnt.data.AssignmentStore)) {
            Ext.Error.raise("An `assignmentStore` should be an instance of `Gnt.data.AssignmentStore` (or of a subclass)");
        }
        this.bindAssignmentStore(assignmentStore, true);
        this.bindResourceStore(resourceStore, true);
        if (this.needToTranslateOption('weekendsAreWorkdays')) {
            // may trigger a renormalization of all tasks - need all stores to be defined
            calendar.setWeekendsAreWorkDays(this.weekendsAreWorkdays);
        }
    },
    // For buffered rendering, we need to avoid each indent/outdent operation causing a full view refresh + layouts + re-filtering
    // Tested in /#view/213_indent.t.js
    onBeforeBatchStoreUpdate: function() {
        this.taskStore.suspendEvent('refresh', 'add', 'insert', 'remove');
        this.taskStore.filterUpdateSuspended = true;
        var position = this.getSchedulingView().getNavigationModel().getPosition();
        if (position) {
            // During indent (not outdent) operation store will fire few update events (for single record
            // 3 events will be fired) that will trigger view rows to be updated. Renderer will call getPosition() on
            // navigation model and that call will null position. So following refresh couldn't save navigation position
            // because it was already nulled. That doesn't happen on outdent, because no update events thrown on store
            // Idea behind this fix is to restore navigation position
            // 213_indent
            this._lastNavigationPosition = position.clone();
        }
        var selModel = this.getSelectionModel(),
            selected = selModel.getSelected();
        // only cell selection is cleared on refresh
        if (selected && selected.isCells && this.keepSelection) {
            this._lastCellSelectedRange = selModel.getSelected().getRange();
            var records = [];
            selected.eachRow(function(record) {
                records.push(record);
            });
            this._lastCellSelectedRecords = records;
        }
        if (this.bufferedRenderer) {
            this.suspendLayouts();
        }
    },
    onBatchStoreUpdate: function() {
        var taskStore = this.getTaskStore();
        taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
        taskStore.filterUpdateSuspended = false;
        var lastNavigationPosition = this._lastNavigationPosition;
        if (lastNavigationPosition) {
            if (lastNavigationPosition.record && taskStore.getNodeById(lastNavigationPosition.record.getId())) {
                this.getSchedulingView().getNavigationModel().setPosition(lastNavigationPosition);
            }
            delete this._lastNavigationPosition;
        }
        this.getView().relayFn('refreshView');
        if (this.bufferedRenderer) {
            this.resumeLayouts(true);
            taskStore.reApplyFilter();
        }
        var records = this._lastCellSelectedRecords;
        if (records && records.length) {
            var view = this.lockedGrid.view;
            var lastIndex = -1,
                firstIndex, currentIndex;
            // iterate over selected records, find first visible record and select next until they're sequent
            for (var i = 0,
                len = records.length; i < len; i++) {
                currentIndex = view.indexOf(records[i]);
                if (currentIndex !== -1) {
                    if (lastIndex === -1) {
                        // current record is found in view and it's first found record
                        lastIndex = firstIndex = currentIndex;
                    } else if (currentIndex - lastIndex > 1) {
                        // gap between current and last found record, need to stop
                        break;
                    } else {
                        lastIndex = currentIndex;
                    }
                } else if (lastIndex !== -1) {
                    // current record is not visible, smth was added to selection. stop.
                    break;
                }
            }
            if (lastIndex !== -1) {
                lastIndex = Math.min(view.getNodes().length - 1, lastIndex);
                var range = this._lastCellSelectedRange;
                this.getSelectionModel().selectCells([
                    range[0][0],
                    firstIndex
                ], [
                    range[1][0],
                    lastIndex
                ]);
            }
            this._lastCellSelectedRecords = null;
            this._lastCellSelectedRange = null;
        }
    },
    initComponent: function() {
        this.autoHeight = false;
        this.initStores();
        if (this.needToTranslateOption('cascadeChanges')) {
            this.setCascadeChanges(this.cascadeChanges);
        }
        if (this.needToTranslateOption('recalculateParents')) {
            this.setRecalculateParents(this.recalculateParents);
        }
        if (this.needToTranslateOption('skipWeekendsDuringDragDrop')) {
            this.setSkipWeekendsDuringDragDrop(this.skipWeekendsDuringDragDrop);
        }
        this.normalViewConfig = this.normalViewConfig || {};
        // Copy some properties to the view instance
        Ext.applyIf(this.normalViewConfig, {
            taskStore: this.taskStore,
            dependencyStore: this.dependencyStore,
            snapRelativeToEventStartDate: this.snapRelativeToEventStartDate,
            enableDependencyDragDrop: this.enableDependencyDragDrop,
            enableTaskDragDrop: this.enableTaskDragDrop,
            enableProgressBarResize: this.enableProgressBarResize,
            enableDragCreation: this.enableDragCreation,
            allowParentTaskMove: this.allowParentTaskMove,
            allowParentTaskDependencies: this.allowParentTaskDependencies,
            toggleParentTasksOnClick: this.toggleParentTasksOnClick,
            //TODO: remove for 5.0
            // Read value from deprecated config first. It was always taken from panel, so this is enough to check
            taskResizeHandles: this.resizable ? this.taskResizeHandles : this.resizeHandles,
            enableBaseline: this.baselineVisible || this.enableBaseline,
            leftLabelField: this.leftLabelField,
            rightLabelField: this.rightLabelField,
            topLabelField: this.topLabelField,
            bottomLabelField: this.bottomLabelField,
            eventTemplate: this.eventTemplate,
            parentEventTemplate: this.parentEventTemplate,
            milestoneTemplate: this.milestoneTemplate,
            rollupTemplate: this.rollupTemplate,
            taskBodyTemplate: this.taskBodyTemplate,
            parentTaskBodyTemplate: this.parentTaskBodyTemplate,
            milestoneBodyTemplate: this.milestoneBodyTemplate,
            resizeConfig: this.resizeConfig,
            dragDropConfig: this.dragDropConfig,
            showRollupTasks: this.showRollupTasks
        });
        if (this.topLabelField || this.bottomLabelField) {
            this.addCls('sch-gantt-topbottom-labels ' + (this.topLabelField ? 'sch-gantt-top-label' : ''));
            this.normalViewConfig.rowHeight = 52;
        }
        this.configureFunctionality();
        this.mon(this.taskStore, {
            beforecascade: this.onBeforeCascade,
            cascade: this.onAfterCascade,
            scope: this
        });
        if (this.tooltipTpl === true) {
            this.tooltipTpl = new Gnt.template.TaskTooltip();
        }
        this.callParent(arguments);
        var sm = this.getSelectionModel();
        // https://www.assembla.com/spaces/bryntum/tickets/2609
        // Selection should not be lost after record is removed
        if (this.keepSelection && sm instanceof Ext.grid.selection.SpreadsheetModel) {
            this.mon(this.taskStore, {
                remove: this.tryRestoreSelectionAfterRemove,
                // catch event before selection model can react to that
                // for ext 6.0.1 it's enough priority to get correct selection in listener
                priority: 1,
                scope: this
            });
            // In ext 6.0.0 remove event has listeners with priority 1000 that will refresh view
            // and loose selection before we can restore it
            if (Ext.getVersion().isLessThan('6.0.1')) {
                this.mon(this.taskStore, {
                    remove: this.storeSelectionBeforeRemove,
                    // this priority required to catch remove before view is refreshed
                    priority: 1001,
                    scope: this
                });
            }
            // batch remove will trigger refresh and clear cell selection, we need to save it
            this.mon(this.taskStore, {
                beforebatchremove: this.storeSelectionBeforeRemove,
                batchremove: this.tryRestoreSelectionAfterBatchRemove,
                scope: this
            });
        }
        // if gantt is set with spreadsheet model ...
        if (sm instanceof Ext.grid.selection.SpreadsheetModel) {
            // HACK - move the drag handle into locked grid since it should not live in the 'top' grid
            var lockedGrid = this.lockedGrid;
            var old = sm.applyExtensible;
            sm.applyExtensible = function(extensible) {
                var selExt = old.apply(this, arguments);
                lockedGrid.body.appendChild(selExt.handle);
                this.applyExtensible = old;
                return selExt;
            };
        }
        if (this.autoFitOnLoad) {
            var fitOptions = typeof this.autoFitOnLoad === 'object' ? this.autoFitOnLoad : {};
            // in order to make zoomToFit work ok, normal view should have some width
            this.normalGrid.on('afterlayout', function() {
                // if store already loaded
                if (this.store.getCount()) {
                    this.zoomToFit(null, fitOptions);
                }
                // append listener now to make sure we do not fit twice during initial rendering
                this.mon(this.store, 'load', function() {
                    this.zoomToFit(null, fitOptions);
                }, this);
            }, this, {
                single: true
            });
        }
        this.bodyCls = (this.bodyCls || '') + " sch-ganttpanel-container-body";
        var ganttView = this.getSchedulingView();
        this.relayEvents(ganttView, [
            /**
             * @event taskclick
             * Fires when a task is clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskclick',
            /**
             * @event taskdblclick
             * Fires when a task is double clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskdblclick',
            /**
             * @event taskcontextmenu
             * Fires when contextmenu is activated on a task
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskcontextmenu',
            // Resizing events start --------------------------
            /**
             * @event beforetaskresize
             * Fires before a resize starts, return false to stop the execution
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskresize',
            /**
             * @event taskresizestart
             * Fires when resize starts
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             */
            'taskresizestart',
            /**
             * @event partialtaskresize
             * Fires during a resize operation and provides information about the current start and end of the resized event
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task being resized
             * @param {Date} startDate The start date of the task
             * @param {Date} endDate The end date of the task
             * @param {Ext.Element} element The element being resized
             */
            'partialtaskresize',
            /**
             * @event beforetaskresizefinalize
             * Fires before a succesful resize operation is finalized. Return false to finalize the resize at a later time.
             * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
             * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
             * @param {Mixed} view The gantt view instance
             * @param {Object} resizeContext An object containing 'record', 'start', 'end', 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskresizefinalize',
            /**
             * @event aftertaskresize
             * Fires after a succesful resize operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task that has been resized
             */
            'aftertaskresize',
            // Resizing events end --------------------------
            // Task progress bar resizing events start --------------------------
            /**
             * @event beforeprogressbarresize
             * Fires before a progress bar resize starts, return false to stop the execution
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'beforeprogressbarresize',
            /**
             * @event progressbarresizestart
             * Fires when a progress bar resize starts
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'progressbarresizestart',
            /**
             * @event afterprogressbarresize
             * Fires after a succesful progress bar resize operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord record The updated record
             */
            'afterprogressbarresize',
            // Task progressbar resizing events end --------------------------
            // Dnd events start --------------------------
            /**
             * @event beforetaskdrag
             * Fires before a task drag drop is initiated, return false to cancel it
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskdrag',
            /**
             * @event taskdragstart
             * Fires when a dnd operation starts
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record being dragged
             */
            'taskdragstart',
            /**
             * @event beforetaskdropfinalize
             * Fires before a succesful drop operation is finalized. Return false to finalize the drop at a later time.
             * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
             * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
             * @param {Mixed} view The gantt view instance
             * @param {Object} dragContext An object containing 'record', 'start', 'duration' (in minutes), 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskdropfinalize',
            /**
             * @event beforedragcreate
             * Fires before a drag create operation starts, return false to prevent the operation
             * @param {Gnt.view.Gantt} gantt The gantt view
             * @param {Gnt.model.Task} task The task record being updated
             * @param {Date} date The date of the drag start point
             * @param {Ext.EventObject} e The event object
             */
            'beforedragcreate',
            /**
             * @event dragcreatestart
             * Fires before a drag starts, return false to stop the operation
             * @param {Gnt.view.Gantt} view The gantt view
             */
            'dragcreatestart',
            /**
             * @event beforedragcreatefinalize
             * Fires before a succesful create operation is finalized. Return false to finalize creating at a later time.
             * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
             * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
             * @param {Mixed} view The gantt view instance
             * @param {Object} createContext An object containing 'record', 'start', 'end', 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforedragcreatefinalize',
            /**
             * @event dragcreateend
             * Fires after a successful drag-create operation
             * @param {Gnt.view.Gantt} view The gantt view
             * @param {Gnt.model.Task} task The updated task record
             * @param {Ext.EventObject} e The event object
             */
            'dragcreateend',
            /**
             * @event afterdragcreate
             * Always fires after a drag-create operation
             * @param {Gnt.view.Gantt} view The gantt view
             */
            'afterdragcreate',
            /**
             * @event taskdrop
             * Fires after a succesful drag and drop operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The dropped record
             */
            'taskdrop',
            /**
             * @event aftertaskdrop
             * Fires after a drag and drop operation, regardless if the drop valid or invalid
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             */
            'aftertaskdrop',
            // Dnd events end --------------------------
            /**
             * @event labeledit_beforestartedit
             * Fires before editing is started for a field
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Mixed} value The field value being set
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_beforestartedit',
            /**
             * @event labeledit_beforecomplete
             * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_beforecomplete',
            /**
             * @event labeledit_complete
             * Fires after editing is complete and any changed value has been written to the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_complete',
            /**
             * @event scheduleclick
             * Fires after a click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduleclick',
            /**
             * @event scheduledblclick
             * Fires after a doubleclick on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduledblclick',
            /**
             * @event schedulecontextmenu
             * Fires after a context menu click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'schedulecontextmenu',
            // Not supported in gridview as of Ext 6.0.1
            // https://www.sencha.com/forum/showthread.php?307978-GridPanel-should-fire-rowlongpress-celllongpress-etc&p=1124914#post1124914
            'rowlongpress',
            'containerlongpress'
        ]);
        this.relayEvents(this.lockedGrid.getView(), [
            // Not supported in gridview as of Ext 6.0.1
            // https://www.sencha.com/forum/showthread.php?307978-GridPanel-should-fire-rowlongpress-celllongpress-etc&p=1124914#post1124914
            'rowlongpress',
            'containerlongpress'
        ]);
        if (this.addRowOnTab) {
            var lockedView = this.lockedGrid.getView();
            lockedView.onRowExit = Ext.Function.createInterceptor(lockedView.onRowExit, this.beforeRowExit, this);
        }
        this.registerRenderer(ganttView.columnRenderer, ganttView);
        var cls = ' sch-ganttpanel sch-horizontal ';
        this.addCls(cls);
        if (this.eventBorderWidth < 1) {
            this.addCls('sch-gantt-no-task-border');
        }
        if (this.baselineVisible) {
            this.showBaseline();
        }
        // HACK: Editors belong in the locked grid, otherwise they float visibly on top of the normal grid when scrolling the locked grid
        this.on('add', function(me, cmp) {
            if (cmp instanceof Ext.Editor) {
                me.lockedGrid.suspendLayouts();
                me.suspendLayouts();
                me.lockedGrid.add(cmp);
                me.resumeLayouts();
                me.lockedGrid.resumeLayouts();
            }
        });
        this.on('viewready', this.onMyViewReady, this);
        // Prevent the Pan plugin from interfering with a dragcreate action
        this.on({
            dragcreatestart: function() {
                var panPlug = this.findPlugin('scheduler_pan');
                var scrollable = this.getSchedulingView().getScrollable();
                if (panPlug) {
                    panPlug.disable();
                }
                scrollable.setDisabled && scrollable.setDisabled(true);
            },
            afterdragcreate: function() {
                var panPlug = this.findPlugin('scheduler_pan');
                var scrollable = this.getSchedulingView().getScrollable();
                if (panPlug) {
                    panPlug.enable();
                }
                scrollable.setDisabled && scrollable.setDisabled(false);
            },
            scope: this
        });
        if (this.scrollTaskIntoViewOnClick) {
            this.lockedGrid.on('itemclick', this.onRowClicked, this);
        }
        Ext.Array.each(this.lockedGrid.plugins || [], function(plug) {
            if (Sch.plugin && Sch.plugin.TreeCellEditing && plug instanceof Sch.plugin.TreeCellEditing) {
                this.ganttEditingPlugin = plug;
                return false;
            }
        }, this);
    },
    onRender: function() {
        this.setRowHeight(this.rowHeight);
        this.callParent(arguments);
    },
    tryRestoreSelectionAfterRemove: function(store, records, index) {
        // this listener is prioritized, it will get old data in selection model and modified store/view
        var selModel = this.getSelectionModel();
        var selected = this._lastSpreadsheetSelection || selModel.selected;
        this._lastSpreadsheetSelection = null;
        // nothing was selected yet or store is empty
        if (!selected || store.getCount() === 0) {
            return;
        }
        var view = this.lockedGrid.getView();
        if (selected.isCells) {
            var range = selected.getRange();
            // Do not do anything, if negative coordinates passed. Can happen when node is collapsed with
            // click in 6.0.1
            if (range[1][0] === -1) {
                return;
            }
            var nodesCount = view.getNodes().length - 1;
            selModel.selectCells([
                range[0][0],
                Math.min(nodesCount, range[0][1])
            ], [
                range[1][0],
                Math.min(nodesCount, range[1][1])
            ]);
        } else if (selected.isRows) {
            var selectedRecords = selected.getRecords();
            if (selectedRecords.length) {
                var selectedRecordExists = false;
                for (var i = 0,
                    len = selectedRecords.length; i < len; i++) {
                    // if any record from current selection is still alive - selection model will handle it itself
                    if (selectedRecordExists = selectedRecordExists || store.indexOf(selectedRecords[i]) !== -1) {
                        break;
                    }
                }
                // if smth was selected and nothing is now - select record by current index or last in store
                if (!selectedRecordExists) {
                    var recordToSelect = view.getRecord(Math.min(index, store.getCount() - 1));
                    recordToSelect && selModel.select(recordToSelect);
                }
            }
        }
    },
    storeSelectionBeforeRemove: function() {
        var selected = this.getSelectionModel().getSelected();
        if (!selected) {
            return;
        }
        selected = selected.clone();
        if (selected.isRows) {
            var records = selected.getRecords();
            if (records.length) {
                selected._lastRecordIndex = this.getView().indexOf(records[records.length - 1]);
            }
        }
        this._lastSpreadsheetSelection = selected;
    },
    tryRestoreSelectionAfterBatchRemove: function(store, records) {
        var selected = this._lastSpreadsheetSelection;
        this._lastSpreadsheetSelection = null;
        // We suspend remove event for some operations, firing batchremove instead. In this case we should notify
        // selection model that records were removed.
        // 3rd argument is not utilized, 4th - should be false, because we don't move records
        this.getSelectionModel().onStoreRemove(store, records, null, false);
        if (!selected || store.getCount() === 0) {
            return;
        }
        var selModel = this.getSelectionModel();
        var view = this.lockedGrid.getView();
        if (selected.isCells) {
            var range = selected.getRange();
            // Do not do anything, if negative coordinates passed. Can happen when node is collapsed with
            // click in 6.0.1
            if (range[1][0] === -1) {
                return;
            }
            var nodesCount = view.getNodes().length;
            selModel.selectCells([
                range[0][0],
                Math.min(nodesCount, range[0][1])
            ], [
                range[1][0],
                Math.min(nodesCount, range[1][1])
            ]);
        } else if (selected.isRows) {
            var selectedRecords = selected.getRecords();
            var selectedRecordExists = false;
            for (var i = 0,
                len = selectedRecords.length; i < len; i++) {
                // if any record from current selection is still alive - selection model will handle it itself
                if (selectedRecordExists = selectedRecordExists || store.indexOf(selectedRecords[i]) !== -1) {
                    break;
                }
            }
            // if smth was selected and nothing is now - select record by current index or last in store
            if (!selectedRecordExists) {
                var recordToSelect = view.getRecord(Math.min(selected._lastRecordIndex, store.getCount() - 1));
                recordToSelect && selModel.select(recordToSelect);
            }
        }
    },
    getTreeViewDragDropPlugin: function() {
        var plugins = this.lockedGrid.view.plugins || [];
        var plugin;
        for (var i = 0; i < plugins.length; i++) {
            plugin = plugins[i];
            // this class is required in patch
            if (plugin instanceof Ext.tree.plugin.TreeViewDragDrop) {
                return plugin;
            }
        }
    },
    doSetTreeViewDragDropDisabled: function(disabled) {
        var plugin = this.getTreeViewDragDropPlugin();
        if (plugin) {
            if (disabled) {
                plugin.disable();
            } else {
                plugin.enable();
            }
        }
    },
    setTreeViewDragDropDisabled: function(disabled) {
        var me = this;
        var view = this.lockedGrid.view;
        if (view.rendered) {
            me.doSetTreeViewDragDropDisabled(disabled);
        } else {
            view.on('render', function() {
                me.doSetTreeViewDragDropDisabled(disabled);
            });
        }
    },
    restoreSpreadsheetSelectionModel: function() {
        var selModel = this.getSelectionModel(),
            plugin = this.getTreeViewDragDropPlugin();
        // only restore listener if selection model and dragdrop plugin are disabled
        if (selModel.isLocked() && plugin && !plugin.disabled) {
            selModel.setLocked(false);
            this.setTreeViewDragDropDisabled(true);
            this.lockedGrid.view.on('cellmousedown', selModel.handleMouseDown, selModel);
            selModel.navigationListeners = selModel.navigationModel.on({
                navigate: selModel.onNavigate,
                scope: selModel,
                destroyable: true
            });
        }
    },
    //selectionModel.cellSelect = selectionModel._cellSelect;
    //selectionModel.rowSelect = selectionModel._rowSelect;
    setReadOnly: function(readOnly) {
        this.callParent(arguments);
        // notify other parts of readOnly mode switching
        this.fireEvent('setreadonly', this, readOnly);
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore;
    },
    bindAutoTimeSpanListeners: function() {
        if (!this.autoFitOnLoad) {
            this.callParent(arguments);
        }
    },
    // Make sure views doesn't react to store changes during cascading
    onBeforeCascade: function() {
        // HACK no easy way to disable grid view from reacting to the store
        this.lockedGrid.view.onUpdate = this.normalGrid.view.onUpdate = Ext.emptyFn;
        this.suspendLayouts();
    },
    // Re-activate view->store listeners and update views if needed
    onAfterCascade: function(treeStore, context) {
        var me = this;
        this.lockedGrid.view.onUpdate = this.lockedGrid.view.self.prototype.onUpdate;
        this.normalGrid.view.onUpdate = this.normalGrid.view.self.prototype.onUpdate;
        me.resumeLayouts();
        if (context.nbrAffected > 0) {
            var lockedView = this.lockedGrid.getView();
            // Manual refresh of a few row nodes is way faster in large DOM scenarios where the
            // refresh operation takes too long (read/set scroll position, gridview refreshSize etc)
            if (context.nbrAffected <= me.simpleCascadeThreshold) {
                var view = this.getView();
                var ganttView = this.getSchedulingView();
                // let the view finish redrawing all the rows before we are trying to repaint dependencies
                ganttView.suspendEvents(true);
                // "context.affected" will contain parent affected parent tasks as well
                for (var id in context.affected) {
                    var task = context.affected[id];
                    var index = lockedView.store.indexOf(task);
                    // The target task may be inside a collapsed parent, in which case we should ignore updating it
                    if (index >= 0) {
                        view.refreshNode(index);
                    }
                }
                ganttView.resumeEvents();
                return;
            }
            this.refreshViews();
        }
    },
    bindFullRefreshListeners: function(column) {
        var me = this;
        var refreshColumn = function() {
                if (me.refreshTimer)  {
                    return;
                }
                
                me.refreshTimer = setTimeout(function() {
                    me.refreshTimer = null;
                    me.redrawColumns([
                        column
                    ]);
                }, me.refreshTimeout);
            };
        column.mon(this.taskStore, {
            nodeappend: refreshColumn,
            nodeinsert: refreshColumn,
            noderemove: refreshColumn,
            scope: this
        });
    },
    bindSequentialDataListeners: function(column) {
        var lockedView = this.lockedGrid.view;
        var taskStore = this.taskStore;
        // the combination of buffered renderer + tree will perform a full refresh on any CRUD,
        // no need to update only some of the cells
        // Update: Seems unreliable
        //if (lockedView.bufferedRenderer) return;
        column.mon(taskStore, {
            nodeappend: function(store, node) {
                if (!taskStore.fillCount) {
                    // We refresh all nodes following the inserted node parent (since at this point, node is not yet part of the store)
                    this.updateAutoGeneratedCells(column, lockedView.store.indexOf(node.parentNode));
                }
            },
            nodeinsert: function(store, node, insertedBefore) {
                this.updateAutoGeneratedCells(column, lockedView.store.indexOf(insertedBefore));
            },
            noderemove: function(store, node, isMove) {
                if (!isMove) {
                    this.updateAutoGeneratedCells(column, lockedView.store.indexOf(node));
                }
            },
            nodemove: function(store, oldParent) {
                this.updateAutoGeneratedCells(column, lockedView.store.indexOf(oldParent));
            },
            scope: this
        });
    },
    bindSlackListeners: function() {
        var updateSlackColumns = Ext.Function.createBuffered(this.updateSlackColumns, this.refreshTimeout, this, []);
        this.slackListeners = this.mon(this.taskStore, {
            resetearlydates: updateSlackColumns,
            resetlatedates: updateSlackColumns,
            scope: this,
            destroyable: true
        });
    },
    bindEarlyDatesListeners: function() {
        var updateEarlyDateColumns = Ext.Function.createBuffered(this.updateEarlyDateColumns, this.refreshTimeout, this, []);
        this.earlyDatesListeners = this.mon(this.taskStore, {
            resetearlydates: updateEarlyDateColumns,
            scope: this,
            destroyable: true
        });
    },
    bindLateDatesListeners: function() {
        var updateLateDateColumns = Ext.Function.createBuffered(this.updateLateDateColumns, this.refreshTimeout, this, []);
        this.lateDatesListeners = this.mon(this.taskStore, {
            resetlatedates: updateLateDateColumns,
            scope: this,
            destroyable: true
        });
    },
    startEditScrollToEditor: function() {
        var editingPlugin = this.ganttEditingPlugin;
        // HACK: Need to do an extra 'realign' call since the Ext call to show the editor messes up the scrollposition
        // See test 1002_tabbing.t.js
        !Sch.disableOverrides && editingPlugin && editingPlugin.on('beforeedit', function(plug, context) {
            context.column.getEl().scrollIntoView(this.lockedGrid.getHeaderContainer().getEl());
        }, this, {
            single: true
        });
    },
    beforeRowExit: function(keyEvent, prevRow, newRow, forward) {
        // In < Ext 6.2, only 3 arguments
        if (!(keyEvent instanceof Ext.event.Event)) {
            forward = newRow;
            newRow = prevRow;
            prevRow = keyEvent;
        }
        if (forward && !newRow) {
            var view = this.lockedGrid.getView();
            var record = view.getRecord(prevRow);
            var newRec = record.addTaskBelow({
                    leaf: true
                });
            this.startEditScrollToEditor(newRec);
        }
    },
    // this function checks whether the configuration option should be translated to task store or calendar
    // idea is that some configuration option (`cascadeChanges` for example) actually belongs to TaskStore
    // so they are not persisted in the gantt panel (panel only provides accessors which reads/write from/to TaskStore)
    // however the values for those options could also be specified in the prototype of the Gnt.panel.Gantt subclass
    // see #172
    needToTranslateOption: function(optionName) {
        return this.hasOwnProperty(optionName) || this.self.prototype.hasOwnProperty(optionName) && this.self != Gnt.panel.Gantt;
    },
    /**
     * <p>Returns the task record for a DOM node</p>
     * @param {Ext.Element/HTMLElement} el The DOM node or Ext Element to lookup
     * @return {Gnt.model.Task} The task record
     */
    resolveTaskRecord: function(el) {
        return this.getSchedulingView().resolveTaskRecord(el);
    },
    /**
     * Tries to fit the time columns to the available view width
     */
    fitTimeColumns: function() {
        this.getSchedulingView().fitColumns();
    },
    /**
     * Returns the resource store associated with the Gantt panel instance
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function() {
        return this.getTaskStore().getResourceStore();
    },
    /**
     * Returns the assignment store associated with the Gantt panel instance
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.getTaskStore().getAssignmentStore();
    },
    /**
     * Returns the associated CRUD manager
     * @return {Gnt.data.CrudManager}
     */
    getCrudManager: function() {
        return this.crudManager;
    },
    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    /**
     * Returns the task store instance
     * @return {Gnt.data.TaskStore}
     */
    getEventStore: function() {
        return this.taskStore;
    },
    /**
     * Returns the associated dependency store
     * @return {Gnt.data.DependencyStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    // private
    onDragDropStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },
    // private
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
    },
    // private
    configureFunctionality: function() {
        // Normalize to array
        var plugins = this.plugins = [].concat(this.plugins || []);
        if (this.enableConstraintsResolutionGui && !Ext.Array.findBy(plugins, function(item) {
            return (item instanceof Gnt.plugin.ConstraintResolutionGui) || (item.ptype == 'constraintresolutiongui');
        })) {
            plugins.push(Ext.apply(this.constraintResolutionGuiConfig || {}, {
                pluginId: "constraintresolutiongui",
                ptype: "constraintresolutiongui"
            }));
        }
        if (this.showProjectLines) {
            plugins.push(Ext.apply({
                pluginId: 'gantt_projectlines',
                ptype: 'gantt_projectlines'
            }, this.projectLinesConfig));
        }
        // Either object or boolean
        if (this.enableTaskReordering) {
            // if config is defined in prototype or not defined at all - define property on instance
            if (!this.hasOwnProperty('lockedViewConfig')) {
                this.lockedViewConfig = Ext.apply({}, this.lockedViewConfig || {});
            }
            this.lockedViewConfig.plugins = [].concat(this.lockedViewConfig.plugins || []);
            // HACK - remove post v4.0
            // Users may have added their own drag drop plugin, in such case we should not add our owns
            var lockedViewPlugins = this.lockedViewConfig.plugins;
            var userAddedOwnDragDropPlugin;
            Ext.Array.each(lockedViewPlugins, function(plug) {
                if (plug === 'treeviewdragdrop' || plug.ptype === 'treeviewdragdrop') {
                    userAddedOwnDragDropPlugin = true;
                }
            });
            if (!userAddedOwnDragDropPlugin) {
                var pluginConfig = typeof this.enableTaskReordering !== 'boolean' ? this.enableTaskReordering : {
                        ptype: 'treeviewdragdrop',
                        pluginId: 'bryntum_treedragdrop',
                        nodeHighlightOnDrop: false,
                        nodeHighlightOnRepair: false,
                        containerScroll: true,
                        dragZone: {
                            onBeforeDrag: Ext.Function.bind(this.onBeforeTaskReorder, this),
                            beforeDragOver: Ext.Function.bind(this.onBeforeTaskReorderOver, this)
                        },
                        dropZone: {
                            onNodeDrop: this.onTaskReorder
                        }
                    };
                lockedViewPlugins.push(pluginConfig);
            }
        }
    },
    /**
     * If configured to highlight non-working time, this method returns the {@link Sch.plugin.NonWorkingTime workingTime} feature
     * responsible for providing this functionality.
     * @return {Sch.plugin.NonWorkingTime} workingTime
     */
    getWorkingTimePlugin: function() {
        return this.workingTimePlugin;
    },
    registerLockedDependencyListeners: function() {
        var me = this;
        var depStore = this.getDependencyStore();
        // Need to save these to be able to deregister them properly.
        this._lockedDependencyListeners = this._lockedDependencyListeners || {
            load: function() {
                var taskStore = me.getTaskStore();
                // reset cached early/late dates
                taskStore.resetEarlyDates();
                taskStore.resetLateDates();
                me.lockedGrid.getView().refreshView();
            },
            clear: function() {
                var taskStore = me.getTaskStore();
                // reset cached early/late dates
                taskStore.resetEarlyDates();
                taskStore.resetLateDates();
                me.lockedGrid.getView().refreshView();
            },
            add: function(depStore, records) {
                me.refreshTasksForDependencies(records);
            },
            update: function(depStore, record, operation) {
                if (operation != Ext.data.Model.COMMIT) {
                    var view = me.lockedGrid.view;
                    if (record.previous[record.fromField]) {
                        var prevFromTask = me.taskStore.getModelById(record.previous[record.fromField]);
                        if (prevFromTask) {
                            view.refreshNode(prevFromTask);
                        }
                    }
                    if (record.previous[record.toField]) {
                        var prevToTask = me.taskStore.getModelById(record.previous[record.toField]);
                        if (prevToTask) {
                            view.refreshNode(prevToTask);
                        }
                    }
                }
                // we update the record related tasks not for EDIT operation only
                // since we need to react on record COMMIT as well
                me.refreshTasksForDependencies([
                    record
                ]);
            },
            remove: function(depStore, records) {
                me.refreshTasksForDependencies(records);
            }
        };
        // This could be called multiple times, if both predecessor and successor columns are used
        this.mun(depStore, this._lockedDependencyListeners);
        this.mon(depStore, this._lockedDependencyListeners);
    },
    getDependencyTasks: function(depRecord) {
        var sourceTask = depRecord.getSourceTask(this.taskStore),
            targetTask = depRecord.getTargetTask(this.taskStore),
            result = [];
        // we should not refresh node which is being removed
        if (sourceTask && sourceTask.getTreeStore()) {
            result.push(sourceTask);
        }
        if (targetTask && targetTask.getTreeStore()) {
            result.push(targetTask);
        }
        return result;
    },
    refreshLockedViewRows: function(tasks) {
        var lockedView = this.lockedGrid.view;
        for (var i = 0; i < tasks.length; i++) {
            lockedView.refreshNode(tasks[i]);
        }
    },
    refreshTasksForDependencies: function(dependencies) {
        var me = this,
            addedTasks = {},
            toRefresh = [];
        Ext.Array.each(dependencies, function(dependency) {
            // get dependency related tasks
            var tasks = me.getDependencyTasks(dependency);
            for (var i = 0; i < tasks.length; i++) {
                // put them into toRefresh array if they aren't there already
                if (!addedTasks[tasks[i].getId()]) {
                    addedTasks[tasks[i].getId()] = 1;
                    toRefresh.push(tasks[i]);
                }
            }
            me.refreshLockedViewRows(toRefresh);
        });
    },
    /**
     * Shows the baseline tasks
     */
    showBaseline: function() {
        this.addCls('sch-ganttpanel-showbaseline');
    },
    /**
     * Hides the baseline tasks
     */
    hideBaseline: function() {
        this.removeCls('sch-ganttpanel-showbaseline');
    },
    /**
     * Toggles the display of the baseline
     */
    toggleBaseline: function() {
        this.toggleCls('sch-ganttpanel-showbaseline');
    },
    /**
     * Changes the timeframe of the gantt chart to fit all the tasks in it. Provide left/right margin if you want to fit also
     * labels.
     * @param {Gnt.model.Task/Gnt.model.Task[]} [tasks] A list of tasks to zoom to. If not specified then the gantt will
     * try to fit all the tasks in the {@link #taskStore task store}.
     * @param {Object} [options] Options object for zooming.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first task start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last task end date and last visible date
     */
    zoomToFit: function(tasks, options) {
        options = Ext.apply({
            adjustStart: 1,
            adjustEnd: 1
        }, options);
        // If view is being filtered, only considered the matching results when zooming
        if (!tasks && this.taskStore.isTreeFiltered()) {
            tasks = this.getSchedulingView().store.getRange();
        }
        var span = tasks ? this.taskStore.getTimeSpanForTasks(tasks) : this.taskStore.getTotalTimeSpan();
        if (this.zoomToSpan(span, options) === null) {
            // if no zooming was performed - fit columns to view space
            if (!tasks)  {
                this.fitTimeColumns();
            }
            
        }
    },
    /**
     * "Get" accessor for the `cascadeChanges` option
     */
    getCascadeChanges: function() {
        return this.taskStore.cascadeChanges;
    },
    /**
     * "Set" accessor for the `cascadeChanges` option
     */
    setCascadeChanges: function(value) {
        this.taskStore.cascadeChanges = value;
    },
    /**
     * "Get" accessor for the `recalculateParents` option
     */
    getRecalculateParents: function() {
        return this.taskStore.recalculateParents;
    },
    /**
     * "Set" accessor for the `recalculateParents` option
     */
    setRecalculateParents: function(value) {
        this.taskStore.recalculateParents = value;
    },
    /**
     * "Set" accessor for the `skipWeekendsDuringDragDrop` option
     */
    setSkipWeekendsDuringDragDrop: function(value) {
        this.taskStore.skipWeekendsDuringDragDrop = this.skipWeekendsDuringDragDrop = value;
    },
    /**
     * "Get" accessor for the `skipWeekendsDuringDragDrop` option
     */
    getSkipWeekendsDuringDragDrop: function() {
        return this.taskStore.skipWeekendsDuringDragDrop;
    },
    bindResourceStore: function(resourceStore, initial) {
        var me = this;
        var listeners = {
                scope: me,
                update: me.onResourceStoreUpdate,
                datachanged: me.onResourceStoreDataChanged
            };
        if (!initial && me.resourceStore) {
            if (resourceStore !== me.resourceStore && me.resourceStore.autoDestroy) {
                me.resourceStore.destroy();
            } else {
                me.mun(me.resourceStore, listeners);
            }
            if (!resourceStore) {
                me.resourceStore = null;
            }
        }
        if (resourceStore) {
            resourceStore = Ext.data.StoreManager.lookup(resourceStore);
            me.mon(resourceStore, listeners);
            this.taskStore.setResourceStore(resourceStore);
        }
        me.resourceStore = resourceStore;
        if (resourceStore && !initial) {
            me.refreshViews();
        }
    },
    bindAssignmentStore: function(assignmentStore, initial) {
        var me = this;
        var listeners = {
                scope: me,
                beforetaskassignmentschange: me.onBeforeSingleTaskAssignmentChange,
                taskassignmentschanged: me.onSingleTaskAssignmentChange,
                update: me.onAssignmentStoreUpdate,
                datachanged: me.onAssignmentStoreDataChanged
            };
        if (!initial && me.assignmentStore) {
            if (assignmentStore !== me.assignmentStore && me.assignmentStore.autoDestroy) {
                me.assignmentStore.destroy();
            } else {
                me.mun(me.assignmentStore, listeners);
            }
            if (!assignmentStore) {
                me.assignmentStore = null;
            }
        }
        if (assignmentStore) {
            assignmentStore = Ext.data.StoreManager.lookup(assignmentStore);
            me.mon(assignmentStore, listeners);
            this.taskStore.setAssignmentStore(assignmentStore);
        }
        me.assignmentStore = assignmentStore;
        if (assignmentStore && !initial) {
            me.refreshViews();
        }
    },
    // BEGIN RESOURCE STORE LISTENERS
    onResourceStoreUpdate: function(store, resource) {
        Ext.Array.each(resource.getTasks(), function(task) {
            var index = this.lockedGrid.view.store.indexOf(task);
            if (index >= 0) {
                this.getView().refreshNode(index);
            }
        }, this);
    },
    onResourceStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },
    // EOF RESOURCE STORE LISTENERS
    // BEGIN ASSIGNMENT STORE LISTENERS
    onAssignmentStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },
    onAssignmentStoreUpdate: function(store, assignment) {
        var task = assignment.getTask();
        if (task) {
            var index = this.lockedGrid.view.store.indexOf(task);
            if (index >= 0) {
                this.getView().refreshNode(index);
            }
        }
    },
    // We should not react to changes in the assignment store when it is happening for a single resource
    // We rely on the "taskassignmentschanged" event for updating the UI
    onBeforeSingleTaskAssignmentChange: function() {
        this.assignmentStore.un('datachanged', this.onAssignmentStoreDataChanged, this);
    },
    onSingleTaskAssignmentChange: function(assignmentStore, taskId) {
        this.assignmentStore.on('datachanged', this.onAssignmentStoreDataChanged, this);
        if (this.rendered) {
            var task = this.taskStore.getModelById(taskId);
            // Make sure task is part of the tree and wasn't just removed
            if (task && task.parentNode) {
                var index = this.taskStore.indexOf(task);
                if (index >= 0) {
                    this.getView().refreshNode(index);
                }
            }
        }
    },
    // EOF ASSIGNMENT STORE LISTENERS
    updateAutoGeneratedCells: function(column, recordIndex) {
        var view = this.lockedGrid.view;
        var startIndex = view.all.startIndex;
        var endIndex = view.all.endIndex;
        if (recordIndex < 0 || recordIndex > endIndex)  {
            return;
        }
        
        for (var i = Math.max(startIndex, recordIndex); i <= endIndex; i++) {
            var rec = view.store.getAt(i);
            var cell = this.getCellDom(view, rec, column);
            if (cell) {
                cell.firstChild.innerHTML = column.renderer(null, null, rec);
            }
        }
    },
    getCellDom: function(view, record, column) {
        var row = view.getNode(record, true);
        return row && Ext.fly(row).down(column.getCellSelector(), true);
    },
    redrawCell: function(column, record, recordIndex, rowIndex, columnIndex) {
        if (!this.isDestroyed) {
            var view = this.lockedGrid.view;
            var cell = this.getCellDom(view, record, column);
            // cell might be null for a hidden column
            if (cell) {
                var out = [];
                if (recordIndex === undefined) {
                    recordIndex = this.taskStore.indexOf(record);
                }
                if (rowIndex === undefined) {
                    rowIndex = view.indexOf(record);
                }
                if (columnIndex === undefined) {
                    columnIndex = column.getIndex();
                }
                view.renderCell(column, record, recordIndex, rowIndex, columnIndex, out);
                // out contain whole cell element starting from <td>, but createDom will return only inner element
                var newContent = Ext.DomHelper.createDom(out.join(''));
                // use sync content for the inner element, because cell can still contain editor
                Ext.fly(cell).down('.' + Ext.baseCSSPrefix + 'grid-cell-inner').syncContent(newContent);
            }
        }
    },
    redrawColumns: function(cols) {
        // this method is called a lot from various buffered listeners, need to check
        // if component has not been destroyed
        if (cols.length && !this.isDestroyed) {
            var view = this.lockedGrid.view;
            for (var i = view.all.startIndex; i <= view.all.endIndex; i++) {
                var rec = view.store.getAt(i);
                for (var j = 0,
                    ll = cols.length; j < ll; j++) {
                    var col = cols[j];
                    this.redrawCell(col, rec, i, i, col.getIndex());
                }
            }
        }
    },
    updateSlackColumns: function() {
        if (this.slackColumn)  {
            this.redrawColumns([
                this.slackColumn
            ]);
        }
        
    },
    updateEarlyDateColumns: function() {
        var cols = [];
        if (this.earlyStartColumn)  {
            cols.push(this.earlyStartColumn);
        }
        
        if (this.earlyEndColumn)  {
            cols.push(this.earlyEndColumn);
        }
        
        if (cols.length)  {
            this.redrawColumns(cols);
        }
        
    },
    updateLateDateColumns: function() {
        var cols = [];
        if (this.lateStartColumn)  {
            cols.push(this.lateStartColumn);
        }
        
        if (this.lateEndColumn)  {
            cols.push(this.lateEndColumn);
        }
        
        if (cols.length)  {
            this.redrawColumns(cols);
        }
        
    },
    onMyViewReady: function() {
        // Prevent editing of non-editable fields
        this.on('beforeedit', this.onBeforeEdit, this);
        this.setupColumnListeners();
        this.mon(this.taskStore, {
            'nodestore-datachange-start': this.onFilterChange,
            'filter-clear': this.onFilterChange,
            scope: this
        });
        var splitter = this.down('splitter');
        if (splitter) {
            // Since Ext JS doesn't handle locked grid sizing, we do this ourselves.
            splitter.on('dragend', function() {
                this.saveState();
            }, this, {
                delay: 10
            });
        }
        if (this.ganttEditingPlugin) {
            // Fixing bug described in this fiddle
            // https://fiddle.sencha.com/#fiddle/19dc
            if ((Ext.isIE10m || Ext.isFirefox) && Ext.getVersion().isLessThan('6.0.2')) {
                this.applyIETabbingPatch();
            }
            this.ganttEditingPlugin.on({
                editingstart: this.onEditingStart,
                edit: this.onAfterEdit,
                canceledit: this.onAfterEdit
            });
        }
        var dragDropPlugin = this.getTreeViewDragDropPlugin();
        // Tree view dragdrop plugin doesn't work with spreadsheet, disable it on mouse move and
        // enable only when dragdrop column is hovered.
        if (dragDropPlugin && this.getSelectionModel() instanceof Ext.grid.selection.SpreadsheetModel) {
            var view = this.lockedGrid.getView();
            // disable treeviewdragdrop plugin
            // https://www.sencha.com/forum/showthread.php?305681-Spreadsheet-tree-dragdrop-plugin
            view.getEl().on('mouseover', function(e, cell) {
                if (Ext.fly(cell).hasCls('sch-gantt-column-dragdrop')) {
                    dragDropPlugin.enable();
                } else if (!dragDropPlugin.dragZone.dragging) {
                    // disable plugin only if no current drag is happening
                    dragDropPlugin.disable();
                }
            }, this, {
                delegate: view.getCellSelector()
            });
        }
    },
    // When value in editor is changed and user presses tab, editor in the next cell is activated and focused. Blur on
    // previous editor will trigger complete edit. In some cases value in the next cell can be changed (i.e. when we
    // set start date to be greater than end date) and this will trigger row update process (see
    // Ext.view.Table#handleUpdate method). 'beforeitemupdate' event will be fired just before and cellediting plugin
    // will try to save currently focused editor (which is in the new cell), then ext will render new row
    // (because we set hasCustomRenderer to true to columns), sync content for updated cells and after will fire
    // 'itemupdate' which will be caught by plugin and it will try to restore editing and won't do it properly. After
    // some massive focus jumping view will receive focus and will stop editing.
    // Our solution is to prevent update for the certain cell - one we tabbed into, and restore it as soon as we
    // tab away. preventUpdate flag is used, because it's only way to block update without overriding whole
    // Ext.view.Table#handleUpdate method. We also should update cell value every time editing is completed/cancelled
    // to keep it synced with model.
    // NOTE: only applicable to ext 6.0.1 in IE10 and older.
    // Covered by 1002_tabbing_4
    applyIETabbingPatch: function() {
        var restoreColumnUpdate = function(plugin, context) {
                var column = context.column;
                column.preventUpdate = column._oldPreventUpdate;
                this.redrawCell(column, context.record);
            };
        var blockColumnUpdate = function(plugin, context) {
                var column = context.column;
                // private property, used in widget column so we have to store original value
                column._oldPreventUpdate = column.preventUpdate;
                column.preventUpdate = true;
            };
        this.ganttEditingPlugin.on({
            edit: restoreColumnUpdate,
            canceledit: restoreColumnUpdate,
            scope: this
        });
        this.ganttEditingPlugin.on({
            beforeedit: blockColumnUpdate,
            // need a low prio on this listener in case editing is prevented
            priority: -50
        });
    },
    onBeforeEdit: function(editor, o) {
        var column = o.column;
        return !this.isReadOnly() && o.record.isEditable(o.field) && (!column.isEditable || column.isEditable(o.record));
    },
    onEditingStart: function(plug, editor) {
        var field = editor.field;
        // Set instant update enabled only after editing has started
        if (field.originalInstantUpdate) {
            field.setInstantUpdate(true);
        }
    },
    onAfterEdit: function(editor, context) {
        var field = context.column.getEditor();
        if (field.setInstantUpdate) {
            field.setInstantUpdate(false);
        }
    },
    onFilterChange: function() {
        this.getSelectionModel().deselectAll();
    },
    setupColumnListeners: function() {
        var me = this;
        var lockedHeader = this.lockedGrid.getHeaderContainer();
        lockedHeader.on('add', this.onLockedColumnAdded, this);
        lockedHeader.items.each(function(col) {
            me.onLockedColumnAdded(lockedHeader, col);
        });
    },
    onLockedColumnAdded: function(ct, col) {
        var GntCol = Gnt.column;
        // Gnt.column can be null if no class from that namespace was used/required. We don't require that, so better check
        if (GntCol) {
            if ((GntCol.WBS && col instanceof GntCol.WBS) || (GntCol.Sequence && col instanceof GntCol.Sequence)) {
                this.bindSequentialDataListeners(col);
            } else if (GntCol.Dependency && col instanceof GntCol.Dependency && col.useSequenceNumber) {
                this.bindFullRefreshListeners(col);
            } else if (GntCol.EarlyStartDate && col instanceof GntCol.EarlyStartDate)  {
                this.earlyStartColumn = col;
            }
            else if (GntCol.EarlyEndDate && col instanceof GntCol.EarlyEndDate)  {
                this.earlyEndColumn = col;
            }
            else if (GntCol.LateStartDate && col instanceof GntCol.LateStartDate)  {
                this.lateStartColumn = col;
            }
            else if (GntCol.LateEndDate && col instanceof GntCol.LateEndDate)  {
                this.lateEndColumn = col;
            }
            else if (GntCol.Slack && col instanceof GntCol.Slack)  {
                this.slackColumn = col;
            }
            
        }
        if (!this.slackListeners && this.slackColumn) {
            this.bindSlackListeners();
        }
        if (!this.earlyDatesListeners && (this.earlyStartColumn || this.earlyEndColumn)) {
            this.bindEarlyDatesListeners();
        }
        if (!this.lateDatesListeners && (this.lateStartColumn || this.lateEndColumn)) {
            this.bindLateDatesListeners();
        }
    },
    getState: function() {
        var me = this,
            state = me.callParent(arguments);
        state.lockedWidth = me.lockedGrid.getWidth();
        return state;
    },
    applyState: function(state) {
        var me = this;
        me.callParent(arguments);
        if (state && state.lockedWidth) {
            me.lockedGrid.setWidth(state.lockedWidth);
        }
    },
    completeEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.completeEdit();
    },
    cancelEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.cancelEdit();
    },
    setRowHeight: function(height) {
        var rowHeightSelector = '#' + this.getId() + ' .' + Ext.baseCSSPrefix + 'grid-cell';
        var rule = rowHeightSelector + '{ height:' + height + 'px; }';
        if (!this.rowHeightStyleSheetNode) {
            // Create panel specific row height rule
            this.rowHeightStyleSheetNode = Ext.util.CSS.createStyleSheet(rule).ownerNode;
        } else {
            this.rowHeightStyleSheetNode.innerHTML = rule;
        }
        // Let view know about this too
        this.getSchedulingView().setRowHeight(height);
    },
    // If task is provided returns a proper task editor plugin instance that can be used for editing.
    // Return any task editor instance available when no task is provided.
    getTaskEditor: function(task) {
        var plugins = this.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
            var plugin = plugins[i];
            if (plugin.isTaskEditor && (!task || plugin.matchFilters(task)))  {
                return plugin;
            }
            
        }
    },
    onRowClicked: function(panel, task) {
        this.getSchedulingView().scrollEventIntoView(task, false, false);
    },
    // BEGIN TREE NODE REORDERING HOOKS
    // Prevents a readonly task reordering or any task reordering if the gantt is in readonly mode.
    onBeforeTaskReorder: function(data, ev) {
        var task = ev.record;
        // remember task being reordered
        this._reorderingTask = task;
        // reorder if the panel and the task being drag are not readonly
        return !this.isReadOnly() && task && !task.isReadOnly();
    },
    // Prevents dropping a task being reordered into another readonly task
    onBeforeTaskReorderOver: function(dropZone, ev) {
        var target = dropZone.getTargetFromEvent(ev);
        if (target) {
            var targetTask = dropZone.view.getRecord(target);
            return targetTask !== this._reorderingTask && !targetTask.isReadOnly();
        }
    },
    // Prevent excessive parent node calculations during tree restructuring
    // https://app.assembla.com/spaces/bryntum/tickets/3049-treeviewdragdrop-is-slow-when-reordering-50+-nodes-/details#
    onTaskReorder: function(nodeData, source, e, data) {
        var taskStore = source.view.store;
        var tasks = data.records;
        var affectedParents = {};
        var gantt = source.view.up('ganttpanel');
        var falseFn = function() {
                return false;
            };
        // Prevent excessive view refreshes
        // https://www.sencha.com/forum/showthread.php?322186-Full-refresh-after-tree-view-drag-drop-once-for-every-dropped-node&p=1151897#post1151897
        gantt.lockedGrid.view.on('beforerefresh', falseFn);
        gantt.normalGrid.view.on('beforerefresh', falseFn);
        // Collect all old parent nodes of all moved tasks
        Ext.Array.each(tasks, function(task) {
            affectedParents[task.parentNode.id] = task.parentNode;
        });
        // Prevent excessive parent recalculation
        taskStore.suspendAutoRecalculateParents++;
        this.self.prototype.onNodeDrop.apply(this, arguments);
        taskStore.suspendAutoRecalculateParents--;
        // Add the new parent node of moved tasks
        affectedParents[tasks[0].parentNode.id] = tasks[0].parentNode;
        var affectedParentsArray = Ext.Object.getValues(affectedParents);
        // Process deepest nodes first, sort accordingly
        affectedParentsArray.sort(function(node1, node2) {
            return node1.data.depth > node2.data.depth ? -1 : 1;
        });
        Ext.Array.each(affectedParentsArray, function(parent) {
            parent.refreshCalculatedParentNodeData();
        });
        gantt.lockedGrid.view.un('beforerefresh', falseFn);
        gantt.normalGrid.view.un('beforerefresh', falseFn);
        gantt.refreshViews();
    },
    // EOF TREE NODE REORDERING HOOKS
    /**
    * Returns an array of the currently selected rows
    *
    * @return {[Gnt.model.Task]}
    * */
    getSelectedRows: function() {
        var selected = this.getSelectionModel().getSelected();
        var tasks = [];
        if (Ext.grid.selection.Cells && selected instanceof Ext.grid.selection.Cells) {
            selected.eachRow(function(task) {
                tasks.push(task);
            });
        } else {
            // Rows are being selected
            tasks = this.getSelectionModel().getSelection();
        }
        return tasks;
    },
    destroy: function() {
        if (this.destroyStores) {
            var calendarManager = this.taskStore.calendarManager;
            this.assignmentStore && this.assignmentStore.destroy();
            this.assignmentStore = null;
            this.resourceStore && this.resourceStore.destroy();
            this.resourceStore = null;
            this.taskStore && this.taskStore.destroy();
            this.taskStore = null;
            this.dependencyStore && this.dependencyStore.destroy();
            this.dependencyStore = null;
            this.dependencyStore && this.dependencyStore.destroy();
            this.dependencyStore = null;
            calendarManager && calendarManager.destroy();
        }
        if (this.rowHeightStyleSheetNode) {
            this.rowHeightStyleSheetNode.parentNode.removeChild(this.rowHeightStyleSheetNode);
            this.rowHeightStyleSheetNode = null;
        }
        clearTimeout(this.refreshTimer);
        this.callParent(arguments);
    },
    // @OVERRIDE  Overridden due to bad performance in superclass implementation
    collapseAll: function() {
        this.taskStore.suspendEvent('refresh', 'add', 'insert', 'remove');
        this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = true;
        this.callParent(arguments);
        this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = false;
        this.taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
        this.refreshViews();
    },
    // @OVERRIDE Overridden due to bad performance in superclass implementation
    expandAll: function() {
        this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = true;
        this.callParent(arguments);
        this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = false;
        this.refreshViews();
    },
    getCalendar: function() {
        return this.getTaskStore().getCalendar();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.panel.TimelineGridPanel
@extends Ext.grid.Panel
@mixin Sch.mixin.TimelinePanel

Internal class.

*/
Ext.define("Sch.panel.TimelineGridPanel", {
    extend: "Ext.grid.Panel",
    mixins: [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],
    alias: [
        'widget.timelinegrid'
    ],
    subGridXType: 'gridpanel',
    isTimelineGridPanel: true,
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2405
// https://www.sencha.com/forum/showthread.php?307509
Ext.define('Sch.patches.TablePanel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.panel.Table',
    applyFn: function() {
        var overrides = {};
        if (Ext.getVersion().equals('6.0.1.250')) {
            overrides.ensureVisible = function(record, options) {
                if (options && options.column && this.getVisibleColumnManager().indexOf(options.column) === -1) {
                    return;
                }
                this.callParent(arguments);
            };
        }
        // https://www.sencha.com/forum/showthread.php?310933
        //if (Ext.getVersion().equals('6.0.2.437')) {
        //    Ext.apply(overrides, {
        //        onRender: function() {
        //            // BUG: onRender implementation needs removing
        //            // Skip the bugged onRender in TablePanel
        //            this.callSuper(arguments);
        //        },
        //
        //        // BUG.
        //        // TablePanel needs beforeLayout on the first layout to measure the
        //        // width taken up by borders because in addition to the grid
        //        // border, the headerCt might have borders, so they need
        //        // to be subtracted from available width too.
        //        beforeLayout: function() {
        //            var me = this,
        //                gridPanelBorderWidth = me.gridPanelBorderWidth,
        //                totalColumnWidth;
        //
        //            // If this is the locked side, include border width in calculated locked grid width.
        //            // TODO: Use shrinkWrapDock on the locked grid's headerCt when it works.
        //            if (!gridPanelBorderWidth && me.isLocked && me.getSizeModel().width.shrinkWrap) {
        //                me.shrinkWrapColumns = true;
        //                totalColumnWidth = me.headerCt.getTableWidth();
        //                //<debug>
        //                if (isNaN(totalColumnWidth)) {
        //                    Ext.raise("Locked columns in an unsized locked side do NOT support a flex width.");
        //                }
        //                //</debug>
        //                gridPanelBorderWidth = me.gridPanelBorderWidth || (me.gridPanelBorderWidth = me.el.getBorderWidth('lr') + me.headerCt.el.getBorderWidth('lr'));
        //                me.width = totalColumnWidth + gridPanelBorderWidth;
        //            }
        //            me.callParent();
        //        }
        //    });
        //}
        Ext.ClassManager.get(this.target).override(overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.view.ResourceHistogram
 @extends Sch.view.TimelineGridView

 A view of the resource histogram panel. Use the {@link Gnt.panel.ResourceHistogram#getSchedulingView} method to get its instance from gantt panel.

 */
Ext.define('Gnt.view.ResourceHistogram', {
    extend: 'Sch.view.TimelineGridView',
    alias: 'widget.resourcehistogramview',
    requires: [
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Ext.XTemplate',
        'Ext.util.Format',
        'Sch.util.Date'
    ],
    mixins: [
        'Sch.mixin.GridViewCanvas'
    ],
    _cmpCls: 'gnt-resourcehistogramview',
    scheduledEventName: 'bar',
    // private
    eventSelector: '.gnt-resourcehistogram-bar',
    barTpl: null,
    barRenderer: Ext.emptyFn,
    limitLineRenderer: Ext.emptyFn,
    lineRenderer: Ext.emptyFn,
    lineTpl: null,
    limitLineTpl: null,
    // private cls properties
    _barCls: 'gnt-resourcehistogram-bar',
    _limitLineCls: 'gnt-resourcehistogram-limitline',
    _limitLineVerticalCls: 'gnt-resourcehistogram-limitline-vertical',
    _lineCls: 'gnt-resourcehistogram-line',
    barCls: null,
    limitLineCls: null,
    lineCls: null,
    limitLineWidth: 1,
    rowHeight: 60,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    labelMode: false,
    labelPercentFormat: '0',
    labelUnitsFormat: '0.0',
    histogram: null,
    unitHeight: null,
    availableRowHeight: null,
    /**
     * @event barclick
     * Fires when a histogram bar is clicked
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing a description of the clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event bardblclick
     * Fires when a histogram bar is double clicked
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing description of clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event barcontextmenu
     * Fires when contextmenu is activated on a histogram bar
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing description of clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event beforetooltipshow
     * Fires before the event tooltip is shown, return false to suppress it.
     *
     * @param {Sch.mixin.SchedulerPanel} view Resource histogram scheduling view
     * @param {Object} allocationData Allocation data
     * @param {Date} allocationData.startDate Allocation start date
     * @param {Date} allocationData.endDate Allocation end date
     * @param {Gnt.model.Assignment[]} allocationData.assignments Assignments for this allocation
     * @param {Number} allocationData.allocationMS Resource allocation time in milliseconds
     * @param {Number} allocationData.totalAllocation Resource allocation in percents
     * @param {Gnt.model.Resource} allocationData.resource Resource record
     */
    /**
     */
    initComponent: function(config) {
        if (this.barCls) {
            this.eventSelector = '.' + this.barCls;
        }
        // bar template
        if (!this.barTpl) {
            this.barTpl = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="gnt-resourcehistogram-bar ' + (this.barCls || '') + ' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">', '<tpl if="text !== \'\'">', '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight / 2) + 'px">{text}</span>', '</tpl>', '</div>', '</tpl>');
        }
        // scale line template
        if (!this.lineTpl) {
            this.lineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-line ' + (this.lineCls || '') + ' {cls}" style="top:{top}px;"></div>', '</tpl>');
        }
        // limit line template
        if (!this.limitLineTpl) {
            this.limitLineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-limitline ' + (this.limitLineCls || '') + ' {cls}" style="left:{left}px;top:{top}px;width:{width}px;height:{height}px"></div>', '</tpl>');
        }
        this.callParent(arguments);
        // calculate pixels per scale step
        this.unitHeight = this.getAvailableRowHeight() / (this.scaleMax - this.scaleMin + this.scaleStep);
    },
    // histogram scale lines renderer
    renderLines: function() {
        return this.lineTpl.apply(this.prepareLines());
    },
    // prepare data for scale lines renderer
    prepareLines: function() {
        var scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            value = scaleMin,
            labelStep = this.scaleLabelStep,
            rowHeight = this.getAvailableRowHeight(),
            tplData = [],
            lineCls = this._lineCls,
            cls = lineCls + 'min';
        var line, userData;
        // if scale point array specified
        if (this.scalePoints) {
            for (var i = 0,
                l = this.scalePoints.length; i < l; i++) {
                var point = this.scalePoints[i];
                line = {
                    value: point.value,
                    top: point.top || Math.round(rowHeight - this.unitHeight * (point.value - scaleMin)),
                    cls: point.cls + (point.label ? ' ' + lineCls + '-label' : '') + (i === 0 ? ' ' + lineCls + '-min' : (i == l ? ' ' + lineCls + '-max' : ''))
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
            }
        } else // otherwise we have to calculate line top-coordinates
        {
            // loop from scaleMin up to scaleMax
            while (value <= scaleMax) {
                line = {
                    value: value,
                    top: Math.round(rowHeight - this.unitHeight * (value - scaleMin)),
                    cls: cls
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
                // increment by scale step size
                value += this.scaleStep;
                cls = value % labelStep ? '' : lineCls + '-label';
                if (value == scaleMax)  {
                    cls += ' ' + lineCls + '-max';
                }
                
            }
            // ensure that we have scaleMax as last tplData element (we can step over it for some stepSize values)
            if (tplData.length && tplData[tplData.length - 1].value !== scaleMax) {
                line = {
                    value: scaleMax,
                    top: Math.round(rowHeight - this.unitHeight * (scaleMax - scaleMin)),
                    cls: (scaleMax % labelStep ? '' : lineCls + '-label') + ' ' + lineCls + '-max'
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
            }
        }
        return tplData;
    },
    renderLimitLines: function(data) {
        return this.limitLineTpl.apply(this.prepareLimitLines(data));
    },
    getLimitLinesConnector: function(from, to) {
        return {
            left: from.right,
            width: 1,
            top: Math.min(from.top, to.top),
            height: Math.abs(from.top - to.top) + this.limitLineWidth,
            cls: this._limitLineCls + '-top' + ' ' + this._limitLineVerticalCls
        };
    },
    pushLimitLine: function(tplData, line, toMerge) {
        var prev = tplData[tplData.length - 1];
        // if we had cached lines too small to display
        if (toMerge) {
            // let's lengthen the previous line (if any) right coordinate
            if (prev) {
                prev.width = toMerge.right - prev.left;
                prev.right = toMerge.right;
            } else {
                line.left = toMerge.left;
                line.width = line.right - toMerge.left;
            }
        }
        if (prev && this.showVerticalLimitLines) {
            // if previous line is invisible get rid of it
            if (!prev.visible)  {
                tplData.pop();
            }
            
            tplData.push(this.getLimitLinesConnector(prev, line));
        }
        // call user provided function to modify the data
        var userData = this.limitLineRenderer(tplData, line, toMerge);
        tplData.push(Ext.apply(line, userData));
    },
    prepareLimitLines: function(data) {
        if (!data)  {
            return;
        }
        
        var tplData = [],
            scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            scaleStep = this.scaleStep,
            scaleUnit = this.scaleUnit,
            rowHeight = this.getAvailableRowHeight(),
            lineCls = this._limitLineCls,
            maxWidth = this.getTimeAxisViewModel() && this.getTimeAxisViewModel().getTotalWidth(),
            toMerge, line, prev;
        for (var i = 0,
            l = data.length; i < l; i++) {
            // get allocation in scale units
            var allocation = this.calendar.convertMSDurationToUnit(data[i].allocationMS, scaleUnit);
            var visible = true;
            // if the line doesn't fit into row height
            if (allocation * this.unitHeight > rowHeight) {
                allocation = scaleMax + scaleStep;
                visible = false;
            } else if (allocation <= 0) {
                allocation = 0;
                visible = false;
            }
            var left = data[i].startDate && this.getCoordinateFromDate(data[i].startDate, true) || 0;
            var right = data[i].endDate && this.getCoordinateFromDate(data[i].endDate, true) || maxWidth;
            // interval may start 0 timeaxis start
            if (left < 0)  {
                left = 0;
            }
            
            if (right < 0)  {
                right = maxWidth;
            }
            
            line = {
                left: left,
                width: right - left,
                right: right,
                top: '',
                height: 0,
                cls: '',
                visible: visible
            };
            // get top-position based on max possible allocation
            line.top = Math.round(rowHeight - (allocation - scaleMin) * this.unitHeight);
            if (visible) {
                line.cls += ' ' + lineCls + '-top';
            }
            prev = tplData[tplData.length - 1] || toMerge;
            // check if line size is less than threshold
            var small = line.width <= this.showLimitLinesThreshold;
            // if the line has the same allocation as the previous one
            // or it's a small invisible line -> then we merge it w/ the previous line
            if (prev && (line.top == prev.top || (small && !visible))) {
                prev.width = right - prev.left;
                prev.right = right;
                // reset cached line
                line = null;
                // if we have a pushed line we simply skip small line(s) after it
                if (tplData[tplData.length - 1]) {
                    toMerge = null;
                }
                // if we enlarged "toMerge" line and its width got greater than threshold
                else if (toMerge.width > this.showLimitLinesThreshold) {
                    this.pushLimitLine(tplData, toMerge);
                    // reset cached line since we just pushed it
                    toMerge = null;
                }
            }
            // if the line is small and visible we'll try to merge it w/ next lines and approximate its top coordinate
            else if (small && visible) {
                // if the previous line was also too small
                if (toMerge) {
                    var width = toMerge.width + line.width;
                    // merge both lines and approximate average top level
                    toMerge.top = Math.round(line.top * line.width / width + toMerge.top * toMerge.width / width);
                    toMerge.width = right - toMerge.left;
                    toMerge.right = right;
                } else // remember this line hoping to merge w/ the next line
                {
                    toMerge = line;
                }
                // if merged line width is greater than threshold
                if (toMerge.width > this.showLimitLinesThreshold) {
                    this.pushLimitLine(tplData, toMerge);
                    // reset cached lines since we just pushed them
                    line = toMerge = null;
                }
            } else // if the current line is large enough to display
            {
                this.pushLimitLine(tplData, line, toMerge);
                // reset cached lines since we just pushed them
                line = toMerge = null;
            }
        }
        line && this.pushLimitLine(tplData, line, toMerge);
        // make sure we don't have invisible line in the last item
        prev = tplData[tplData.length - 1];
        if (prev && !prev.visible)  {
            tplData.pop();
        }
        
        return tplData;
    },
    renderBars: function(data, resourceId) {
        return this.barTpl.apply(this.prepareBars(data, resourceId));
    },
    prepareBars: function(data, resourceId) {
        if (!data)  {
            return;
        }
        
        // loop over periods that we have for the resource
        var tplData = [],
            rowHeight = this.getAvailableRowHeight(),
            barCls = this._barCls,
            scaleUnit = this.scaleUnit,
            scaleUnitName = Sch.util.Date.getShortNameOfUnit(scaleUnit),
            scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            scaleStep = this.scaleStep,
            scaleMaximum = scaleMax + scaleStep,
            tplItem, allocation;
        for (var i = 0,
            l = data.length; i < l; i++) {
            // if resource is allocated
            if (data[i].totalAllocation) {
                // get allocation in units (hours by default)
                allocation = this.calendar.convertMSDurationToUnit(data[i].allocationMS, scaleUnit);
                tplItem = {
                    id: 'bar-' + resourceId + '-' + i,
                    index: i,
                    left: this.getCoordinateFromDate(data[i].startDate, true),
                    width: this.getCoordinateFromDate(data[i].endDate, true) - this.getCoordinateFromDate(data[i].startDate, true),
                    height: rowHeight,
                    top: 0,
                    text: '',
                    cls: ''
                };
                // if label has to be shown
                if (this.labelMode) {
                    // what type of label requested
                    switch (this.labelMode) {
                        case 'percent':
                            tplItem.text = Ext.util.Format.number(data[i].totalAllocation, this.labelPercentFormat) + '%';
                            break;
                        case 'units':
                            tplItem.text = Ext.util.Format.number(allocation, this.labelUnitsFormat) + scaleUnitName;
                            break;
                        // custom template
                        default:
                            tplItem.text = this.labelMode.apply({
                                allocation: allocation,
                                percent: data[i].totalAllocation
                            });
                    }
                }
                // if the bar fits in row height
                if (allocation <= scaleMaximum) {
                    tplItem.height = allocation >= scaleMin ? Math.round((allocation - scaleMin) * this.unitHeight) : 0;
                    tplItem.top = rowHeight - tplItem.height;
                } else // if bar is higher than row height
                {
                    // add class to indicate it
                    tplItem.cls += ' ' + barCls + '-partofbar';
                }
                // overworking (allocation > 100%)
                if (data[i].totalAllocation > 100 || data[i].totalOverAllocationMS > 0) {
                    tplItem.cls += ' ' + barCls + '-overwork';
                }
                // get user provided data
                var userData = this.barRenderer(resourceId, data[i], tplItem);
                // if CSS classes provided combine them w/ the panel defined ones
                if (userData && userData.cls) {
                    userData.cls = tplItem.cls + ' ' + userData.cls;
                }
                tplItem = Ext.apply(tplItem, userData);
                tplData.push(tplItem);
            }
        }
        return tplData;
    },
    getAvailableRowHeight: function() {
        if (this.availableRowHeight)  {
            return this.availableRowHeight;
        }
        
        this.availableRowHeight = this.rowHeight - this.cellTopBorderWidth - this.cellBottomBorderWidth;
        return this.availableRowHeight;
    },
    /**
     * Returns the allocation data for a DOM element
     * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
     * @return {Object} Allocation data
     * @return {Date} return.startDate Allocation start date
     * @return {Date} return.endDate Allocation end date
     * @return {Gnt.model.Assignment[]} return.assignments Assignments for this allocation
     * @return {Number} return.allocationMS Resource allocation time in milliseconds
     * @return {Number} return.totalAllocation Resource allocation in percents
     * @return {Gnt.model.Resource} return.resource Resource record
     */
    resolveEventRecord: function(el) {
        var node = this.findItemByChild(el);
        if (node) {
            var resource = this.getRecord(node);
            if (resource) {
                var result = {
                        resource: resource
                    };
                var data = this.histogram.allocationData[resource.getId()];
                var index = el.getAttribute('gnt-bar-index');
                var bar = data.bars[index];
                if (bar) {
                    result.startDate = bar.startDate;
                    result.endDate = bar.endDate;
                    result.assignments = bar.assignments;
                    result.allocationMS = bar.allocationMS;
                    result.totalAllocation = bar.totalAllocation;
                }
                return result;
            }
        }
        return null;
    },
    resolveEventRecordFromResourceRow: function(el) {
        return this.resolveEventRecord(el);
    },
    getDataForTooltipTpl: function(record) {
        return record;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.panel.ResourceHistogram
@extends Sch.panel.TimelineGridPanel

A histogram panel, which allows you to visualize resource utilization and highlight overallocation.
The panel is a subclass of the Ext.grid.Panel class so any normal grid configs can be applied to it.

#Two ways of using

You can either use this widget as a standalone panel or it can be used together with a {@link Gnt.panel.Gantt gantt panel}.
When using it together with a {@link Gnt.panel.Gantt gantt panel} you need to specify its instance as the {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} config.

#Predefined columns

The panel has a default set of columns which is used if no `columns` config has been specified.
The default columns include a resource name column and a {@link Gnt.column.Scale scale column} to display a resource utilization scale.

For example in the following code snippet, the histogram will be created with a default set of columns:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        viewPreset          : 'weekAndDayLetter',
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 1, 11),
        renderTo            : Ext.getBody()
    });


{@img gantt/images/histogram-panel.png}

*/
Ext.define('Gnt.panel.ResourceHistogram', {
    extend: 'Sch.panel.TimelineGridPanel',
    requires: [
        'Sch.patches.TablePanel',
        'Ext.XTemplate',
        'Sch.util.Date',
        'Sch.plugin.NonWorkingTime',
        'Gnt.column.Scale',
        'Gnt.view.ResourceHistogram'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.resourcehistogram',
    viewType: 'resourcehistogramview',
    layout: 'border',
    preserveScrollOnRefresh: true,
    /**
     * @cfg {Ext.XTemplate} barTpl The template used to render the bars in the histogram view.
     *
     * When specifying a custom template please make sure that the bar element must have:
     *
     *  - unique `id` attribute, like this: ... id="{id}" ...
     *  - `gnt-bar-index` attribute defined this way: ... gnt-bar-index="{index}" ...
     *  - support for {@link #barCls} config.
     *  - support bar labels
     *
     * Please take a look at the default markup of this template to see an example of how the above restrictions can be applied:
     *
     *      this.barTpl = new Ext.XTemplate(
     *          '<tpl for=".">',
     *              '<div id="{id}" class="gnt-resourcehistogram-bar '+ (this.barCls || '') +' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">',
     *                  '<tpl if="text !== \'\'">',
     *                      '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight/2) + 'px">{text}</span>',
     *                  '</tpl>',
     *              '</div>',
     *          '</tpl>'
     *      );
     *
     * See {@link Ext.XTemplate} for more information on templates syntax.
     */
    /**
     * @cfg {Function} barRenderer When provided this function creates a data object for {@link #barTpl} template.
     *
     *
     *      Ext.create('Gnt.panel.ResourceHistogram', {
     *          crudManager     : crudManager,
     *          viewPreset      : 'weekAndDayLetter',
     *          height          : 300,
     *          width           : 500,
     *          renderTo        : Ext.getBody(),
     *
     *          barTpl          : new Ext.XTemplate(
     *                              '<tpl for=".">',
     *                                  '<div id="{id}" class="gnt-resourcehistogram-bar {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">',
     *                                      '<span class="gnt-resourcehistogram-bar-text" style="bottom:20px">{text}<br>{taskName}</span>',
     *                                  '</div>',
     *                              '</tpl>'
     *                            ),
     *
     *          barRenderer     : function (resourceId, allocationData, tplData) {
     *              var task = allocationData.assignments[0].getTask();
     *
     *              return {
     *                  taskName : task.getName(),
     *                  cls      : 'foo' // provide a custom CSS class for a histogram bar
     *              };
     *          }
     *      });
     *
     *
     * @param {Number} resourceId Id of the current resource
     *
     * @param {Object} allocationData
     * @param {Data} allocationData.startDate Bar start date
     * @param {Data} allocationData.endDate Bar end date
     * @param {Int} allocationData.allocationMS Duration of rendering bar
     * @param {Number} allocationData.totalAllocation Allocation of resource in percent
     * @param {Gnt.model.Assignment[]} allocationData.assignments Assignments for current resource
     *
     * @return {Object} Specify properties you would like to use in your {@link #barTpl template}
     */
    /**
     * @cfg {String} barCls The CSS class to apply to rendered bars in the histogram view.
     * This can be used if you want to implement your own bar styling.
     */
    /**
     * @cfg {Ext.XTemplate} lineTpl The template used to render the scale line in the histogram view.
     */
    /**
     * @cfg {String} lineCls The CSS class to apply to scale lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */
    /**
     * @cfg {Ext.XTemplate} limitLineTpl The template used to render the maximum resource utilization line in the histogram view.
     */
    /**
     * @cfg {String} limitLineCls The CSS class to apply to the maximum resource utilization lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */
    /**
     * @cfg {Number} limitLineWidth The width of the maximum resource utilization line. Used for the line coordinates calculations.
     * Should be specified only if the width of that utilization line was changed as result of any custom styling.
     */
    /**
     * @cfg {Mixed} labelMode Defines the type of scale labels to be used or disables labels completely.
     * Possible values are:
     *
     *  - empty string or `false` to disable labels (default).
     *  - `units` - displays the per day allocation in {@link #scaleUnit units}.
     *  - `percent` - displays the per day allocation in percents.
     *  - any other non-empty value will be considered as compiled `Ext.XTemplate` instance.
     */
    /**
     * @cfg {String} labelPercentFormat Defines the label format to use when the {@link #labelMode} is set to `percent`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */
    /**
     * @cfg {String} labelUnitsFormat Defines the label format to use when the {@link #labelMode} is set to `units`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */
    /**
     * @cfg {Object[]} scalePoints Alternative way of defining the utilization scale.
     * Can be used instead of setting {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep} configs.
     * When using the default columns, this config will be applied to the {@link Gnt.column.Scale} instance.
     *
     * For usage details please refer to the {@link Gnt.column.Scale#scalePoints scalePoints} property.
     */
    /**
     * @cfg {Boolean} showScaleLines Whether to show scale lines or not.
     */
    showScaleLines: false,
    /**
     * @cfg {Boolean} showLimitLines
     * Whether to show maximum resource allocation lines or not.
     * See {@link #showVerticalLimitLines} to disable vertical segments of the lines drawing.
     */
    showLimitLines: true,
    /**
     * @cfg {Number} showLimitLinesThreshold Sets the histogram to show maximum resource allocation lines only wider than specified width in pixels.
     * This option allows to get rid of redundant details during zooming out (which also implicitly raises performance).
     * When line has smaller size than the provided value the histogram will merge it with neighbor segments and approximate its level.
     * Use {@link #showLimitLines} to completely disable resource allocation lines rendering.
     */
    showLimitLinesThreshold: 10,
    /**
     * @cfg {Boolean} showVerticalLimitLines
     * Set this to false to not render vertical segments of maximum resource allocation lines.
     * This implicitly raises performance due to reducing the number of DOM elements being generated.
     */
    showVerticalLimitLines: true,
    cacheLimitDurationMS: 0,
    /**
     * @cfg {Number} cacheLimitDuration Combined with {@link #cacheLimitDurationUnit} forces cache to hold only data
     * for visible time span and {@link #cacheLimitDuration} number of {@link #cacheLimitDurationUnit units} to the left/right from it.
     *
     * **Note:** Does not limit the cache size when set to zero `0`.
     */
    cacheLimitDuration: 6,
    /**
     * @cfg {String} cacheLimitDurationUnit Combined with {@link #cacheLimitDuration} forces cache to hold only data
     * for visible time span and {@link #cacheLimitDuration} number of units to the left/right from it.
     */
    cacheLimitDurationUnit: 'mo',
    calendarResources: null,
    calendarListenersHash: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance for the histogram panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     *
     * **Please note,** that this option is required if the {@link #taskStore} option is not specified.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks.
     * When using this option, the histogram will instantly reflect any changes made to a task.
     *
     * **Please note,** that this option is required if the {@link #calendar} option is not specified.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources to be rendered into the histogram (required).
     *
     * See also {@link Gnt.model.Resource}
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     *
     * If not specified, it will be taken from the {@link #resourceStore} or {@link #taskStore}.
     *
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore: null,
    /**
     * @cfg {Date} startDate Defines the start date of this panel.
     *
     * **Note:** This option is **required** if a {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} is not specified.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate Defines the end date of this panel.
     *
     * **Note:** This option is **required** if a {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} is not specified.
     */
    endDate: null,
    highlightWeekends: true,
    allocationData: null,
    /**
     * @cfg {String} scaleUnit Name of the resource utilization scale unit. `Sch.util.Date` constants can be used, like `Sch.util.Date.HOUR`.
     */
    scaleUnit: 'HOUR',
    /**
     * @cfg {Number} scaleMin Minimum for the resource utilization scale (required).
     */
    scaleMin: 0,
    /**
     * @cfg {Number} scaleMax Maximum for the resource utilization scale.
     *
     * **Note:** this option is **required** except in cases when you use {@link #scalePoints} to define utilization scale.
     */
    scaleMax: 24,
    /**
     * @cfg {Number} scaleLabelStep Defines the interval between two adjacent scale lines which have labels.
     * The histogram itself does not render any labels but corresponding lines will get a specific CSS class for styling purposes.
     */
    scaleLabelStep: 4,
    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale lines.
     *
     * **Also,** this value is used as a margin between the top scale line (defined by {@lin #scaleMax} option) and the top border of the cell
     * containing the histogram for a resource.
     */
    scaleStep: 2,
    rowHeight: 50,
    /**
     * Class name to be used for the scale column creating
     * @cfg {String} scaleColumnClass
     */
    scaleColumnClass: 'Gnt.column.Scale',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - resourceText : 'Resource'
     */
    scaleColumnConfigs: [
        'scalePoints',
        'scaleStep',
        'scaleLabelStep',
        'scaleMin',
        'scaleMax',
        'scaleLabelStep',
        'scaleStep'
    ],
    normalViewConfigs: [
        'barCls',
        'barTpl',
        'barRenderer',
        'lineRenderer',
        'limitLineRenderer',
        'lineTpl',
        'lineCls',
        'limitLineTpl',
        'limitLineCls',
        'limitLineWidth',
        'labelMode',
        'labelPercentFormat',
        'labelUnitsFormat',
        'scaleMin',
        'scaleMax',
        'scaleStep',
        'scaleLabelStep',
        'scalePoints',
        'scaleUnit',
        'loadMask',
        'showLimitLinesThreshold',
        'showVerticalLimitLines',
        'calendar'
    ],
    cacheUpdateSuspended: false,
    suspendedCacheUpdatesCount: 0,
    gapThreshold: 24 * 3600000,
    // 24 hrs
    rowLines: true,
    initComponent: function() {
        // convert "cacheLimitDuration" value to ms
        this.cacheLimitDurationMS = Sch.util.Date.getUnitDurationInMs(this.cacheLimitDurationUnit) * this.cacheLimitDuration;
        // initialize the allocation cache
        this.resetAllocationDataCache();
        // initialize store references
        this.initStores();
        this.lockedGridConfig = Ext.applyIf(this.lockedGridConfig || {}, {
            reserveScrollbar: false,
            width: 300,
            forceFit: true
        });
        this.normalViewConfig = Ext.apply(this.normalViewConfig || {}, {
            histogram: this,
            trackOver: false,
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        this.lockedViewConfig = Ext.apply(this.lockedViewConfig || {}, {
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        // if scale was specified by scalePoints
        if (this.scalePoints) {
            this.scalePoints.sort(function(a, b) {
                return a.value > b.value ? 1 : -1;
            });
            this.scaleMin = this.scalePoints[0].value;
            this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
            this.scaleStep = (this.scaleMax - this.scaleMin) / 10;
        }
        this.initColumns();
        // transfer some configs to the view instance
        Ext.Array.each(this.normalViewConfigs, function(prop) {
            if (prop in this)  {
                this.normalViewConfig[prop] = this[prop];
            }
            
        }, this);
        this.callParent(arguments);
        var cls = 'gnt-resourcehistogram sch-horizontal ';
        this.addCls(cls);
        // register our renderer
        this.registerRenderer(this.columnRenderer, this);
        var view = this.getSchedulingView();
        this.relayEvents(view, [
            /**
            * @event barclick
            * Fires when a histogram bar is clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing a description of the clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barclick',
            /**
            * @event bardblclick
            * Fires when a histogram bar is double clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'bardblclick',
            /**
            * @event barcontextmenu
            * Fires when contextmenu is activated on a histogram bar
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barcontextmenu'
        ]);
    },
    initStores: function() {
        var listenersBound = false;
        // if CrudManager is used let's grab store references from it
        if (this.crudManager) {
            this.setCrudManager(this.crudManager);
            // we called bindStores() in setCrudManager() call
            listenersBound = true;
        }
        // resourceStore acts as store for the grid
        this.store = this.resourceStore;
        this.taskStore = this.taskStore || this.store.getTaskStore();
        // get project calendar
        this.calendar = this.calendar || this.taskStore && this.taskStore.getCalendar();
        if (!this.calendar)  {
            throw 'Cannot get project calendar instance: please specify either "calendar" or "taskStore" option';
        }
        
        this.assignmentStore = this.assignmentStore || this.store.getAssignmentStore() || this.taskStore && this.taskStore.getAssignmentStore();
        if (!listenersBound)  {
            this.bindStores();
        }
        
    },
    getCrudManager: function() {
        return this.crudManager;
    },
    setCrudManager: function(crudManager) {
        this.unbindStores();
        // if we set another crud manager unbind from the previous one
        this.crudManagerListeners && this.crudManagerListeners.destroy();
        this.crudManager = crudManager;
        this.taskStore = this.crudManager.getTaskStore();
        this.store = this.resourceStore = this.crudManager.getResourceStore();
        this.assignmentStore = this.crudManager.getAssignmentStore();
        this.crudManagerListeners = this.mon(this.crudManager, {
            beforeloadapply: {
                fn: this.beforeCrudManagerLoad,
                // we want to listen to "beforeloadapply" the last one
                // to have some guarantee that the event is not cancelled
                priority: -999
            },
            load: this.afterCrudManagerLoad,
            destroyable: true,
            scope: this
        });
        this.bindStores();
    },
    beforeCrudManagerLoad: function() {
        // suspend store listeners upon crud manager stores loading
        this.suspendStoreListeners();
    },
    afterCrudManagerLoad: function() {
        // keep showing loading mask
        this.beforeCrudOperationStart(this.crudManager, null, 'load');
        // resume stores listeners and refresh the histogram
        this.resumeStoreListeners(true);
        // hide loading mask
        this.onCrudOperationComplete();
    },
    bindStores: function() {
        if (this.taskStore) {
            this.mon(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                // Ext JS 5: tree store doesn't fire 'refresh' on load completion so we listen to 'load' as well
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdateOrAppend,
                // we listen to append to support twisted case when someone first adds assignment and then adds a task
                nodeappend: this.onTaskUpdateOrAppend,
                scope: this
            });
        }
        if (this.assignmentStore) {
            // on assignments change we update corresponding resource row
            this.mon(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            });
        }
        // track the project calendar changes
        this.calendar && this.mon(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        // bind resource calendars listeners
        this.bindCalendarListeners();
        this.store && this.mon(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        });
    },
    unbindStores: function() {
        if (this.taskStore) {
            this.mun(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                // EtxJS5: tree store doesn't fire 'refresh' on load completion so we listen to 'load' as well
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdateOrAppend,
                // we listen to append to support twisted case when someone first adds assignment and then adds a task
                nodeappend: this.onTaskUpdateOrAppend,
                scope: this
            });
        }
        if (this.assignmentStore) {
            // on assignments change we update corresponding resource row
            this.mun(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            });
        }
        this.calendar && this.mun(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        this.unbindCalendarListeners();
        this.store && this.mun(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        });
    },
    /**
     * Suspends the histogram stores listeners. Call this method before massive stores data modifications
     * (like data loading) if you want to speed the histogram up.
     * Use {@link #resumeStoreListeners} to restore store listeners back.
     */
    suspendStoreListeners: function() {
        // set flag to avoid cache updating
        this.cacheUpdateSuspended = true;
        this.suspendedCacheUpdatesCount = 0;
        // unbind stores listeners
        this.unbindStores();
    },
    /**
     * Resumes the histogram stores listeners suspended by {@link #suspendStoreListeners} call.
     * @param {Boolean} [refreshIfAttempted] Pass `true` to refresh the histogram if there were suspended refresh attempts
     */
    resumeStoreListeners: function(refreshIfAttempted) {
        // restore cache recalculations
        this.cacheUpdateSuspended = false;
        // restore listeners
        this.bindStores();
        // refresh if it's asked and there were attempts to update the histogram cache
        if (refreshIfAttempted && this.suspendedCacheUpdatesCount) {
            this.clearCacheAndRefresh();
        }
    },
    // Clears allocation cache for the resource and refreshes corresponding view node
    clearCacheAndRefresh: function(resource) {
        this.resetAllocationDataCache(resource);
        this.refreshIfRendered(resource);
    },
    createDefaultColumns: function() {
        var columns = [],
            scaleCol;
        columns.push({
            flex: 1,
            resizable: false,
            text: this.L('resourceText'),
            dataIndex: this.resourceStore.model.prototype.nameField,
            renderer: function(value) {
                return Ext.String.htmlEncode(value);
            }
        });
        scaleCol = {
            width: 40,
            resizable: false,
            availableHeight: this.rowHeight
        };
        // map some scale column configs from this panel
        Ext.copyTo(scaleCol, this, this.scaleColumnConfigs, true);
        scaleCol = this.scaleCol = Ext.create(this.scaleColumnClass, scaleCol);
        // before column render we'll give it information about row height
        scaleCol.on({
            beforerender: function() {
                scaleCol.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
                if (this.scalePoints) {
                    // we update scalePoints since it was
                    // filled in with calculated top-coordinates
                    this.scalePoints = scaleCol.scalePoints;
                }
            },
            scope: this
        });
        columns.push(scaleCol);
        return columns;
    },
    initColumns: function() {
        // if no columns provided we'll generate default column set: resource name & scale
        if (!this.columns) {
            this.columns = this.createDefaultColumns();
            var scaleCol = this.scaleCol;
            // if scale was specified by scalePoints let's set params equal to scale column ones
            // since they were calculated there
            if (this.scalePoints) {
                this.scaleMin = scaleCol.scaleMin;
                this.scaleMax = scaleCol.scaleMax;
                this.scaleStep = scaleCol.scaleStep;
            }
        } else // if columns specified we try to find Gnt.column.Scale instances and set its configs
        {
            var columns = !Ext.isArray(this.columns) ? [
                    this.columns
                ] : this.columns;
            for (var i = 0; i < columns.length; i++) {
                var col = columns[i];
                if (this.isScaleColumn(col)) {
                    // map some scale column configs from this panel
                    Ext.copyToIf(col, this, this.scaleColumnConfigs);
                    if (!(col instanceof Gnt.column.Scale)) {
                        col = columns[i] = Ext.ComponentManager.create(col, col.xtype);
                    }
                    // before column render let's give it information about row height
                    this.mon(col, {
                        beforerender: function() {
                            col.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
                        },
                        scope: this,
                        single: true
                    });
                }
            }
        }
    },
    isScaleColumn: function(col) {
        var proto = col.xtype && (Ext.ClassManager.getByAlias('widget.' + col.xtype));
        proto = proto && proto.prototype;
        return (col instanceof Gnt.column.Scale || (proto && proto.isXType('scalecolumn')));
    },
    destroy: function() {
        this.unbindStores();
        this.callParent(arguments);
    },
    /**
     * Returns the task store instance
     * @return {Gnt.data.TaskStore}
     */
    getEventStore: function() {
        return this.taskStore;
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore;
    },
    unbindResourceCalendarListener: function(resource, calendarId) {
        var calendarResources = this.calendarResources[calendarId];
        if (calendarResources) {
            Ext.Array.remove(calendarResources, resource);
            // if no more resources left bound to the calendar
            // destroy the calendar listener
            if (!calendarResources.length) {
                this.calendarListenersHash[calendarId].destroy();
                delete this.calendarListenersHash[calendarId];
                delete this.calendarResources[calendarId];
            }
        }
    },
    bindResourceCalendarListener: function(resource) {
        var me = this,
            calendar = resource.getOwnCalendar(),
            calendarId = calendar.getCalendarId();
        // bind new listener to the calendar if it doesn't have it yet
        if (!me.calendarListenersHash[calendarId]) {
            me.calendarListenersHash[calendarId] = me.mon(calendar, {
                // on calendar load/change we'll recalculate allocation data and redraw resource(s) rows
                load: me.onCalendarChange,
                calendarchange: me.onCalendarChange,
                scope: me,
                destroyable: true
            });
        }
        if (!me.calendarResources[calendarId]) {
            me.calendarResources[calendarId] = [
                resource
            ];
        } else if (Ext.Array.indexOf(me.calendarResources, resource) === -1) {
            me.calendarResources[calendarId].push(resource);
        }
    },
    // resource is already bound to this calendar
    bindCalendarListeners: function() {
        var me = this;
        // unbind exisiting listeners (if any)
        me.unbindCalendarListeners();
        me.store.each(function(resource) {
            // if resource has own calendar and it differs from project one
            var calendar = resource.getOwnCalendar();
            if (calendar && calendar !== me.calendar) {
                me.bindResourceCalendarListener(resource);
            }
        });
    },
    unbindCalendarListeners: function() {
        for (var calendarId in this.calendarListenersHash) {
            this.calendarListenersHash[calendarId].destroy();
        }
        // reset array of listeners
        this.calendarResources = [];
        this.calendarListenersHash = {};
    },
    onTaskStoreRefresh: function() {
        this.clearCacheAndRefresh();
    },
    onCalendarChange: function(calendar) {
        var resources = this.calendarResources[calendar.getCalendarId()];
        if (resources) {
            // reset allocation cache and render row for each resource bound to the calendar
            for (var i = 0; i < resources.length; i++) {
                this.clearCacheAndRefresh(resources[i]);
            }
        }
    },
    onProjectCalendarChange: function() {
        this.clearCacheAndRefresh();
    },
    onTaskUpdateOrAppend: function(notUsed, task) {
        var assignments;
        var taskStore = task.getTreeStore();
        if (!taskStore.isSettingRoot && !task.isRoot()) {
            if (this.assignmentStore && task.getAssignmentStore() != this.assignmentStore) {
                assignments = this.assignmentStore.getAssignmentsForTask(task.getId());
            } else {
                assignments = task.getAssignments();
            }
            this.onAssignmentsChange(this.assignmentStore, assignments);
        }
    },
    onAssignmentsRefresh: function(assignmentStore) {
        this.onAssignmentsChange(assignmentStore, assignmentStore.getRange());
    },
    onAssignmentUpdate: function(assignmentStore, assignment, operation, modifiedFieldNames) {
        var me = this,
            resourceIdField = me.assignmentStore.model.prototype.resourceIdField,
            resource;
        if (operation == Ext.data.Model.EDIT) {
            // if the assignment resource has been changed
            if (modifiedFieldNames && Ext.Array.contains(modifiedFieldNames, resourceIdField)) {
                var oldResourceId = assignment.previous[resourceIdField];
                resource = this.resourceStore.getModelById(oldResourceId);
                if (resource) {
                    // resetting previous resource allocation and refresh corresponding row,
                    // resource allocation data will be updated upon row rendering
                    this.clearCacheAndRefresh(resource);
                }
            }
            // invoke refreshing of rows of all the resources associated w/ the assignment
            me.onAssignmentsChange(assignmentStore, [
                assignment
            ]);
        }
    },
    onAssignmentsChange: function(assignmentStore, assignments) {
        var me = this,
            resource;
        if (!Ext.isArray(assignments))  {
            assignments = [
                assignments
            ];
        }
        
        // for each provided assignment
        for (var i = 0,
            l = assignments.length; i < l; i++) {
            // get assigned resource
            resource = me.resourceStore.getModelById(assignments[i].getResourceId());
            // this might be called as result of resource calendar change
            // if task(s) get realigned, but we don't need this since the histogram also listens
            // to calendar changes and updates resource rows accordingly.
            // So here we skip resources that are in the middle of reacting on their calendar change
            if (resource && !resource.inOnCalendarChange) {
                // resetting resource allocation and refresh corresponding row,
                // resource allocation data will be updated upon row rendering
                me.clearCacheAndRefresh(resource);
            }
        }
    },
    findEndIndex: function(array, endDate) {
        endDate = endDate || this.getEndDate();
        var result = array.length - 1;
        for (var i = result; i >= 0; i--) {
            if (array[i].startDate < endDate) {
                result = i;
                break;
            }
        }
        return result;
    },
    findStartIndex: function(array, startDate) {
        startDate = startDate || this.getStartDate();
        var result = 0;
        for (var i = 0,
            l = array.length; i < l; i++) {
            if (array[i].endDate > startDate) {
                result = i;
                break;
            }
        }
        return result;
    },
    resetAllocationDataCache: function(resource) {
        var me = this;
        if (!resource) {
            me.allocationData = {};
        } else {
            me.allocationData = me.allocationData || {};
            me.allocationData[resource.getId()] = null;
        }
    },
    constrainAllocationDataCache: function(allocData) {
        var me = this,
            // minimum allowed cached date
            cacheMinStartDate = new Date(me.timeAxis.getStart() - this.cacheLimitDurationMS),
            // maximum allowed cached date
            cacheMaxEndDate = new Date(me.timeAxis.getEnd() - 0 + this.cacheLimitDurationMS),
            maxBarsLastIndex = allocData.maxBars.length - 1,
            maxBarsFirstIndex = 0,
            barsLastIndex = allocData.bars.length - 1,
            barsFirstIndex = 0,
            trimCache = false;
        // if right cache border violates its allowed maximum
        if (allocData.cacheEnd > cacheMaxEndDate) {
            maxBarsLastIndex = me.findEndIndex(allocData.maxBars, cacheMaxEndDate);
            barsLastIndex = me.findEndIndex(allocData.bars, cacheMaxEndDate);
            allocData.cacheEnd = cacheMaxEndDate;
            trimCache = true;
        }
        // if left cache border violates its allowed minimum
        if (allocData.cacheStart < cacheMinStartDate) {
            maxBarsFirstIndex = me.findStartIndex(allocData.maxBars, cacheMinStartDate);
            barsFirstIndex = me.findStartIndex(allocData.bars, cacheMinStartDate);
            allocData.cacheStart = cacheMinStartDate;
            trimCache = true;
        }
        // truncate caches if needed
        if (trimCache) {
            allocData.maxBars = Ext.Array.splice(allocData.maxBars, maxBarsFirstIndex, maxBarsLastIndex + 1 - maxBarsFirstIndex);
            allocData.bars = Ext.Array.splice(allocData.bars, barsFirstIndex, barsLastIndex + 1 - barsFirstIndex);
        }
        return trimCache;
    },
    updateAllocationDataCache: function(resource, start, end) {
        var DATE = Sch.util.Date,
            me = this,
            allocData, cacheStart, cacheEnd, left, right;
        if (me.cacheUpdateSuspended) {
            me.suspendedCacheUpdatesCount++;
            return;
        }
        start = start || me.getStartDate();
        end = end || me.getEndDate();
        if (!resource) {
            me.resourceStore.each(function(resource) {
                me.updateAllocationDataCache(resource, start, end);
            });
        } else {
            // Update resource cache
            allocData = me.allocationData[resource.getId()] || {};
            cacheStart = allocData.cacheStart;
            cacheEnd = allocData.cacheEnd;
            // check if update is needed at all
            if (cacheStart != start || cacheEnd != end) {
                // if we already have cached allocation data for required span or part of it
                if (cacheStart && cacheEnd && DATE.intersectSpans(cacheStart, cacheEnd, start, end)) {
                    // new span starts earlier, calculate missing allocation
                    if (cacheStart > start) {
                        left = me.processAllocationData(resource.getAllocationInfo({
                            startDate: start,
                            endDate: cacheStart,
                            includeResCalIntervals: true
                        }));
                        // there can be an extra max bar element for span end, that we don't need
                        if (left.maxBars.length) {
                            if (left.maxBars[left.maxBars.length - 1].startDate.getTime() === cacheStart.getTime()) {
                                // extra max bar can appear after merge
                                left.maxBars.pop();
                            }
                        }
                        // we don't split allocation bar element to avoid inconsistency
                        // if last new allocation element is a subset of first cached - we can drop it because it's cached
                        if (left.bars.length && allocData.bars.length) {
                            var lastNewBar = left.bars[left.bars.length - 1];
                            var firstOldBar = allocData.bars[0];
                            if (lastNewBar.startDate >= firstOldBar.startDate && lastNewBar.endDate <= firstOldBar.endDate) {
                                left.bars.pop();
                            }
                        }
                        // clue to previous cache borders
                        left.maxBars.length && (left.maxBars[left.maxBars.length - 1].endDate = cacheStart);
                        allocData.maxBars.length && (allocData.maxBars[0].startDate = cacheStart);
                        // insert missing allocation data to the allocation cache beginning
                        allocData.bars = left.bars.concat(allocData.bars);
                        allocData.maxBars = left.maxBars.concat(allocData.maxBars);
                        // visible span starts from the very first cached item
                        allocData.maxBarsStartIndex = 0;
                        allocData.barsStartIndex = 0;
                        allocData.cacheStart = start;
                    }
                    // new span ends later, calculate trailing allocation
                    if (cacheEnd < end) {
                        right = me.processAllocationData(resource.getAllocationInfo({
                            startDate: cacheEnd,
                            endDate: end,
                            includeResCalIntervals: true
                        }));
                        // there can be an extra max bar element that we don't need
                        if (right.maxBars.length) {
                            var firstBar = right.maxBars[0];
                            if (firstBar.endDate.getTime() === cacheEnd.getTime()) {
                                // extra max bar can appear after merge
                                right.maxBars.shift();
                            } else {
                                firstBar.startDate = cacheEnd;
                            }
                        }
                        // we don't split allocation bar element to avoid inconsistency
                        // if first new allocation element is a subset of last cached - we can drop it because it's cached
                        if (right.bars.length && allocData.bars.length) {
                            var firstNewBar = right.bars[0];
                            var lastOldBar = allocData.bars[allocData.bars.length - 1];
                            if (firstNewBar.startDate >= lastOldBar.startDate && firstNewBar.endDate <= lastOldBar.endDate) {
                                right.bars.shift();
                            }
                        }
                        right.maxBars.length && (right.maxBars[right.maxBars.length - 1].endDate = end);
                        allocData.maxBars.length && (allocData.maxBars[allocData.maxBars.length - 1].endDate = cacheEnd);
                        allocData.bars = allocData.bars.concat(right.bars);
                        allocData.maxBars = allocData.maxBars.concat(right.maxBars);
                        allocData.maxBarsEndIndex = allocData.maxBars.length - 1;
                        allocData.barsEndIndex = allocData.bars.length - 1;
                        allocData.cacheEnd = end;
                    }
                    // constrain cached data if needed
                    if (me.cacheLimitDuration > 0) {
                        me.constrainAllocationDataCache(allocData);
                    }
                    // update indexes of first/last visible cache elements
                    allocData.maxBarsStartIndex = me.findStartIndex(allocData.maxBars, start);
                    allocData.barsStartIndex = me.findStartIndex(allocData.bars, start);
                    allocData.maxBarsEndIndex = me.findEndIndex(allocData.maxBars, end);
                    allocData.barsEndIndex = me.findEndIndex(allocData.bars, end);
                } else // if new timespan does not intersect the cached one data
                {
                    allocData = me.processAllocationData(resource.getAllocationInfo({
                        startDate: start,
                        endDate: end,
                        includeResCalIntervals: true
                    }));
                    // we completely replace cache so indexes have to wrap whole arrays
                    allocData.maxBarsStartIndex = 0;
                    allocData.maxBarsEndIndex = allocData.maxBars.length - 1;
                    allocData.barsStartIndex = 0;
                    allocData.barsEndIndex = allocData.bars.length - 1;
                    allocData.cacheStart = start;
                    allocData.cacheEnd = end;
                }
            }
            me.allocationData[resource.getId()] = allocData;
        }
    },
    // Another set of task started
    isBarAssignmentsChanged: function(context) {
        var bar = context.bar,
            period = context.period;
        if (!bar.assignments || !period.inResourceCalendar || !period.totalAllocation || !period.inTasksCalendar)  {
            return false;
        }
        
        for (var i = 0,
            l = bar.assignments.length; i < l; i++) {
            if (period.assignmentsHash[bar.assignments[i].getTaskId()])  {
                return false;
            }
            
        }
        // no intersection with previous set of tasks
        return true;
    },
    // Opens new bar
    openBar: function(openDate, context) {
        context.bar = {
            startDate: openDate,
            totalAllocation: context.period.totalAllocation,
            allocationMS: context.allocationMS,
            assignments: context.period.assignments,
            totalOverAllocationMS: context.totalOverAllocationMS
        };
        context.barOpened = true;
        return context.bar;
    },
    // Closes histogram bar
    closeBar: function(closeDate, context) {
        if (!context.barOpened)  {
            return false;
        }
        
        if (closeDate)  {
            context.bar.endDate = closeDate;
        }
        
        context.bars.push(context.bar);
        context.barOpened = false;
    },
    // Appends zero level limit line
    appendZeroMaxBars: function(fromDate, toDate, context) {
        if (!fromDate)  {
            return false;
        }
        
        var me = this,
            diff = Sch.util.Date.getDurationInDays(fromDate, toDate);
        if (diff < 2)  {
            return false;
        }
        
        var add = true,
            maxBar = context.maxBar,
            maxBars = context.maxBars;
        // if there is a previous level line
        if (maxBar) {
            if (!maxBar.allocationMS) {
                add = false;
            } else // and it's not zero
            {
                // let's close it
                maxBar.endDate = Sch.util.Date.getStartOfNextDay(fromDate, true);
                maxBars.push(maxBar);
            }
        }
        if (add) {
            // ..and start new line with zero level
            context.maxBar = {
                startDate: maxBar && maxBar.endDate || me.getStart(),
                allocationMS: 0
            };
        }
        // update last calculated allocation limit
        context.maxAllocationMS = 0;
        return context.maxBar;
    },
    // By default we sum up allocations per day.
    // So here we just trim time part to get period start by date
    getMergePeriodStart: function(date) {
        return Ext.Date.clearTime(date, true);
    },
    // This function processes report made by resource.getAllocationInfo() method and build arrays of
    // histogram bars and levels of max resource allocation.
    // Returns:
    //      {
    //        bars: [], // array of histogram bars
    //        maxBars: [] // levels of max resource allocation
    //      }
    processAllocationData: function(data) {
        var period, bar, maxBar, prevPeriodStart, closeDate, openDate, allocationMS, prevAllocationMS, maxAllocationMS, prevMaxAllocationMS, totalOverAllocationMS, prevTotalOverAllocationMS,
            bars = [],
            maxBars = [],
            me = this,
            context = {
                bars: bars,
                maxBars: maxBars
            };
        var newPeriodStart = me.getMergePeriodStart(data[0].startDate);
        if (newPeriodStart > this.getStartDate()) {
            maxBars.push({
                startDate: this.getStartDate(),
                endDate: newPeriodStart,
                allocationMS: 0
            });
        }
        for (var i = 0,
            l = data.length; i < l; i++) {
            period = context.period = data[i];
            newPeriodStart = me.getMergePeriodStart(period.startDate);
            // if it's 1st period of a new day
            if (newPeriodStart - prevPeriodStart !== 0) {
                // if there is a gap between working days in resource calendar
                // we need to fill it with zero level lines
                if (this.showLimitLines) {
                    if (me.appendZeroMaxBars(prevPeriodStart, newPeriodStart, context)) {
                        maxBar = context.maxBar;
                    }
                }
                prevPeriodStart = newPeriodStart;
                prevAllocationMS = context.allocationMS;
                prevTotalOverAllocationMS = context.totalOverAllocationMS;
                prevMaxAllocationMS = context.maxAllocationMS;
                // reset allocation time counters
                allocationMS = 0;
                totalOverAllocationMS = 0;
                maxAllocationMS = 0;
                var j = i;
                // let's calculate allocation time for the period
                while (data[j] && me.getMergePeriodStart(data[j].startDate) - newPeriodStart === 0) {
                    // if it's working time according to resource calendar
                    if (data[j].inResourceCalendar) {
                        // increment maximum possible resource allocation time
                        maxAllocationMS += data[j].endDate - data[j].startDate;
                        // if it's working time and task is in progress
                        if (data[j].totalAllocationMS) {
                            // increment allocation time
                            allocationMS += data[j].totalAllocationMS;
                            totalOverAllocationMS += data[j].totalOverAllocationMS || 0;
                        }
                    }
                    j++;
                }
                context.allocationMS = allocationMS;
                context.totalOverAllocationMS = totalOverAllocationMS;
                context.maxAllocationMS = maxAllocationMS;
            } else {
                newPeriodStart = false;
            }
            // if we need to render limit lines
            if (me.showLimitLines) {
                // here we trace resource max available allocation changes
                if (newPeriodStart && maxAllocationMS != prevMaxAllocationMS) {
                    // on change we close existing line
                    if (maxBar) {
                        maxBar.endDate = newPeriodStart;
                        maxBars.push(maxBar);
                    }
                    // ..and start new one with new allocationMS value
                    maxBar = context.maxBar = {
                        startDate: newPeriodStart,
                        allocationMS: maxAllocationMS
                    };
                }
                // update end of max available allocation line
                maxBar.endDate = period.endDate;
            }
            // if no bar opened
            if (!context.barOpened) {
                // if period belongs to some task(s)
                // need to open new bar
                if (period.inTask) {
                    bar = me.openBar(new Date(period.startDate), context);
                }
            }
            // bar opened & task is finished
            // need to close opened bar
            else if (!period.inTask) {
                me.closeBar(null, context);
            } else // bar opened & task in progress
            {
                var splitBar = false;
                // another task(s) started
                if (me.isBarAssignmentsChanged(context)) {
                    closeDate = bar.endDate;
                    openDate = new Date(period.startDate);
                    splitBar = true;
                }
                // if there is a gap we need to close old bar and start new one
                // ("gap" is when we have no periods during day before newPeriodStart)
                else if (newPeriodStart && newPeriodStart - bar.endDate >= me.gapThreshold) {
                    // close bar at midnight after bar.endDate
                    closeDate = Ext.Date.clearTime(bar.endDate, true);
                    if (closeDate < bar.endDate) {
                        closeDate = Sch.util.Date.add(closeDate, Sch.util.Date.DAY, 1);
                    }
                    // open new bar at midnight before period.startDate
                    openDate = Ext.Date.clearTime(period.startDate, true);
                    splitBar = true;
                }
                // if day allocation has changed (due to calendars)
                else if (newPeriodStart && allocationMS !== prevAllocationMS && period.totalAllocation) {
                    closeDate = openDate = Ext.Date.clearTime(period.startDate, true);
                    splitBar = true;
                }
                if (splitBar) {
                    me.closeBar(closeDate, context);
                    bar = me.openBar(openDate, context);
                }
            }
            // if we have opened bar
            if (context.barOpened) {
                // update its end date
                bar.endDate = period.endDate;
            }
        }
        // close bar if task goes after timeline end
        me.closeBar(null, context);
        // if we need to render limits lines
        if (me.showLimitLines) {
            // if there is a gap between working days in resource calendar
            // we need to fill it with zero level lines
            if (me.appendZeroMaxBars(prevPeriodStart || me.getStart(), me.getEnd(), context)) {
                maxBar = context.maxBar;
            }
            // push last line to lines array
            if (maxBar) {
                maxBars.push(maxBar);
            }
        }
        return {
            bars: bars,
            maxBars: maxBars
        };
    },
    onResourceUpdate: function(store, resource, operation, changedFieldNames) {
        // if calendar on resource was changed
        if (Ext.Array.indexOf(changedFieldNames, resource.calendarIdField) > -1) {
            // setting allocation data for resource it will be updated upon next resource row rendering
            // which should happen as the result of update
            this.resetAllocationDataCache(resource);
            // unbind old listeners from resource calendar
            var oldCalendarId = resource.previous[resource.calendarIdField];
            this.unbindResourceCalendarListener(resource, oldCalendarId);
            // if new resource calendar differs from the project one
            var calendar = resource.getOwnCalendar();
            if (calendar && calendar !== this.calendar) {
                // bind listener on it
                this.bindResourceCalendarListener(resource);
            }
        }
    },
    onResourceStoreRefresh: function() {
        var me = this;
        // Reset all allocations data and refresh view
        me.clearCacheAndRefresh();
        // bind listeners to resources calendars
        me.bindCalendarListeners();
    },
    refreshIfRendered: function(resource) {
        var me = this;
        if (me.rendered && me.resourceStore && resource) {
            me.getView().refreshNode(me.resourceStore.indexOf(resource));
        } else if (me.rendered) {
            me.getView().refresh();
        }
    },
    columnRenderer: function(val, meta, resource, rowIndex, colIndex) {
        var me = this,
            resourceId = resource.getId(),
            view = this.normalGrid.getView(),
            data, bars, maxBars;
        // The method is protected against unneeded recalculation
        me.updateAllocationDataCache(resource);
        data = me.allocationData[resourceId];
        bars = data && data.bars;
        maxBars = data && data.maxBars;
        // if visible window for the histogram bars is less than all cached bars
        // let's cut this array to pass only related data
        if (bars && (data.barsStartIndex > 0 || data.barsEndIndex < bars.length - 1)) {
            bars = bars.slice(data.barsStartIndex, data.barsEndIndex + 1);
        }
        // if visible window for the resource limit lines is less than all cached limit lines info
        // let's cut this array to pass only related data
        if (maxBars && (data.maxBarsStartIndex > 0 || data.maxBarsEndIndex < maxBars.length - 1)) {
            maxBars = maxBars.slice(data.maxBarsStartIndex, data.maxBarsEndIndex + 1);
        }
        // changed, rowHeight must be matched in css .x-grid-cell-inner
        //meta.style = 'height:' + this.getSchedulingView().getAvailableRowHeight() + 'px';
        // render: scale lines (if requested),
        return (me.showScaleLines ? view.renderLines() : '') + // histogram bars,
        view.renderBars(bars, resourceId) + // max resource allocation line (if requested)
        (me.showLimitLines ? view.renderLimitLines(maxBars) : '');
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.ResourceZones
@extends Sch.feature.AbstractTimeSpan

A plugin (ptype = 'scheduler_resourcezones') for visualizing resource specific meta data such as availability, used internally by the Scheduler.
To use this feature, assign an {@link Sch.data.EventStore eventStore} to the {@link Sch.mixin.SchedulerPanel#cfg-resourceZones resourceZones}
config on the main Scheduler panel class. Additionally, you can provide the {@link Sch.mixin.SchedulerPanel#cfg-resourceZonesConfig resourceZonesConfig} object
with configuration options.


    {
          xtype           : 'schedulergrid',
          region          : 'center',
          startDate       : new Date(2013, 0, 1),
          endDate         : new Date(2014, 0, 1),
          resourceStore   : new Sch.data.ResourceStore(),
          // Meta events such as availabilities can be visualized here
          resourceZones   : new Sch.data.EventStore(),
          resourceZonesConfig : {
             innerTpl                : '... customized template here ...'
          },
          eventStore      : new Sch.data.EventStore()  // Regular tasks in this store
    }


 Records in the store should be regular {@link Sch.model.Event events} where you can specify the Resource, StartDate, EndDate and Cls (to set a CSS class on the rendered zone).
 */
Ext.define("Sch.plugin.ResourceZones", {
    extend: 'Sch.plugin.Zones',
    alias: 'plugin.scheduler_resourcezones',
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    /**
     * @cfg {Sch.data.EventStore} store (required) The store containing the meta 'events' to be rendered for each resource
     */
    store: null,
    cls: 'sch-resourcezone',
    init: function(scheduler) {
        this.store = Ext.StoreManager.lookup(this.store);
        // unique css class to be able to identify the elements belonging to this instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        this.scheduler = scheduler;
        scheduler.registerRenderer(this.renderer, this);
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">' + '<div id="' + this.uniqueCls + '-{id}" class="' + this.cls + ' ' + this.uniqueCls + ' {Cls}" style="' + (scheduler.rtl ? 'right' : 'left') + ':{start}px;width:{width}px;top:{start}px;height:{width}px;{style}">' + // Let implementer override the rendering with the innerTpl property, output Name field by default
            (innerTpl ? '{[this.renderInner(values)]}' : ('{' + this.store.getModel().prototype.nameField + '}')) + '</div>' + '</tpl>', {
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        this.storeListeners = {
            load: this.fullRefresh,
            datachanged: this.fullRefresh,
            clear: this.fullRefresh,
            // Ext JS
            add: this.fullRefresh,
            remove: this.fullRefresh,
            update: this.onModelUpdate,
            // Sencha Touch
            addrecords: this.fullRefresh,
            removerecords: this.fullRefresh,
            updaterecord: this.onModelUpdate,
            scope: this
        };
        this.store.on(this.storeListeners);
    },
    destroy: function() {
        this.store.un(this.storeListeners);
        this.callParent(arguments);
    },
    fullRefresh: function() {
        this.scheduler.getSchedulingView().refreshView();
    },
    renderer: function(val, meta, resource, rowIndex) {
        if (this.scheduler.getOrientation() === 'horizontal' || rowIndex === 0) {
            return this.renderZones(resource);
        }
        return '';
    },
    renderZones: function(resource) {
        var zoneStore = this.store,
            scheduler = this.scheduler,
            viewStart = scheduler.timeAxis.getStart(),
            viewEnd = scheduler.timeAxis.getEnd(),
            data = [],
            zonesForResource = resource.getEvents(zoneStore),
            spanStartDate, spanEndDate;
        for (var i = 0,
            len = zonesForResource.length; i < len; i++) {
            var record = zonesForResource[i];
            spanStartDate = record.getStartDate();
            spanEndDate = record.getEndDate();
            // Make sure resource exists in resourceStore (filtering etc)
            if (spanStartDate && spanEndDate && // Make sure this zone is inside current view
            Sch.util.Date.intersectSpans(spanStartDate, spanEndDate, viewStart, viewEnd)) {
                var renderData = scheduler.getSchedulingView()[scheduler.getOrientation()].getEventRenderData(record);
                var start, width;
                if (scheduler.getMode() === 'horizontal') {
                    start = scheduler.rtl ? renderData.right : renderData.left;
                    width = renderData.width;
                } else {
                    start = renderData.top;
                    width = renderData.height;
                }
                data[data.length] = Ext.apply({
                    id: record.internalId,
                    start: start,
                    width: width,
                    Cls: record.getCls()
                }, record.data);
            }
        }
        return this.template.apply(data);
    },
    onModelUpdate: function(store, zone) {
        var node = document.getElementById(this.uniqueCls + '-' + zone.internalId);
        if (node) {
            var scheduler = this.scheduler,
                viewStart = scheduler.timeAxis.getStart(),
                viewEnd = scheduler.timeAxis.getEnd();
            var start = Sch.util.Date.max(viewStart, zone.getStartDate()),
                end = Sch.util.Date.min(viewEnd, zone.getEndDate()),
                cls = zone.getCls();
            var startPos = scheduler.getSchedulingView().getCoordinateFromDate(start);
            var width = scheduler.getSchedulingView().getCoordinateFromDate(end) - startPos;
            // Reapply CSS classes
            node.className = this.cls + ' ' + this.uniqueCls + ' ' + (cls || '');
            node.style.left = startPos + 'px';
            node.style.top = startPos + 'px';
            node.style.height = width + 'px';
            node.style.width = width + 'px';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.mixin.AbstractSchedulerPanel
@private

A mixin providing "scheduling" functionality to the consuming "panel".
A consuming class should have already consumed the {@link Sch.mixin.AbstractTimelinePanel} mixin.

This should not be used directly.

*/
Ext.define('Sch.mixin.AbstractSchedulerPanel', {
    requires: [
        'Sch.model.Event',
        'Sch.model.Resource',
        'Sch.data.EventStore',
        'Sch.data.ResourceStore',
        'Sch.util.Date',
        'Sch.plugin.ResourceZones'
    ],
    /**
    * @cfg {String} eventBarIconClsField
    * A field in the Event model whose value will be applied as a CSS class to each event bar to place a 16x16 icon.
    */
    eventBarIconClsField: '',
    /**
    * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
    */
    enableEventDragDrop: true,
    /**
    * @cfg {String} eventBarTextField The field in your data model that will be rendered into each event bar.
    * You can alternatively use the eventBarRenderer to get full control over what gets displayed.
    */
    /**
     * @cfg {String} resourceColumnClass
     * Defines the column class for the resources, override this to use your own custom column class. (Used only in vertical orientation)
     */
    resourceColumnClass: "Sch.column.Resource",
    /**
     * @cfg {Number} resourceColumnWidth
     * Used only in vertical mode. Defines the width of a single column.
     */
    resourceColumnWidth: null,
    /**
     * @cfg {Number} calendarColumnWidth
     * Used only in calendar mode. Defines the width of a single column.
     */
    calendarColumnWidth: null,
    /**
    * @cfg {Boolean} allowOverlap Set to false if you don't want to allow events overlapping (defaults to true).
    */
    allowOverlap: true,
    /**
    * @cfg {String} startParamName The name of the start date parameter that will be passed to in every `eventStore` load request.
    */
    startParamName: 'startDate',
    /**
    * @cfg {String} endParamName The name of the end date parameter that will be passed to in every `eventStore` load request.
    */
    endParamName: 'endDate',
    /**
    * @cfg {Boolean} passStartEndParameters true to apply start and end dates of the current view to any `eventStore` load requests.
    */
    passStartEndParameters: false,
    /**
     * @cfg {Number} barMargin
     * Controls how much space to leave between the event bars and the row borders. Defaults to 1.
     */
    /**
     * @cfg {Boolean} constrainDragToResource
     * Set to true to only allow dragging events within the same resource. Defaults to false.
     */
    /**
    * @cfg {Function} eventRenderer
    * An empty function by default, but provided so that you can override it. This function is called each time an event
    * is rendered into the schedule to render the contents of the event. It's called with the event, its resource and a tplData object which
    * allows you to populate data placeholders inside the event template.
    * By default, the {@link #eventTpl} includes placeholders for 'cls' and 'style'. The cls property is a CSS class which will be added to the
    * event element. The style property is an inline style declaration for the event element. If you override the default {@link #eventTpl}, you can of course
    * include other placeholder in your template markup. Note: You will still need to keep the original built-in placeholders for the scheduler to work.
    *
    * <pre>
    *  eventRenderer : function (eventRec, resourceRec, templateData) {
    *      templateData.style = 'color:white';                 // You can use inline styles too.
    *      templateData.cls = resourceRec.get('Category');     // Read a property from the resource record, used as a CSS class to style the event
    *
    *      return Ext.Date.format(eventRec.getStartDate(), 'Y-m-d') + ': ' + eventRec.getName();
    *  }
    *</pre>
    * @param {Sch.model.Event} eventRecord The event about to be rendered
    * @param {Sch.model.Resource} resourceRecord The resource row in which the event is being created
    * @param {Object} tplData An object that will be applied to the containing {@link #eventTpl}.
    * @param {Number} row The row index
    * @param {Number} col The column index
    * @param {Sch.data.ResourceStore} ds The resource store
    * @return {String/Object} A simple string, or a custom object which will be applied to the {@link #eventBodyTemplate}, creating the actual HTML
    */
    eventRenderer: null,
    /**
    * @cfg {Object} eventRendererScope The scope to use for the {@link #eventRenderer} function
    */
    eventRendererScope: null,
    /**
     * @cfg {Sch.data.EventStore} eventStore (required) The {@link Ext.data.Store} holding the events to be rendered into the scheduler.
     */
    eventStore: null,
    /**
     * @cfg {Sch.data.ResourceStore} resourceStore (required) The {@link Ext.data.Store} holding the resources to be rendered into the scheduler.
     */
    resourceStore: null,
    /**
     * @method onEventCreated An empty function by default, but provided so that you can override it to supply default record values etc. This function is called after a new event has been created (but
     * before it is inserted to the store). This is for example called after a user dragged a new bar in the scheduler (the DragFreate feature).
     * @param {Sch.model.Event} eventRecord The event that was just created
     */
    onEventCreated: function(newEventRecord) {},
    /**
    * @cfg {Ext.Template} eventTpl The wrapping template used to renderer your events in the scheduler. Normally you should not override this,
    * only do so if you need total control of how the events are rendered/styled. See the {@link #eventBodyTemplate} for more information.
    */
    /**
    * @cfg {String/Ext.Template} eventBodyTemplate The template used to generate the markup of your events in the scheduler. To 'populate' the eventBodyTemplate with data, use the {@link #eventRenderer} method
    */
    /**
    *  @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
    */
    /**
     * @cfg {Object} calendarTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in calendar mode.
     */
    /**
     * @cfg {Sch.data.EventStore} resourceZones A special store containing data used to highlight the underlying schedule for the resources,
     * using {@link Sch.plugin.ResourceZones}. This can be used to color non-working time or any other meta data associated with a resource.
     * See also {@link #resourceZonesConfig}.
     */
    resourceZones: null,
    /**
     * @cfg {Object} resourceZonesConfig An object with configuration options for {@link Sch.plugin.ResourceZones}. Ignored if no {@link #resourceZones}
     * config is provided.
     */
    resourceZonesConfig: null,
    initStores: function() {
        var resourceStore = this.resourceStore || this.store;
        if (this.crudManager && Sch.data.CrudManager && !(this.crudManager instanceof Sch.data.CrudManager)) {
            this.crudManager = new Sch.data.CrudManager(Ext.clone(this.crudManager));
        }
        if (!resourceStore) {
            if (this.crudManager) {
                resourceStore = this.resourceStore = this.crudManager.getResourceStore();
            }
            if (!resourceStore) {
                if (this.isTree) {
                    resourceStore = new Sch.data.ResourceTreeStore({
                        proxy: 'memory'
                    });
                } else {
                    resourceStore = new Sch.data.ResourceStore();
                }
            }
        }
        if (!this.dependencyStore) {
            if (this.crudManager) {
                this.dependencyStore = this.crudManager.getDependencyStore();
            }
        }
        //this.dependencyStore = this.dependencyStore || new Sch.data.DependencyStore();
        if (!this.eventStore) {
            if (this.crudManager) {
                this.eventStore = this.crudManager.getEventStore();
            }
            this.eventStore = this.eventStore || new Sch.data.EventStore();
        }
        // Set "store" for the grid panel API
        this.store = Ext.StoreManager.lookup(resourceStore);
        this.resourceStore = this.store;
        this.setEventStore(this.eventStore);
        if (!this.eventStore || !this.eventStore.isEventStore) {
            Ext.Error.raise("Your eventStore should be a subclass of Sch.data.EventStore (or consume the EventStore mixin)");
        }
        this.resourceStore.eventStore = this.getEventStore();
    },
    _initializeSchedulerPanel: function() {
        this.initStores();
        if (this.eventBodyTemplate && typeof this.eventBodyTemplate === 'string') {
            this.eventBodyTemplate = new Ext.XTemplate(this.eventBodyTemplate);
        }
        this.on('destroy', function() {
            this.setResourceStore(null);
            this.setEventStore(null);
        });
    },
    /**
    * Returns the resource store instance
    * @return {Sch.data.ResourceStore}
    */
    getResourceStore: function() {
        return this.resourceStore;
    },
    /**
     * Sets the resource store
     * @param {Sch.data.ResourceStore} newResourceStore
     */
    setResourceStore: function(newResourceStore) {
        var oldResourceStore = this.getResourceStore();
        var isBackingRowStore = oldResourceStore === this.store;
        newResourceStore = newResourceStore && Ext.StoreManager.lookup(newResourceStore);
        var eventStore = this.getEventStore();
        var assignmentStore = this.getAssignmentStore();
        this.resourceStore = newResourceStore;
        if (eventStore) {
            eventStore.setResourceStore(newResourceStore);
        }
        var view = this.getSchedulingView();
        view && view.setResourceStore(newResourceStore);
        // Reconfigure grid if resourceStore is backing the rows
        if (newResourceStore) {
            this.fireEvent('resourcestorechange', this, newResourceStore, oldResourceStore);
            if (isBackingRowStore) {
                this.reconfigure(this.resourceStore);
            } else {
                this.refreshViews(false);
            }
        }
    },
    /**
    * Returns the event store instance
    * @return {Sch.data.EventStore}
    */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the event store
     * @param {Sch.data.EventStore} newEventStore
     */
    setEventStore: function(newEventStore) {
        var oldEventStore = this.getEventStore();
        newEventStore = newEventStore && Ext.StoreManager.lookup(newEventStore);
        if (this.getEventStore()) {
            this.mun(this.getEventStore(), 'beforeload', this.applyStartEndParameters, this);
        }
        var resourceStore = this.getResourceStore();
        var assignmentStore = this.getAssignmentStore();
        var dependencyStore = this.getDependencyStore();
        this.eventStore = newEventStore;
        if (resourceStore) {
            resourceStore.setEventStore(newEventStore);
        }
        if (assignmentStore && newEventStore && !newEventStore.getAssignmentStore()) {
            newEventStore.setAssignmentStore(assignmentStore);
        }
        if (dependencyStore && newEventStore && !newEventStore.getDependencyStore()) {
            newEventStore.setDependencyStore(dependencyStore);
        }
        var view = this.getSchedulingView();
        view && view.setEventStore(newEventStore);
        if (newEventStore) {
            this.fireEvent('eventstorechange', this, newEventStore, oldEventStore);
            if (this.passStartEndParameters) {
                this.mon(newEventStore, 'beforeload', this.applyStartEndParameters, this);
            }
            this.refreshViews(false);
        }
    },
    // Applies the start and end date to each event store request
    applyStartEndParameters: function(eventStore, options) {
        var proxy = eventStore.getProxy();
        proxy.setExtraParam(this.startParamName, this.getStart());
        proxy.setExtraParam(this.endParamName, this.getEnd());
    },
    /**
     * Returns the assignment store instance
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isStore && eventStore.getAssignmentStore() || me.assignmentStore;
    },
    /**
     * Sets the assignment store
     * @param {Sch.data.AssignmentStore} newAssignmentStore
     */
    setAssignmentStore: function(newAssignmentStore) {
        var oldStore = this.getAssignmentStore();
        this.getEventStore().setAssignmentStore(newAssignmentStore);
        if (newAssignmentStore) {
            this.fireEvent('assignmentstorechange', this, newAssignmentStore, oldStore);
            this.refreshViews(false);
        }
    },
    /**
     * Returns the assignment store instance
     * @return {Sch.data.DependencyStore}
     */
    getDependencyStore: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isStore && eventStore.getDependencyStore() || me.dependencyStore;
    },
    /**
     * Sets the assignment store
     * @param {Sch.data.DependencyStore} newDependencyStore
     */
    setDependencyStore: function(newDependencyStore) {
        var oldStore = this.getDependencyStore();
        this.getEventStore().setDependencyStore(newDependencyStore);
        if (newDependencyStore) {
            this.fireEvent('dependencystorechange', this, newDependencyStore, oldStore);
            this.refreshViews(false);
        }
    },
    createResourceColumns: function(colWidth) {
        return Ext.Array.map(this.resourceStore.getRange(), function(resource) {
            return {
                xclass: this.resourceColumnClass,
                renderer: this.mainRenderer,
                scope: this,
                width: colWidth || 100,
                text: resource.getName(),
                model: resource
            };
        }, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.template.Event

 */
Ext.define("Sch.template.Event", {
    extend: 'Ext.XTemplate',
    eventPrefix: null,
    // 'none', 'start', 'end' or 'both'
    resizeHandles: null,
    resizeTpl: '<div class="sch-resizable-handle sch-resizable-handle-DIR"></div>',
    constructor: function(config) {
        Ext.apply(this, config);
        this.callParent([
            '<tpl for=".">' + '<div unselectable="on" tabindex="-1" id="' + this.eventPrefix + '{id}" style="right:{right}px;left:{left}px;top:{top}px;height:{height}px;width:{width}px;{style}" class="sch-event ' + Ext.baseCSSPrefix + 'unselectable {internalCls} {cls}">' + ((this.resizeHandles === 'start' || this.resizeHandles === 'both') ? this.resizeTpl.replace(/DIR/, 'start') : '') + '<div unselectable="on" class="sch-event-inner {iconCls}">' + '{body}' + '</div>' + ((this.resizeHandles === 'end' || this.resizeHandles === 'both') ? this.resizeTpl.replace(/DIR/, 'end') : '') + '</div>' + '</tpl>'
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define("Sch.eventlayout.Horizontal", {
    nbrOfBandsByResource: null,
    bandIndexToPxConvertFn: null,
    bandIndexToPxConvertScope: null,
    constructor: function(config) {
        Ext.apply(this, config);
        this.nbrOfBandsByResource = {};
    },
    clearCache: function(resource) {
        if (resource)  {
            delete this.nbrOfBandsByResource[resource.internalId];
        }
        else  {
            this.nbrOfBandsByResource = {};
        }
        
    },
    // Input:
    // 1. Resource record
    // 2. Array of Event models, or a function to call to receive such event records lazily
    getNumberOfBands: function(resource, resourceEventsOrFn) {
        var nbrOfBandsByResource = this.nbrOfBandsByResource;
        if (nbrOfBandsByResource.hasOwnProperty(resource.internalId)) {
            return nbrOfBandsByResource[resource.internalId];
        }
        var resourceEvents = Ext.isFunction(resourceEventsOrFn) ? resourceEventsOrFn() : resourceEventsOrFn;
        var eventsData = Ext.Array.map(resourceEvents, function(event) {
                return {
                    start: event.getStartDate(),
                    end: event.getEndDate(),
                    event: event
                };
            });
        return this.applyLayout(eventsData, resource);
    },
    // TODO DOC
    applyLayout: function(events, resource) {
        var rowEvents = events.slice();
        // Sort events by start date, and text properties.
        var me = this;
        rowEvents.sort(function(a, b) {
            return me.sortEvents(a.event, b.event);
        });
        // return a number of bands required
        return this.nbrOfBandsByResource[resource.internalId] = this.layoutEventsInBands(rowEvents);
    },
    // Override this sorting method to control in what order events are laid out. By default they are sorted by start date, then end date.
    sortEvents: function(a, b) {
        var startA = a.getStartDate();
        var startB = b.getStartDate();
        var sameStart = (startA - startB === 0);
        if (sameStart) {
            return a.getEndDate() > b.getEndDate() ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }
    },
    // Input: Array of event layout data
    layoutEventsInBands: function(events) {
        var verticalPosition = 0;
        do {
            var event = events[0];
            while (event) {
                event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);
                Ext.Array.remove(events, event);
                event = this.findClosestSuccessor(event, events);
            }
            verticalPosition++;
        } while (// Apply band height to the event cfg
        // Remove it from the array and continue searching
        events.length > 0);
        // Done!
        return verticalPosition;
    },
    findClosestSuccessor: function(event, events) {
        var minGap = Infinity,
            closest,
            eventEnd = event.end,
            gap,
            isMilestone = event.end - event.start === 0;
        for (var i = 0,
            l = events.length; i < l; i++) {
            gap = events[i].start - eventEnd;
            if (gap >= 0 && gap < minGap && // Two milestones should not overlap
            (gap > 0 || events[i].end - events[i].start > 0 || !isMilestone)) {
                closest = events[i];
                minGap = gap;
            }
        }
        return closest;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.view.Vertical

A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation of some methods, specific to vertical mode.

*/
Ext.define("Sch.view.Vertical", {
    // Provided by creator, in the config object
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    translateToScheduleCoordinate: function(y) {
        var view = this.view;
        return y - view.getEl().getY() + view.getScroll().top;
    },
    // private
    translateToPageCoordinate: function(y) {
        var view = this.view;
        var el = view.getEl(),
            scroll = view.getScroll();
        return y + el.getY() - scroll.top;
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy[1];
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event, resource) {
        var M = Math,
            eventStart = event.getStartDate(),
            eventEnd = event.getEndDate(),
            view = this.view,
            viewStart = view.timeAxis.getStart(),
            viewEnd = view.timeAxis.getEnd(),
            startY = M.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart))),
            endY = M.floor(view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd))),
            data = {
                event: event
            };
        data.top = M.max(0, M.min(startY, endY) - view.eventBorderWidth);
        data.height = M.max(1, M.abs(startY - endY));
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region = resourceRecord ? Ext.fly(view.getScheduleCell(view.getNodes()[0], view.getResourceStore().indexOf(resourceRecord))).getRegion() : view.getTableRegion(),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {
                start: taStart,
                end: taEnd
            },
            startY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),
            left = region.left + view.barMargin,
            right = (resourceRecord ? (region.left + this.getResourceColumnWidth(resourceRecord)) : region.right) - view.barMargin;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    getResourceColumnWidth: function(resource) {
        return this.view.timeAxisViewModel.resourceColumnWidth;
    },
    getResourceColumnLayoutAvailableWidth: function(resourceRecord) {
        var me = this;
        return me.getResourceColumnWidth(resourceRecord) - (2 * me.view.barMargin) - me.view.cellBorderWidth;
    },
    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getResourceColumnWidth(resourceRecord),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left = cellLeft + view.cellBorderWidth,
            right = cellLeft + this.getResourceColumnWidth(resourceRecord) - view.cellBorderWidth;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';
        if (rowIndex === 0) {
            var D = Sch.util.Date,
                ta = view.timeAxis,
                columnEvents, resourceEvents, i, l;
            columnEvents = [];
            resourceEvents = view.getEventStore().getEventsForResource(resourceRecord);
            // Iterate events (belonging to current resource)
            for (i = 0 , l = resourceEvents.length; i < l; i++) {
                var event = resourceEvents[i],
                    start = event.getStartDate(),
                    end = event.getEndDate();
                // Determine if the event should be rendered or not
                if (start && end && ta.timeSpanInAxis(start, end)) {
                    columnEvents.push(view.generateTplData(event, resourceRecord, colIndex));
                }
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getResourceColumnLayoutAvailableWidth(resourceRecord));
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }
        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }
        return retVal;
    },
    // private
    resolveResource: function(node) {
        var me = this,
            view = me.view,
            eventNode,
            index = -1,
            result;
        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        } else {
            node = Ext.fly(node).is(view.timeCellSelector) ? node : Ext.fly(node).up(view.timeCellSelector, null, true);
            if (node) {
                if (Ext.isIE8m) {
                    index = 0;
                    node = node.previousSibling;
                    while (node) {
                        if (node.nodeType === 1) {
                            index++;
                        }
                        node = node.previousSibling;
                    }
                } else {
                    index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
                }
            }
            result = index >= 0 && view.getResourceStore().getAt(index) || null;
        }
        return result;
    },
    // private
    onEventUpdate: function(store, event) {
        var me = this;
        var previous = event.previous || {};
        var view = me.view;
        var timeAxis = view.timeAxis;
        var newStartDate = event.getStartDate();
        var newEndDate = event.getEndDate();
        var startDate = previous.StartDate || newStartDate;
        var endDate = previous.EndDate || newEndDate;
        // event was visible or visible now
        var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
        var resource;
        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (event.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new resource, refresh old resource first
            resource = store.getResourceStore().getById(previous[event.resourceIdField]);
            resource && me.relayoutRenderedEvents(resource);
        }
        // also resource has to be repanted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            me.renderSingle(event);
            Ext.Array.each(event.getResources(), function(resource) {
                me.relayoutRenderedEvents(resource);
                view.getEventSelectionModel().isSelected(event) && view.onEventBarSelect(event, true);
            });
        }
    },
    // private
    onEventAdd: function(store, recs) {
        var me = this,
            view = me.view,
            event, startDate, endDate;
        if (recs.length === 1) {
            event = recs[0];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                me.renderSingle(event);
                // Here one could use event.getResources() as well, I use store.getResourcesForEvent() here
                // for consistency with onEventUpdate only
                Ext.Array.each(store.getResourcesForEvent(event), function(resource) {
                    me.relayoutRenderedEvents(resource);
                });
            }
        } else {
            view.repaintAllEvents();
        }
    },
    // private
    onEventRemove: function(s, events) {
        // a comment from `repaintEventsForResource`
        // For vertical, we always repaint all events (do per-column repaint is not supported)
        // so it seems we can't optimize and repaint only for single resource
        var me = this,
            view = me.view,
            event, startDate, endDate, i, len, gotEventInTimeSpan;
        for (gotEventInTimeSpan = false , i = 0 , len = events.length; !gotEventInTimeSpan && i < len; i++) {
            event = events[i];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            gotEventInTimeSpan = startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate);
            gotEventInTimeSpan && view.repaintAllEvents();
        }
    },
    relayoutRenderedEvents: function(resource) {
        var data = [],
            view = this.view,
            events = view.getEventStore().getEventsForResource(resource);
        Ext.Array.each(events, function(event) {
            // In vertical mode there can be only 0 or 1 nodes rendered for each event/resource pair
            var nodes = view.getElementsFromEventRecord(event, resource);
            nodes.length && data.push({
                start: event.getStartDate(),
                end: event.getEndDate(),
                event: event,
                node: nodes[0]
            });
        });
        // Now do a layout pass to get updated dimension / position data for all affected events
        view.eventLayout.vertical.applyLayout(data, this.getResourceColumnLayoutAvailableWidth(resource));
        Ext.Array.each(data, function(event) {
            event.node.setStyle({
                left: event.left + 'px',
                width: event.width + 'px'
            });
            view.fireEvent('eventrepaint', view, event.event, event.node);
        });
    },
    renderSingle: function(event) {
        // Inject moved event into correct cell
        var me = this,
            view = me.view,
            startDate = event.getStartDate(),
            endDate = event.getEndDate(),
            resources;
        // First removing existing event DOM elements, there might be one element per each event/resource pair
        Ext.Array.each(view.getElementsFromEventRecord(event), function(el) {
            el.destroy();
        });
        // If event is within a currently displayed timespan
        if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
            // then render event DOM elements for each event assigned resource
            Ext.Array.each(event.getResources(), function(resource) {
                var rIndex = view.getResourceStore().indexOf(resource),
                    containerCell = Ext.fly(view.getScheduleCell(0, rIndex)),
                    data;
                if (containerCell) {
                    // This check is unclear, I've just left it as is after the method refactoring
                    data = view.generateTplData(event, resource, rIndex);
                    view.eventTpl.append(containerCell.first(), [
                        data
                    ]);
                }
            });
        }
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate) {
        var view = this.view,
            startY = view.getCoordinateFromDate(startDate),
            endY = endDate ? view.getCoordinateFromDate(endDate) : startY,
            tableRegion = view.getTableRegion(),
            width = tableRegion ? tableRegion.right - tableRegion.left : view.getEl().dom.clientWidth;
        // fallback in case grid is not rendered (no rows/table)
        return new Ext.util.Region(Math.min(startY, endY), width, Math.max(startY, endY), 0);
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var topDate = this.view.getDateFromCoordinate(region.top, roundingMethod),
            bottomDate = this.view.getDateFromCoordinate(region.bottom, roundingMethod);
        if (topDate && bottomDate) {
            return {
                start: topDate,
                end: bottomDate
            };
        } else {
            return null;
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.resourceColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.rendered) {
            return null;
        }
        var scroll = view.getScroll(),
            height = view.getHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();
        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate = view.timeAxis.getStart();
            return {
                startDate: startDate,
                endDate: viewEndDate
            };
        }
        return {
            startDate: view.getDateFromCoordinate(scroll.top, null, true),
            endDate: view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    },
    /**
     * Gets box for displayed item designated by the record. If there're several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan will not be returned.
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @protected
     */
    getItemBox: function(eventRecord) {
        var me = this;
        return Ext.Array.map(eventRecord.getResources(), function(resourceRecord) {
            return me.getResourceEventBox(eventRecord, resourceRecord);
        });
    },
    getResourceEventBox: function(eventRecord, resourceRecord) {
        var SUD = Sch.util.Date,
            me = this,
            result = null,
            view = me.view,
            viewStartDate = view.timeAxis.getStart(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            viewEndDate = view.timeAxis.getEnd(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            eventStartDate = eventRecord.getStartDate(),
            eventEndDate = eventRecord.getEndDate(),
            eventLayout, eventsLayoutData, eventRecordData, resourceColumnLeft, eventEls, eventEl, eventElOffsets, eventElBox;
        // Checking if event record is within current time axis timespan, i.e. if it's rendered
        if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) {
            // Managed event sizing means that the view is responsible for event height setting, the oposite case
            // is when event height is controlled by CSS's top and height properties.
            // Fast case: managed event sizing on, querying the view for box position and dimensions
            if (view.managedEventSizing) {
                eventLayout = view.eventLayout.vertical;
                var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
                // Preparing events layout data for event layout instance to process
                eventsLayoutData = Ext.Array.map(resourceEvents, me.getEventRenderData, me);
                // Processing event layout data injecting event horizontal position into them
                eventLayout.applyLayout(eventsLayoutData, me.getResourceColumnLayoutAvailableWidth(resourceRecord));
                // Now we are to find our particular event data inside all events data for the given row record
                eventRecordData = Ext.Array.findBy(eventsLayoutData, function(eventData) {
                    return eventData.event == eventRecord;
                });
                // We must find our event record corresponding layout data object here, but just to make sure
                if (eventRecordData) {
                    // We have event record data with coordinates within the row node, but we need
                    // those coordinates to be translated relative to view's viewport left.
                    resourceColumnLeft = view.getResourceStore().indexOf(resourceRecord) * me.getResourceColumnWidth(resourceRecord);
                    // Finally we have all the data needed to calculated the event record box
                    result = {
                        rendered: true,
                        start: eventRecordData.left + resourceColumnLeft,
                        end: eventRecordData.left + eventRecordData.width + resourceColumnLeft,
                        top: eventRecordData.top,
                        bottom: eventRecordData.top + eventRecordData.height
                    };
                }
            } else // Slow case: managed event sizing off, querying the DOM for box position and dimensions
            {
                eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
                // We must have at one and only one element here, but just to make sure
                if (eventEls.length) {
                    eventEl = eventEls[0];
                    eventElOffsets = eventEl.getOffsetsTo(view.getEl());
                    eventElBox = eventEl.getBox();
                    result = {
                        rendered: true,
                        start: eventElOffsets[0],
                        end: eventElOffsets[0] + eventElBox.width,
                        top: eventElOffsets[1],
                        bottom: eventElOffsets[1] + eventElBox.height
                    };
                }
            }
            // Some boxes might need special adjustments
            if (result) {
                result = me.adjustItemBox(eventRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Sch.model.Event} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(eventRecord, eventRecordBox) {
        return eventRecordBox;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'top';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'bottom';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Sch.eventlayout.Vertical
 * @private
 *
 */
Ext.define("Sch.eventlayout.Vertical", {
    requires: [
        'Sch.util.Date'
    ],
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    // Try to pack the events to consume as little space as possible
    applyLayout: function(events, totalAvailableWidth) {
        if (events.length === 0) {
            return;
        }
        // Sort events by start date, and text properties.
        var me = this;
        events.sort(function(a, b) {
            return me.sortEvents(a.event, b.event);
        });
        var start, end,
            view = this.view,
            D = Sch.util.Date,
            band = 1,
            startFraction, slot, firstInCluster, j;
        for (var i = 0,
            l = events.length; i < l; i++) {
            firstInCluster = events[i];
            start = firstInCluster.start;
            end = firstInCluster.end;
            slot = this.findStartSlot(events, firstInCluster);
            var cluster = this.getCluster(events, i);
            if (cluster.length > 1) {
                firstInCluster.left = slot.start;
                firstInCluster.width = slot.end - slot.start;
                // If there are multiple slots and events in the cluster have multiple start dates, group all same-start events into first slot
                j = 1;
                while (j < (cluster.length - 1) && cluster[j + 1].start - firstInCluster.start === 0) {
                    j++;
                }
                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot
                var nextSlot = this.findStartSlot(events, cluster[j]);
                if (nextSlot && nextSlot.start < 0.8) {
                    cluster = cluster.slice(0, j);
                }
            }
            var count = cluster.length,
                barWidth = (slot.end - slot.start) / count;
            // Apply fraction values
            for (j = 0; j < count; j++) {
                cluster[j].width = barWidth;
                cluster[j].left = slot.start + (j * barWidth);
            }
            i += count - 1;
        }
        for (i = 0 , l = events.length; i < l; i++) {
            events[i].width = events[i].width * totalAvailableWidth;
            events[i].left = view.barMargin + (events[i].left * totalAvailableWidth);
        }
    },
    findStartSlot: function(events, event) {
        var priorOverlappers = this.getPriorOverlappingEvents(events, event),
            i;
        if (priorOverlappers.length === 0) {
            return {
                start: 0,
                end: 1
            };
        }
        for (i = 0; i < priorOverlappers.length; i++) {
            if (i === 0 && priorOverlappers[0].left > 0) {
                return {
                    start: 0,
                    end: priorOverlappers[0].left
                };
            } else if (priorOverlappers[i].left + priorOverlappers[i].width < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1)) {
                return {
                    start: priorOverlappers[i].left + priorOverlappers[i].width,
                    end: i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1
                };
            }
        }
        return false;
    },
    getPriorOverlappingEvents: function(events, event) {
        var D = Sch.util.Date,
            start = event.start,
            end = event.end,
            overlappers = [];
        for (var i = 0,
            l = Ext.Array.indexOf(events, event); i < l; i++) {
            if (D.intersectSpans(start, end, events[i].start, events[i].end)) {
                overlappers.push(events[i]);
            }
        }
        overlappers.sort(this.sortOverlappers);
        return overlappers;
    },
    sortOverlappers: function(e1, e2) {
        return e1.left < e2.left ? -1 : 1;
    },
    getCluster: function(events, startIndex) {
        if (startIndex >= events.length - 1) {
            return [
                events[startIndex]
            ];
        }
        var evts = [
                events[startIndex]
            ],
            start = events[startIndex].start,
            end = events[startIndex].end,
            l = events.length,
            D = Sch.util.Date,
            i = startIndex + 1;
        while (i < l && D.intersectSpans(start, end, events[i].start, events[i].end)) {
            evts.push(events[i]);
            start = D.max(start, events[i].start);
            end = D.min(events[i].end, end);
            i++;
        }
        return evts;
    },
    sortEvents: function(a, b) {
        var startA = a.getStartDate(),
            endA = a.getEndDate();
        var startB = b.getStartDate(),
            endB = b.getEndDate();
        var sameStart = (startA - startB === 0);
        if (sameStart) {
            return endA > endB ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.mixin.AbstractSchedulerView
@private

A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
should have already consumed the {@link Sch.mixin.TimelineView} mixin.

Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

*/
Ext.define('Sch.mixin.AbstractSchedulerView', {
    requires: [
        'Sch.model.Assignment',
        'Sch.template.Event',
        'Sch.eventlayout.Horizontal',
        'Sch.view.Vertical',
        'Sch.eventlayout.Vertical'
    ],
    _cmpCls: 'sch-schedulerview',
    scheduledEventName: 'event',
    eventTemplateClass: 'Sch.template.Event',
    // The template instance responsible for rendering the event bars
    eventTpl: null,
    /**
    * @cfg {Number} barMargin
    * Controls how much space to leave between stacked event bars in px
    */
    barMargin: 0,
    /**
    * @cfg {Boolean} constrainDragToResource Set to true to only allow dragging events within the same resource.
    */
    constrainDragToResource: false,
    // Provided by panel
    allowOverlap: null,
    readOnly: null,
    altColCls: 'sch-col-alt',
    /**
    * @cfg {Boolean} dynamicRowHeight
    * True to layout events without overlapping, meaning the row height will be dynamically calculated to fit any overlapping events.
    */
    dynamicRowHeight: true,
    /**
    * @cfg {Boolean} managedEventSizing
    * True to size events based on the rowHeight and barMargin settings. Set this to false if you want to control height and top properties via CSS instead.
    */
    managedEventSizing: true,
    /**
    * @cfg {Boolean} eventAnimations
    * True to animate event updates, currently only used in vertical mode in CSS3 enabled browsers.
    */
    eventAnimations: true,
    /**
     * @cfg {String} horizontalLayoutCls
     * The class name responsible for the horizontal event layout process. Override this to take control over the layout process.
     */
    horizontalLayoutCls: 'Sch.eventlayout.Horizontal',
    horizontalEventSorterFn: null,
    /**
     * @cfg {Function} horizontalEventSorterFn
     *
     *  Override this method to provide a custom sort function to sort any overlapping events. By default,
     *  overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     *  Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event a is placed above event b.
     *
     horizontalEventSorterFn : function (a, b) {

            var startA = a.getStartDate(), endA = a.getEndDate();
            var startB = b.getStartDate(), endB = b.getEndDate();

            var sameStart = (startA - startB === 0);

            if (sameStart) {
                return endA > endB ? -1 : 1;
            } else {
                return (startA < startB) ? -1 : 1;
            }
        }
     *
     * @param  {Sch.model.Event} a
     * @param  {Sch.model.Event} b
     * @return {Int}
     */
    /**
     * @cfg {String} verticalLayoutCls
     * The class name responsible for the vertical event layout process. Override this to take control over the layout process.
     */
    verticalLayoutCls: 'Sch.eventlayout.Vertical',
    /**
     * @cfg {Function} verticalEventSorterFn
     * Override this method to provide a custom sort function to sort any overlapping events. By default,
     * overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     * If this function returns -1, then event a is placed above event b.
     * See also {@link #horizontalEventSorterFn} for a description.
     * @param {Sch.model.Event} a
     * @param {Sch.model.Event} b
     * @return {Int}
     */
    verticalEventSorterFn: null,
    eventCls: 'sch-event',
    verticalViewClass: 'Sch.view.Vertical',
    eventStore: null,
    resourceStore: null,
    eventLayout: null,
    /**
     * @event eventrepaint
     * Fires after an event has been repainted by the view.
     * @param {Sch.mixin.AbstractSchedulerView} view The view instance
     * @param {Sch.model.Event} event
     * @param {HTMLElement} node The updated DOM representation of the event
     */
    _initializeSchedulerView: function() {
        var horLayoutCls = Ext.ClassManager.get(this.horizontalLayoutCls);
        var vertLayoutCls = Ext.ClassManager.get(this.verticalLayoutCls);
        this.eventSelector = '.' + this.eventCls;
        this.eventLayout = {};
        this.eventTpl = this.eventTpl || Ext.create(this.eventTemplateClass, {
            eventPrefix: this.eventPrefix,
            resizeHandles: this.eventResizeHandles
        });
        if (horLayoutCls) {
            this.eventLayout.horizontal = new horLayoutCls(Ext.apply(// this is required for table layout
            {
                timeAxisViewModel: this.timeAxisViewModel
            }, {
                bandIndexToPxConvertFn: this.horizontal.layoutEventVertically,
                bandIndexToPxConvertScope: this.horizontal
            }, this.horizontalEventSorterFn ? {
                sortEvents: this.horizontalEventSorterFn
            } : {}));
        }
        if (vertLayoutCls) {
            this.eventLayout.vertical = new vertLayoutCls(Ext.apply({}, {
                view: this
            }, this.verticalEventSorterFn ? {
                sortEvents: this.verticalEventSorterFn
            } : {}));
        }
        this.store = this.store || this.resourceStore;
        this.resourceStore = this.resourceStore || this.store;
    },
    generateTplData: function(event, resourceRecord, columnIndex) {
        var renderData = this[this.mode].getEventRenderData(event, resourceRecord, columnIndex),
            start = event.getStartDate(),
            end = event.getEndDate(),
            internalCls = event.getCls() || '';
        internalCls += ' sch-event-resizable-' + event.getResizable();
        if (event.dirty)  {
            internalCls += ' sch-dirty ';
        }
        
        if (renderData.endsOutsideView)  {
            internalCls += ' sch-event-endsoutside ';
        }
        
        if (renderData.startsOutsideView)  {
            internalCls += ' sch-event-startsoutside ';
        }
        
        if (this.eventBarIconClsField)  {
            internalCls += ' sch-event-withicon ';
        }
        
        if (event.isDraggable() === false)  {
            internalCls += ' sch-event-fixed ';
        }
        
        if (end - start === 0)  {
            internalCls += ' sch-event-milestone ';
        }
        
        if (this.getEventSelectionModel().isSelected(event))  {
            internalCls += ' ' + this.selectedEventCls + ' ';
        }
        
        // in calendar mode event can be rendered in miltiple columns yet it remains the same
        // to distinguish them we append resource index to element id
        renderData.id = event.internalId + '-' + resourceRecord.internalId + (this.isCalendar() ? ('-' + columnIndex) : '-x');
        /* this is important for getElement(s)FromEventRecord() */
        renderData.internalCls = internalCls;
        renderData.start = start;
        renderData.end = end;
        renderData.iconCls = event.data[this.eventBarIconClsField] || (event.getIconCls && event.getIconCls()) || '';
        renderData.event = event;
        if (this.eventRenderer) {
            // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate
            var value = this.eventRenderer.call(this.eventRendererScope || this, event, resourceRecord, renderData, columnIndex);
            if (this.eventBodyTemplate) {
                renderData.body = this.eventBodyTemplate.apply(value);
            } else {
                renderData.body = value;
            }
        } else if (this.eventBodyTemplate) {
            // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.
            renderData.body = this.eventBodyTemplate.apply(event.data);
        } else if (this.eventBarTextField) {
            // User has specified a field in the data model to read from
            renderData.body = event.data[this.eventBarTextField] || '';
        }
        return renderData;
    },
    /**
    * Resolves the resource based on a dom element
    * @param {HtmlElement} node The HTML element
    * @return {Sch.model.Resource} The resource corresponding to the element, or null if not found.
    */
    resolveResource: function(node) {
        var me = this;
        return me[me.mode].resolveResource(node);
    },
    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        return this[this.mode].getResourceRegion(resourceRecord, startDate, endDate);
    },
    /**
    * <p>Returns the event record for a DOM element </p>
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Event|Null} The event record
    */
    resolveEventRecord: function(el) {
        // Normalize to DOM node
        el = el.dom ? el.dom : el;
        if (!(Ext.fly(el).is(this.eventSelector))) {
            el = Ext.fly(el).up(this.eventSelector);
        }
        return el && this.getEventRecordFromDomId(el.id);
    },
    // TODO: Get rid of this, make it in inline?, move it to mixins/SchedulerView
    resolveEventRecordFromResourceRow: function(el) {
        var me = this,
            sm = me.getEventSelectionModel(),
            resource, event;
        el = el.dom ? el.dom : el;
        resource = me.getRecord(el);
        return sm.getFirstSelectedEventForResource(resource);
    },
    /**
    * Returns an assignment record for a DOM element
    *
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Assignment|Null} The assignment record
    */
    resolveAssignmentRecord: function(el) {
        var me = this,
            assignmentStore = me.getEventStore().getAssignmentStore(),
            assignment = null,
            event, resource;
        if (assignmentStore) {
            event = me.getEventRecordFromDomId(el.id);
            resource = me.getResourceRecordFromDomId(el.id);
            if (event && resource) {
                assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
            }
        }
        return assignment;
    },
    /**
    * <p>Returns the event record for a DOM id </p>
    * @param {String} id The id of the DOM node
    * @return {Sch.model.Event} The event record
    */
    getEventRecordFromDomId: function(id) {
        id = this.getEventIdFromDomNodeId(id);
        return this.getEventStore().getModelByInternalId(id);
    },
    /**
     * Returns a resource record for a DOM id
     * @param {String} id An id of an event DOM node
     * @return {Sch.model.Resource} A resource record
     */
    getResourceRecordFromDomId: function(id) {
        id = this.getResourceIdFromDomNodeId(id);
        return this.getResourceStore().getByInternalId(id);
    },
    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function(start, end, excludeEvent, resource) {
        return this.getEventStore().isDateRangeAvailable(start, end, excludeEvent, resource);
    },
    /**
    * Returns events that are (partly or fully) inside the timespan of the current view.
    * @return {Ext.util.MixedCollection} The collection of events
    */
    getEventsInView: function() {
        var viewStart = this.timeAxis.getStart(),
            viewEnd = this.timeAxis.getEnd();
        return this.getEventStore().getEventsInTimeSpan(viewStart, viewEnd);
    },
    /**
    * Returns the current set of rendered event nodes
    * @return {Ext.CompositeElement} The collection of event nodes
    */
    getEventNodes: function() {
        return this.getEl().select(this.eventSelector);
    },
    /**
     * Highlights one or more events in the current timeline view
     *
     * @param {Sch.model.Range/[Sch.model.Range]} date Center date for the viewport.
     */
    highlightEvents: function(eventRecords) {
        var me = this;
        var elements = [];
        Ext.Array.each([].concat(eventRecords), function(ev) {
            elements.push.apply(elements, me.getElementsFromEventRecord(ev, null, null, true));
        });
        Ext.Array.each([].concat(elements), function(el) {
            Ext.fly(el).addCls('sch-event-highlighted');
        });
    },
    /**
     * Highlights events in the current timeline view that match the passed filter function
     *
     * @param {Sch.model.Range/[Sch.model.Range]} date Center date for the viewport.
     */
    highlightEventsBy: function(fn, scope) {
        var events = this.getEventsInView();
        this.highlightEvents(events.filterBy(fn, scope).getRange());
    },
    /**
     * Clears the highlight of all events
     *
     * @param {Sch.model.Range/[Sch.model.Range]} date Center date for the viewport.
     */
    clearHighlightedEvents: function(fn, scope) {
        this.getEl().select('.sch-event-highlighted').removeCls('sch-event-highlighted');
    },
    onEventCreated: function(newEventRecord) {},
    // Empty but provided so that you can override it to supply default record values etc.
    getEventStore: function() {
        return this.eventStore;
    },
    registerEventEditor: function(editor) {
        this.eventEditor = editor;
    },
    getEventEditor: function() {
        return this.eventEditor;
    },
    // Call mode specific implementation
    onEventUpdate: function(store, model, operation) {
        this[this.mode].onEventUpdate(store, model, operation);
    },
    // Call mode specific implementation
    onEventAdd: function(s, recs) {
        // TreeStore 'insert' and 'append' events pass a single Model instance, not an array
        if (!Ext.isArray(recs))  {
            recs = [
                recs
            ];
        }
        
        this[this.mode].onEventAdd(s, recs);
    },
    // Call mode specific implementation
    onAssignmentAdd: function(store, assignments) {
        var me = this;
        Ext.Array.each(assignments, function(assignment) {
            var resource = assignment.getResource();
            resource && me.repaintEventsForResource(resource);
        });
    },
    onAssignmentUpdate: function(store, assignment) {
        var me = this,
            oldResourceId = assignment.previous && assignment.previous[assignment.resourceIdField],
            newResourceId = assignment.getResourceId(),
            oldResource, newResource;
        if (oldResourceId) {
            oldResource = me.getResourceStore().getModelById(oldResourceId);
            me.repaintEventsForResource(oldResource);
        }
        if (newResourceId) {
            newResource = me.getResourceStore().getModelById(newResourceId);
            me.repaintEventsForResource(newResource);
        }
    },
    onAssignmentRemove: function(store, assignments) {
        var me = this;
        Ext.Array.each(assignments, function(assignment) {
            var resourceId = assignment.getResourceId();
            var resource = resourceId && me.getResourceStore().getModelById(resourceId);
            resource && me.repaintEventsForResource(resource);
        });
    },
    // Call orientation specific implementation
    onEventRemove: function(s, recs) {
        this[this.mode].onEventRemove(s, recs);
    },
    setEventStore: function(eventStore, initial) {
        var me = this;
        var oldStore = me.getEventStore();
        var listenerCfg = {
                scope: me,
                refresh: me.onEventDataRefresh,
                // Sencha Touch
                addrecords: me.onEventAdd,
                updaterecord: me.onEventUpdate,
                removerecords: me.onEventRemove,
                // Ext JS
                add: me.onEventAdd,
                update: me.onEventUpdate,
                remove: me.onEventRemove,
                // If the eventStore is a TreeStore
                nodeinsert: me.onEventAdd,
                nodeappend: me.onEventAdd
            };
        // In case there is an assigment store used
        var assignmentListenerCfg = {
                scope: me,
                refresh: me.onEventDataRefresh,
                load: me.onEventDataRefresh,
                update: me.onAssignmentUpdate,
                add: me.onAssignmentAdd,
                remove: me.onAssignmentRemove
            };
        // Sencha Touch fires "refresh" when clearing the store. Avoid double repaints
        if (!Ext.versions.touch) {
            listenerCfg.clear = me.onEventDataRefresh;
        }
        if (!initial && me.eventStore) {
            me.eventStore.setResourceStore(null);
            if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
                me.eventStore.destroy();
            } else {
                if (me.mun) {
                    me.mun(me.eventStore, listenerCfg);
                    var oldAssignmentStore = me.eventStore.getAssignmentStore();
                    if (oldAssignmentStore) {
                        me.mun(oldAssignmentStore, assignmentListenerCfg);
                    }
                } else {
                    me.eventStore.un(listenerCfg);
                }
            }
            if (!eventStore) {
                me.eventStore = null;
            }
        }
        if (eventStore) {
            eventStore = Ext.data.StoreManager.lookup(eventStore);
            if (me.mon) {
                me.mon(eventStore, listenerCfg);
            } else {
                eventStore.on(listenerCfg);
            }
            me.eventStore = eventStore;
            eventStore.setResourceStore(me.getResourceStore());
            var assignmentStore = eventStore.getAssignmentStore();
            if (assignmentStore) {
                me.mon(assignmentStore, assignmentListenerCfg);
            }
        }
        if (eventStore && !initial) {
            this.getTimeAxisViewModel().setEventStore(eventStore);
            this.getEventSelectionModel().bindStore(eventStore);
            this.fireEvent('eventstorechange', this, eventStore, oldStore);
            me.refreshView();
        }
    },
    onEventDataRefresh: function() {
        this.refreshKeepingScroll();
    },
    // invoked by the selection model to maintain visual UI cues
    onEventBarSelect: function(record) {
        var me = this,
            event, resource;
        if (record instanceof Sch.model.Assignment) {
            event = record.getEvent();
            resource = record.getResource();
        } else {
            event = record;
            resource = null;
        }
        Ext.Array.each(me.getElementsFromEventRecord(event, resource), function(el) {
            el.addCls(me.selectedEventCls);
        });
    },
    // invoked by the selection model to maintain visual UI cues
    onEventBarDeselect: function(record) {
        var me = this,
            event, resource;
        if (record instanceof Sch.model.Assignment) {
            event = record.getEvent();
            resource = record.getResource();
        } else {
            event = record;
            resource = null;
        }
        event && Ext.Array.each(me.getElementsFromEventRecord(event, resource), function(el) {
            el.removeCls(me.selectedEventCls);
        });
    },
    refresh: function() {
        throw 'Abstract method call';
    },
    /**
    * Refreshes the events for a single resource
    * @param {Sch.model.Resource} resource
    */
    repaintEventsForResource: function(record) {
        throw 'Abstract method call';
    },
    /**
     * Refreshes all events in the scheduler view
     */
    repaintAllEvents: function() {
        this.refreshKeepingScroll();
    },
    /**
     * Scrolls an event record into the viewport.
     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.
     *
     * @param {Sch.model.Event} eventRec, the event record to scroll into view
     * @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     *
     * @deprecated
     */
    scrollEventIntoView: function(eventRec, highlight, animate, callback, scope) {
        var me = this,
            resources = eventRec.getResources();
        resources.length && me.scrollResourceEventIntoView(resources[0], eventRec, null, highlight, animate, callback, scope);
    },
    getResourceStore: function() {
        return this.resourceStore;
    },
    setResourceStore: function(store) {
        var oldStore = this.resourceStore;
        this.resourceStore = store;
        if (store) {
            this.fireEvent('resourcestorechange', this, store, oldStore);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class
 * @static
 * @private
 * Private utility class for dealing with scroll triggering based on various mousemove events in the UI
 */
Ext.define('Sch.util.ScrollManager', {
    singleton: true,
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 200,
    activeCmp: null,
    activeEl: null,
    scrollElRegion: null,
    scrollProcess: {},
    pt: null,
    scrollWidth: null,
    scrollHeight: null,
    // "horizontal", "vertical" or "both"
    direction: 'both',
    constructor: function() {
        this.doScroll = Ext.Function.bind(this.doScroll, this);
    },
    triggerRefresh: function() {
        if (this.activeEl) {
            this.refreshElRegion();
            this.clearScrollInterval();
            this.onMouseMove();
        }
    },
    doScroll: function() {
        var scrollProcess = this.scrollProcess,
            scrollProcessCmp = scrollProcess.cmp,
            // HACK: Ext JS has different behavior for viewport case vs non-viewport case.
            rtlWithoutViewport = scrollProcessCmp.rtl && !scrollProcessCmp.up('[isViewport]'),
            dir = scrollProcess.dir[0],
            increment = this.increment,
            scrollLeft = this.activeCmp.getScrollX(),
            scrollTop = this.activeCmp.getScrollY();
        // Make sure we don't scroll too far
        if (dir === 'r') {
            increment = Math.min(increment, rtlWithoutViewport ? scrollLeft : this.scrollWidth - scrollLeft - this.activeEl.dom.clientWidth);
        } else if (dir === 'd') {
            increment = Math.min(increment, this.scrollHeight - scrollTop - this.activeEl.dom.clientHeight);
        }
        increment = Math.max(increment, 0);
        var deltaX = 0,
            deltaY = 0;
        if (dir === 'r')  {
            deltaX = increment;
        }
        
        if (dir === 'l')  {
            deltaX = -increment;
        }
        
        if (dir === 'u')  {
            deltaY = -increment;
        }
        
        if (dir === 'd')  {
            deltaY = increment;
        }
        
        if (rtlWithoutViewport) {
            deltaX = -deltaX;
        }
        scrollProcessCmp.scrollBy(deltaX, deltaY, {
            duration: this.animDuration,
            callback: this.triggerRefresh,
            scope: this
        });
    },
    clearScrollInterval: function() {
        var scrollProcess = this.scrollProcess;
        if (scrollProcess.id) {
            clearTimeout(scrollProcess.id);
        }
        scrollProcess.id = 0;
        scrollProcess.cmp = null;
        scrollProcess.dir = "";
    },
    isScrollAllowed: function(dir) {
        switch (this.direction) {
            case 'both':
                return true;
            case 'horizontal':
                return dir === 'right' || dir === 'left';
            case 'vertical':
                return dir === 'up' || dir === 'down';
            default:
                throw 'Invalid direction: ' + this.direction;
        }
    },
    startScrollInterval: function(cmp, dir) {
        if (!this.isScrollAllowed(dir)) {
            return;
        }
        this.clearScrollInterval();
        this.scrollProcess.cmp = cmp;
        this.scrollProcess.dir = dir;
        this.scrollProcess.id = setTimeout(this.doScroll, this.frequency);
    },
    onMouseMove: function(e) {
        var pt = e ? e.getPoint() : this.pt,
            x = pt.x,
            y = pt.y,
            scrollProcess = this.scrollProcess,
            cmp = this.activeCmp,
            scrollLeft = cmp.getScrollX(),
            scrollTop = cmp.getScrollY(),
            id,
            // HACK: Ext JS has different behavior for viewport case vs non-viewport case.
            rtlWithoutViewport = cmp.rtl && !cmp.up('[isViewport]'),
            el = this.activeEl,
            region = this.scrollElRegion,
            elDom = el.dom,
            me = this;
        this.pt = pt;
        if (region && region.contains(pt) && el.isScrollable()) {
            if (region.bottom - y <= me.vthresh && (this.scrollHeight - scrollTop - elDom.clientHeight > 0)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "down");
                }
                return;
            } else if (region.right - x <= me.hthresh && (rtlWithoutViewport ? scrollLeft > 0 : this.scrollWidth - scrollLeft - elDom.clientWidth > 0)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "right");
                }
                return;
            } else if (y - region.top <= me.vthresh && scrollTop > 0) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "up");
                }
                return;
            } else if (x - region.left <= me.hthresh && (rtlWithoutViewport ? elDom.clientWidth + scrollLeft < this.scrollWidth : scrollLeft > 0)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "left");
                }
                return;
            }
        }
        this.clearScrollInterval();
    },
    refreshElRegion: function() {
        this.scrollElRegion = this.activeEl.getRegion();
    },
    // Pass an element, and optionally a direction ("horizontal", "vertical" or "both")
    activate: function(cmp, direction) {
        var scrollbarSize = Ext.getScrollbarSize();
        this.direction = direction || 'both';
        this.activeCmp = cmp;
        this.activeEl = cmp.getEl();
        var maxPosition = cmp.getScrollable().getMaxPosition();
        this.scrollWidth = maxPosition.x + cmp.getWidth() - scrollbarSize.width;
        this.scrollHeight = maxPosition.y + cmp.getHeight() - scrollbarSize.height;
        this.refreshElRegion();
        this.activeEl.on('mousemove', this.onMouseMove, this);
    },
    deactivate: function() {
        this.clearScrollInterval();
        this.activeEl.un('mousemove', this.onMouseMove, this);
        this.activeEl = this.activeCmp = this.scrollElRegion = this.scrollWidth = this.scrollHeight = null;
        this.direction = 'both';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.tooltip.ClockTemplate
 * @extends Ext.XTemplate
 * @private
 * A template showing a clock. It accepts an object containing a 'date' and a 'text' property to its apply method.
 * @constructor
 * @param {Object} config The object containing the configuration of this model.
 **/
Ext.define("Sch.tooltip.ClockTemplate", {
    extend: 'Ext.XTemplate',
    minuteHeight: 8,
    minuteTop: 2,
    hourHeight: 8,
    hourTop: 2,
    handLeft: 10,
    // 'hour' for a clock view or 'day' for a calendar view
    mode: 'hour',
    getRotateStyle: function(degrees) {
        return "transform:rotate(Ddeg);-ms-transform:rotate(Ddeg);-moz-transform: rotate(Ddeg);-webkit-transform: rotate(Ddeg);-o-transform:rotate(Ddeg);".replace(/D/g, degrees);
    },
    getRotateStyleIE: (function() {
        var toRad = Math.PI / 180,
            cos = Math.cos,
            sin = Math.sin;
        return function(degrees, top, height) {
            var me = this,
                rad = degrees * toRad,
                cosV = cos(rad),
                sinV = sin(rad),
                y = height * sin((90 - degrees) * toRad),
                x = height * cos((90 - degrees) * toRad),
                topAdjust = Math.min(height, height - y),
                leftAdjust = degrees > 180 ? x : 0,
                matrixString = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + cosV + ", M12 = " + (-sinV) + ", M21 = " + sinV + ", M22 = " + cosV + ")";
            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", matrixString, topAdjust + top, leftAdjust + me.handLeft);
        };
    })(),
    constructor: function() {
        var isLegacyIE = Ext.isIE && Ext.isIE8m;
        this.callParent([
            '<div class="sch-clockwrap ' + (isLegacyIE ? '' : 'sch-supports-border-radius') + ' sch-clock-{[this.mode]}">' + '<div class="sch-clock">' + '<div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ', + ' + this.hourHeight + ')]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div>' + '<div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6,' + this.minuteTop + ', + ' + this.minuteHeight + ')]}">{[values.date.getDate()]}</div>' + (isLegacyIE ? '' : '<div class="sch-clock-dot"></div>') + '</div>' + '<span class="sch-clock-text">{text}</span>' + '</div>',
            {
                getMinuteStyle: isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle,
                getHourStyle: isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle
            }
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.tooltip.Tooltip
 @extends Ext.ToolTip
 @private

 Internal plugin showing a tooltip with event start/end information.
 */
Ext.define("Sch.tooltip.Tooltip", {
    extend: "Ext.tip.ToolTip",
    requires: [
        'Sch.tooltip.ClockTemplate'
    ],
    autoHide: false,
    anchor: 'b',
    padding: '0 3 0 0',
    showDelay: 0,
    hideDelay: 0,
    quickShowInterval: 0,
    dismissDelay: 0,
    trackMouse: false,
    anchorOffset: 5,
    shadow: false,
    frame: false,
    schedulerView: null,
    message: null,
    startDate: null,
    endDate: null,
    template: null,
    valid: true,
    mode: null,
    offsetAdjust: [
        18,
        5
    ],
    constructor: function(config) {
        var clockTpl = new Sch.tooltip.ClockTemplate();
        this.startDate = this.endDate = new Date();
        if (!this.template) {
            this.template = Ext.create("Ext.XTemplate", '<div class="sch-tip-{[values.valid ? "ok" : "notok"]}">' + '{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}' + '{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}' + '<div class="sch-tip-message">{message}</div>' + '</div>', {
                disableFormats: true,
                renderClock: function(date, text, cls) {
                    return clockTpl.apply({
                        date: date,
                        text: text,
                        cls: cls
                    });
                }
            });
        }
        this.callParent(arguments);
    },
    // set redraw to true if you want to force redraw of the tip
    // required to update drag tip after scroll
    update: function(startDate, endDate, valid, message) {
        if (this.startDate - startDate !== 0 || this.endDate - endDate !== 0 || this.valid !== valid || this.message !== message) {
            // Readjust position if message is removed or appears
            var realignNeeded = (this.message && !message) || (!this.message && message);
            // This will be called a lot so cache the values
            this.startDate = startDate;
            this.endDate = endDate;
            this.valid = valid;
            this.message = message;
            var startText = this.schedulerView.getFormattedDate(startDate),
                endText = this.schedulerView.getFormattedEndDate(endDate, startDate);
            // If resolution is day or greater, and end date is greater then start date
            if (this.mode === 'calendar' && endDate.getHours() === 0 && endDate.getMinutes() === 0 && !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) {
                endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
            }
            this.callParent([
                this.template.apply({
                    valid: valid,
                    startDate: startDate,
                    endDate: endDate,
                    startText: startText,
                    endText: endText,
                    message: message
                })
            ]);
            if (realignNeeded) {
                this.realign();
            }
        }
    },
    show: function(el, xOffset) {
        // Ext internal tooltip code may call this method with an Array, ignore it
        if (!el || Ext.isArray(el)) {
            return;
        }
        //restore initial position
        //https://www.assembla.com/spaces/bryntum/tickets/2134#/activity/ticket:
        if (this.rendered === true) {
            this.setPosition(0, 0);
        }
        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = 'calendar';
            this.addCls('sch-day-resolution');
            this.removeCls('sch-hour-resolution');
        } else {
            this.mode = 'clock';
            this.removeCls('sch-day-resolution');
            this.addCls('sch-hour-resolution');
        }
        // xOffset has to have default value
        // when it's 18 tip is aligned to left border
        xOffset = arguments.length > 1 ? xOffset : this.offsetAdjust[0];
        this.mouseOffsets = [
            xOffset - this.offsetAdjust[0],
            -this.offsetAdjust[1]
        ];
        this.setTarget(el);
        this.callParent();
        this.realign();
    },
    realign: function() {
        this.el.alignTo(this.target, 'bl-tl', this.mouseOffsets);
    },
    afterRender: function() {
        this.callParent(arguments);
        // In slower browsers, the mouse pointer may end up over the tooltip interfering with drag drop etc
        this.el.on('mouseenter', this.realign, this);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.tooltip.HoverTip
 * HoverTip is a class that represents a tooltip with clock and time which updates as the mouse pointer moves over the schedule area.
 */
Ext.define('Sch.tooltip.HoverTip', {
    extend: 'Ext.tip.ToolTip',
    alias: 'widget.scheduler_hovertip',
    requires: [
        'Sch.tooltip.ClockTemplate'
    ],
    trackMouse: true,
    bodyCls: 'sch-hovertip',
    messageTpl: '<div class="sch-hovertip-msg">{message}</div>',
    autoHide: false,
    dismissDelay: 1000,
    showDelay: 0,
    /**
     * @cfg {Sch.mixin.SchedulerView} schedulerView (required) View instance to bind this tooltip to
     */
    schedulerView: null,
    clockTpl: null,
    lastTime: null,
    lastResource: null,
    initComponent: function() {
        var me = this;
        var view = me.schedulerView;
        me.clockTpl = new Sch.tooltip.ClockTemplate();
        me.messageTpl = new Ext.XTemplate(me.messageTpl);
        me.callParent(arguments);
        me.on('beforeshow', me.tipOnBeforeShow, me);
        view.mon(view.el, {
            mouseleave: function() {
                me.hide();
            },
            mousemove: me.handleMouseMove,
            scope: me
        });
        // Force hide on a mouse down, in case the user is having a click listener on the schedule element
        // to show a window popup for example - in that case the hover-tooltip should not interfere
        view.mon(view.el, {
            click: me.onBodyMouseDown,
            scope: me,
            delay: 1
        });
    },
    onBodyMouseDown: function() {
        this.hide();
    },
    handleMouseMove: function(e) {
        var me = this;
        var view = me.schedulerView;
        if (me.disabled) {
            return;
        }
        if (e.getTarget('.' + view.itemCls, 5) && !e.getTarget(view.eventSelector)) {
            var time = view.getDateFromDomEvent(e, 'floor');
            if (time) {
                var resourceRecord = view.resolveResource(e.getTarget());
                if (time - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
                    me.lastResource = resourceRecord;
                    if (me.hidden) {
                        // HACK, find better solution
                        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
                            me.clockTpl.mode = 'day';
                        } else {
                            me.clockTpl.mode = 'hour';
                        }
                        me.show();
                    }
                    me.updateHoverTip(time, e);
                }
            } else {
                me.hide();
                me.lastTime = null;
                me.lastResource = null;
            }
        } else {
            me.hide();
            me.lastTime = null;
            me.lastResource = null;
        }
    },
    /**
     * Override this to render custom text to default hover tip
     * @param {Date} date
     * @param {Ext.event.Event} e Browser event
     * @return {String}
     */
    getText: function() {},
    // private
    updateHoverTip: function(date, e) {
        if (date) {
            var clockHtml = this.clockTpl.apply({
                    date: date,
                    text: this.schedulerView.getFormattedDate(date)
                });
            var messageHtml = this.messageTpl.apply({
                    message: this.getText(date, e)
                });
            this.update(clockHtml + messageHtml);
            this.lastTime = date;
        }
    },
    tipOnBeforeShow: function(tip) {
        return !this.disabled && this.lastTime !== null;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @private
 * @class Sch.feature.DragCreator
 * @constructor
 * An internal class which shows a drag proxy while clicking and dragging.
 * Create a new instance of this plugin
 * @param {Object} config The configuration options
 */
Ext.define("Sch.feature.DragCreator", {
    requires: [
        'Ext.XTemplate',
        'Ext.ToolTip',
        'Sch.util.Date',
        'Sch.util.ScrollManager',
        'Sch.util.DragTracker',
        'Sch.tooltip.Tooltip',
        'Sch.tooltip.HoverTip'
    ],
    /**
     * @cfg {Boolean} disabled true to start disabled
     */
    disabled: false,
    /**
     * @cfg {Boolean} showHoverTip true to show a time tooltip when hovering over the time cells
     */
    showHoverTip: true,
    /**
     * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
     */
    showDragTip: true,
    /**
     * @cfg {Ext.tip.ToolTip/Object} dragTip
     * The tooltip instance to show while dragging to create a new event or a configuration object for the default instance of
     * {@link Sch.tooltip.ToolTip}
     */
    dragTip: null,
    /**
     * @cfg {Number} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
     */
    dragTolerance: 2,
    /**
     * @cfg {Ext.tip.ToolTip/Object} hoverTip
     * The tooltip instance to show when mouse pointer is over scheduling area or a configuration object
     */
    hoverTip: null,
    /**
     * An empty function by default, but provided so that you can perform custom validation on the event being created.
     * Return true if the new event is valid, false to prevent an event being created.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.event.Event} e The event object
     * @return {Boolean} isValid
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    /**
     * @cfg {Object} trackerConfig A custom config object used to create the internal {@link Sch.util.DragTracker} instance
     */
    trackerConfig: null,
    schedulerView: null,
    /**
     * @cfg {Ext.Template/String} template The HTML template shown when dragging to create new items
     */
    template: '<div class="sch-dragcreator-proxy">' + '<div class="sch-event-inner">&#160;</div>' + '</div>',
    constructor: function(config) {
        Ext.apply(this, config || {});
        this.lastTime = new Date();
        if (!(this.template instanceof Ext.Template)) {
            this.template = new Ext.Template(this.template);
        }
        this.schedulerView.on("destroy", this.onSchedulerDestroy, this);
        if (Ext.supports.Touch) {
            this.schedulerView.on('boxready', this.initDragTracker, this);
        } else {
            this.schedulerView.el.on('mousemove', this.initDragTracker, this, {
                single: true
            });
        }
        this.callParent([
            config
        ]);
    },
    /**
     * Enable/disable the plugin
     * @param {Boolean} disabled True to disable this plugin
     */
    setDisabled: function(disabled) {
        this.disabled = disabled;
        if (this.hoverTip) {
            this.hoverTip.setDisabled(disabled);
        }
        if (this.dragTip) {
            this.dragTip.setDisabled(disabled);
        }
    },
    getProxy: function() {
        if (!this.proxy) {
            this.proxy = this.template.append(this.schedulerView.getSecondaryCanvasEl(), {}, true);
            this.proxy.hide = function() {
                this.setStyle({
                    left: 0,
                    right: 0,
                    top: '-10000px'
                });
            };
        }
        return this.proxy;
    },
    // private
    onBeforeDragStart: function(tracker, e) {
        var s = this.schedulerView,
            t = e.getTarget('.' + s.timeCellCls, 5);
        if (t && this.isCreateAllowed(e) && (!e.event.touches || e.event.touches.length === 1)) {
            var resourceRecord = s.resolveResource(t);
            var dateTime = s.getDateFromDomEvent(e);
            if (!this.disabled && t && s.fireEvent('beforedragcreate', s, resourceRecord, dateTime, e) !== false) {
                // Save record if the user ends the drag outside the current row
                this.resourceRecord = resourceRecord;
                // Start time of the event to be created
                this.originalStart = dateTime;
                // Constrain the dragging within the current row schedule area
                this.resourceRegion = s.getScheduleRegion(this.resourceRecord, this.originalStart);
                // Save date constraints
                this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);
                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },
    isCreateAllowed: function(e) {
        return !e.getTarget(this.schedulerView.eventSelector);
    },
    disableHoverTip: function() {
        this.hoverTip && this.hoverTip.disable();
    },
    // private
    onDragStart: function() {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            proxy = me.getProxy();
        this.dragging = true;
        if (this.hoverTip) {
            // Ext.tip.Tooltip will disable itself on click and reenable after 100ms
            this.hoverTip.on('enable', this.disableHoverTip, this);
            this.hoverTip.disable();
        }
        me.start = me.originalStart;
        me.end = me.start;
        me.originalScroll = view.getScroll();
        if (view.getMode() === 'horizontal') {
            me.rowBoundaries = {
                top: me.resourceRegion.top,
                bottom: me.resourceRegion.bottom
            };
        } else {
            me.rowBoundaries = {
                left: me.resourceRegion.left,
                right: me.resourceRegion.right
            };
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        if (view.rtl) {
            // proxy.setBox() is going to calculate relative coordinate
            // if not set to auto - coordinates are messed up
            proxy.setStyle({
                right: 'auto'
            });
        }
        proxy.setBox(dragRegion);
        proxy.show();
        view.fireEvent('dragcreatestart', view, proxy);
        if (me.showDragTip) {
            me.dragTip.enable();
            me.dragTip.update(me.start, me.end, true);
            me.dragTip.show(proxy);
            // for some reason Ext set `visibility` to `hidden` after a couple of `.hide()` calls
            me.dragTip.setStyle('visibility', 'visible');
        }
        Sch.util.ScrollManager.activate(view, view.getMode() === 'horizontal' ? 'horizontal' : 'vertical');
    },
    // private
    onDrag: function() {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            dates = view.getStartEndDatesFromRegion(dragRegion, 'round'),
            message = '';
        if (!dates) {
            return;
        }
        me.start = dates.start || me.start;
        me.end = dates.end || me.end;
        var dc = me.dateConstraints;
        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }
        me.valid = this.validatorFn.call(me.validatorFnScope || me, me.resourceRecord, me.start, me.end);
        if (me.valid && typeof me.valid !== 'boolean') {
            message = me.valid.message;
            me.valid = me.valid.valid;
        }
        // If users returns nothing, that's interpreted as valid
        me.valid = (me.valid !== false);
        if (me.showDragTip) {
            me.dragTip.update(me.start, me.end, me.valid, message);
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        var scroll = view.getScroll();
        var proxy = this.getProxy();
        proxy.setBox(dragRegion);
        if (view.isHorizontal()) {
            proxy.setY(me.resourceRegion.top + me.originalScroll.top - scroll.top);
        }
    },
    eventSwallower: function(e) {
        e.stopPropagation();
        e.preventDefault();
    },
    // private
    onDragEnd: function(tracker, e) {
        var me = this,
            s = me.schedulerView,
            doFinalize = true,
            t = e.getTarget(),
            el = Ext.get(t);
        // When dragging, we don't want a regular scheduleclick to fire - swallow the coming "click" event
        el.on('click', this.eventSwallower);
        me.unbindTimer = setTimeout(function() {
            el.un('click', me.eventSwallower);
        }, 100);
        me.dragging = false;
        if (me.showDragTip) {
            me.dragTip.disable();
        }
        if (!me.start || !me.end || (me.end - me.start <= 0)) {
            me.valid = false;
        }
        me.createContext = {
            start: me.start,
            end: me.end,
            resourceRecord: me.resourceRecord,
            e: e,
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        if (me.valid) {
            doFinalize = s.fireEvent('beforedragcreatefinalize', me.schedulerView, me.createContext, e, this.getProxy()) !== false;
        }
        if (doFinalize) {
            me.finalize(me.valid);
        }
        Sch.util.ScrollManager.deactivate();
    },
    finalize: function(doCreate) {
        var context = this.createContext;
        var schedulerView = this.schedulerView;
        if (doCreate) {
            var newEvent = Ext.create(schedulerView.getEventStore().getModel());
            // In the Gantt case this requires the presence of a a calendar, set a temporary calendar for this operation
            if (newEvent.setCalendar) {
                newEvent.setCalendar(schedulerView.getEventStore().getCalendar());
            }
            newEvent.setStartEndDate(context.start, context.end);
            // Remove temporary calendar
            if (newEvent.setCalendar) {
                newEvent.setCalendar(null);
            }
            schedulerView.fireEvent('dragcreateend', schedulerView, newEvent, context.resourceRecord, context.e, this.getProxy());
        } else {
            this.proxy.hide();
        }
        this.schedulerView.fireEvent('afterdragcreate', schedulerView, this.getProxy());
        if (this.hoverTip) {
            this.hoverTip.un('enable', this.disableHoverTip, this);
            this.hoverTip.enable();
        }
    },
    dragging: false,
    // Lazy setup of additional functionality
    initDragTracker: function() {
        var me = this,
            isTouch = Ext.supports.Touch,
            view = me.schedulerView;
        var config = Ext.apply({
                el: view.el,
                rtl: view.rtl,
                // defer drag create on touch devices since scrolling is the default action
                deferredTouchActivation: isTouch ? 1000 : false,
                tolerance: me.dragTolerance,
                listeners: {
                    mousedown: me.verifyLeftButtonPressed,
                    beforedragstart: me.onBeforeDragStart,
                    dragstart: me.onDragStart,
                    drag: me.onDrag,
                    dragend: me.onDragEnd,
                    scope: me
                }
            }, this.trackerConfig);
        this.bindRightClickPreventer();
        // disable tips for touch mode
        if (isTouch) {
            this.showDragTip = false;
            this.showHoverTip = false;
            this.dragTip = null;
            this.hoverTip = null;
        } else {
            this.setupTooltips();
        }
        me.tracker = new Sch.util.DragTracker(config);
    },
    // Prevent right clicks when drag creating an event
    bindRightClickPreventer: function() {
        var eventName;
        if (Ext.isIE9m) {
            eventName = 'mousedown';
        } else {
            eventName = 'contextmenu';
        }
        this.schedulerView.el.on(eventName, this.stopDragCreateOnRightClick, this, {
            priority: 999
        });
    },
    stopDragCreateOnRightClick: function(e) {
        // https://www.assembla.com/spaces/bryntum/tickets/2113
        // to unify behavior of IE under different OS's we interpret right mouse button down as left mouse button up
        // to stop dragcreate.
        // cannot be tested in siesta using simulated events
        if (e.button !== 0 && this.dragging) {
            // for windows 7 we need to force mouse up
            this.tracker.onMouseUp(e);
        }
    },
    setupTooltips: function() {
        var me = this,
            sv = me.schedulerView;
        if (this.showDragTip) {
            var dragTip = this.dragTip;
            if (dragTip instanceof Ext.tip.ToolTip) {
                dragTip.schedulerView = sv;
                dragTip.on('beforeshow', function() {
                    return me.dragging;
                });
            } else {
                this.dragTip = new Sch.tooltip.Tooltip(Ext.apply({
                    cls: 'sch-dragcreate-tip',
                    schedulerView: sv,
                    listeners: {
                        beforeshow: function() {
                            return me.dragging;
                        }
                    }
                }, dragTip));
            }
        }
        if (me.showHoverTip) {
            var hoverTip = me.hoverTip;
            if (hoverTip instanceof Ext.tip.ToolTip) {
                hoverTip.schedulerView = sv;
            } else {
                me.hoverTip = Ext.ComponentManager.create(Ext.applyIf({
                    renderTo: Ext.getBody(),
                    target: sv.el,
                    schedulerView: sv
                }, hoverTip), 'scheduler_hovertip');
            }
        }
    },
    verifyLeftButtonPressed: function(dragTracker, e) {
        return e.button === 0;
    },
    onSchedulerDestroy: function() {
        // hoverTip might still be a config object if tip hasn't been instantiated/rendered
        if (this.hoverTip && this.hoverTip.destroy) {
            this.hoverTip.destroy();
        }
        // dragTip might still be a config object if tip hasn't been instantiated/rendered
        if (this.dragTip && this.dragTip.destroy) {
            this.dragTip.destroy();
        }
        if (this.tracker) {
            this.tracker.destroy();
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
        clearTimeout(this.unbindTimer);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.feature.SchedulerDragZone
 @extends Ext.dd.DragZone

 A custom scheduler dragzone that also acts as the dropzone, and optionally
 constrains the drag to the resource area that contains the dragged element.

 Generally it should not need to be used directly.
 To configure drag and drop use {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig instead.
 */
Ext.define("Sch.feature.SchedulerDragZone", {
    extend: "Ext.dd.DragZone",
    requires: [
        'Sch.tooltip.Tooltip',
        'Ext.dd.StatusProxy'
    ],
    repairHighlight: false,
    repairHighlightColor: 'transparent',
    // this has to be set to `false` because we will manually register the view element in the ScrollManager
    // we don't need to register the dragged element in it
    containerScroll: false,
    /**
     * @cfg {Boolean} showTooltip Specifies whether or not to show tooltip while dragging event
     */
    showTooltip: true,
    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while dragging event or a configuration object
     */
    tip: null,
    // this property is taking part in coordinates calculations in alignElWithMouse
    // these adjustments required for correct positioning of proxy on mouse move after view scroll
    deltaSetXY: null,
    schedulerView: null,
    _onValidDropTimer: null,
    // The last 'good' coordinates received by mousemove events (needed when a scroll event happens, which doesn't contain XY info)
    lastXY: null,
    /**
     * @type {Boolean} showExactDropPosition When enabled, the event being dragged always "snaps" to the exact start date that it will have after drop.
     */
    showExactDropPosition: false,
    /**
     * @cfg {Boolean} enableCopy true to enable copy by pressing modifier key
     * (see {@link #enableCopyKey enableCopyKey}) during drag drop.
     */
    enableCopy: false,
    /**
     *
     * @cfg {String} enableCopyKey
     * Modifier key that should be pressed during drag drop to copy item.
     * Available values are 'CTRL', 'ALT', 'SHIFT'
     */
    enableCopyKey: 'SHIFT',
    /**
     * @cfg {Object} validatorFn
     *
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    validatorFn: function(dragRecords, targetResourceRecord, date, duration, e) {
        return true;
    },
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the {@link #validatorFn}
     */
    validatorFnScope: null,
    copyKeyPressed: false,
    /**
     * @cfg {String} dragDropProxyCls Special CSS class added to drag proxy to perform lookups
     * @required
     * @private
     */
    dragDropProxyCls: 'sch-dd-ref',
    /**
     * @constructor
     * @param {String/HTMLElement/Ext.dom.Element} el The container element or its ID
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor: function(el, config) {
        // Drag drop won't work in IE8 if running in an iframe
        // https://www.assembla.com/spaces/bryntum/tickets/712#/activity/ticket:
        if (Ext.isIE8m && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true;
        }
        var proxy = this.proxy = this.proxy || new Ext.dd.StatusProxy({
                shadow: false,
                dropAllowed: this.dropAllowed,
                dropNotAllowed: this.dropNotAllowed,
                // HACK, we want the proxy inside the scheduler, so that when user drags the event
                // out of the scheduler el, the event should be cropped by the scheduler edge
                ensureAttachedToBody: Ext.emptyFn
            });
        this.callParent(arguments);
        this.isTarget = true;
        this.scroll = false;
        this.ignoreSelf = false;
        var schedulerView = this.schedulerView;
        if (schedulerView.touchScroll) {
            // disable tooltips for touch devices
            this.showTooltip = false;
        }
        schedulerView.el.appendChild(proxy.el);
        this.bindRightClickPreventer();
        proxy.addCls('sch-dragproxy');
        // Activate the auto-scrolling behavior during the drag drop process
        schedulerView.on({
            eventdragstart: function() {
                Sch.util.ScrollManager.activate(schedulerView, schedulerView.constrainDragToResource && schedulerView.getMode());
            },
            aftereventdrop: function() {
                Sch.util.ScrollManager.deactivate();
            },
            scope: this
        });
        if (this.showTooltip) {
            var tip = this.tip,
                containerEl = schedulerView.up('[lockable=true]').el;
            if (tip instanceof Ext.tip.ToolTip) {
                tip.schedulerView = schedulerView;
            } else {
                this.tip = new Sch.tooltip.Tooltip(Ext.apply({
                    schedulerView: schedulerView,
                    cls: 'sch-dragdrop-tip',
                    constrainTo: containerEl
                }, tip));
            }
        }
    },
    bindRightClickPreventer: function() {
        var eventName;
        if (Ext.isIE10) {
            eventName = 'contextmenu';
        } else {
            // fixes exception in IE9<, chrome, ff
            eventName = 'mousedown';
        }
        this.schedulerView.el.on(eventName, this.preventRightClick, this, {
            priority: 999
        });
    },
    destroy: function() {
        this.callParent(arguments);
        clearTimeout(this._onValidDropTimer);
        Ext.destroyMembers(this, 'tip');
    },
    // Prevents right clicking when dragging is in progress
    preventRightClick: function(e) {
        if (this.dragging && e.button !== 0) {
            // While dragging event clone is under pointer, so when user open context menu
            // scheduler also tries to resolve event and fails. When button is released, event dropped correctly
            // Preventing event is required for IE10 under windows 7. Otherwise it would be enough just to return false
            e.stopEvent();
            return false;
        }
    },
    // @OVERRIDE
    autoOffset: function() {
        this.setDelta(0, 0);
    },
    // private
    setupConstraints: function(constrainRegion, elRegion, xOffset, yOffset, isHorizontal, tickSize, constrained) {
        this.clearTicks();
        var xTickSize = isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
        var yTickSize = !isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
        this.resetConstraints();
        this.initPageX = constrainRegion.left + xOffset;
        this.initPageY = constrainRegion.top + yOffset;
        var width = elRegion.right - elRegion.left;
        var height = elRegion.bottom - elRegion.top;
        // if `constrained` is false then we haven't specified getDateConstraint method and should constrain mouse position to scheduling area
        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.
        if (isHorizontal) {
            if (constrained) {
                this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            } else {
                this.setXConstraint(constrainRegion.left, constrainRegion.right, xTickSize);
            }
            this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
        } else {
            this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            if (constrained) {
                this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
            } else {
                this.setYConstraint(constrainRegion.top, constrainRegion.bottom, yTickSize);
            }
        }
    },
    // @OVERRIDE
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = iLeft;
        this.rightConstraint = iRight;
        this.minX = iLeft;
        this.maxX = iRight;
        if (iTickSize) {
            this.setXTicks(this.initPageX, iTickSize);
        }
        this.constrainX = true;
    },
    // @OVERRIDE
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = iUp;
        this.bottomConstraint = iDown;
        this.minY = iUp;
        this.maxY = iDown;
        if (iTickSize) {
            this.setYTicks(this.initPageY, iTickSize);
        }
        this.constrainY = true;
    },
    // These cause exceptions, and are not needed
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    setVisibilityForSourceEvents: function(show) {
        Ext.Array.each(this.dragData.getEventBarElements(), function(el) {
            el[show ? 'show' : 'hide']();
        });
    },
    // private
    onDragOver: function(e) {
        if (e && e.event.touches && e.event.touches.length > 1) {
            // Force a stop if multi touch is detected
            Ext.dd.DragDropManager.handleMouseUp(e);
            return;
        }
        var xy = e ? e.getXY() : this.lastXY;
        // May have a situation where user grabs an event, drags it outside the view - then when back in the view the first thing
        // that happens is a view scroll
        if (!xy)  {
            return;
        }
        
        this.checkShiftChange();
        var dd = this.dragData;
        if (!dd.originalHidden) {
            // Hide dragged event elements at this time
            this.setVisibilityForSourceEvents(false);
            dd.originalHidden = true;
        }
        var start = dd.startDate;
        var resource = dd.newResource;
        var view = this.schedulerView;
        this.updateDragContext(e);
        if (this.showExactDropPosition) {
            var isHorizontal = view.isHorizontal();
            var timeDiff = view.getDateFromCoordinate(isHorizontal ? xy[0] : xy[1]) - dd.sourceDate;
            var realStart = new Date(dd.origStart - 0 + timeDiff);
            var offset = view.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);
            if (dd.startDate > view.timeAxis.getStart()) {
                var proxyEl = this.proxy.el;
                if (offset) {
                    if (view.isHorizontal()) {
                        proxyEl.setX(xy[0] + (this.schedulerView.shouldAdjustForRtl() ? -offset : offset));
                    } else {
                        proxyEl.setY(xy[1] + offset);
                    }
                }
            }
        }
        if (dd.startDate - start !== 0 || resource !== dd.newResource) {
            this.schedulerView.fireEvent('eventdrag', this.schedulerView, dd.draggedRecords, dd.startDate, dd.newResource, dd);
        }
        if (this.showTooltip) {
            this.tip.realign();
            this.tip.update(dd.startDate, dd.endDate, dd.valid, dd.message);
        }
        if (e) {
            this.lastXY = [
                e.browserEvent.clientX + document.body.scrollLeft,
                e.getY()
            ];
        }
    },
    getCoordinate: function(coord) {
        switch (this.schedulerView.getMode()) {
            case 'horizontal':
                return coord[0];
            /* pass through */
            case 'vertical':
                return coord[1];
            /* pass through */
            case 'calendar':
                return coord;
        }
    },
    /* pass through */
    getDragData: function(e) {
        var s = this.schedulerView,
            t = e.getTarget(s.eventSelector);
        if (!t || e.event.touches && e.event.touches.length > 1)  {
            return;
        }
        
        var eventRecord = s.resolveEventRecord(t),
            resourceRecord = s.resolveResource(t),
            assignmentRecord = s.resolveAssignmentRecord(t);
        // there will be no event record when trying to drag the drag creator proxy for example
        if (!eventRecord || eventRecord.isDraggable() === false || s.fireEvent('beforeeventdrag', s, eventRecord, e) === false) {
            return null;
        }
        var xy = e.getXY(),
            eventEl = Ext.get(t),
            eventXY = eventEl.getXY(),
            offsets = [
                xy[0] - eventXY[0],
                xy[1] - eventXY[1]
            ],
            eventRegion = eventEl.getRegion();
        this.lastXY = null;
        var isHorizontal = s.getMode() === 'horizontal';
        s.constrainDragToResource && !resourceRecord && Ext.Error.raise('Resource could not be resolved for event: ' + eventRecord.getId());
        var dateConstraints = s.getDateConstraints(s.constrainDragToResource ? resourceRecord : null, eventRecord);
        this.setupConstraints(s.getScheduleRegion(s.constrainDragToResource ? resourceRecord : null, eventRecord), eventRegion, offsets[0], offsets[1], isHorizontal, s.getSnapPixelAmount(), Boolean(dateConstraints));
        var origStart = eventRecord.getStartDate(),
            origEnd = eventRecord.getEndDate(),
            timeAxis = s.timeAxis,
            relatedRecords = this.getRelatedRecords(assignmentRecord || eventRecord) || [],
            eventBarEls = s.getElementsFromEventRecord(eventRecord, s.isCalendar() ? null : resourceRecord);
        // Collecting additional elements to drag
        Ext.Array.each(relatedRecords, function(r) {
            if (r instanceof Sch.model.Assignment) {
                eventBarEls = eventBarEls.concat(s.getElementsFromEventRecord(r.getEvent(), r.getResource()));
            } else {
                eventBarEls = eventBarEls.concat(s.getElementsFromEventRecord(r));
            }
        });
        eventBarEls = Ext.Array.unique(eventBarEls);
        // I'm not sure if it's required, but this way it seems safer
        var dragData = {
                offsets: offsets,
                repairXY: eventXY,
                prevScroll: s.getScroll(),
                dateConstraints: dateConstraints,
                eventBarEls: eventBarEls,
                // During infinite scroll the scheduling view might be refreshed, due to time axis reconfiguration,
                // thus destroying previously stored DOM elements (and possibly new DOMs rendered),
                // by getting stored event elements via this method we make sure to always get fresh Elements
                // and ignore stale ones.
                getEventBarElements: function() {
                    return dragData.eventBarEls = Ext.Array.map(dragData.eventBarEls, function(el) {
                        return el.dom && el || Ext.get(el.id);
                    });
                },
                draggedRecords: [
                    assignmentRecord || eventRecord
                ].concat(relatedRecords),
                resourceRecord: resourceRecord,
                sourceDate: s.getDateFromCoordinate(this.getCoordinate(xy)),
                origStart: origStart,
                origEnd: origEnd,
                startDate: origStart,
                endDate: origEnd,
                timeDiff: 0,
                startsOutsideView: origStart < timeAxis.getStart(),
                endsOutsideView: origEnd > timeAxis.getEnd(),
                duration: origEnd - origStart,
                bodyScroll: Ext.getBody().getScroll(),
                eventObj: e
            };
        // So we can know if SHIFT/CTRL was pressed
        dragData.ddel = this.getDragElement(eventEl, dragData);
        return dragData;
    },
    onStartDrag: function() {
        var s = this.schedulerView,
            dd = this.dragData;
        // To make sure any elements made visible by hover are not visible when the original element is hidden (using visibility:hidden)
        Ext.Array.each(dd.getEventBarElements(), function(el) {
            el.removeCls('sch-event-hover');
        });
        s.fireEvent('eventdragstart', s, dd.draggedRecords);
        s.getScrollable().on('scroll', this.onViewScroll, this);
    },
    alignElWithMouse: function(el, iPageX, iPageY) {
        this.callParent(arguments);
        // HACK proxy position calculation is off the first drag action in IE with RTL + viewport
        if (Ext.isIE && this.schedulerView.rtl && this.schedulerView.up('[isViewport]')) {
            this.deltaSetXY = null;
            this.callParent(arguments);
        }
        var oCoord = this.getTargetCoord(iPageX, iPageY),
            fly = el.dom ? el : Ext.fly(el, '_dd');
        // original method limits task position by viewport dimensions
        // our drag proxy is located on secondary canvas and can have height larger than viewport
        // so we have to set position relative to bigger secondary canvas
        this.setLocalXY(fly, oCoord.x + this.deltaSetXY[0], oCoord.y + this.deltaSetXY[1]);
    },
    onViewScroll: function(scrollable, left, top) {
        var proxy = this.proxy,
            s = this.schedulerView,
            dd = this.dragData,
            rtlWithoutViewport = s.rtl && !s.up('[isViewport]');
        // Ext JS has different behavior for viewport case vs non-viewport case.
        this.setVisibilityForSourceEvents(false);
        var xy = proxy.getXY();
        // getScroll works different for RTL case: it will return 0 when view is scrolled max to the right
        var newXY;
        if (rtlWithoutViewport) {
            newXY = [
                xy[0] - left + dd.prevScroll.left,
                xy[1] + top - dd.prevScroll.top
            ];
        } else {
            newXY = [
                xy[0] + left - dd.prevScroll.left,
                xy[1] + top - dd.prevScroll.top
            ];
        }
        var deltaSetXY = this.deltaSetXY;
        if (rtlWithoutViewport) {
            this.deltaSetXY = [
                deltaSetXY[0] - left + dd.prevScroll.left,
                deltaSetXY[1] + top - dd.prevScroll.top
            ];
        } else {
            this.deltaSetXY = [
                deltaSetXY[0] + left - dd.prevScroll.left,
                deltaSetXY[1] + top - dd.prevScroll.top
            ];
        }
        dd.prevScroll = {
            left: left,
            top: top
        };
        proxy.setXY(newXY);
        this.onDragOver();
    },
    /**
     * Returns true if the current action is a copy action.
     * @returns {boolean}
     */
    isCopyKeyPressed: function() {
        return Boolean(this.enableCopy && this.dragData.eventObj[this.enableCopyKey.toLowerCase() + 'Key']);
    },
    checkShiftChange: function() {
        var copyKeyPressed = this.isCopyKeyPressed(),
            dd = this.dragData;
        if (copyKeyPressed !== this.copyKeyPressed) {
            this.copyKeyPressed = copyKeyPressed;
            if (copyKeyPressed) {
                dd.refElements.addCls('sch-event-copy');
                this.setVisibilityForSourceEvents(true);
            } else {
                dd.refElements.removeCls('sch-event-copy');
                this.setVisibilityForSourceEvents(false);
            }
        }
    },
    onKey: function(e) {
        if (this.enableCopy && e.getKey() === e[this.enableCopyKey])  {
            this.checkShiftChange();
        }
        
        // Simulate abort on ESC key
        if (e.getKey() === e.ESC) {
            this.dragData.ddCallbackArgs = [
                e.getTarget(),
                e,
                this.id
            ];
            this.finalize(false);
            Ext.dd.DragDropManager.stopDrag(e);
            Ext.dd.DragDropManager.stopEvent(e);
        }
    },
    // HACK, overriding private method, proxy needs to be shown before aligning to it
    startDrag: function() {
        Ext.getDoc().on({
            keydown: this.onKey,
            keyup: this.onKey,
            useCapture: true,
            scope: this
        });
        var retVal = this.callParent(arguments);
        var dragData = this.dragData;
        // This is the representation of the original element inside the proxy
        dragData.refElement = this.proxy.el.down('.' + this.dragDropProxyCls);
        dragData.refElements = this.proxy.el.select('.sch-event');
        // The dragged element should not be in hover state
        dragData.refElement.removeCls('sch-event-hover');
        if (this.showTooltip) {
            this.tip.update(dragData.origStart, dragData.origEnd, true);
            // Seems required as of Ext 4.1.0, to clear the visibility:hidden style.
            this.tip.setStyle('visibility');
            this.tip.show(dragData.refElement, dragData.offsets[0]);
        }
        this.copyKeyPressed = this.isCopyKeyPressed();
        if (this.copyKeyPressed) {
            dragData.refElements.addCls('sch-event-copy');
            dragData.originalHidden = true;
        }
        return retVal;
    },
    endDrag: function() {
        this.schedulerView.getScrollable().un('scroll', this.onViewScroll, this);
        Ext.getDoc().un({
            keydown: this.onKey,
            keyup: this.onKey,
            useCapture: true,
            scope: this
        });
        this.callParent(arguments);
    },
    onMouseUp: function() {
        if (!this.dragging) {
            // Reset drag proxy position on a simple mouse click (which triggers a change in the 'left' position of the proxy el)
            this.afterDragFinalized();
        }
    },
    afterDragFinalized: function() {
        // https://www.assembla.com/spaces/bryntum/tickets/1524#/activity/ticket:
        // If drag is done close to the edge to invoke scrolling, the proxy could be left there and interfere
        // with the view sizing if the columns are shrunk.
        this.proxy.el.dom.style.top = this.proxy.el.dom.style.left = 0;
    },
    updateRecords: function(context) {
        var me = this,
            schedulerView = me.schedulerView,
            eventStore = schedulerView.getEventStore(),
            resourceStore = schedulerView.getResourceStore(),
            assignmentStore = eventStore.getAssignmentStore(),
            newResource = context.newResource,
            draggedRecord = context.draggedRecords[0],
            relatedDraggedRecords = context.draggedRecords.slice(1),
            resourceRecord = context.resourceRecord,
            copyKeyPressed = me.isCopyKeyPressed(),
            startDate = context.startDate,
            timeDiff = context.timeDiff,
            viewMode = schedulerView.getMode();
        // Scheduler multiple assignment mode
        if (assignmentStore && eventStore instanceof Sch.data.EventStore) {
            me.updateRecordsMultipleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, assignmentStore, copyKeyPressed, viewMode);
        }
        // Gantt mode (and task store instead of event store)
        else if (assignmentStore) {
            me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord.getEvent(), Ext.Array.map(relatedDraggedRecords, function(r) {
                return r.getEvent();
            }), resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, viewMode);
        } else // Scheduler single assignment mode
        {
            me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, viewMode);
        }
        // Tell the world there was a successful drop
        schedulerView.fireEvent('eventdrop', schedulerView, context.draggedRecords, copyKeyPressed);
    },
    updateRecordsSingleAssignmentMode: function(startDate, timeDiff, draggedEvent, relatedEvents, fromResource, toResource, eventStore, resourceStore, copy, viewMode) {
        // The code is written to emit as little store events as possible
        var me = this,
            toAdd = [];
        if (copy) {
            draggedEvent = draggedEvent.fullCopy(null);
            toAdd.push(draggedEvent);
        }
        // Process original dragged record
        draggedEvent.beginEdit();
        // in calendar view resources are just time spans, so we have to skip this part
        if (!copy && toResource !== fromResource && fromResource instanceof Sch.model.Resource && toResource instanceof Sch.model.Resource) {
            draggedEvent.reassign(fromResource, toResource);
        } else if (toResource !== fromResource && fromResource instanceof Sch.model.Resource && toResource instanceof Sch.model.Resource) {
            draggedEvent.assign(toResource);
        }
        draggedEvent.setStartDate(startDate, true, eventStore.skipWeekendsDuringDragDrop);
        draggedEvent.endEdit();
        // in calendar view drag&drop doesn't change resource
        if (viewMode !== 'calendar') {
            // Process related records
            var indexDiff = resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource);
            Ext.Array.each(relatedEvents, function(related) {
                // grabbing resources early, since after ".copy()" the record won't belong to any store
                // and ".getResources()" won't work
                var relatedResources = related.getResources();
                if (copy) {
                    related = related.fullCopy(null);
                    toAdd.push(related);
                }
                related.beginEdit();
                // calculate new startDate (and round it) based on timeDiff
                related.setStartDate(me.adjustStartDate(related.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
                indexDiff !== 0 && relatedResources.length && Ext.Array.each(relatedResources, function(r) {
                    var newIndex = resourceStore.indexOf(r) - indexDiff,
                        newResource;
                    if (newIndex < 0) {
                        newIndex = 0;
                    } else if (newIndex >= resourceStore.getCount()) {
                        newIndex = resourceStore.getCount() - 1;
                    }
                    newResource = resourceStore.getAt(newIndex);
                    related.reassign(r, newResource);
                });
                related.endEdit();
            });
        }
        if (toAdd.length) {
            eventStore.append(toAdd);
        }
    },
    updateRecordsMultipleAssignmentMode: function(startDate, timeDiff, draggedAssignment, relatedAssignments, fromResource, toResource, eventStore, resourceStore, assignmentStore, copy, viewMode) {
        var me = this;
        Ext.Array.each([].concat(draggedAssignment, relatedAssignments), function(assignment) {
            var event = assignment.getEvent();
            event.setStartDate(me.adjustStartDate(event.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
            // if we dragged the event to a different resource
            if (viewMode != 'calendar' && fromResource !== toResource) {
                if (copy) {
                    event.assign(toResource);
                } else if (!event.isAssignedTo(toResource)) {
                    event.reassign(assignment.getResource(), toResource);
                } else {
                    event.unassign(assignment.getResource());
                }
            }
        });
    },
    isValidDrop: function(oldResource, newResource, sourceRecord) {
        // Not allowed to assign an event twice to the same resource -
        // which might happen when we deal with an assignment store
        if (oldResource !== newResource) {
            // if we operate assignments
            if (sourceRecord instanceof Sch.model.Assignment) {
                return !sourceRecord.getEvent().isAssignedTo(newResource);
            } else {
                return !sourceRecord.isAssignedTo(newResource);
            }
        }
        return true;
    },
    resolveResource: function(xy) {
        var proxyDom = this.proxy.el.dom;
        var bodyScroll = this.dragData.bodyScroll;
        proxyDom.style.display = 'none';
        var node = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
        // IE8 likes it twice, for simulated events..
        if (Ext.isIE8 && window.top.Siesta) {
            node = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
        }
        proxyDom.style.display = 'block';
        if (!node) {
            return null;
        }
        var view = this.schedulerView;
        // If we hover a table row border we will match a row element here.
        // We then need to adjust the Y-pos to get a cell which gives us the correct cell index.
        if (node.className.match(Ext.baseCSSPrefix + 'grid-item')) {
            return this.resolveResource([
                xy[0],
                xy[1] + 3
            ]);
        }
        if (!node.className.match(view.timeCellCls)) {
            var parent = Ext.fly(node).up('.' + view.timeCellCls);
            if (parent) {
                node = parent.dom;
            } else {
                return null;
            }
        }
        return view.resolveResource(node);
    },
    adjustStartDate: function(startDate, timeDiff) {
        var s = this.schedulerView;
        return s.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), s.snapRelativeToEventStartDate ? startDate : false);
    },
    // private
    updateDragContext: function(e) {
        var dd = this.dragData,
            xy = e ? e.getXY() : this.lastXY,
            // Ext JS might convert e.getXY() coordinates to be calculated from right side if Scheduler is in a viewport
            // So for resource lookup we always use the raw browser XY since we rely on document.elementFromPoint
            rawXY = e ? [
                e.browserEvent.clientX + document.body.scrollLeft,
                e.getY()
            ] : this.lastXY;
        if (!dd.refElement) {
            return;
        }
        var s = this.schedulerView,
            proxyRegion = dd.refElement.getRegion();
        if (s.timeAxis.isContinuous()) {
            if ((s.isHorizontal() && this.minX < xy[0] && xy[0] < this.maxX) || (!s.isHorizontal() && this.minY < xy[1] && xy[1] < this.maxY)) {
                var newDate = s.getDateFromCoordinate(this.getCoordinate(xy));
                dd.timeDiff = newDate - dd.sourceDate;
                // calculate and round new startDate based on actual dd.timeDiff
                dd.startDate = this.adjustStartDate(dd.origStart, dd.timeDiff);
                dd.endDate = new Date(dd.startDate - 0 + dd.duration);
            }
        } else {
            var range = this.resolveStartEndDates(proxyRegion);
            dd.startDate = range.startDate;
            dd.endDate = range.endDate;
            dd.timeDiff = dd.startDate - dd.origStart;
        }
        dd.newResource = s.constrainDragToResource ? dd.resourceRecord : (this.resolveResource(rawXY) || dd.newResource || dd.resourceRecord);
        if (dd.newResource) {
            var result = !e || this.validatorFn.call(this.validatorFnScope || this, dd.draggedRecords, dd.newResource, dd.startDate, dd.duration, e);
            if (!result || typeof result === 'boolean') {
                dd.valid = result !== false;
                dd.message = '';
            } else {
                dd.valid = result.valid !== false;
                dd.message = result.message;
            }
        } else {
            dd.valid = false;
        }
    },
    /**
     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
     * @param {Ext.data.Model} eventRecord The eventRecord about to be dragged
     * @return {[Ext.data.Model]} An array of event records to drag together with the original event
     */
    getRelatedRecords: function(eventRecord) {
        var view = this.schedulerView,
            sm = view.getEventSelectionModel(),
            result = sm.getDraggableSelections();
        return Ext.Array.filter(result, function(selectedRecord) {
            return eventRecord !== selectedRecord;
        });
    },
    /**
     * This function should return a DOM node representing the markup to be dragged. By default it just returns the selected element(s) that are to be dragged.
     * If dragging multiple events, the clone of the original item should be assigned the special CSS class {@link #dragDropProxyCls}
     * @param {Ext.Element} sourceEl The event element that is the source drag element
     * @param {Object} dragData The drag drop context object
     * @return {HTMLElement} The DOM node to drag
     */
    getDragElement: function(sourceEl, dragData) {
        var eventBarEls = dragData.getEventBarElements();
        var copy;
        var retVal;
        var offsetX = dragData.offsets[0];
        var offsetY = dragData.offsets[1];
        var side = this.schedulerView.getHorizontalPositionSide();
        if (eventBarEls.length > 1) {
            var ctEl = Ext.core.DomHelper.createDom({
                    tag: 'div',
                    cls: 'sch-dd-wrap',
                    style: {
                        overflow: 'visible'
                    }
                });
            Ext.Array.each(eventBarEls, function(el) {
                copy = el.dom.cloneNode(true);
                copy.id = Ext.id();
                if (el.dom === sourceEl.dom) {
                    // Using Ext fly here seems buggy in Ext 5.0.1
                    copy.className += ' ' + this.dragDropProxyCls;
                    // removing this will fail 012_dragdrop tests in IE8
                    if (Ext.isIE8) {
                        Ext.fly(copy).addCls(this.dragDropProxyCls);
                    }
                }
                ctEl.appendChild(copy);
                var elOffsets = el.getOffsetsTo(sourceEl);
                // Adjust each element offset to the source event element
                copy.style[side] = -elOffsets[0] + 'px';
                copy.style.top = -elOffsets[1] + 'px';
            }, this);
            retVal = ctEl;
        } else {
            copy = sourceEl.dom.cloneNode(true);
            copy.id = Ext.id();
            // Special handling for RTL mode
            copy.style.left = (!this.schedulerView.rtl || this.schedulerView.shouldAdjustForRtl() ? -offsetX : (offsetX - sourceEl.getWidth())) + 'px';
            copy.style.top = -offsetY + 'px';
            // Using Ext fly here seems buggy in Ext 5.0.1
            // removing this will fail 061_dragdrop_sanity test in IE8
            copy.className += ' ' + this.dragDropProxyCls;
            // removing this will fail 012_dragdrop tests in IE8
            if (Ext.isIE8) {
                Ext.fly(copy).addCls(this.dragDropProxyCls);
            }
            retVal = copy;
        }
        // TODO: fix this, it's written as if we will always have 1 element being dragged.
        // If event rendering is not using px values (could be overridden to % values in CSS) we need to
        // put a height in place for the proxy element to look correctly
        if (!sourceEl.dom.style.height) {
            Ext.fly(retVal).setHeight(sourceEl.getHeight());
        }
        return retVal;
    },
    onDragDrop: function(e, id) {
        this.updateDragContext(e);
        var me = this,
            s = me.schedulerView,
            target = me.cachedTarget || Ext.dd.DragDropMgr.getDDById(id),
            dragData = me.dragData,
            modified = false,
            doFinalize = true;
        if (me.tip) {
            me.tip.hide();
        }
        // Used later in finalizeDrop
        dragData.ddCallbackArgs = [
            target,
            e,
            id
        ];
        if (dragData.valid && dragData.startDate && dragData.endDate) {
            dragData.finalize = function() {
                me.finalize.apply(me, arguments);
            };
            // Allow implementer to take control of the flow, by returning false from this listener,
            // to show a confirmation popup etc.
            doFinalize = s.fireEvent('beforeeventdropfinalize', me, dragData, e) !== false;
            // Internal validation, making sure all dragged records fit inside the view
            if (doFinalize && me.isValidDrop(dragData.resourceRecord, dragData.newResource, dragData.draggedRecords[0])) {
                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;
            }
        }
        if (doFinalize) {
            me.finalize(dragData.valid && modified);
        } else {
            // In case Ext JS sets a very high Z-index, lower it temporarily so it doesn't interfere with popups etc
            me.proxy.el.addCls('sch-before-drag-finalized');
        }
    },
    finalize: function(updateRecords) {
        var me = this,
            view = me.schedulerView,
            eventStore = view.getEventStore(),
            dragData = me.dragData;
        me.proxy.el.removeCls('sch-before-drag-finalized');
        if (updateRecords) {
            // Catch one more edge case, if a taskStore with calendars is used - there is a possible scenario where the UI isn't
            // repainted. In gantt+scheduler demo, move an event in the scheduler a few px and it disappears since Calendar adjusts its start date and scheduler is unaware of this.
            var updated,
                checkerFn = function() {
                    updated = true;
                };
            eventStore.on('update', checkerFn, null, {
                single: true
            });
            me.updateRecords(dragData);
            eventStore.un('update', checkerFn, null, {
                single: true
            });
            if (!updated) {
                me.onInvalidDrop.apply(me, dragData.ddCallbackArgs);
            } else {
                // For our good friend IE9, the pointer cursor gets stuck without the defer
                if (Ext.isIE9) {
                    me.proxy.el.setStyle('visibility', 'hidden');
                    me._onValidDropTimer = Ext.Function.defer(me.onValidDrop, 10, me, dragData.ddCallbackArgs);
                } else {
                    me.onValidDrop.apply(me, dragData.ddCallbackArgs);
                }
                view.fireEvent('aftereventdrop', view, dragData.draggedRecords);
            }
            me.afterDragFinalized();
        } else {
            me.onInvalidDrop.apply(me, dragData.ddCallbackArgs);
        }
    },
    // HACK: Override for IE, if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // https://www.assembla.com/spaces/bryntum/tickets/716
    onInvalidDrop: function(target, e, id) {
        if (!e) {
            e = target;
            target = e.getTarget() || document.body;
        }
        if (this.tip) {
            this.tip.hide();
        }
        this.setVisibilityForSourceEvents(true);
        var s = this.schedulerView,
            retVal = this.callParent([
                target,
                e,
                id
            ]);
        s.fireEvent('aftereventdrop', s, this.dragData.draggedRecords);
        this.afterDragFinalized();
        return retVal;
    },
    resolveStartEndDates: function(proxyRegion) {
        var dd = this.dragData,
            startEnd,
            start = dd.origStart,
            end = dd.origEnd;
        var DATE = Sch.util.Date;
        if (!dd.startsOutsideView) {
            startEnd = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            if (startEnd) {
                start = startEnd.start || dd.startDate;
                end = DATE.add(start, DATE.MILLI, dd.duration);
            }
        } else if (!dd.endsOutsideView) {
            startEnd = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            if (startEnd) {
                end = startEnd.end || dd.endDate;
                start = DATE.add(end, DATE.MILLI, -dd.duration);
            }
        }
        return {
            startDate: start,
            endDate: end
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.feature.DragDrop
 * @private
 * Internal class enabling drag and drop for event nodes and creating drag proxy (classic or simplified).
 * Type of proxy can be configured with {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig property.
 */
Ext.define("Sch.feature.DragDrop", {
    requires: [
        'Ext.XTemplate',
        'Sch.feature.SchedulerDragZone'
    ],
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made.
     * Return true if the new position is valid, false to prevent the drag.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean}
     */
    validatorFn: function(dragRecords, targetResourceRecord, date, duration, e) {
        return true;
    },
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    /**
     * @cfg {Object} dragConfig
     *
     * The config object which will be passed to the `Sch.feature.SchedulerDragZone` instance
     */
    dragConfig: null,
    /**
     * @constructor
     * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor: function(schedulerView, config) {
        Ext.apply(this, config);
        this.schedulerView = schedulerView;
        // The drag zone behaviour, can't attach to the view el (crash in IE), using panel el instead.
        schedulerView.eventDragZone = new Sch.feature.SchedulerDragZone(schedulerView.ownerCt.el, Ext.apply({
            ddGroup: schedulerView.id,
            schedulerView: schedulerView,
            validatorFn: this.validatorFn,
            validatorFnScope: this.validatorFnScope
        }, this.dragConfig));
        this.schedulerView.on("destroy", this.cleanUp, this);
        this.callParent([
            config
        ]);
    },
    cleanUp: function() {
        var schedulerView = this.schedulerView;
        if (schedulerView.eventDragZone) {
            schedulerView.eventDragZone.destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.feature.ResizeZone
 * @extends Ext.util.Observable
 * @private
 * Internal classing enabling resizing of rendered events
 * @constructor
 * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
 * @param {Object} config The object containing the configuration of this model.
 */
Ext.define("Sch.feature.ResizeZone", {
    extend: "Ext.util.Observable",
    requires: [
        'Ext.resizer.Resizer',
        'Sch.tooltip.Tooltip',
        'Sch.util.ScrollManager'
    ],
    /**
      * @cfg {Boolean} showTooltip `false` to not show a tooltip while resizing
      */
    showTooltip: true,
    /**
     * @type {Boolean} showExactResizePosition true to see exact event length during resizing
     */
    showExactResizePosition: false,
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being resized. Return true if the new duration is valid, false to signal that it is not.
     * @param {Sch.model.Resource} resourceRecord the resource to which the event belongs
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.event.Event} e The event object
     * @return {Boolean}
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    schedulerView: null,
    origEl: null,
    handlePos: null,
    eventRec: null,
    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while resizing an event or a configuration object for the {@link Sch.tooltip.Tooltip}.
     */
    tip: null,
    // cached reference to the created tooltip instance
    tipInstance: null,
    startScroll: null,
    constructor: function(config) {
        Ext.apply(this, config);
        var s = this.schedulerView;
        s.on({
            destroy: this.cleanUp,
            scope: this
        });
        s.el.on({
            mousedown: this.onMouseDown,
            mouseup: this.onMouseUp,
            scope: this,
            delegate: '.sch-resizable-handle'
        });
        this.bindRightClickPreventer();
        this.callParent(arguments);
    },
    bindRightClickPreventer: function() {
        var eventName;
        if (Ext.isIE9m) {
            eventName = 'mousedown';
        } else {
            eventName = 'contextmenu';
        }
        var listener = {
                scope: this,
                priority: 999
            };
        listener[eventName] = this.preventRightClick;
        this.schedulerView.el.on(listener);
    },
    // Prevent right clicks while resizing an event
    preventRightClick: function(e) {
        if (e.button !== 0 && this.resizer) {
            e.stopEvent();
            return false;
        }
    },
    onMouseDown: function(e, t) {
        var s = this.schedulerView;
        var eventRec = this.eventRec = s.resolveEventRecord(t);
        var isResizable = eventRec.isResizable();
        if (e.button !== 0 || (isResizable === false || typeof isResizable === 'string' && !t.className.match(isResizable))) {
            return;
        }
        this.eventRec = eventRec;
        this.handlePos = this.getHandlePosition(t);
        this.origEl = Ext.get(e.getTarget('.sch-event'));
        s.el.on({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        });
    },
    onMouseUp: function(e, t) {
        var s = this.schedulerView;
        s.el.un({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        });
    },
    getTipInstance: function() {
        if (this.tipInstance)  {
            return this.tipInstance;
        }
        
        var s = this.schedulerView;
        var tip = this.tip;
        var containerEl = s.up('[lockable=true]').el;
        if (tip instanceof Ext.tip.ToolTip) {
            tip.schedulerView = s;
        } else {
            tip = new Sch.tooltip.Tooltip(Ext.apply({
                rtl: this.rtl,
                schedulerView: s,
                constrainTo: containerEl,
                cls: 'sch-resize-tip'
            }, tip));
        }
        return this.tipInstance = tip;
    },
    onMouseMove: function(e, t) {
        var s = this.schedulerView,
            eventRec = this.eventRec,
            handlePos = this.handlePos;
        if (!eventRec || s.fireEvent('beforeeventresize', s, eventRec, e) === false) {
            return;
        }
        delete this.eventRec;
        e.stopEvent();
        this.origEl.addCls('sch-event-resizing');
        this.resizer = this.createResizer(this.origEl, eventRec, handlePos);
        var tracker = this.resizer.resizeTracker;
        if (this.showTooltip) {
            var tip = this.getTipInstance();
            // update requires target that was removed after previous resize
            tip.setTarget(this.origEl);
            tip.update(eventRec.getStartDate(), eventRec.getEndDate(), true);
            tip.show(this.origEl, e.getX() - this.origEl.getX());
        }
        // HACK, fake the start of the resizing right away
        tracker.onMouseDown(e, this.resizer[handlePos].dom);
        tracker.onMouseMove(e, this.resizer[handlePos].dom);
        s.fireEvent('eventresizestart', s, eventRec);
        // Handle inifinite scroll case
        s.getScrollable().on('scroll', this.onViewScroll, this);
    },
    getHandlePosition: function(node) {
        var isStart = node.className.match('start');
        if (this.schedulerView.getMode() === 'horizontal') {
            if (this.schedulerView.rtl) {
                return isStart ? 'east' : 'west';
            }
            return isStart ? 'west' : 'east';
        } else {
            return isStart ? 'north' : 'south';
        }
    },
    // private
    createResizer: function(eventEl, eventRecord, handlePos) {
        var s = this.schedulerView,
            me = this,
            resourceRecord = s.resolveResource(eventEl),
            increment = s.getSnapPixelAmount(),
            constrainRegion = s.getScheduleRegion(resourceRecord, eventRecord),
            dateConstraints = s.getDateConstraints(resourceRecord, eventRecord),
            height = eventEl.getHeight(),
            isStart = (s.rtl && handlePos[0] === 'e') || (!s.rtl && handlePos[0] === 'w') || handlePos[0] === 'n',
            isVertical = s.getMode() !== 'horizontal',
            resizerCfg = {
                otherEdgeX: isStart ? eventEl.getRight() : eventEl.getLeft(),
                otherEdgeY: isStart ? eventEl.getBottom() : eventEl.getTop(),
                target: eventEl,
                isStart: isStart,
                // calculate event's position relative to cell
                startYOffset: eventEl.getY() - eventEl.parent().getY(),
                startXOffset: eventEl.getX() - eventEl.parent().getX(),
                dateConstraints: dateConstraints,
                resourceRecord: resourceRecord,
                eventRecord: eventRecord,
                handles: handlePos[0],
                minHeight: height,
                constrainTo: constrainRegion,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            };
        // Apply orientation specific configs
        if (isVertical) {
            if (increment > 0) {
                var w = eventEl.getWidth();
                Ext.apply(resizerCfg, {
                    minHeight: increment,
                    // To avoid SHIFT causing a ratio preserve
                    minWidth: w,
                    maxWidth: w,
                    heightIncrement: increment
                });
            }
        } else {
            if (increment > 0) {
                Ext.apply(resizerCfg, {
                    minWidth: increment,
                    // To avoid SHIFT causing a ratio preserve
                    maxHeight: height,
                    widthIncrement: increment
                });
            }
        }
        var resizer = new Ext.resizer.Resizer(resizerCfg);
        if (resizer.resizeTracker) {
            // Force tracker to start tracking even with just 1px movement, defaults to 3.
            resizer.resizeTracker.tolerance = -1;
            // Ignore resizing action if dragging outside the scheduler
            // Fixes WebKit issue https://www.assembla.com/spaces/bryntum/tickets/994#/activity/ticket:
            var old = resizer.resizeTracker.updateDimensions;
            resizer.resizeTracker.updateDimensions = function(e) {
                if (!Ext.isWebKit || !e.getTarget || e.getTarget('.sch-timelineview')) {
                    var scrollDelta;
                    // minWidth needs to be adjusted to take a new scroll position into account
                    if (isVertical) {
                        scrollDelta = s.getScrollY() - me.startScroll.top;
                        resizer.resizeTracker.minHeight = resizerCfg.minHeight - Math.abs(scrollDelta);
                    } else {
                        scrollDelta = s.getScrollX() - me.startScroll.left;
                        resizer.resizeTracker.minWidth = resizerCfg.minWidth - Math.abs(scrollDelta);
                    }
                    old.apply(this, arguments);
                }
            };
            // Patched to handle changes in containing scheduler view el scroll position
            resizer.resizeTracker.resize = function(box) {
                var scrollDelta;
                if (isVertical) {
                    scrollDelta = s.getScrollY() - me.startScroll.top;
                    if (handlePos[0] === 's') {
                        box.y -= scrollDelta;
                    }
                    box.height += Math.abs(scrollDelta);
                } else {
                    scrollDelta = s.getScrollX() - me.startScroll.left;
                    if (handlePos[0] === 'e') {
                        box.x -= scrollDelta;
                    }
                    box.width += Math.abs(scrollDelta);
                }
                Ext.resizer.ResizeTracker.prototype.resize.apply(this, arguments);
            };
        }
        // Make sure the resizing event is on top of other events
        eventEl.setStyle('z-index', parseInt(eventEl.getStyle('z-index'), 10) + 1);
        Sch.util.ScrollManager.activate(s, s.getMode() === 'horizontal' ? 'horizontal' : 'vertical');
        this.startScroll = s.getScroll();
        return resizer;
    },
    getStartEndDates: function() {
        var r = this.resizer,
            rEl = r.el,
            schedulerView = this.schedulerView,
            isStart = r.isStart,
            start, end, x, xy;
        if (isStart) {
            if (schedulerView.getMode() === 'horizontal') {
                x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getRight() : rEl.getLeft() + 1;
                xy = [
                    x,
                    0
                ];
            } else {
                xy = [
                    (rEl.getRight() + rEl.getLeft()) / 2,
                    rEl.getTop()
                ];
            }
            end = r.eventRecord.getEndDate();
            if (schedulerView.snapRelativeToEventStartDate) {
                start = schedulerView.getDateFromXY(xy);
                start = schedulerView.timeAxis.roundDate(start, r.eventRecord.getStartDate());
            } else {
                start = schedulerView.getDateFromXY(xy, 'round');
            }
        } else {
            if (schedulerView.getMode() === 'horizontal') {
                x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getLeft() : rEl.getRight();
                xy = [
                    x,
                    0
                ];
            } else {
                xy = [
                    (rEl.getRight() + rEl.getLeft()) / 2,
                    rEl.getBottom()
                ];
            }
            start = r.eventRecord.getStartDate();
            if (schedulerView.snapRelativeToEventStartDate) {
                end = schedulerView.getDateFromXY(xy);
                end = schedulerView.timeAxis.roundDate(end, r.eventRecord.getEndDate());
            } else {
                end = schedulerView.getDateFromXY(xy, 'round');
            }
        }
        start = start || r.start;
        end = end || r.end;
        if (r.dateConstraints) {
            start = Sch.util.Date.constrain(start, r.dateConstraints.start, r.dateConstraints.end);
            end = Sch.util.Date.constrain(end, r.dateConstraints.start, r.dateConstraints.end);
        }
        return {
            start: start,
            end: end
        };
    },
    // private
    partialResize: function(r, width, height, e) {
        var s = this.schedulerView,
            xy = e ? e.getXY() : this.resizer.resizeTracker.lastXY,
            startEndDates = this.getStartEndDates(xy),
            start = startEndDates.start,
            end = startEndDates.end,
            record = r.eventRecord,
            isHorizontal = s.isHorizontal();
        if (isHorizontal) {
            r.target.el.setY(r.target.parent().getY() + r.startYOffset);
        } else {
            r.target.el.setX(r.target.parent().getX() + r.startXOffset);
        }
        if (this.showTooltip) {
            var valid = this.validatorFn.call(this.validatorFnScope || this, r.resourceRecord, record, start, end);
            var message = '';
            // Implementer could also return an object { valid : false, message : 'foo' }
            if (valid && typeof valid !== 'boolean') {
                message = valid.message;
                valid = valid.valid;
            }
            this.getTipInstance().update(start, end, valid !== false, message);
        }
        if (this.showExactResizePosition) {
            var target = r.target.el,
                exactWidth, cursorDate, offset;
            if (r.isStart) {
                if (s.isCalendar()) {
                    var column = s.calendar.getEventColumns(record)[0];
                    exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, column.end);
                } else {
                    exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, record.getEndDate());
                }
                if (isHorizontal) {
                    cursorDate = s.getDateFromCoordinate(r.otherEdgeX - Math.min(width, r.maxWidth)) || start;
                    offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    target.setWidth(exactWidth);
                    target.setX(target.getX() + offset);
                } else {
                    cursorDate = s.getDateFromCoordinate(r.otherEdgeY - Math.min(width, r.maxHeight)) || start;
                    offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    target.setHeight(exactWidth);
                    target.setY(target.getY() + offset);
                }
            } else {
                exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(record.getStartDate(), end);
                if (isHorizontal) {
                    target.setWidth(exactWidth);
                } else {
                    target.setHeight(exactWidth);
                }
            }
        } else {
            if (!start || !end || ((r.start - start === 0) && (r.end - end === 0))) {
                return;
            }
        }
        r.end = end;
        r.start = start;
        s.fireEvent('eventpartialresize', s, record, start, end, r.el);
    },
    onViewScroll: function(e, t) {
        this.resizer.resizeTracker.onDrag({});
        this.partialResize(this.resizer, 0, 0);
    },
    // private
    afterResize: function(r, w, h, e) {
        var me = this,
            resourceRecord = r.resourceRecord,
            eventRecord = r.eventRecord,
            oldStart = eventRecord.getStartDate(),
            oldEnd = eventRecord.getEndDate(),
            start = r.start || oldStart,
            end = r.end || oldEnd,
            sv = me.schedulerView,
            modified = false,
            doFinalize = true,
            valid = me.validatorFn.call(me.validatorFnScope || me, resourceRecord, eventRecord, start, end, e);
        Sch.util.ScrollManager.deactivate();
        sv.getScrollable().un('scroll', this.onViewScroll, this);
        if (this.showTooltip) {
            this.getTipInstance().hide();
        }
        sv.el.select('[id^=calendar-resizer-placeholder]').remove();
        me.resizeContext = {
            resourceRecord: r.resourceRecord,
            eventRecord: eventRecord,
            start: start,
            end: end,
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        // Implementer could also return an object { valid : false, message : 'foo' }
        if (valid && typeof valid !== 'boolean') {
            valid = valid.valid;
        }
        if (start && end && (end - start > 0) && // Input sanity check
        ((start - oldStart !== 0) || (end - oldEnd !== 0)) && // Make sure start OR end changed
        valid !== false) {
            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,
            // to show a confirm dialog prior to applying the new values.
            doFinalize = sv.fireEvent('beforeeventresizefinalize', me, me.resizeContext, e) !== false;
            modified = true;
        } else {
            sv.repaintEventsForResource(resourceRecord);
        }
        if (doFinalize) {
            me.finalize(modified);
        }
    },
    finalize: function(updateRecord) {
        var sv = this.schedulerView;
        var context = this.resizeContext;
        var wasChanged = false;
        var checker = function() {
                wasChanged = true;
            };
        sv.getEventStore().on('update', checker);
        // Without manually destroying the target, Ext Element cache gets confused
        this.resizer.target.destroy();
        // #2436 - Keymap do not capture events after event resize in IE
        // In chrome after resize focus goes to document body, in IE it doesn't
        if (Ext.isIE) {
            document.body.focus();
        }
        if (updateRecord) {
            if (this.resizer.isStart) {
                context.eventRecord.setStartDate(context.start, false, sv.getEventStore().skipWeekendsDuringDragDrop);
            } else {
                context.eventRecord.setEndDate(context.end, false, sv.getEventStore().skipWeekendsDuringDragDrop);
            }
            if (!wasChanged)  {
                sv.repaintEventsForResource(context.resourceRecord);
            }
            
        } else {
            sv.repaintEventsForResource(context.resourceRecord);
        }
        // Destroy resizer
        this.resizer.destroy();
        delete this.resizer;
        sv.getEventStore().un('update', checker);
        sv.fireEvent('eventresizeend', sv, context.eventRecord);
        this.resizeContext = null;
    },
    cleanUp: function() {
        if (this.tipInstance) {
            this.tipInstance.destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
@class Sch.column.Resource
@extends Ext.grid.Column
@private

A Column representing a resource, used only in vertical orientation. By default this column will use the resource
name as the header text. To get complete control over the rendering, you can use your own custom Column class by
using the {@link Sch.mixin.SchedulerPanel#resourceColumnClass resourceColumnClass} config on your SchedulerPanel.

*/
Ext.define("Sch.column.Resource", {
    extend: "Ext.grid.Column",
    alias: "widget.resourcecolumn",
    /*
     * Default resource column properties
     */
    align: 'center',
    menuDisabled: true,
    hideable: false,
    sortable: false,
    locked: false,
    lockable: false,
    draggable: false,
    enableLocking: false,
    /*
     * @property {Sch.model.Resource} model The resource model associated with this column
     * Default resource column properties
     */
    model: null,
    initComponent: function() {
        this.tdCls = (this.tdCls || '') + ' sch-timetd';
        this.cls = (this.cls || '') + ' sch-resourcecolumn-header';
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Sch.column.Day
 * @private
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in weekview mode
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.Day', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.weekview-day',
    align: 'center',
    // date range for this Day column
    start: null,
    end: null,
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    menuDisabled: true,
    enableLocking: false,
    flex: 1,
    resizable: false,
    tdCls: 'sch-timetd',
    initComponent: function() {
        var now = new Date();
        this.addCls('sch-daycolumn-header');
        if (this.isWeekend()) {
            this.addCls('sch-daycolumn-header-weekend');
            this.tdCls = (this.tdCls || '') + ' sch-daycolumn-weekend';
        }
        if (this.start.getDate() === now.getDate() && this.start.getMonth() === now.getMonth() && this.start.getYear() === now.getYear()) {
            this.addCls('sch-daycolumn-header-today');
            this.tdCls = (this.tdCls || '') + ' sch-daycolumn-today';
        }
        this.callParent(arguments);
    },
    isWeekend: function() {
        var day = this.start.getDay();
        return day === 6 || day === 0;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.view.Calendar

 A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation of some methods, specific to calendar mode.

 */
Ext.define("Sch.view.Calendar", {
    requires: [
        'Ext.util.Region'
    ],
    // Provided by creator, in the config object
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    // return columns that passes condition
    // if includeIndex is true then column index is also returned
    getColumnsBy: function(conditionFn, includeIndex) {
        var columns = this.view.panel.headerCt.getGridColumns();
        var result = [];
        for (var i = 0; i < columns.length; i++) {
            if (conditionFn.call(this, columns[i])) {
                if (includeIndex !== true) {
                    result.push(columns[i]);
                } else {
                    result.push({
                        column: columns[i],
                        index: i
                    });
                }
            }
        }
        return result;
    },
    getColumnsForDateRange: function(range, includeIndex) {
        return this.getColumnsBy(function(column) {
            return !(range.getEndDate() <= column.start || range.getStartDate() >= column.end);
        }, includeIndex);
    },
    getColumnEvents: function(column) {
        var result = [];
        this.view.getEventStore().each(function(record) {
            if (!(record.getEndDate() <= column.start || record.getStartDate() >= column.end)) {
                result.push(record);
            }
        });
        return result;
    },
    getColumnsByResource: function(resource, includeIndex) {
        return this.getColumnsBy(function(column) {
            return column.start == resource.start;
        }, includeIndex)[0];
    },
    translateToScheduleCoordinate: function(coord) {
        var view = this.view;
        if (Ext.isArray(coord)) {
            return [
                coord[0] - view.getEl().getX() + view.getScroll().left,
                coord[1] - view.getEl().getY() + view.getScroll().top
            ];
        } else {
            return coord - view.getEl().getY() + view.getScroll().top;
        }
    },
    // private
    translateToPageCoordinate: function(coord) {
        var view = this.view;
        var el = view.getEl(),
            scroll = view.getScroll();
        if (Ext.isArray(coord)) {
            return [
                coord[0] + el.getX() - scroll.left,
                coord[1] + el.getY() - scroll.top
            ];
        } else {
            return coord + el.getY() - scroll.top;
        }
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy;
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event, resource, resourceIndex) {
        var eventStart = event.getStartDate(),
            eventEnd = event.getEndDate(),
            view = this.view,
            columns = view.panel.headerCt.getGridColumns(),
            viewStart = columns[resourceIndex].start,
            viewEnd = columns[resourceIndex].end,
            M = Math;
        var startY = Math.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)));
        var endY = Math.floor(view.timeAxisViewModel.getPositionFromDate(Sch.util.Date.min(eventEnd, viewEnd), true));
        var data;
        // in calendar view we duplicate time for end of column and start of next column
        // if we got 0 that means end is in fact column bottom
        if (endY === 0) {
            endY = view.getStore().getCount() * view.getRowHeight();
        }
        data = {
            top: M.max(0, M.min(startY, endY) - view.eventBorderWidth),
            height: M.max(1, M.abs(startY - endY))
        };
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    // we consider resourceRecord to be date
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region = resourceRecord ? this.getColumnsByResource(resourceRecord).getRegion() : view.getTableRegion(),
            startY = this.translateToPageCoordinate(0),
            endY = this.translateToPageCoordinate(view.getStore().getCount() * view.getRowHeight()),
            left = region.left + view.barMargin,
            right = region.right - view.barMargin;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    getCalendarColumnWidth: function() {
        return this.view.timeAxisViewModel.calendarColumnWidth;
    },
    /**
     * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
     * @param {Sch.model.Resource} resourceRecord The resource record
     * @param {Date} startDate A start date constraining the region
     * @param {Date} endDate An end date constraining the region
     * @return {Ext.util.Region} The region of the resource
     */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getCalendarColumnWidth(),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left = cellLeft + view.cellBorderWidth,
            right = cellLeft + this.getCalendarColumnWidth() - view.cellBorderWidth;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';
        if (rowIndex === 0) {
            var columnEvents, resourceEvents, i, l;
            columnEvents = [];
            resourceEvents = this.getColumnEvents(meta.column);
            // Iterate events (belonging to current resource)
            for (i = 0 , l = resourceEvents.length; i < l; i++) {
                var event = resourceEvents[i];
                // resourceRecord is a timeAxis tick, we should try to get real resource
                columnEvents.push(view.generateTplData(event, event.getResources()[0] || resourceRecord, colIndex));
            }
            if (meta.column.rendered && this.getCalendarColumnWidth() !== meta.column.getWidth()) {
                this.setColumnWidth(meta.column.getWidth(), true);
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getCalendarColumnWidth() - (2 * view.barMargin) - view.cellBorderWidth);
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }
        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }
        return retVal;
    },
    // private
    resolveResource: function(el) {
        var view = this.view;
        el = Ext.fly(el).is(view.timeCellSelector) ? el : Ext.fly(el).up(view.timeCellSelector);
        if (el) {
            var node = el.dom ? el.dom : el;
            var index = 0;
            if (Ext.isIE8m) {
                node = node.previousSibling;
                while (node) {
                    if (node.nodeType === 1) {
                        index++;
                    }
                    node = node.previousSibling;
                }
            } else {
                index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
            }
            if (index >= 0) {
                // TODO: unsafe
                var column = view.panel.headerCt.getGridColumns()[index];
                return {
                    start: column.start,
                    end: column.end
                };
            }
        }
    },
    // private
    onEventUpdate: function(store, model) {
        this.renderSingle(model);
        // restore visual event selection
        var view = this.view;
        var sm = view.getEventSelectionModel();
        sm.forEachEventRelatedSelection(model, function(selectedRecord) {
            view.onEventBarSelect(selectedRecord);
        });
    },
    // private
    onEventAdd: function(s, recs) {
        var view = this.view;
        if (recs.length === 1) {
            this.renderSingle(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },
    // private
    onEventRemove: function(s, recs) {
        var view = this.view;
        if (recs.length === 1) {
            // remove nodes from view
            Ext.Array.each(view.getElementsFromEventRecord(recs[0]), function(el) {
                Ext.fly(el).destroy();
            });
            this.relayoutRenderedEvents(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },
    relayoutRenderedEvents: function(targetEvent) {
        var me = this,
            columns = me.getColumnsForDateRange(targetEvent, true);
        // When event is rendered into multiple columns each part should behave like separate event.
        // For example, event is rendered into two columns. User created new event and dropped it so
        // new one is overlapping with old one in second column. Desired behavior is following:
        // part in the first column is untouched and part of old event in second column takes only half width.
        Ext.Array.each(columns, function(column) {
            me.repaintEventsForColumn(column.column, column.index);
        });
    },
    renderSingle: function(event) {
        var view = this.view;
        // remove rendered event nodes
        Ext.Array.each(view.getElementsFromEventRecord(event), function(el) {
            Ext.fly(el).destroy();
        });
        // TODO: If event doesn't have resource assigned - use default one (currently first from store)
        var resource = event.getResources()[0] || view.getResourceStore().first();
        var previous = event.previous || {};
        var UD = Sch.util.Date;
        // relayout all affected columns
        var timeSpan = new Sch.model.Range({
                StartDate: UD.min(previous.StartDate || event.getStartDate(), event.getStartDate()),
                EndDate: UD.max(previous.EndDate || event.getEndDate(), event.getEndDate())
            });
        var columns = this.getColumnsForDateRange(timeSpan);
        Ext.Array.each(columns, function(column) {
            var columnIndex = column.getIndex();
            // gather rendered events data to apply layout and calculate new correct size
            var events = this.getColumnEvents(column);
            var eventRenderData = Ext.Array.map(events, function(record) {
                    if (record === event) {
                        // append new render data for new event
                        return view.generateTplData(event, resource, columnIndex);
                    } else {
                        return {
                            start: record.getStartDate() < column.start ? column.start : record.getStartDate(),
                            end: record.getEndDate() > column.end ? column.end : record.getEndDate(),
                            event: record
                        };
                    }
                });
            view.eventLayout.vertical.applyLayout(eventRenderData, column.getWidth() - (2 * view.barMargin) - view.cellBorderWidth);
            // refresh rendered events
            Ext.Array.each(eventRenderData, function(renderData) {
                if (renderData.event === event) {
                    // render new event
                    var containerCell = view.getScheduleCell(0, columnIndex);
                    // if grid content is not yet rendered, then just do nothing
                    if (containerCell) {
                        if (!Ext.versions.touch) {
                            containerCell = Ext.fly(containerCell).first();
                        }
                        view.eventTpl.append(containerCell, [
                            renderData
                        ]);
                    }
                } else {
                    var eventNode = view.getElementsFromEventRecord(renderData.event, renderData.event.getResource(), columnIndex)[0];
                    eventNode.setStyle({
                        left: renderData.left + 'px',
                        width: Math.max(renderData.width, 0) + 'px'
                    });
                }
            });
        }, this);
    },
    repaintEventsForColumn: function(column, index) {
        var me = this;
        var events = me.getColumnEvents(column);
        var view = me.view;
        var data = [],
            i, l, event, node, start, end;
        for (i = 0 , l = events.length; i < l; i++) {
            event = events[i];
            node = view.getElementsFromEventRecord(event)[0];
            // nothing is rendered yet
            if (!node) {
                return;
            }
            // each event node if calendar view has column index in it
            // we need a common id without column index, so we perform split/pop/join
            var commonId = node.id.split('-');
            commonId.pop();
            start = event.getStartDate();
            end = event.getEndDate();
            // simulate one-column events for vertical layout
            data.push({
                start: start < column.start ? column.start : start,
                end: end > column.end ? column.end : end,
                event: event,
                id: commonId.join('-')
            });
        }
        view.eventLayout.vertical.applyLayout(data, column.getWidth() - (2 * view.barMargin) - view.cellBorderWidth);
        // We render events into first row in the table so we need this element to make lookups.
        var rowNode = view.getNode(0);
        for (i = 0; i < data.length; i++) {
            event = data[i];
            // We should only touch events (events' parts) that are rendered into changed column.
            // Since parts of one event share element id we have to look up in certain cell.
            // In Ext5 Ext.dom.Query is not a default selector, so pseudo classes are failing in IE8
            node = Ext.DomQuery.selectNode('td:nth-child(' + (index + 1) + ') [id^=' + event.id + '-]', rowNode);
            // for the case when we relayout short event
            node && Ext.fly(node).setStyle({
                left: event.left + 'px',
                width: Math.max(event.width, 0) + 'px'
            });
        }
    },
    /**
     *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
     *  @param {Date} startDate The start date of the span
     *  @param {Date} endDate The end date of the span
     *  @return {Ext.util.Region} The region for the time span
     */
    getTimeSpanRegion: function(startDate, endDate) {
        var view = this.view,
            startY = view.getCoordinateFromDate(startDate),
            endY = endDate ? view.getCoordinateFromDate(endDate, true, true) : startY;
        var startColumn = this.getColumnsBy(function(column) {
                return column.start <= startDate && column.end > startDate;
            })[0];
        var endColumn = this.getColumnsBy(function(column) {
                return column.start < endDate && column.end >= endDate;
            })[0];
        if (!startColumn || !endColumn) {
            return new Ext.util.Region(-1, 0, -1, 0);
        }
        var pair1 = this.translateToScheduleCoordinate([
                startColumn.getX(),
                0
            ]);
        var pair2 = this.translateToScheduleCoordinate([
                endColumn ? endColumn.getRegion().right : startColumn.getWidth() + pair1[0],
                0
            ]);
        return new Ext.util.Region(Math.min(startY, endY), pair2[0], Math.max(startY, endY), pair1[0]);
    },
    /**
     * Gets the start and end dates for an element Region
     * @param {Ext.util.Region} region The region to map to start and end dates
     * @param {String} roundingMethod The rounding method to use
     * @returns {Object} an object containing start/end properties
     */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var topDate = this.view.getDateFromCoordinate([
                region.left,
                region.top
            ], roundingMethod),
            bottomDate = this.view.getDateFromCoordinate([
                region.left,
                region.bottom
            ], roundingMethod);
        if (topDate && bottomDate) {
            return {
                start: topDate,
                end: bottomDate
            };
        } else {
            return null;
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.calendarColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
     * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
     * @return {Object} object with `startDate` and `endDate` properties.
     */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.rendered) {
            return null;
        }
        var scroll = view.getScroll(),
            height = view.getHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();
        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate = view.timeAxis.getStart();
            return {
                startDate: startDate,
                endDate: viewEndDate
            };
        }
        return {
            startDate: view.getDateFromCoordinate(scroll.top, null, true),
            endDate: view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    },
    /**
     * Gets box for displaying item disgnated by the record. If there're several boxes are displayed for the given
     * item then the method returns all of them
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered
     */
    getItemBox: function(eventRecord) {
        return null;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'top';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'bottom';
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Sch.mixin.SchedulerView

 A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
 should have already consumed the {@link Sch.mixin.TimelineView} mixin.

 Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

 */
Ext.define('Sch.mixin.SchedulerView', {
    extend: 'Sch.mixin.AbstractSchedulerView',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Sch.patches.NavigationModel6_0_2',
        'Sch.feature.DragCreator',
        'Sch.feature.DragDrop',
        'Sch.feature.ResizeZone',
        'Sch.column.Resource',
        'Sch.column.Day',
        'Sch.view.Calendar',
        'Ext.XTemplate'
    ],
    /**
     * @property {Sch.feature.SchedulerDragZone} eventDragZone
     * Accessor to the event dragzone (available only if the drag drop feature is enabled)
     */
    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'end'
     */
    eventResizeHandles: 'end',
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the drop position is valid, else false to prevent a drop. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    dndValidatorFn: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * an item being resized. To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the resize state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    resizeValidatorFn: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    createValidatorFn: Ext.emptyFn,
    // Scheduled events: click events --------------------------
    /**
     * @event eventclick
     * Fires when an event is clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventlongpress
     * Fires when an event is longpressed
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmousedown
     * Fires when a mousedown event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseup
     * Fires when a mouseup event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdblclick
     * Fires when an event is double clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventcontextmenu
     * Fires when contextmenu is activated on an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseenter
     * Fires when the mouse moves over an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseout
     * Fires when the mouse moves out of an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    // Resizing events start --------------------------
    /**
     * @event beforeeventresize
     * Fires before a resize starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record about to be resized
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventresizestart
     * Fires when resize starts
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     */
    /**
     * @event eventpartialresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     * @param {Date} startDate The new start date of the event
     * @param {Date} endDate The new end date of the event
     * @param {Ext.Element} element The proxy element being resized
     */
    /**
     * @event beforeeventresizefinalize
     * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} resizeContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventresizeend
     * Fires after a succesful resize operation
     * @param {Mixed} view The scheduler view instance
     * @param {Sch.model.Event} record The updated event record
     */
    // Resizing events end --------------------------
    // Dnd events start --------------------------
    /**
     * @event beforeeventdrag
     * Fires before a dnd operation is initiated, return false to cancel it
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdragstart
     * Fires when a dnd operation starts
     * @param {Sch.mixin.SchedulerView} scheduler The scheduler object
     * @param {Array} records the records being dragged
     */
    /**
     * @event beforeeventdropfinalize
     * Fires before a succesful drop operation is finalized.
     * @param {Sch.feature.SchedulerDragZone} dragZone The scheduler dragzone. Scheduler view instance: dragZone.schedulerView.
     * @param {Object} dragContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdrop
     * Fires after a succesful drag and drop operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event[]} records the affected records (if copies were made, they were not inserted into the store)
     * @param {Boolean} isCopy True if the records were copied instead of moved
     */
    /**
     * @event aftereventdrop
     * Fires when after a drag n drop operation, even when drop was performed on an invalid location
     * @param {Mixed} view The scheduler view instance
     */
    // Dnd events end --------------------------
    // Drag create events start --------------------------
    /**
     * @event beforedragcreate
     * Fires before a drag starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Resource} resource The resource record
     * @param {Date} date The clicked date on the timeaxis
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event dragcreatestart
     * Fires before a drag starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event beforedragcreatefinalize
     * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
     * @param {Ext.event.Event} e The event object
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
     * @param {Sch.model.Resource} resource The resource record to which the event belongs
     * @param {Ext.event.Event} e The event object
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */
    // Drag create events end --------------------------
    /**
     * @event beforeeventadd
     * Fires after a successful drag-create operation, before the new event is added to the store. Return false to prevent the event from being added to the store.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record
     * @param {[Sch.model.Resource]} resources The resources to which the event is assigned
     */
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading events...'
     */
    calendarViewClass: 'Sch.view.Calendar',
    lockedGridDependsOnSchedule: null,
    _initializeSchedulerView: function() {
        this.callParent(arguments);
        this.on({
            destroy: this._destroy,
            afterrender: this._afterRender,
            itemupdate: this.onRowUpdated,
            scope: this
        });
        // https://www.assembla.com/spaces/bryntum/tickets/2567
        // 092_rowheight
        // cache has to be cleared on time span change in order to draw correct row height for empty rows
        this.timeAxis.on('beginreconfigure', this.clearRowHeightCache, this);
        // HACK
        // 015_buffered_scroll fails in IE and FF because end row in normal view may have
        // inline style, added by sencha row synchronizer, that will break rows sync
        // TODO: When Ext 5.1.2 is out - try removing this hack
        if (Ext.getVersion().isGreaterThan('5.1.1')) {
            this.on('itemadd', function(records) {
                var el = this.all.item(this.all.endIndex - records.length);
                if (el) {
                    el.dom.style.height = '';
                }
            });
        }
        // ENDHACK
        var me = this;
        if (!this.eventPrefix) {
            throw 'eventPrefix missing';
        }
        this.on({
            resourcestorechange: this.clearRowHeightCache,
            assignmentstorechange: this.clearRowHeightCache,
            eventstorechange: this.clearRowHeightCache,
            scope: this
        });
    },
    inheritables: function() {
        return {
            // Configuring underlying grid view
            loadingText: this.L('loadingText'),
            overItemCls: '',
            trackOver: false,
            selectedItemCls: '',
            // We don't want row selection visible here
            // EOF: Configuring underlying grid view
            setReadOnly: function(readOnly) {
                if (this.dragCreator) {
                    this.dragCreator.setDisabled(readOnly);
                }
                this.callParent(arguments);
            },
            repaintEventsForResource: function(resourceRecord, refreshSelections) {
                var me = this,
                    mode = me.getMode(),
                    isHorizontal = mode === 'horizontal',
                    // For vertical, we always repaint all events (do per-column repaint is not supported)
                    index = isHorizontal ? me.indexOf(resourceRecord) : 0;
                if (isHorizontal) {
                    me.eventLayout.horizontal.clearCache(resourceRecord);
                }
                if (index >= 0) {
                    // HACK, Ext insists on performing layouts when refreshing a grid row.
                    // Prevent this, "should be" safe.
                    Ext.suspendLayouts();
                    // we operate "resourceRecord" here since "index" might be incorrect when grouping plugin is used
                    if (isHorizontal) {
                        me.refreshNode(resourceRecord);
                        if (me.lockedGridDependsOnSchedule) {
                            me.lockingPartner.refreshNode(resourceRecord);
                        }
                    } else // Use index here to keep vertical view only refreshing first row always
                    {
                        me.refreshNode(index);
                    }
                    Ext.resumeLayouts();
                    if (refreshSelections) {
                        var sm = me.getEventSelectionModel();
                        var events = me.getEventStore().getEventsForResource(resourceRecord);
                        Ext.Array.each(events, function(ev) {
                            sm.forEachEventRelatedSelection(ev, function(selectedRecord) {
                                me.onEventBarSelect(selectedRecord, true);
                            });
                        });
                    }
                }
            },
            repaintAllEvents: function() {
                if (this.mode === 'horizontal') {
                    this.refreshView();
                } else {
                    // All events are rendered in first row, no need to do a full refresh
                    this.refreshNode(0);
                }
            },
            handleScheduleEvent: function(e) {
                var te = e.getTarget('.' + this.eventCls, 3),
                    t = !te && e.getTarget('.' + this.timeCellCls, 3);
                if (t) {
                    var clickedDate = this.getDateFromDomEvent(e, 'floor');
                    var resourceNode = this.findRowByChild(t);
                    var index = this.indexOf(resourceNode);
                    var resource;
                    if (this.mode == 'horizontal') {
                        resource = this.getRecordForRowNode(resourceNode);
                    } else {
                        var cellNode = e.getTarget(this.timeCellSelector, 5);
                        if (cellNode) {
                            var cellIndex = typeof cellNode.cellIndex == 'number' ? cellNode.cellIndex : cellNode.getAttribute('data-cellIndex');
                            var header = this.headerCt.getGridColumns()[cellIndex];
                            resource = header && header.model;
                        }
                    }
                    if (e.type.indexOf('pinch') >= 0) {
                        this.fireEvent('schedule' + e.type, this, e);
                    } else {
                        this.fireEvent('schedule' + e.type, this, clickedDate, index, resource, e);
                    }
                }
            },
            onEventDataRefresh: function() {
                this.clearRowHeightCache();
                this.callParent(arguments);
            },
            onUnbindStore: function(store) {
                store.un({
                    refresh: this.clearRowHeightCache,
                    clear: this.clearRowHeightCache,
                    load: this.clearRowHeightCache,
                    scope: this
                });
                this.callParent(arguments);
            },
            // our listeners must go before any other listeners, that's why we override the 'bindStore'
            // instead of `onBindStore`
            bindStore: function(store) {
                store && store.on({
                    refresh: this.clearRowHeightCache,
                    clear: this.clearRowHeightCache,
                    load: this.clearRowHeightCache,
                    scope: this
                });
                this.callParent(arguments);
            },
            refreshKeepingScroll: function() {
                this.lockingPartner.saveScrollState();
                this.lockingPartner.refreshView();
                this.callParent(arguments);
                this.lockingPartner.restoreScrollState();
            }
        };
    },
    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel: function() {
        var me = this,
            eventSelModel = me.eventSelModel,
            eventSelModelType = me.eventSelModelType,
            mode;
        // already has the event selection model
        if (eventSelModel && eventSelModel.events) {
            return eventSelModel;
        }
        if (!eventSelModel) {
            eventSelModel = {};
        }
        if (!eventSelModelType && me.getEventStore().getAssignmentStore()) {
            eventSelModelType = 'assignmentmodel';
        } else if (!eventSelModelType) {
            eventSelModelType = 'eventmodel';
        }
        mode = 'SINGLE';
        if (me.simpleSelect) {
            mode = 'SIMPLE';
        } else if (me.multiSelect) {
            mode = 'MULTI';
        }
        Ext.applyIf(eventSelModel, {
            allowDeselect: me.allowDeselect,
            mode: mode
        });
        if (!eventSelModel.events) {
            eventSelModel = me.eventSelModel = Ext.create('selection.' + eventSelModelType, eventSelModel);
        }
        // lock the selection model if user
        // has disabled selection
        if (me.disableSelection) {
            eventSelModel.locked = true;
        }
        return eventSelModel;
    },
    _afterRender: function() {
        this.setEventStore(this.eventStore, true);
        this.getEventSelectionModel().bindToView(this);
        this.setupEventListeners();
        this.configureFunctionality();
        var resizer = this.headerCt.resizer;
        if (resizer) {
            resizer.doResize = Ext.Function.createSequence(resizer.doResize, this.afterHeaderResized, this);
        }
        // Delete the hoveredEventNode (last item we hovered over) so that after a drag drop the UI considers the
        // mouse to be over the current element
        this.on('itemupdate', function() {
            this.hoveredEventNode = null;
        });
    },
    // private, clean up
    _destroy: function() {
        this.setEventStore(null);
    },
    clearRowHeightCache: function() {
        if (this.mode === 'horizontal') {
            this.eventLayout.horizontal.clearCache();
        }
    },
    configureFunctionality: function() {
        var vfScope = this.validatorFnScope || this;
        if (this.eventResizeHandles !== 'none' && Sch.feature.ResizeZone) {
            this.resizePlug = new Sch.feature.ResizeZone(Ext.applyIf({
                schedulerView: this,
                validatorFn: function(resourceRecord, eventRecord, startDate, endDate) {
                    return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, eventRecord, resourceRecord)) && this.resizeValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: this
            }, this.resizeConfig || {}));
        }
        if (this.enableEventDragDrop !== false && Sch.feature.DragDrop) {
            this.dragdropPlug = new Sch.feature.DragDrop(this, {
                validatorFn: function(dragRecords, targetResourceRecord, date, duration) {
                    return (this.allowOverlap || this.isDateRangeAvailable(date, Sch.util.Date.add(date, Sch.util.Date.MILLI, duration), dragRecords[0], targetResourceRecord)) && this.dndValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: this,
                dragConfig: this.dragConfig || {}
            });
        }
        if (this.enableDragCreation !== false && Sch.feature.DragCreator) {
            this.dragCreator = new Sch.feature.DragCreator(Ext.applyIf({
                schedulerView: this,
                disabled: this.readOnly,
                validatorFn: function(resourceRecord, startDate, endDate) {
                    return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, null, resourceRecord)) && this.createValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: this
            }, this.createConfig || {}));
        }
    },
    // ---------------------------------------
    // Interaction listeners
    onBeforeDragDrop: function(s, rec, e) {
        return !this.readOnly && !e.getTarget().className.match('sch-resizable-handle');
    },
    onDragDropStart: function() {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }
        // To be able to refresh last hovered node
        this.hoveredEventNode = null;
    },
    onDragDropEnd: function() {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }
        if (this.tip) {
            this.tip.enable();
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
    },
    onBeforeDragCreate: function(s, resourceRecord, date, e) {
        return !this.readOnly && !e.ctrlKey;
    },
    onDragCreateStart: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },
    onDragCreateEnd: function(s, newEventRecord, resourceRecord) {
        // If an event editor is defined, it has to manage how/if/when the event is added to the event store
        if (!this.getEventEditor()) {
            // we may not have any resources if we're in Calendar view mode
            var resources = resourceRecord ? [
                    resourceRecord
                ] : [];
            if (this.fireEvent('beforeeventadd', this, newEventRecord, resources) !== false) {
                this.onEventCreated(newEventRecord);
                this.getEventStore().append(newEventRecord);
                // In calendar mode both axes are time so resourceRecord is object {start: foo, end: bar}
                // so we do not need assign this resource to event
                if (this.getMode() != 'calendar') {
                    newEventRecord.assign(resourceRecord);
                }
            }
            this.dragCreator.getProxy().hide();
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
    },
    // Empty but provided so that you can override it to supply default record values etc.
    onEventCreated: function(newEventRecord) {},
    onAfterDragCreate: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
        if (this.tip) {
            this.tip.enable();
        }
        this.disableViewScroller(false);
    },
    onBeforeResize: function() {
        return !this.readOnly;
    },
    onResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },
    onResizeEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(false);
    },
    // EOF Interaction listeners
    // ---------------------------------------
    setupEventListeners: function() {
        this.on({
            beforeeventdrag: this.onBeforeDragDrop,
            eventdragstart: this.onDragDropStart,
            aftereventdrop: this.onDragDropEnd,
            beforedragcreate: this.onBeforeDragCreate,
            dragcreatestart: this.onDragCreateStart,
            dragcreateend: this.onDragCreateEnd,
            afterdragcreate: this.onAfterDragCreate,
            beforeeventresize: this.onBeforeResize,
            eventresizestart: this.onResizeStart,
            eventresizeend: this.onResizeEnd,
            scope: this
        });
    },
    afterHeaderResized: function() {
        var resizer = this.headerCt.resizer;
        // if we perform resize on panel with forceFit cfg set to true events will be sized incorrectly
        if (resizer && this.getMode() !== 'horizontal') {
            // if forceFit is enabled columns cannot be resized
            if (this.panel.forceFit) {
                this.setColumnWidth(resizer.origWidth);
            } else {
                var w = resizer.dragHd.getWidth();
                this.setColumnWidth(w);
            }
        }
    },
    columnRenderer: function(val, meta, record, row, col) {
        return this[this.mode].columnRenderer(val, meta, record, row, col);
    },
    onRowUpdated: function(resourceRecord) {
        var me = this,
            nodes;
        // Only relevant for horizontal mode
        if (me.getMode() === 'horizontal' && me.hasListener('eventrepaint')) {
            Ext.Array.each(resourceRecord.getEvents(), function(event) {
                nodes = me.getElementsFromEventRecord(event, resourceRecord, null, true);
                Ext.Array.each(nodes, function(node) {
                    me.fireEvent('eventrepaint', me, event, node);
                });
            });
        }
    },
    /**
     * Scrolls a resource event record into the viewport.
     *
     * If the resource store is a tree store, this method will also expand all relevant parent nodes
     * to locate the event.
     *
     * @param {Sch.model.Resource} resourceRec A resource record an event record is assigned to
     * @param {Sch.model.Event} eventRec    An event record to scroll into view
     * @param {Number} index                DOM node index, applicable only for Calendar view mode
     * @param {Boolean/Object} highlight    Either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate      Either `true/false` or an animation config object used to scroll the element
     */
    scrollResourceEventIntoView: function(resourceRec, eventRec, index, highlight, animate, callback, scope) {
        var me = this,
            eventStart = eventRec.getStartDate(),
            eventEnd = eventRec.getEndDate(),
            currentTimeSpanRange, el;
        var doScroll = function() {
                // Establishing element to scroll to
                el = me.getElementsFromEventRecord(eventRec, resourceRec, index);
                el = el.length && el[0] || null;
                // In Calendar view there might be several elements correspond to resource/event pair.
                // Scrolling with view with animation and highlighting if needed
                me.scrollElementIntoView(el, true, animate, highlight, null, callback, scope);
            };
        // Make sure resource is visible if it's part of a TreeStore
        if (me.getResourceStore().isTreeStore) {
            resourceRec.bubble(function(node) {
                node.expand();
            });
        }
        // Make sure event is within current time axis time span
        if (!me.timeAxis.dateInAxis(eventStart) || !me.timeAxis.dateInAxis(eventEnd)) {
            currentTimeSpanRange = me.timeAxis.getEnd() - me.timeAxis.getStart();
            me.timeAxis.setTimeSpan(new Date(eventStart.valueOf() - currentTimeSpanRange / 2), new Date(eventEnd.getTime() + currentTimeSpanRange / 2));
            // HACK:
            // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
            // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
            me.up('panel').scrollTask.cancel();
        }
        if (this.getOrientation() === 'horizontal') {
            // Dealing with buffered rendering, making sure row is rendered
            me.up('timelinegrid,timelinetree').ensureVisible(resourceRec, {
                callback: function() {
                    // 1. ensureVisible on a lockable grid will call callback twice one for normal grid and another
                    //    for locked grid
                    // 2. since we do not provide the scope for the callback then 'this' here will point to either
                    //    normal grid or locked grid the callback is called for
                    // 3. We use this.isLocked to execute callback logic for the normal grid only.
                    if (this.isLocked === false)  {
                        doScroll();
                    }
                    
                }
            });
        } else {
            doScroll();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.view.SchedulerGridView
@extends Sch.view.TimelineGridView
@mixin Sch.mixin.SchedulerView

Empty class just consuming the Sch.mixin.SchedulerView mixin.

*/
Ext.define("Sch.view.SchedulerGridView", {
    extend: 'Sch.view.TimelineGridView',
    mixins: [
        'Sch.mixin.SchedulerView',
        'Sch.mixin.GridViewCanvas',
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.schedulergridview'
}, function() {
    this.override(Sch.mixin.SchedulerView.prototype.inheritables() || {});
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.selection.EventModel
@extends Ext.selection.Model

This class provides the basic implementation event selection in a grid.

*/
Ext.define("Sch.selection.EventModel", {
    extend: 'Ext.selection.Model',
    alias: 'selection.eventmodel',
    requires: [
        'Ext.util.KeyNav'
    ],
    /**
     * @cfg {Boolean} deselectOnContainerClick `True` to deselect all events when user clicks on the underlying space in scheduler. Defaults to `true`.
     */
    deselectOnContainerClick: true,
    // Stores selected record on mousedown event to avoid
    // unselecting record on click
    selectedOnMouseDown: null,
    /**
     * @event beforedeselect
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event beforeselect
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     */
    bindToView: function(view) {
        var me = this;
        me.view = view;
        me.bindStore(view.getEventStore());
        view.on({
            eventclick: me.onEventClick,
            eventmousedown: me.onEventMouseDown,
            itemmousedown: me.onItemMouseDown,
            refresh: function() {
                me.refresh();
            },
            destroy: function() {
                me.bindStore(null);
            },
            scope: me
        });
    },
    bindStore: function(eventStore) {
        if (this.getStore()) {
            this.mun(this.getStore(), 'load', this.onEventStoreLoad, this);
        }
        if (eventStore) {
            this.mon(eventStore, 'load', this.onEventStoreLoad, this);
        }
        this.callParent(arguments);
    },
    onEventStoreLoad: function() {
        this.deselectAll();
    },
    onEventMouseDown: function(view, record, e) {
        // Reset previously stored records
        this.selectedOnMouseDown = null;
        // Change selection before dragging to avoid moving of unselected events
        if (!this.isSelected(record)) {
            this.selectedOnMouseDown = record;
            this.selectWithEvent(record, e);
        }
    },
    onEventClick: function(view, record, e) {
        // Don't change selection if record been already selected on mousedown
        if (!this.selectedOnMouseDown) {
            this.selectWithEvent(record, e);
        }
    },
    onItemMouseDown: function(a, b, c, d, eventObj) {
        if (this.deselectOnContainerClick && !eventObj.getTarget(this.view.eventSelector)) {
            this.deselectAll();
        }
    },
    onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
        var me = this,
            view = me.view,
            store = me.store,
            eventName = isSelected ? 'select' : 'deselect',
            i = 0;
        if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
            if (isSelected) {
                view.onEventBarSelect(record, suppressEvent);
            } else {
                view.onEventBarDeselect(record, suppressEvent);
            }
            if (!suppressEvent) {
                me.fireEvent(eventName, me, record);
            }
        }
    },
    // Not supported.
    selectRange: Ext.emptyFn,
    selectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.select(r, keepExisting, suppressEvent);
        }
    },
    deselectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.deselect(r, suppressEvent);
        }
    },
    /**
     * Returns first selected event record for the given resource record or null if the resource has no assigned
     * events which are selected.
     *
     * @param {Sch.model.Resource} resource
     * @return {Sch.model.Event}
     */
    getFirstSelectedEventForResource: function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;
        for (i = 0 , len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.isAssignedTo(resource)) {
                event = r;
            }
        }
        return event;
    },
    getDraggableSelections: function() {
        return Ext.Array.filter(this.getSelection(), function(record) {
            return record.isDraggable();
        });
    },
    forEachEventRelatedSelection: function(eventRecord, fn) {
        this.isSelected(eventRecord) && fn(eventRecord);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Sch.selection.AssignmentModel
 * @extends Ext.selection.Model
 *
 * This class provides assignment selection model for multiple assignments mode, i.e. when the event store is configured
 * with assignment store and uses it for storing event to resource and resource to event assignment information.
 * In multiple assignment mode there're might be several event bars rendered for each event in the event store, thus
 * an inconsistency appears, to solve the inconsistency we use assignment record as entities being selected since
 * there's direct correspondence between event bar and assignment the bar is rendered for.
 */
Ext.define('Sch.selection.AssignmentModel', {
    extend: 'Sch.selection.EventModel',
    alias: 'selection.assignmentmodel',
    /**
     * @event beforedeselect
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event beforeselect
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    assignmentStoreDetacher: null,
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher');
        me.callParent();
    },
    onBindStore: function(eventStore) {
        this.callParent(arguments);
        var assignmentStore = eventStore.getAssignmentStore();
        if (assignmentStore) {
            var me = this;
            me.assignmentStoreDetacher && me.assignmentStoreDetacher.destroy();
            me.assignmentStoreDetacher = assignmentStore.on({
                remove: me.onAssignmentStoreRemove,
                clear: me.onAssignmentStoreClear,
                refresh: me.onAssignmentStoreRefresh,
                scope: me,
                destroyable: true
            });
        }
    },
    selectWithEvent: function(eventRecord, e) {
        var me = this,
            view = me.view,
            resourceRecord = view.resolveResource(e.getTarget()),
            assignmentStore, assignmentRecord;
        if (resourceRecord) {
            assignmentStore = view.getEventStore().getAssignmentStore();
            assignmentRecord = assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);
            if (assignmentRecord) {
                me.callParent([
                    assignmentRecord,
                    e
                ]);
            }
        }
    },
    getFirstSelectedEventForResource: function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;
        for (i = 0 , len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.getEvent().isAssignedTo(resource)) {
                event = r;
                break;
            }
        }
        return event;
    },
    getDraggableSelections: function() {
        return Ext.Array.filter(this.getSelection(), function(record) {
            return record.getEvent().isDraggable();
        });
    },
    forEachEventRelatedSelection: function(eventRecord, fn) {
        Ext.Array.each(this.getSelection(), function(selectedRecord) {
            selectedRecord.getEvent() === eventRecord && fn(selectedRecord);
        });
    },
    onAssignmentStoreRemove: function(assignmentStore, removedRecords) {
        this.deselect(removedRecords, true);
    },
    onAssignmentStoreClear: function(assignmentStore) {
        this.clearSelections();
    },
    onAssignmentStoreRefresh: function(assignmentStore) {
        this.clearSelections();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/*
 * @class Sch.column.timeAxis.Vertical
 *
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in vertical orientation
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.timeAxis.Vertical', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.verticaltimeaxis',
    /*
     * Default timeaxis column properties
     */
    align: 'right',
    width: 100,
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    menuDisabled: true,
    timeAxis: null,
    timeAxisViewModel: null,
    cellTopBorderWidth: null,
    cellBottomBorderWidth: null,
    totalBorderWidth: null,
    enableLocking: false,
    locked: true,
    dataIndex: 'start',
    initComponent: function() {
        this.callParent(arguments);
        this.tdCls = (this.tdCls || '') + ' sch-verticaltimeaxis-cell';
        this.scope = this;
        this.addCls('sch-verticaltimeaxis-header');
        this.totalBorderWidth = this.cellTopBorderWidth + this.cellBottomBorderWidth;
    },
    renderer: function(val, meta, record, rowIndex) {
        var hc = this.timeAxisViewModel.getBottomHeader();
        meta.style = 'height:' + (this.timeAxisViewModel.getTickWidth() - this.totalBorderWidth) + 'px';
        if (hc.renderer) {
            return hc.renderer.call(hc.scope || this, record.data.start, record.data.end, meta, rowIndex);
        } else {
            return Ext.Date.format(val, hc.dateFormat);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Sch.mixin.SchedulerPanel
 @extends Sch.mixin.AbstractSchedulerPanel

 A mixin for {@link Ext.panel.Panel} classes, providing "scheduling" functionality to the consuming panel.
 A consuming class should have already consumed the {@link Sch.mixin.TimelinePanel} mixin.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

 */
Ext.define('Sch.mixin.SchedulerPanel', {
    extend: 'Sch.mixin.AbstractSchedulerPanel',
    requires: [
        'Sch.view.SchedulerGridView',
        'Sch.selection.EventModel',
        'Sch.selection.AssignmentModel',
        'Sch.column.timeAxis.Vertical'
    ],
    /**
     * @cfg {String} eventSelModelType The xtype of the selection model to be used to events. Should be a {@link Sch.selection.EventModel} or its subclass.
     */
    eventSelModelType: null,
    // 'eventmodel', 'assignmentmodel'
    /**
     * @cfg {Object} eventSelModel The configuration object for the event selection model. See {@link Sch.selection.EventModel} for available configuration options.
     */
    eventSelModel: null,
    /**
     * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
     */
    enableEventDragDrop: true,
    /**
     * @cfg {Boolean} enableDragCreation true to enable creating new events by click and drag, defaults to true
     */
    enableDragCreation: true,
    /**
     * @cfg {Object} dragConfig Custom config to pass to the {@link Sch.feature.SchedulerDragZone}
     * instance which will be created by {@link Sch.feature.DragDrop}.
     */
    dragConfig: null,
    /**
     * @cfg {String} calendarColumnClass
     * Defines the column class for the days, override this to use your own custom column class. (Used only in calendar mode)
     */
    calendarColumnClass: 'Sch.column.Day',
    /**
     * @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
     */
    /**
     * @cfg {Object} calendarTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in calendar mode.
     */
    /**
     * @cfg {Object} createConfig Custom config to pass to the {@link Sch.feature.DragCreator} instance
     */
    /**
     * @cfg {Object} resizeConfig Custom config to pass to the {@link Sch.feature.ResizeZone} instance
     */
    componentCls: 'sch-schedulerpanel',
    // even that this config "belongs" to the Sch.mixin.TimelinePanel mixin
    // we can't define it there, because of various reasons (extjs mixin system)
    // this is guarded by the 203_buffered_view_1.t.js test in gantt and 092_rowheight.t.js in scheduler
    /**
     * @ignore
     * @cfg {Boolean} lockedGridDependsOnSchedule set this to true if you require the left (locked) grid section to be refreshed when the schedule is updated.
     */
    lockedGridDependsOnSchedule: true,
    /**
     * @cfg {Boolean} [multiSelect=false]
     * True to allow selection of more than one event at a time, false to allow selection of only a single item
     * at a time or no selection at all, depending on the value of {@link #singleSelect}.
     */
    /**
     * @cfg {Boolean} [singleSelect]
     * Allows selection of exactly one event at a time. As this is the default selection mode anyway, this config
     * is completely ignored.
     */
    /**
     * @cfg {Boolean} [simpleSelect=false]
     * True to enable multiselection by clicking on multiple events without requiring the user to hold Shift or Ctrl,
     * false to force the user to hold Ctrl or Shift to select more than on item.
     */
    /**
     * @cfg {Function} dndValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the drop position is valid, else false to prevent a drop.
     * @param {Array} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean}
     */
    /**
     * @cfg {Function} resizeValidatorFn
     * Provide to perform custom validation on an item being resized.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the resize state is valid, else false.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean}
     */
    /**
     * @cfg {Function} createValidatorFn
     * Provide to perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true to signal that the new event is valid, or false prevent it.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} true
     */
    verticalListeners: null,
    /**
     * @event orientationchange
     * Fires after an orientation change
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
     * @param {String} orientation The new orientation ('horizontal' or 'vertical')
     * @deprecated 2.2.22 Use {@link #modechange}
     */
    /**
     * @event modechange
     * Fires after a mode change
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
     * @param {String} mode The new mode ('horizontal', 'vertical', 'calendar')
     */
    // Cached value of locked grid width used when switching orientation
    horizontalLockedWidth: null,
    verticalColumns: null,
    calendarColumns: null,
    inheritables: function() {
        return {
            variableRowHeight: true,
            // private
            initComponent: function() {
                var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
                this._initializeSchedulerPanel();
                this.verticalListeners = {
                    clear: this.refreshResourceColumns,
                    datachanged: this.refreshResourceColumns,
                    update: this.refreshResourceColumns,
                    // TODO WASTEFUL
                    load: this.refreshResourceColumns,
                    scope: this
                };
                this.calendarListeners = {
                    reconfigure: this.refreshCalendarColumns,
                    priority: 1,
                    scope: this
                };
                this.normalGridListeners = {
                    columnresize: this.onCalendarColumnResize,
                    scope: this
                };
                Ext.apply(viewConfig, {
                    eventStore: this.eventStore,
                    resourceStore: this.resourceStore,
                    dependencyStore: this.dependencyStore,
                    eventBarTextField: this.eventBarTextField || this.getEventStore().getModel().prototype.nameField
                });
                // TODO: replace with Ext.copyTo() when ExtJS 6.0.0 support is dropped
                Ext.Array.each([
                    "barMargin",
                    "eventBodyTemplate",
                    "eventTpl",
                    "allowOverlap",
                    "dragConfig",
                    "eventBarIconClsField",
                    "onEventCreated",
                    "constrainDragToResource",
                    "snapRelativeToEventStartDate",
                    "eventSelModelType",
                    "eventSelModel",
                    "simpleSelect",
                    "multiSelect",
                    "allowDeselect",
                    "lockedGridDependsOnSchedule"
                ], function(prop) {
                    if (prop in this)  {
                        viewConfig[prop] = this[prop];
                    }
                    
                }, this);
                this.callParent(arguments);
                if (!this.isHorizontal()) {
                    this.setGroupingFeatureDisabled(true);
                }
                // mode is safe to use after callParent where we check for deprecated 'orientation' option
                if (this.mode === 'vertical') {
                    this.mon(this.resourceStore, this.verticalListeners);
                }
                var lockedView = this.lockedGrid.getView();
                var normalView = this.getSchedulingView();
                lockedView.on('resize', this.onLockedViewResize, this);
                this.registerRenderer(normalView.columnRenderer, normalView);
                if (this.resourceZones) {
                    var resourceZoneStore = Ext.StoreManager.lookup(this.resourceZones);
                    resourceZoneStore.setResourceStore(this.resourceStore);
                    this.resourceZonesPlug = new Sch.plugin.ResourceZones(Ext.apply({
                        store: resourceZoneStore
                    }, this.resourceZonesConfig));
                    this.resourceZonesPlug.init(this);
                }
                normalView.on('columnwidthchange', this.onColWidthChange, this);
                // Relaying after parent class has setup the locking grid components
                this.relayEvents(normalView, [
                    /**
                 * @event eventclick
                 * Fires when an event is clicked
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventclick',
                    /**
                 * @event eventlongpress
                 * Fires when an event is longpressed
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventlongpress',
                    /**
                 * @event eventmousedown
                 * Fires when a mousedown event is detected on a rendered event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventmousedown',
                    /**
                 * @event eventmouseup
                 * Fires when a mouseup event is detected on a rendered event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventmouseup',
                    /**
                 * @event eventdblclick
                 * Fires when an event is double clicked
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventdblclick',
                    /**
                 * @event eventcontextmenu
                 * Fires when contextmenu is activated on an event
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventcontextmenu',
                    /**
                 * @event eventmouseenter
                 * Fires when the mouse moves over an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventmouseenter',
                    /**
                 * @event eventmouseleave
                 * Fires when the mouse moves out of an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventmouseleave',
                    /**
                 * @event eventkeydown
                 * Fires when a keydown event is detected on an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventkeydown',
                    /**
                 * @event eventkeyup
                 * Fires when a keyup event is detected on an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.event.Event} e The event object
                 */
                    'eventkeyup',
                    // Resizing events start --------------------------
                    /**
                 * @event beforeeventresize
                 * Fires before a resize starts, return false to stop the execution
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The record about to be resized
                 * @param {Ext.event.Event} e The event object
                 */
                    'beforeeventresize',
                    /**
                 * @event eventresizestart
                 * Fires when resize starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The event record being resized
                 */
                    'eventresizestart',
                    /**
                 * @event eventpartialresize
                 * Fires during a resize operation and provides information about the current start and end of the resized event
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The event record being resized
                 * @param {Date} startDate The new start date of the event
                 * @param {Date} endDate The new end date of the event
                 * @param {Ext.Element} element The proxy element being resized
                 */
                    'eventpartialresize',
                    /**
                 * @event beforeeventresizefinalize
                 * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
                 * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
                 * To finalize the operation, call the 'finalize' method available on the resizeContext object.
                 * @param {Mixed} view The scheduler view instance
                 * @param {Object} resizeContext An object containing 'eventRecord', 'start', 'end' and 'finalize' properties.
                 * @param {Ext.event.Event} e The event object
                 */
                    'beforeeventresizefinalize',
                    /**
                 * @event eventresizeend
                 * Fires after a succesful resize operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The updated event record
                 */
                    'eventresizeend',
                    // Resizing events end --------------------------
                    // Dnd events start --------------------------
                    /**
                 * @event beforeeventdrag
                 * Fires before a dnd operation is initiated, return false to cancel it
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
                 * @param {Ext.event.Event} e The event object
                 */
                    'beforeeventdrag',
                    /**
                 * @event eventdragstart
                 * Fires when a dnd operation starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records An array with the records being dragged
                 */
                    'eventdragstart',
                    /**
                 * @event eventdrag
                 * Fires when an event is dragged onto a new resource or time slot
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records An array with the records being dragged
                 * @param {Date} date The new start date of the main event record
                 * @param {Sch.model.Resource} resource The new resource for the main event record
                 * @param {Object} dragData A custom drag drop context object
                 */
                    'eventdrag',
                    /**
                 * @event beforeeventdropfinalize
                 * Fires before a succesful drop operation is finalized. Return false to finalize the drop at a later time.
                 * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
                 * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
                 * @param {Sch.feature.SchedulerDragZone} dragZone The scheduler dragzone. Scheduler view instance: dragZone.schedulerView.
                 * @param {Object} dragContext An object containing 'eventRecord', 'start', 'end', 'newResource', 'finalize' properties.
                 * @param {Ext.event.Event} e The event object
                 */
                    'beforeeventdropfinalize',
                    /**
                 * @event eventdrop
                 * Fires after a succesful drag-drop operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records the affected records (if copies were made, they were not inserted into the store)
                 * @param {Boolean} isCopy True if the records were copied instead of moved
                 */
                    'eventdrop',
                    /**
                 * @event aftereventdrop
                 * Fires after a drag-drop operation, even when drop was performed on an invalid location
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 */
                    'aftereventdrop',
                    // Dnd events end --------------------------
                    // Drag create events start --------------------------
                    /**
                 * @event beforedragcreate
                 * Fires before a drag starts, return false to stop the execution
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Resource} resource The resource record
                 * @param {Date} date The clicked date on the timeaxis
                 * @param {Ext.event.Event} e The event object
                 */
                    'beforedragcreate',
                    /**
                 * @event dragcreatestart
                 * Fires before a drag starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Ext.Element} el The proxy element
                 */
                    'dragcreatestart',
                    /**
                 * @event beforedragcreatefinalize
                 * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
                 * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
                 * To finalize the operation, call the 'finalize' method available on the createContext object.
                 * @param {Mixed} view The scheduler view instance
                 * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
                 * @param {Ext.event.Event} e The event object
                 * @param {Ext.Element} el The proxy element
                 */
                    'beforedragcreatefinalize',
                    /**
                 * @event dragcreateend
                 * Fires after a successful drag-create operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
                 * @param {Sch.model.Resource} resource The resource record to which the event belongs
                 * @param {Ext.event.Event} e The event object
                 * @param {Ext.Element} el The proxy element
                 */
                    'dragcreateend',
                    /**
                 * @event afterdragcreate
                 * Always fires after a drag-create operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Ext.Element} el The proxy element
                 */
                    'afterdragcreate',
                    // Drag create events end --------------------------
                    /**
                 * @event beforeeventadd
                 * Fires after a successful drag-create operation, before the new event is added to the store. Return false to prevent the event from being added to the store.
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The newly created event record
                 * @param {[Sch.model.Resource]} resources The resources to which the event is assigned
                 */
                    'beforeeventadd'
                ]);
                // enable our row height injection if the default extjs row height synching mechanism is disabled
                // (it is disabled by default in our Lockable mixin, because it's slow)
                if (!this.syncRowHeight)  {
                    this.enableRowHeightInjection(lockedView, normalView);
                }
                
            },
            configureColumns: function(columns) {
                var me = this;
                me.callParent(arguments);
                me.verticalColumns = me.verticalColumns || [
                    Ext.apply({
                        xtype: 'verticaltimeaxis'
                    }, me.timeAxisColumnCfg || {})
                ];
                Ext.Array.each(me.verticalColumns, function(col) {
                    Ext.apply(col, {
                        timeAxis: this.timeAxis,
                        timeAxisViewModel: this.timeAxisViewModel,
                        cellTopBorderWidth: this.cellTopBorderWidth,
                        cellBottomBorderWidth: this.cellBottomBorderWidth
                    });
                }, this);
                me.calendarColumns = [
                    Ext.apply({
                        xtype: 'verticaltimeaxis',
                        width: 60,
                        timeAxis: me.timeAxis,
                        timeAxisViewModel: me.timeAxisViewModel,
                        cellTopBorderWidth: me.cellTopBorderWidth,
                        cellBottomBorderWidth: me.cellBottomBorderWidth
                    }, me.calendarTimeAxisCfg || {})
                ];
                if (me.mode === 'vertical') {
                    me.columns = me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth));
                    me.store = me.timeAxis;
                    if (me.resourceStore.isGrouped()) {
                        me.timeAxis.group(me.resourceStore.groupField);
                        me.bindGroupingFeatureListener();
                    }
                } else if (me.mode === 'calendar') {
                    // in order to build columns/rows for calendar view we need time axis with view preset consumed
                    // but axis is filled only after columns are initialized thus can be changed only via 'reconfigure' method
                    // than requires grid to be rendered.
                    // We provide empty configs for columns and rows in order to make me procedure slightly faster
                    // There is almost no other way until timeaxis is filled before 'callParent' call.
                    me.columns = [];
                    me.store = null;
                    me.on('afterrender', me.refreshCalendarColumns, me);
                }
            },
            applyViewSettings: function(preset, initial) {
                this.callParent(arguments);
                var schedulingView = this.getSchedulingView(),
                    height;
                initial = initial || !this.rendered;
                if (this.orientation === 'vertical') {
                    // timeColumnWidth is used for row height in vertical mode
                    height = preset.timeColumnWidth || 60;
                    schedulingView.setColumnWidth(preset.resourceColumnWidth || 100, true);
                    schedulingView.setRowHeight(height, true);
                }
            },
            onRender: function() {
                // Adjust buffered rendering settings based on mode. See comments at function definition
                if (this.getMode() !== 'horizontal') {
                    this.reconfigureBufferedRendering(this.getMode(), true);
                }
                this.callParent(arguments);
            },
            afterRender: function() {
                var schedulingView = this.getSchedulingView();
                this.callParent(arguments);
                if (this.mode === 'vertical') {
                    this.onLockedViewResize(null, null, this.lockedGrid.getView().getHeight());
                } else if (this.mode === 'calendar') {
                    this.mon(this.timeAxis, this.calendarListeners);
                    this.normalGrid.on(this.normalGridListeners);
                }
                if (this.infiniteScroll) {
                    schedulingView.on({
                        eventdragstart: this.doSuspendLayouts,
                        aftereventdrop: this.doResumeLayouts,
                        eventresizestart: this.doSuspendLayouts,
                        eventresizeend: this.doResumeLayouts,
                        scope: this
                    });
                }
                if (this.lockedGridDependsOnSchedule) {
                    schedulingView.on('itemupdate', this.onNormalViewItemUpdate, this);
                }
                this.relayEvents(this.getEventSelectionModel(), [
                    /**
                     * @event eventselectionchange
                     * Fired after a selection change has occurred
                     * @param {Sch.selection.EventModel} this
                     * @param {Sch.model.Event[]} selected The selected events
                     */
                    'selectionchange',
                    /**
                     * @event eventdeselect
                     * Fired after a record is deselected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The deselected event
                     */
                    'deselect',
                    /**
                     * @event eventselect
                     * Fired after a record is selected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The selected event
                     */
                    'select'
                ], 'event');
            },
            getTimeSpanDefiningStore: function() {
                return this.eventStore;
            },
            destroy: function() {
                var me = this;
                me.destroyStores && Ext.destroyMembers(me, 'eventStore', 'resourceStore', 'assignmentStore', 'dependencyStore');
                me.callParent(arguments);
            },
            scrollToDateCentered: function(date, animate) {
                var view = this.getSchedulingView();
                if (view.isCalendar()) {
                    var column = view.calendar.getColumnsBy(function(column) {
                            return column.start <= date && column.end > date;
                        })[0];
                    if (column) {
                        var deltaX = view.getBox().width / 2;
                        var deltaY = view.getBox().height / 2;
                        view.scrollHorizontallyTo(Math.max(column.getLocalX() - deltaX, 0));
                        view.scrollVerticallyTo(Math.max(view.getCoordinateFromDate(date, true) - deltaY, 0));
                    }
                } else {
                    return this.callParent(arguments);
                }
            }
        };
    },
    doSuspendLayouts: function() {
        // if infinite scroll is set we want to resume layouts for short timespan when scheduler is being refreshed
        this.timeAxis.on({
            beginreconfigure: this.onBeginReconfigure,
            endreconfigure: this.onEndReconfigure,
            scope: this
        });
        this.lockedGrid.suspendLayouts();
        this.normalGrid.suspendLayouts();
    },
    doResumeLayouts: function() {
        this.timeAxis.un({
            beginreconfigure: this.onBeginReconfigure,
            endreconfigure: this.onEndReconfigure,
            scope: this
        });
        this.lockedGrid.resumeLayouts();
        this.normalGrid.resumeLayouts();
    },
    onBeginReconfigure: function() {
        this.normalGrid.resumeLayouts();
    },
    onEndReconfigure: function() {
        this.normalGrid.suspendLayouts();
    },
    onColWidthChange: function(timeAxisViewModel, width) {
        switch (this.getMode()) {
            case 'vertical':
                this.resourceColumnWidth = width;
                this.refreshResourceColumns();
                break;
            case 'calendar':
                this.calendarColumnWidth = width;
                this.refreshCalendarColumns();
                break;
        }
    },
    enableRowHeightInjection: function(lockedView, schedulingView) {
        var me = this;
        var cellTpl = new Ext.XTemplate('{%', 'this.processCellValues(values);', 'this.nextTpl.applyOut(values, out, parent);', '%}', {
                priority: 1,
                processCellValues: function(cellValues) {
                    if (schedulingView.mode === 'horizontal') {
                        var nbrBands = 1;
                        if (schedulingView.dynamicRowHeight) {
                            var resource = cellValues.record;
                            var layout = schedulingView.eventLayout.horizontal;
                            nbrBands = layout.getNumberOfBands(resource, function() {
                                return schedulingView.getEventStore().filterEventsForResource(resource, schedulingView.timeAxis.isRangeInAxis, schedulingView.timeAxis);
                            });
                        }
                        var rowHeight = (nbrBands * me.getRowHeight()) - ((nbrBands - 1) * schedulingView.barMargin) - schedulingView.cellTopBorderWidth - schedulingView.cellBottomBorderWidth;
                        cellValues.style = (cellValues.style || '') + ';height:' + rowHeight + 'px;';
                    }
                }
            });
        lockedView.addCellTpl(cellTpl);
        // this is a workaround, to force ExtJS grid to use "long" rendering path when doing cell updates
        // which involves the cell templates (which we had overrode)
        // w/o it, grid may use "fast" path and only update the cell content, leaving the row height unsynchronized
        Ext.Array.each(this.columns, function(column) {
            column.hasCustomRenderer = true;
        });
        // Use same workaround for horizontal columns as it's a config for future mode changes
        // ticket #2925
        Ext.Array.each(this.horizontalColumns, function(column) {
            column.hasCustomRenderer = true;
        });
        // HACK: on the `refresh` event from the store, we want the normal view to be refreshed first,
        // because refreshing it will also cache the events layout data. After that, the locked view will just reuse the
        // cached data, otherwise the layout data would be calculated twice
        var listeners = this.getView().getStoreListeners();
        listeners = Ext.apply({}, listeners);
        listeners.scope = this.getView();
        this.store.un(listeners);
        this.store.on(listeners);
    },
    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel: function() {
        return this.getSchedulingView().getEventSelectionModel();
    },
    refreshResourceColumns: function() {
        var w = this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth;
        // for vertical mode we only care about one vertical column and generated resource columns
        // this is not customizable
        this.reconfigure(this.verticalColumns.concat(this.createResourceColumns(w)));
    },
    onCalendarColumnResize: function(headerCt, column, width) {
        // Columns are not resizable individually, but we need to track their size to
        // adjust events accordingly in following cases:
        // 1: switching view preset with suspended layouts (e.g. when viewPreset is a binding in a viewmodel, #2641)
        // 2: panel is resized
        // tested by 40_calendar_basic
        if (width !== this.timeAxisViewModel.calendarColumnWidth) {
            this.timeAxisViewModel.setViewColumnWidth(width, true);
        }
        // this may produce an animation of events resizing, but it's most straightforwad approach
        this.getSchedulingView().calendar.repaintEventsForColumn(column, headerCt.columnManager.indexOf(column));
    },
    refreshCalendarColumns: function() {
        var rows = this.createCalendarRows();
        var columns = this.createCalendarColumns();
        this.reconfigure(rows, this.calendarColumns.concat(columns));
    },
    /**
     * Switches the orientation of this panel
     * @param {String} orientation Either "horizontal" or "vertical"
     * @deprecated
     */
    setOrientation: function() {
        this.setMode.apply(this, arguments);
    },
    // This method will disable grouping feature and hide all UI related to groups
    setGroupingFeatureDisabled: function(disabled) {
        var me = this,
            view = me.normalGrid.view;
        // We can only support our scheduler_gropuing feature, which will be stored by this reference
        if (!view.groupingFeature) {
            return;
        }
        // Feature is not shared between views, so it has to disabled on each one
        view.groupingFeature[disabled ? 'disable' : 'enable']();
        view = me.lockedGrid.view;
        view.groupingFeature[disabled ? 'disable' : 'enable']();
    },
    refreshGroupingStore: function() {
        var feature = this.normalGrid.view.groupingFeature;
        if (feature) {
            // Let grouping store know that time axis is reconfigured, otherwise view can be empty
            feature.dataSource.processStore(this.timeAxis);
        }
    },
    // When grid is configured with grouping feature, data source for each view will be replaced with grouping store,
    // which is bound to panel store. It will listen to datachanged event on panel store to update groups. But in vertical view
    // store is a time axis which will suspend all events except 'reconfigure'. So we have to listen to that to update
    // grouping store content
    bindGroupingFeatureListener: function() {
        // Set higher priority to refresh grouping store before view is refreshed
        this.mon(this.timeAxis, 'reconfigure', this.refreshGroupingStore, this, {
            priority: 10
        });
    },
    unbindGroupingFeatureListener: function() {
        this.mun(this.timeAxis, 'reconfigure', this.refreshGroupingStore);
    },
    /**
     * Switches the mode of this panel
     * @param {String} mode Either "horizontal", "vertical" or "calendar"
     */
    setMode: function(mode, force) {
        // This could be called too early during initComponent phase (by responsive mechanism in Ext JS)
        if (!this.normalGrid) {
            this.on('afterrender', function() {
                this.setMode(mode, true);
            });
            return;
        }
        if (mode === this.mode && !force) {
            return;
        }
        this.fireEvent('beforemodechange', this, mode);
        // calendar and vertical modes are similar, but we have to recognize them individually
        // in order to do that we consider sch-vertical as a main CSS for both,
        // sch-calendar for calendar and sch-vertical-resource for vertical
        switch (mode) {
            case 'horizontal':
                this.addCls('sch-horizontal');
                this.removeCls([
                    'sch-vertical',
                    'sch-calendar',
                    'sch-vertical-resource'
                ]);
                break;
            case 'vertical':
                this.addCls([
                    'sch-vertical-resource',
                    'sch-vertical'
                ]);
                this.removeCls([
                    'sch-calendar',
                    'sch-horizontal'
                ]);
                break;
            case 'calendar':
                this.addCls([
                    'sch-calendar',
                    'sch-vertical'
                ]);
                this.removeCls([
                    'sch-vertical-resource',
                    'sch-horizontal'
                ]);
                break;
        }
        this.mode = mode;
        var me = this,
            preventer = function() {
                return false;
            },
            normalGrid = me.normalGrid,
            lockedView = me.lockedGrid.getView(),
            schedulingView = me.getSchedulingView(),
            normalHeaderCt = normalGrid.headerCt;
        lockedView.on('beforerefresh', preventer);
        schedulingView.on('beforerefresh', preventer);
        schedulingView.blockRefresh = lockedView.blockRefresh = true;
        Ext.suspendLayouts();
        if (mode !== 'horizontal') {
            this.setGroupingFeatureDisabled(true);
        } else {
            this.setGroupingFeatureDisabled(false);
        }
        this.unbindGroupingFeatureListener();
        schedulingView.setMode(mode);
        normalHeaderCt.removeAll(true);
        this.reconfigureBufferedRendering(mode);
        // activate required manager
        if (mode !== 'calendar') {
            me.timeAxis.setMode('plain');
            // remove listeners to avoid refreshing calendar columns using wrong presets
            me.mun(me.timeAxis, me.calendarListeners);
            if (me._oldViewPreset) {
                me.setViewPreset.apply(me, me._oldViewPreset);
                delete me._oldViewPreset;
            }
        } else {
            me._oldViewPreset = [
                me.viewPreset,
                me.timeAxis.getStart(),
                me.timeAxis.getEnd()
            ];
            me.timeAxis.setMode('calendar');
            me.setViewPreset(me.calendarViewPreset);
            me.mon(me.timeAxis, me.calendarListeners);
        }
        if (mode === 'horizontal') {
            me.mun(me.resourceStore, me.verticalListeners);
            me.normalGrid.un(me.normalGridListeners);
            schedulingView.setRowHeight(me.rowHeight || me.timeAxisViewModel.rowHeightHorizontal, true);
            me.reconfigure(me.resourceStore, me.horizontalColumns);
            if (this.horizontalLockedWidth !== null) {
                this.lockedGrid.setWidth(this.horizontalLockedWidth);
            }
        } else if (mode === 'calendar') {
            // TODO: we want to save time span of the axis and restore it upon switching back
            me.mun(me.resourceStore, me.verticalListeners);
            me.normalGrid.on(me.normalGridListeners);
            me.bindGroupingFeatureListener();
            me.refreshCalendarColumns();
            schedulingView.setRowHeight(me.rowHeight || me.timeAxisViewModel.rowHeightVertical, true);
            schedulingView.setColumnWidth(me.timeAxisViewModel.calendarColumnWidth || 100, true);
        } else {
            me.normalGrid.un(me.normalGridListeners);
            var lockedWidth = 0;
            this.horizontalLockedWidth = this.lockedGrid.getWidth();
            me.mon(me.resourceStore, me.verticalListeners);
            me.bindGroupingFeatureListener();
            me.reconfigure(me.timeAxis, me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth)));
            Ext.Array.each(me.lockedGrid.query('gridcolumn'), function(col) {
                lockedWidth += col.rendered ? col.getWidth() : col.width || 100;
            });
            schedulingView.setColumnWidth(me.timeAxisViewModel.resourceColumnWidth || 100, true);
            me.lockedGrid.setWidth(lockedWidth);
        }
        var groupField = me.resourceStore.groupField;
        if (groupField) {
            me.store.group(groupField);
        }
        lockedView.un('beforerefresh', preventer);
        schedulingView.un('beforerefresh', preventer);
        schedulingView.blockRefresh = lockedView.blockRefresh = false;
        var splitter = this.getSplitter();
        if (splitter) {
            splitter.setVisible(mode === 'horizontal');
        }
        me.refreshViews(false);
        Ext.resumeLayouts(true);
        this.fireEvent('modechange', this, mode);
        this.fireEvent('orientationchange', this, mode);
    },
    // Disable buffered rendering mechanism for non-horizontal views using the time axis as the row-backing store input
    // https://app.assembla.com/spaces/bryntum/tickets/2956-scroll-not-working-properly-when-time-increment---15/details#
    reconfigureBufferedRendering: function(mode, initial) {
        if (this.bufferedRenderer) {
            var lockedPlugin = this.lockedGrid.bufferedRenderer,
                normalPlugin = this.normalGrid.bufferedRenderer,
                value;
            if (mode !== 'horizontal') {
                value = this.timeAxis.getCount();
                this.__oldLeadingBufferZone = lockedPlugin.leadingBufferZone;
            } else if (this.__oldLeadingBufferZone) {
                value = this.__oldLeadingBufferZone;
                this.__oldLeadingBufferZone = null;
            }
            if (!initial) {
                // HACK, this cached size property must be cleared when our mode changes
                var height = this.lockedGrid.view.getHeight(),
                    viewSize = Math.ceil(height / lockedPlugin.rowHeight) + lockedPlugin.trailingBufferZone + value;
                // Pass true as a second argument to force new calculated value
                lockedPlugin.setViewSize(viewSize, true);
                normalPlugin.setViewSize(viewSize, true);
            }
            lockedPlugin.leadingBufferZone = normalPlugin.leadingBufferZone = value;
        }
    },
    createCalendarRows: function() {
        var me = this,
            rows = me.timeAxis.getRowTicks();
        // we have to cache calendar rows amount to use it in timeAxisViewModel calculations
        me.timeAxisViewModel.calendarRowsAmount = rows.length;
        return new Ext.data.Store({
            model: 'Sch.model.TimeAxisTick',
            data: rows
        });
    },
    createCalendarColumns: function() {
        var me = this,
            currentHeader = me.timeAxis.headerConfig.middle,
            columns = [],
            lastDay;
        // iterate over ticks to find actual days in axis
        me.timeAxis.each(function(tick) {
            var start = tick.getStartDate();
            if (lastDay !== start.getDay()) {
                lastDay = start.getDay();
                start.setHours(me.startTime);
                var end = new Date(start);
                end.setHours(me.endTime);
                var header = {
                        xclass: me.calendarColumnClass,
                        renderer: me.mainRenderer,
                        scope: me,
                        start: start,
                        end: end
                    };
                if (currentHeader.renderer) {
                    header.text = currentHeader.renderer.call(currentHeader.scope || me, start, end, header, columns.length, me.getEventStore());
                } else {
                    header.text = Ext.Date.format(start, currentHeader.dateFormat);
                }
                columns.push(header);
            }
        });
        me.timeAxisViewModel.updateCalendarColumnDates(columns);
        return columns;
    },
    /**
     * Sets the row height of the timeline panel
     * @param {Number} height The height to set
     * @param {Boolean} preventRefresh `true` to prevent view refresh
     */
    setRowHeight: function(height, preventRefresh) {
        // Prevent any side effects if the panel is not yet done initializing
        preventRefresh = preventRefresh || !this.lockedGrid;
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },
    onNormalViewItemUpdate: function(record, index, oldRowEl) {
        if (this.lockedGridDependsOnSchedule) {
            var lockedView = this.lockedGrid.getView();
            lockedView.suspendEvents();
            // we cannot trust 'index' argument it may be wrong in case of grouping feature enabled
            lockedView.refreshNode(lockedView.indexOf(record));
            // Locked rowheight not properly updated when syncRowHeights is true and adding an overlapping event
            if (this.syncRowHeight) {
                this.syncRowHeights();
            }
            lockedView.resumeEvents();
        }
    },
    onLockedViewResize: function(cmp, width, height, oldWidth, oldHeight) {
        var mode = this.getMode();
        if ((mode === 'vertical' || mode === 'calendar') && height !== oldHeight) {
            // Grab the full height of the view, minus the spacer el height and an extra buffer
            this.timeAxisViewModel.update(height - 21);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.panel.SchedulerTree
@extends Sch.panel.TimelineTreePanel
@mixin Sch.mixin.SchedulerPanel

A complete scheduler panel using a tree view. This class can be used when you have a lot of resources organized in a hierarchical structure.

{@img scheduler/images/scheduler-tree.png}

Please refer to the {@link Sch.panel.SchedulerGrid} for additional documentation, as these classes
are virtually identical. This document will only provide the tree-specific details.

In the scheduler tree case:

- the `resourceStore` is expected to be an instance of the {@link Sch.data.ResourceTreeStore}.
- the scheduler tree does not support vertical orientation.
- in your columns definition, you must include a column which will contain the tree itself (the `treecolumn` xtype):

        var schedulerTree = Ext.create('Sch.panel.SchedulerTree', {
            columns: [
                {
                    xtype       : 'treecolumn',

                    text        : 'Name',
                    width       : 200,
                    sortable    : true,
                    dataIndex   : 'Name'
                }
            ]
        });


*/
Ext.define("Sch.panel.SchedulerTree", {
    extend: "Sch.panel.TimelineTreePanel",
    mixins: [
        'Sch.mixin.SchedulerPanel',
        'Sch.view.dependency.Mixin'
    ],
    alias: [
        'widget.schedulertree'
    ],
    viewType: 'schedulergridview',
    setOrientation: function() {
        return this.setMode.apply(this, arguments);
    },
    setMode: function(mode) {
        if (mode !== 'horizontal') {
            Ext.Error.raise("Sch.panel.SchedulerTree only support horizontal mode");
        }
    },
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }
}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @class Gnt.panel.ResourceUtilization
 * @extends Sch.panel.SchedulerTree
 *
 * A UI table component showing the utilization levels for your resources. The resources are displayed in a summary list where each row can
 * be expanded to show the tasks assigned for the resource.
 *
 *
 * {@img gantt/images/utilizationpanel.png width="50%" height=""}
 *
 * To use this panel in your application, here's the most basic usage:
 *
 *
 *      new Ext.Viewport({
            layout : 'border',
            items  : [
                {
                    title            : 'Gantt chart',
                    xtype            : 'ganttpanel',
                    id               : 'gantt',
                    region           : 'center',
                    crudManager      : crudManager,
                    columnLines      : true,

                    startDate        : new Date(2010, 0, 18),
                    endDate          : new Date(2010, 1, 8),
                    viewPreset       : 'weekAndDayLetter',

                    columns          : [
                        {
                            xtype : 'namecolumn',
                            width : 200
                        }
                    ]
                },
                {
                    title                : 'Resource utilization',
                    xtype                : 'resourceutilizationpanel',
                    region               : 'south',
                    height               : 350,
                    partnerTimelinePanel : 'gantt'
                }
            ]
      });
 *
 *
 */
Ext.define('Gnt.panel.ResourceUtilization', {
    extend: 'Sch.panel.SchedulerTree',
    alias: 'widget.resourceutilizationpanel',
    requires: [
        'Gnt.data.ResourceUtilizationStore'
    ],
    uses: [
        'Ext.util.Format'
    ],
    enableDragCreation: false,
    enableEventDragDrop: false,
    eventResizeHandles: 'none',
    readOnly: true,
    rowHeight: 32,
    rowLines: true,
    eventBorderWidth: 0,
    columnLines: {
        useLowestHeader: true
    },
    variableRowHeight: false,
    syncRowHeight: false,
    lockedGridDependsOnSchedule: false,
    // No need for setting custom row heights
    enableRowHeightInjection: function() {},
    // No need to draw dependencies
    dependencyViewConfig: {
        drawDependencies: false
    },
    /**
     * Assignment unit (in %) less or equal to this value will be considered as under-utilization of a resource.
     * Such summary cells will be colored gray by default. If the total units assigned for a resource is between the under and over
     * intervals, the resource is considered to be optimally utilized (green).
     *
     * @cfg {Number} underUtilizationThreshold
     */
    underUtilizationThreshold: 99,
    /**
     * Assignment unit (in %) greater than this value will be considered as over-utilization of a resource
     * Such summary cells will be colored red by default. If the total units assigned for a resource is between the under and over
     * intervals, the resource is considered to be optimally utilized (green).
     *
     * @cfg {Number} overUtilizationThreshold
     */
    overUtilizationThreshold: 100,
    columns: [
        {
            xtype: 'treecolumn',
            flex: 1,
            resizable: false,
            sortable: false,
            renderer: function(v, meta, rec) {
                if (rec.isSurrogateResource()) {
                    return rec.getName();
                } else {
                    return rec.getTaskName();
                }
            }
        }
    ],
    /**
     * @hide
     * @cfg resourceStore
     */
    /**
     * @hide
     * @cfg eventStore
     */
    config: {
        /**
         * @cfg {Gnt.data.TaskStore} taskStore (required) The task store.
         *
         * The panel extracts resources and assignments from the provided task store and makes a new synthetic resource store
         * which in turn is used to generate the rows.
         * The new store is by default a {@link Gnt.data.ResourceUtilizationStore} instance (can be changed by {@link #resourceStoreClass} config)
         * having resources on the 1st level and corresponding assigned tasks on the 2nd level.
         * Please note that both `getStore` and {@link #getResourceStore} methods return reference to the same synthetic store built based on the provided one.
         */
        taskStore: null,
        /**
         * @cfg {String} numberFormat
         *
         * Utilization cell number format
         */
        numberFormat: '0'
    },
    resourceStoreClass: 'Gnt.data.ResourceUtilizationStore',
    viewConfig: {
        markDirty: false,
        dynamicRowHeight: false,
        getRowClass: function(record) {
            return record.data.leaf ? 'gnt-utilizationrow-task' : 'gnt-utilizationrow-resource';
        }
    },
    eventBodyTemplate: [
        '<tpl for=".">',
        '<div class="gnt-resource-utilization-interval gnt-resource-utilization-interval-{status} {cls}" style="{dir}: {position}px; width: {width}px;{style}"',
        'data-utilization-interval-start="{startTime}"',
        'data-utilization-interval-end="{endTime}">',
        '{value}' + '</div>',
        '</tpl>'
    ].join(''),
    lockedGridConfig: {
        width: 200
    },
    /**
     * @cfg {Function} utilizationBarRenderer
     * This function is called each time a utilization bar is rendered. It's called with the allocation info for the resource time slot, the resource and an
     * object containing meta data about allowing you to customize add inline style, a CSS class .
     *
     * <pre>
     *  utilizationBarRenderer : function (allocationInfo, resource, intervalStart, intervalEnd, metaData) {
    *      metaData.style = 'color:white';        // You can use inline styles too.
    *      metaData.cls   = 'some-css-class';     // Set a CSS class to style the event
    *  }
     *</pre>
     * @param {Object}  allocationInfo
     * @param {Boolean} allocationInfo.isUtilized
     * @param {Number}  allocationInfo.allocationMs
     * @param {Number}  allocationInfo.allocationDeltaMs
     * @param {Boolean} allocationInfo.isOverallocated
     * @param {Boolean} allocationInfo.isUnderallocated
     * @param {Sch.model.Resource} resourceRecord The resource row in which the event is being created
     * @param {Date} startDate The interval start date
     * @param {Date} endDate The interval end date
     * @param {Object} metaData An object where you can set 'style' and 'cls' properties to style the bar
     */
    utilizationBarRenderer: null,
    /**
     * @cfg {Object} utilizationBarRendererScope The 'scope' (the 'this' object) for the {@link #utilizationBarRenderer} method
     */
    utilizationBarRendererScope: null,
    initComponent: function() {
        var me = this;
        me.eventRendererScope = me;
        me.setupComponentStores();
        me.callParent(arguments);
        me.addCls('gnt-resourceutilizationpanel');
        me.provideTimeAxisToStore();
        if (me.partnerTimelinePanel && Ext.isFunction(me.partnerTimelinePanel.getTaskStore)) {
            me.resourceStore.setTaskStore(me.partnerTimelinePanel.getTaskStore());
        }
        me.resourceStore.fillStore();
    },
    //me.on({
    //    scope               : me,
    //    'beforeeventdrag'   : me.onBeforeSurrogateEventDrag,
    //    'beforeeventresize' : me.onBeforeSurrogateEventResize
    //});
    setupComponentStores: function() {
        var me = this;
        me.resourceStore = me.resourceStore || Ext.create(me.resourceStoreClass, {
            underUtilizationThreshold: this.underUtilizationThreshold,
            overUtilizationThreshold: this.overUtilizationThreshold,
            taskStore: me.getTaskStore()
        });
        me.eventStore = me.resourceStore.getEventStore();
    },
    provideTimeAxisToStore: function() {
        var me = this;
        me.getStore().setTimeAxis(me.timeAxis);
    },
    eventRenderer: function(surrogateEvent, surrogateResource, meta) {
        var EUF = Ext.util.Format,
            me = this,
            view = me.getSchedulingView(),
            startDate = surrogateEvent.getStartDate(),
            msPerHour = 60 * 60 * 1000,
            numberFormat = me.getNumberFormat(),
            result = [],
            eventLeft, divLeft, divRight, statusCls,
            rendererScope = this.utilizationBarRendererScope || this;
        eventLeft = view.getCoordinateFromDate(startDate);
        surrogateEvent.forEachInterval(function(intervalStartDate, intervalEndDate) {
            var resourceUtilizationInfo = surrogateEvent.getUtilizationInfoForInterval(intervalStartDate),
                value = EUF.number(resourceUtilizationInfo.allocationMs / msPerHour, numberFormat),
                metaData = {};
            divLeft = view.getCoordinateFromDate(intervalStartDate);
            divRight = view.getCoordinateFromDate(intervalEndDate) - 1;
            if (!resourceUtilizationInfo.isUtilized) {
                statusCls = 'notutilized';
            } else if (resourceUtilizationInfo.isUnderallocated) {
                statusCls = 'underallocated';
            } else if (resourceUtilizationInfo.isOverallocated) {
                statusCls = 'overallocated';
            } else {
                statusCls = 'optimallyallocated';
            }
            if (me.utilizationBarRenderer) {
                me.utilizationBarRenderer.call(rendererScope, resourceUtilizationInfo, surrogateResource, intervalStartDate, intervalEndDate, metaData);
            }
            result.push({
                status: statusCls,
                dir: me.rtl ? 'right' : 'left',
                position: divLeft - eventLeft,
                width: divRight - divLeft,
                startTime: intervalStartDate.getTime(),
                endTime: intervalEndDate.getTime(),
                value: (divRight - divLeft > 10 ? value : ''),
                style: metaData.style || '',
                cls: metaData.cls || ''
            });
        });
        return result;
    },
    // Deny surrogate summary dragging
    //onBeforeSurrogateEventDrag : function (me, surrogateEvent) {
    //    return surrogateEvent.isSurrogateAssignment();
    //},
    // Deny surrogate summary resizing
    //onBeforeSurrogateEventResize : function (me, surrogateEvent) {
    //    return surrogateEvent.isSurrogateAssignment();
    //},
    // Don't read from timeAxisViewModel in case it's shared
    getRowHeight: function() {
        return this.rowHeight;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Sch.panel.SchedulerGrid
@extends Sch.panel.TimelineGridPanel
@mixin Sch.mixin.SchedulerPanel

@alternateClassName Sch.SchedulerPanel

A scheduler panel based on the {@link Ext.grid.Panel} class which allows you to visualize and manage "resources" and their scheduled "events".

Please refer to the <a href="#!/guide/scheduler_getting_started">getting started guide</a> for a detailed introduction.

{@img scheduler/images/ext-scheduler.png}

*/
Ext.define("Sch.panel.SchedulerGrid", {
    extend: "Sch.panel.TimelineGridPanel",
    mixins: [
        'Sch.mixin.SchedulerPanel',
        'Sch.view.dependency.Mixin'
    ],
    alias: [
        'widget.schedulergrid',
        'widget.schedulerpanel'
    ],
    alternateClassName: 'Sch.SchedulerPanel',
    viewType: 'schedulergridview',
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }
}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.panel.TimelineScheduler
@extends Sch.panel.SchedulerGrid

A class implementing a __project timeline__ panel, a special view that visualizes only key tasks and milestones.
It might be useful to see a high level project overview without extra unneeded details.

The panel retrieves tasks to show from the provided {@link #taskStore task store}. It shows only tasks that have the `ShowInTimeline` field set to `true`:

    var taskStore = new Gnt.data.TaskStore({
        root : {
            expanded : true,
            children : [
                // this task will be seen in the project timeline panel
                { Name : "Task 1", StartDate : "2015-08-05", Duration : 2, ShowInTimeline : true }
                // ..and this one won't
                { Name : "Task 2", StartDate : "2015-08-05", Duration : 1 }
            ]
        }
    })

    var timelinePanel = Ext.create("Gnt.panel.TimelineScheduler", {
        taskStore     : taskStore
    });

* **Note:** To show/hide tasks in the timeline, there is a special Gantt chart column {@link Gnt.column.ShowInTimeline}.

{@img gantt/images/timeline-scheduler-panel.png}
 */
Ext.define("Gnt.panel.TimelineScheduler", {
    extend: 'Sch.panel.SchedulerGrid',
    requires: [
        'Ext.data.StoreManager',
        'Sch.data.ResourceStore',
        'Sch.data.EventStore'
    ],
    alias: 'widget.gantt_timelinescheduler',
    /**
     * @cfg {Gnt.data.TaskStore} taskStore (required) The {@link Gnt.data.TaskStore store} holding the tasks.
     * The store is tracked to display tasks having `ShowInTimline` field set to `true`.
     */
    taskStore: null,
    split: false,
    /**
     * @cfg resourceStore
     * @hide
     */
    /**
     * @cfg eventStore
     * @hide
     */
    /**
     * @cfg {Number} milestoneBottomPadding Space in the bottom of the panel to leave
     * for milestones to extend outside the row.
     */
    milestoneBottomPadding: 23,
    barMargin: 0,
    header: false,
    enableColumnMove: false,
    enableColumnHide: false,
    enableColumnResize: false,
    sortableColumns: false,
    trackMouseOver: false,
    bufferedRenderer: false,
    border: false,
    rowLines: false,
    columnLines: false,
    readOnly: true,
    resizeHandles: 'none',
    enableDragCreation: false,
    enableEventDragDrop: false,
    forceFit: true,
    autoAdjustTimeAxis: false,
    leftTimespanMargin: 25,
    rightTimespanMargin: 50,
    resourceStoreClass: 'Sch.data.ResourceStore',
    eventStoreClass: 'Sch.data.EventStore',
    refreshMainRowTimeout: 5,
    needToZoom: false,
    destroyStores: true,
    variableRowHeight: false,
    syncRowHeight: false,
    lockedGridDependsOnSchedule: false,
    initComponent: function() {
        var me = this;
        me.addCls('sch-gantt-timeline-scheduler');
        me.setTaskStore(this.taskStore);
        Ext.apply(me, {
            // override few normal grid view methods
            normalViewConfig: {
                onEventUpdate: Ext.Function.bind(me.onEventUpdate, me),
                onEventAdd: Ext.Function.bind(me.onEventAdd, me),
                onEventRemove: Ext.Function.bind(me.onEventRemove, me)
            },
            resourceStore: me.buildResourceStore(),
            eventStore: me.buildEventStore(),
            // repeating refreshMainRow calls will be swallowed during refreshMainRowTimeout milliseconds
            refreshMainRow: Ext.Function.createBuffered(me.refreshMainRow, me.refreshMainRowTimeout, me)
        });
        var root = me.taskStore.getRoot();
        if (root && root.childNodes.length) {
            // wait till the 1st layout happen to make sure the panel has width fullfilled
            me.on({
                afterlayout: me.fillStoreFromTaskStore,
                scope: me,
                single: true
            });
        }
        me.callParent(arguments);
        me.on('resize', me.onSchedResize, me);
        me.resourceRecord = me.resourceStore.first();
        // HACK prevent scheduler from considering milestones when calculating number of bands to use for the
        // event bars - since milestones are put at the bottom.
        var view = me.getSchedulingView(),
            horizontal = view.eventLayout.horizontal,
            oldLayoutFn = horizontal.applyLayout;
        horizontal.applyLayout = function(events, resource) {
            events = Ext.Array.filter(events, function(ev) {
                return ev.event.getDuration() > 0;
            });
            return oldLayoutFn.call(this, events, resource);
        };
        // EOF HACK
        this.registerRenderer(this.rowHeightRenderer, this);
    },
    setTaskStore: function(taskStore, prevTaskStore) {
        var me = this;
        var listeners = {
                load: me.fillStoreFromTaskStore,
                nodeappend: me.onTaskAdded,
                update: me.onTaskUpdated,
                noderemove: me.onTaskRemoved,
                clear: me.onTaskStoreClear,
                scope: me
            };
        prevTaskStore && me.mun(prevTaskStore, listeners);
        taskStore = Ext.data.StoreManager.lookup(taskStore);
        me.mon(taskStore, listeners);
        me.taskStore = taskStore;
        return taskStore;
    },
    buildResourceStore: function(config) {
        return Ext.create(this.resourceStoreClass, Ext.apply({
            storeId: null,
            data: [
                {
                    Id: 1
                }
            ]
        }, config));
    },
    buildEventStore: function(config) {
        return Ext.create(this.eventStoreClass, Ext.apply({
            storeId: null,
            // Since we will fill the store with Tasks instead of events and we work without assignment store
            // we have to disable resource events cache because it is designed to work with Events only
            createResourceEventsCache: Ext.emptyFn,
            filterEventsForResource: function() {
                return Ext.Array.filter(this.getRange(), function(event) {
                    return event.isScheduled();
                });
            },
            getEventsForResource: function() {
                return this.getRange();
            },
            isDateRangeAvailable: function(start, end, excludeEvent, resource) {
                if (!start || !end)  {
                    return true;
                }
                
                var DATE = Sch.util.Date,
                    events = this.getRange(),
                    available;
                for (var i = 0,
                    l = events.length; i < l; i++) {
                    var ev = events[i];
                    available = (excludeEvent === ev || ev.getDuration() === 0 || !ev.getStartDate() || !ev.getEndDate() || !DATE.intersectSpans(start, end, ev.getStartDate(), ev.getEndDate()));
                    // stop looping if interval is occupied by a non excluding event
                    if (!available)  {
                        break;
                    }
                    
                }
                return available;
            }
        }, config));
    },
    refreshMainRow: function(forceZoomToFit) {
        // if we need to zoom
        if (forceZoomToFit || this.needToZoom) {
            this.zoomToFit();
        } else {
            this.getSchedulingView().repaintEventsForResource(this.resourceRecord);
            this.fitEvents();
        }
    },
    eventRenderer: function(ev, resource, meta) {
        if (ev.store.isDateRangeAvailable(ev.getStartDate(), ev.getEndDate(), ev, resource)) {
            meta.cls = 'sch-gantt-timeline-stretch';
        }
        if (!ev.isMilestone()) {
            meta.style = 'line-height:' + meta.height + 'px;';
        }
        return ev.getName();
    },
    // Just a simple renderer to set the row height
    rowHeightRenderer: function(v, meta) {
        meta.style = 'height:' + this.getAvailableRowHeight() + 'px';
    },
    onTaskStoreClear: function() {
        this.eventStore.removeAll();
    },
    onTaskRemoved: function(store, removedNode, isMove) {
        if (!isMove) {
            this.eventStore.remove(removedNode);
            // Clear any child nodes too
            Ext.Array.each(removedNode.childNodes || [], function(node) {
                this.onTaskRemoved(store, node);
            }, this);
        }
    },
    onTaskAdded: function(store, task) {
        if (!this.taskStore.isSettingRoot) {
            if (task.getShowInTimeline()) {
                this.eventStore.add(task);
            }
        }
    },
    // On a change in the task store we only check if ShowInTimeline flag is changed
    onTaskUpdated: function(store, task, operation, modifiedFields) {
        // if ShowInTimeline field was changed
        if (modifiedFields) {
            if (Ext.Array.contains(modifiedFields, task.showInTimelineField)) {
                if (task.getShowInTimeline()) {
                    this.eventStore.add(task);
                } else {
                    this.eventStore.remove(task);
                }
            }
        }
    },
    onEventAdd: function() {
        // check if timespan needs to be revalidated (if it's not detected already)
        if (!this.needToZoom) {
            var timespan = this.eventStore.getTotalTimeSpan();
            this.needToZoom = timespan.start < this.getStart() || timespan.end > this.getEnd();
        }
        this.refreshMainRow();
    },
    onEventRemove: function(store, tasks) {
        // check if timespan needs to be revalidated (if it's not detected already)
        if (!this.needToZoom) {
            var timespan = this.eventStore.getTotalTimeSpan();
            // check if timespan needs to be revalidated
            for (var i = 0; i < tasks.length; i++) {
                var task = tasks[i];
                if (timespan.start > task.getStartDate() || timespan.end < task.getEndDate()) {
                    this.needToZoom = true;
                    break;
                }
            }
        }
        this.refreshMainRow();
    },
    onEventUpdate: function(store, task, operation, modifiedFields) {
        var prev = task.previous,
            timespan = this.eventStore.lastTotalTimeSpan;
        // if task start/end has been changed
        if (modifiedFields) {
            // check if timespan needs to be revalidated (if it's not detected already)
            if (!this.needToZoom && prev && timespan && (task.startDateField in prev || task.endDateField in prev)) {
                // if the task an edge task..
                this.needToZoom = (task.startDateField in prev && timespan.start - prev[task.startDateField] === 0) || (task.endDateField in prev && timespan.end - prev[task.endDateField] === 0) || // ..or it just became an edge task
                (task.startDateField in prev && timespan.start > task.getStartDate()) || (task.endDateField in prev && timespan.end < task.getEndDate());
            }
            this.refreshMainRow();
        }
    },
    fillStoreFromTaskStore: function() {
        var timelineTasks = [],
            milestones = [];
        this.taskStore.forEachTaskUnordered(function(task) {
            if (task.getShowInTimeline()) {
                if (task.isMilestone()) {
                    milestones.push(task);
                } else {
                    timelineTasks.push(task);
                }
            }
        });
        // milestones go after other tasks to have them drawn above by default
        timelineTasks = timelineTasks.concat(milestones);
        this.eventStore.removeAll(true);
        if (timelineTasks.length || this.eventStore.getCount()) {
            var view = this.getSchedulingView();
            view.blockRefresh = true;
            this.eventStore.loadData(timelineTasks);
            view.blockRefresh = false;
            this.zoomToFit();
        }
    },
    zoomToFit: function() {
        // TODO: problem of this method it potentially causes double refresh:
        // 1st - because of zooming, 2nd - because of fitEvents() call (in case row height gets changed)
        this.suspendLayouts();
        // reset flag requiring zooming to be done
        this.needToZoom = false;
        this.callParent([
            {
                leftMargin: this.leftTimespanMargin,
                rightMargin: this.rightTimespanMargin
            }
        ]);
        // causes view refresh if row height is changed
        this.fitEvents();
        this.resumeLayouts();
    },
    onSchedResize: function(cmp, width, height, oldWidth, oldHeight) {
        if (height !== oldHeight) {
            this.fitEvents();
        }
    },
    fitEvents: function(cmp, width, height, oldWidth, oldHeight) {
        if (this.eventStore.getCount() > 0) {
            var nbrBands = this.getSchedulingView().eventLayout.horizontal.nbrOfBandsByResource[this.resourceRecord.internalId] || 1;
            // causes view refresh if row height is changed
            this.setRowHeight(Math.ceil(this.getAvailableRowHeight() / nbrBands));
        }
    },
    getAvailableRowHeight: function() {
        return this.getSchedulingView().getHeight() - this.milestoneBottomPadding;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.panel.Timeline
 @extends Ext.Panel

 A container for the {@link Gnt.panel.TimelineScheduler project timeline panel} instance. It shows a high level timeline of important tasks and includes labels
 with the timespan start and end dates. Using it with your Gantt chart is very simple:

     new Ext.Viewport({
         layout : 'border',
         items : [
             {
                 xtype       : 'advanced-timeline',
                 region      : 'north',
                 taskStore   : yourTaskStore
             },
             {
                 xtype       : 'ganttpanel',
                 region      : 'center',
                 taskStore   : yourTaskStore
             }
         ]
     });

 {@img gantt/images/timeline-panel.png}

 */
Ext.define("Gnt.panel.Timeline", {
    extend: 'Ext.Panel',
    requires: [
        'Ext.form.field.Display',
        'Gnt.panel.TimelineScheduler'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.gantt_timeline',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    bodyPadding: '10 0 20 0',
    height: 190,
    labelWidth: 100,
    taskStore: null,
    scheduler: null,
    /**
     * @cfg {String} schedulerClass The class name that will be instantiated as the timeline component.
     */
    schedulerClass: 'Gnt.panel.TimelineScheduler',
    initComponent: function() {
        this.addCls('sch-gantt-timeline');
        this.scheduler = Ext.create(this.schedulerClass, {
            taskStore: this.taskStore,
            flex: 1
        });
        this.scheduler.on('viewchange', this.onTimespanChange, this);
        this.items = this.buildItems();
        this.callParent(arguments);
    },
    buildItems: function() {
        return [
            {
                xtype: 'displayfield',
                fieldLabel: this.L('start'),
                labelAlign: 'top',
                itemId: 'startlabel',
                cls: 'sch-gantt-timeline-label sch-gantt-timeline-left-label',
                width: this.labelWidth
            },
            this.scheduler,
            {
                xtype: 'displayfield',
                fieldLabel: this.L('end'),
                labelAlign: 'top',
                itemId: 'endlabel',
                cls: 'sch-gantt-timeline-label sch-gantt-timeline-right-label',
                width: this.labelWidth
            }
        ];
    },
    getStartLabel: function() {
        return this.startLabel || (this.startLabel = this.down('#startlabel'));
    },
    getEndLabel: function() {
        return this.endLabel || (this.endLabel = this.down('#endlabel'));
    },
    onTimespanChange: function() {
        var start = this.scheduler.getStart();
        var end = this.scheduler.getEnd();
        this.getStartLabel().setValue(Ext.Date.format(start, this.L('format')));
        this.getEndLabel().setValue(Ext.Date.format(end, this.L('format')));
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?306174-Multiple-sources-do-not-really-work
Ext.define('Gnt.patches.AbstractClipboard', {
    extend: 'Sch.util.Patch',
    target: 'Ext.plugin.AbstractClipboard',
    minVersion: '6.0.0',
    overrides: {
        privates: {
            getData: function(erase, format) {
                var me = this,
                    formats = me.getFormats(),
                    data, i, name, names;
                if (Ext.isString(format)) {
                    if (!formats[format]) {
                        Ext.raise('Invalid clipboard format "' + format + '"');
                    }
                    data = me[formats[format].get](format, erase);
                } else {
                    data = {};
                    names = [];
                    if (format) {
                        for (name in format) {
                            if (!formats[name]) {
                                Ext.raise('Invalid clipboard format "' + name + '"');
                            }
                            names.push(name);
                        }
                    } else {
                        names = Ext.Object.getAllKeys(formats);
                    }
                    for (i = names.length; i-- > 0; ) {
                        name = names[i];
                        data[name] = me[formats[name].get](name, erase && !i);
                    }
                }
                return data;
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?324990-Ext-grid-column-Check-not-checking-presence-of-config-variable
Ext.define('Gnt.patches.CheckColumn', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.column.Check',
    minVersion: '6.2.0',
    overrides: {
        constructor: function(config) {
            this.callParent([
                config || {}
            ]);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?305411-Tabbing-in-grid-picker-stops-editing
Ext.define('Gnt.patches.ComponentManager', {
    extend: 'Sch.util.Patch',
    target: 'Ext.ComponentManager',
    minVersion: '6.0.0',
    applyFn: function() {
        Ext.ComponentManager.onGlobalFocus = function(e) {
            var me = this,
                toElement = e.toElement,
                fromElement = e.fromElement,
                toComponent = Ext.Component.fromElement(toElement),
                fromComponent = Ext.Component.fromElement(fromElement),
                commonAncestor = me.getCommonAncestor(fromComponent, toComponent),
                event, targetComponent;
            if (fromComponent && !(fromComponent.destroyed || fromComponent.destroying)) {
                if (fromComponent.handleBlurEvent) {
                    fromComponent.handleBlurEvent(e);
                }
                // Call onFocusLeave on the component axis from which focus is exiting
                for (targetComponent = fromComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
                    // Sencha set refreshing flag so that onFocusLeave caused by removing a focused element
                    // does not exit actionableMode. This can happen is following scenario:
                    // 1) editor is closed (to be moved, or to stop editing)
                    // 2) editor element is removed from dom -> focus event happens
                    // 3) component manager get component that lost it's focus and start traversing its parents
                    // and call 'onFocusLeave' on them
                    // 4) grid picker knows, that he shouldn't stop editing on that particular event because
                    // of the special flag
                    // 5) but component manager goes further and at some point it'll reach another editor
                    // which doesn't know about it's grid picker child (this is what sencha meant by 'not really
                    // supported' I guess) and it'll complete edit
                    //
                    // ancestor tree is like
                    // numberfield -> editor -> view -> panel -> assignmentfield -> editor -> treeview -> lockedgrid....
                    // Idea behind that fix is simple - if any view has 'refreshing' flag during focus leave, we should
                    // stop focus event.
                    // covered by test 068_assignment_crud
                    // https://www.sencha.com/forum/showthread.php?305411-Tabbing-in-grid-picker-stops-editing
                    // Let's reduce cases to only one we need - assignmentgrid
                    if (targetComponent instanceof Gnt.widget.AssignmentGrid && // focus event can happen in many cases, we need only one when view has this flag
                    targetComponent.view.refreshing && // this is not really necessary, but let's reduce our fix even more
                    targetComponent.getRefOwner() instanceof Gnt.field.Assignment) {
                        break;
                    }
                    if (!(targetComponent.destroyed || targetComponent.destroying)) {
                        targetComponent.onFocusLeave({
                            event: e.event,
                            type: 'focusleave',
                            target: fromElement,
                            relatedTarget: toElement,
                            fromComponent: fromComponent,
                            toComponent: toComponent
                        });
                    }
                }
            }
            if (toComponent && !toComponent.destroyed) {
                if (toComponent.handleFocusEvent) {
                    toComponent.handleFocusEvent(e);
                }
                // Call onFocusEnter on the component axis to which focus is entering
                for (targetComponent = toComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
                    targetComponent.onFocusEnter({
                        event: e.event,
                        type: 'focusenter',
                        relatedTarget: fromElement,
                        target: toElement,
                        fromComponent: fromComponent,
                        toComponent: toComponent
                    });
                }
            }
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?305868-Ext.util.TSV-decode-goes-infinite-loop
Ext.define('Gnt.patches.DelimitedValue', {
    extend: 'Sch.util.Patch',
    target: 'Ext.util.DelimitedValue',
    minVersion: '6.0.0',
    overrides: {
        decode: function(input) {
            if (input === "") {
                return [];
            }
            return this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// When input is hidden using vibility : hidden, or display : none focus goes to secondary canvas
// and produces exception, because navigation model cannot resolve position
// Caught by test 1200_label_editing
// Fiddle: https://fiddle.sencha.com/#fiddle/srg
Ext.define('Gnt.patches.LabelEditor', {
    extend: 'Sch.util.Patch',
    target: 'Gnt.feature.LabelEditor',
    minVersion: '6.0.0',
    // Fixed in nightlies from 19.08
    maxVersion: '6.0.1',
    ieOnly: true,
    overrides: {
        constructor: function() {
            this.callParent(arguments);
            if (this.rendered) {
                this.getEl().setVisibilityMode(Ext.dom.Element.OFFSETS);
            } else {
                this.on('render', function() {
                    this.getEl().setVisibilityMode(Ext.dom.Element.OFFSETS);
                }, this, {
                    single: true
                });
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.patches.SelectionExtender', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SelectionExtender',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                // prevent selection extending to normal view
                onDrag: function(e) {
                    if (!Ext.fly(e.getTarget()).up('.sch-ganttview')) {
                        this.callParent(arguments);
                    }
                }
            };
        if (Ext.getVersion().isLessThan('6.0.1')) {
            // fixes bug that is reproducible in this fiddle: https://fiddle.sencha.com/#fiddle/102p
            // select row #3 and click 'remove'
            overrides.setHandle = function(firstPos, lastPos) {
                firstPos && firstPos.record && lastPos && lastPos.record && this.callParent(arguments);
            };
        }
        Ext.ClassManager.get(this.target).override(overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?300781
Ext.define('Gnt.patches.Tooltip', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tip.ToolTip',
    minVersion: '5.1.0',
    overrides: {
        onDocMouseDown: function() {
            if (this.isDisabled()) {
                return;
            }
            this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Adds clipboard support to a gantt panel.
 *
 * *Note that the grid must use the {@link Ext.grid.selection.SpreadsheetModel spreadsheet selection model} to utilize this plugin.*
 *
 * This class supports the following `{@link #formats formats}`
 * for grid data:
 *
 *  * `text` - Cell content stripped of HTML tags. Data from clipboard cannot be pasted into gantt in this format.
 *  * `raw` - Underlying field values based on `dataIndex`. Alternatively you can define getRawData/putRawData on
 *  column class to implement any special logic for copying/pasting complex values. For example refer to
 *  {@link Gnt.column.ResourceAssignment#getRawData} and {@link Gnt.column.ResourceAssignment#putRawData}
 *
 * Only `text` format is valid for the `{@link Ext.grid.plugin.Clipboard#system system}`
 * clipboard format.
 */
Ext.define('Gnt.plugin.Clipboard', {
    extend: 'Ext.grid.plugin.Clipboard',
    alias: 'plugin.gantt_clipboard',
    requires: [
        'Gnt.patches.DelimitedValue',
        'Gnt.patches.AbstractClipboard'
    ],
    memory: 'raw',
    formats: {
        raw: {
            get: 'getRawData',
            put: 'putRawData'
        }
    },
    // TODO: implement conversion from visible value to data value
    putTextData: function(data, format) {
        return;
    },
    /**
     * Will copy raw values to clipboard
     * @param {String} format Value of {@link #source} config
     * @param {Boolean} erase When true, values in original record will be replaced with field defaults
     */
    getRawData: function(format, erase) {
        var me = this,
            selModel = me.getCmp().getSelectionModel(),
            ret = [],
            isRaw = format === 'raw',
            isText = format === 'text',
            lastRecord, row;
        // Embed info about what is being copied
        ret.schedulingFields = {};
        selModel.getSelected().eachCell(function(cellContext) {
            var column = cellContext.column,
                view = cellContext.column.getView(),
                record = cellContext.record,
                dataIndex = column.dataIndex,
                data;
            // Ignore columns that we don't want to/cannot copy (check column, row numberer, AddNew, dragcolumn etc.)
            if (!me.isColumnCopyPasteable(column, format)) {
                return;
            }
            // if new record cells started
            if (lastRecord !== record) {
                lastRecord = record;
                // start new row array
                ret.push(row = []);
            }
            // Start/End/Duration columns might need special treatment when pasting so we mark if they copied
            // We need to do it only for the first row
            if (ret.length < 2) {
                if (Gnt.column.StartDate && column instanceof Gnt.column.StartDate) {
                    ret.schedulingFields.startDate = 1;
                } else if (Gnt.column.EndDate && column instanceof Gnt.column.EndDate) {
                    ret.schedulingFields.endDate = 1;
                } else if (Gnt.column.Duration && column instanceof Gnt.column.Duration) {
                    ret.schedulingFields.duration = 1;
                }
            }
            if (isRaw) {
                if (column.getRawData) {
                    data = column.getRawData(record);
                } else if (dataIndex) {
                    data = record.data[dataIndex];
                }
            } else {
                // Try to access the view node.
                var viewNode = view.all.item(cellContext.rowIdx);
                // If we could not, it's because it's outside of the rendered block - recreate it.
                if (!viewNode) {
                    viewNode = Ext.fly(view.createRowElement(record, cellContext.rowIdx));
                }
                var cell = viewNode.down(column.getCellInnerSelector());
                data = cell.dom.innerHTML;
                if (isText) {
                    data = Ext.util.Format.stripTags(data);
                }
            }
            row.push(data);
            if (erase && dataIndex) {
                record.set(dataIndex, record.getField(dataIndex).getDefaultValue());
            }
        });
        return ret;
    },
    getCellData: function(format, erase) {
        return Ext.util.TSV.encode(this.getRawData(format, erase));
    },
    // @private
    // Returns if the provided column can be copied or pasted in the provided format
    isColumnCopyPasteable: function(column, format) {
        return !column.ignoreExport && (format != 'raw' || column.dataIndex || column.getRawData);
    },
    /**
     * Will paste values from clipboard
     * @param {Object} data Data to paste
     * @param {String} format Value of {@link #source} config. If clipboard contain some data for few formats - will
     * be called few times during one paste
     */
    putRawData: function(data, format) {
        var me = this,
            recCount = data.length,
            view = this.getCmp().getView(),
            maxRowIdx = view.dataSource.getCount() - 1,
            maxColIdx = view.getVisibleColumnManager().getColumns().length - 1,
            navModel = view.getNavigationModel(),
            destination = navModel.getPosition(),
            sourceColIdx, dataIndex, destinationStartColumn, currentColumn, currentValue, dataObject, field, start, end;
        if (!destination || this.getCmp().isReadOnly())  {
            return;
        }
        
        destination = new Ext.grid.CellContext(view).setPosition(destination.record, destination.column);
        destinationStartColumn = destination.colIdx;
        for (var sourceRowIdx = 0; sourceRowIdx < recCount; sourceRowIdx++) {
            var row = data[sourceRowIdx];
            var targetTask = destination.record;
            dataObject = {};
            // skip target record if it's read only
            if (targetTask.isReadOnly())  {
                
                continue;
            }
            
            // Collect new values in dataObject
            for (sourceColIdx = 0; destination.colIdx < maxColIdx && sourceColIdx < row.length; ) {
                currentColumn = destination.column;
                currentValue = row[sourceColIdx];
                // Ignore columns that we don't want to/cannot copy (check column, row numberer, AddNew, dragcolumn etc.)
                if (me.isColumnCopyPasteable(currentColumn, format)) {
                    var skip;
                    if (data.schedulingFields.startDate && data.schedulingFields.endDate) {
                        skip = currentColumn.fieldProperty === 'durationField' || currentColumn.fieldProperty === 'startDateField' || currentColumn.fieldProperty === 'endDateField';
                        if (currentColumn.fieldProperty === 'startDateField')  {
                            start = currentValue;
                        }
                        
                        if (currentColumn.fieldProperty === 'endDateField')  {
                            end = currentValue;
                        }
                        
                    }
                    dataIndex = currentColumn.dataIndex;
                    if (!skip) {
                        if (currentColumn.putRawData) {
                            currentColumn.putRawData(currentValue, destination.record);
                        } else if (dataIndex && dataIndex !== 'index') {
                            field = currentColumn.field;
                            if (field) {
                                if (!field.getErrors(currentValue).length) {
                                    dataObject[dataIndex] = currentValue;
                                }
                            } else {
                                dataObject[dataIndex] = currentValue;
                            }
                        }
                    }
                    sourceColIdx++;
                }
                // If we are at the end of the destination row, break the column loop.
                if (destination.colIdx === maxColIdx) {
                    break;
                }
                destination.setColumn(destination.colIdx + 1);
            }
            targetTask.beginEdit();
            // Update the record in one go.
            targetTask.set(dataObject);
            // setting start + end, need to be done manually
            if (start !== undefined && end !== undefined) {
                targetTask.setStartEndDate(start, end);
            }
            targetTask.endEdit();
            // If we are at the end of the destination store, break the row loop.
            if (destination.rowIdx === maxRowIdx) {
                break;
            }
            // Jump to next row in destination
            destination.setPosition(destination.rowIdx + 1, destinationStartColumn);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.plugin.DependencyEditor
 @extends Ext.form.Panel

 {@img gantt/images/dependency-editor.png}

 A plugin (ptype = 'gantt_dependencyeditor') which shows the dependency editor panel, when a user double-clicks a dependency line or arrow.

 To customize the fields created by this plugin, override the `buildFields` method.

 You can add it to your gantt chart like this:

 var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create("Gnt.plugin.DependencyEditor", {
                // default value
                hideOnBlur      : true
            })
        ],
        ...
    })


 */
Ext.define("Gnt.plugin.DependencyEditor", {
    extend: "Ext.form.Panel",
    alias: 'plugin.gantt_dependencyeditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_dependencyeditor',
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Filter',
        'Ext.form.field.Display',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Number',
        'Gnt.model.Dependency',
        'Ext.data.ArrayStore'
    ],
    /**
     * @cfg {Boolean} hideOnBlur True to hide this panel if a click is detected outside the panel (defaults to true)
     */
    hideOnBlur: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - fromText         : 'From',
        - toText           : 'To',
        - typeText         : 'Type',
        - lagText          : 'Lag',
        - endToStartText   : 'Finish-To-Start',
        - startToStartText : 'Start-To-Start',
        - endToEndText     : 'Finish-To-Finish',
        - startToEndText   : 'Start-To-Finish',
        - okButtonText     : 'Ok',
        - cancelButtonText : 'Cancel',
        - deleteButtonText : 'Delete'
     */
    /**
     * @cfg {Boolean} showLag True to show the lag editor
     */
    showLag: false,
    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'dependencydblclick'.
     */
    triggerEvent: 'dependencydblclick',
    /**
     * @cfg {Boolean} constrain Pass `true` to enable the constraining - ie editor panel will not exceed the document edges. This option will disable the animation
     * during the expansion. Default value is `false`.
     */
    constrain: true,
    lockableScope: 'top',
    // 1. We don't use header at all, 2. IE8 takes the use of a header personal and dies in Ext 4.2.1. http://www.sencha.com/forum/showthread.php?271770-4.2.1-getFramingInfoCls-broken-in-IE8
    header: false,
    border: false,
    frame: true,
    labelWidth: 60,
    floating: true,
    hideMode: 'offsets',
    bodyPadding: 10,
    initComponent: function() {
        this.buttons = this.hasOwnProperty('buttons') ? this.buttons : (this.buttons || [
            {
                text: this.L('okButtonText'),
                itemId: 'okbutton',
                scope: this,
                handler: function() {
                    this.getForm().updateRecord(this.dependencyRecord);
                    this.collapse();
                }
            },
            {
                text: this.L('cancelButtonText'),
                itemId: 'cancelbutton',
                scope: this,
                handler: function() {
                    this.collapse();
                }
            },
            {
                text: this.L('deleteButtonText'),
                itemId: 'deletebutton',
                scope: this,
                handler: function() {
                    var dependencyStore = this.taskStore && this.taskStore.getDependencyStore();
                    dependencyStore.remove(this.dependencyRecord);
                    this.collapse();
                }
            }
        ]);
        this.callParent(arguments);
        this.saveButton = this.down('#okbutton');
        this.deleteButton = this.down('#deletebutton');
        this.addCls('sch-gantt-dependencyeditor');
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    init: function(cmp) {
        cmp.on(this.triggerEvent, this.onTriggerEvent, this);
        this.gantt = cmp;
        this.taskStore = cmp.getTaskStore();
        // Add fields late, when we have access to taskStore
        this.add(this.buildFields());
    },
    renderAndCollapse: function() {
        this.render(Ext.getBody());
        // Collapse after render, otherwise rendering is messed up
        this.collapse(Ext.Component.DIRECTION_TOP, false);
        this.hide();
        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.on({
                show: function() {
                    this.mon(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    });
                },
                hide: function() {
                    this.mun(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    });
                },
                delay: 50
            });
        }
    },
    /**
     * Expands the editor
     * @param {Gnt.model.Dependency} dependencyRecord The record to show in the editor panel
     * @param {Array} xy the coordinates where the window should be shown
     */
    show: function(dependencyRecord, xy) {
        this.dependencyRecord = dependencyRecord;
        // Load form panel fields
        this.getForm().loadRecord(dependencyRecord);
        this.fromLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getSourceTask().getName()));
        this.toLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getTargetTask().getName()));
        if (this.typeField) {
            var dependencyStore = this.taskStore && this.taskStore.getDependencyStore(),
                allowedTypes = dependencyStore && dependencyStore.allowedDependencyTypes;
            // filter out disabled dependency types
            this.typeField.store.filter();
            // if number of allowed dependency types is less 2 we won't allow to edit this field
            this.typeField.setReadOnly(allowedTypes && allowedTypes.length < 2);
        }
        this.callParent([]);
        this.el.setXY(xy);
        this.expand(!this.constrain);
        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()));
        }
        this.saveButton && this.saveButton.setVisible(!this.gantt.isReadOnly());
        this.deleteButton && this.deleteButton.setVisible(!this.gantt.isReadOnly());
    },
    /**
     * This method is being called during form initialization. It should return an array of fields, which will be assigned to the `items` property.
     * @return {Array}
     */
    buildFields: function() {
        var me = this,
            dependencyStore = me.taskStore && me.taskStore.getDependencyStore();
        var fields = [
                me.fromLabel = new Ext.form.TextField({
                    readOnly: true,
                    border: false,
                    fieldLabel: me.L('fromText'),
                    cls: 'sch-gantt-dependencyeditor-readonly'
                }),
                me.toLabel = new Ext.form.TextField({
                    readOnly: true,
                    border: false,
                    fieldLabel: me.L('toText'),
                    cls: 'sch-gantt-dependencyeditor-readonly'
                }),
                me.typeField = me.buildTypeField()
            ];
        if (me.showLag) {
            fields.push(me.lagField = new Ext.form.NumberField({
                name: dependencyStore ? dependencyStore.model.prototype.lagField : Gnt.model.Dependency.prototype.lagField,
                fieldLabel: me.L('lagText')
            }));
        }
        return fields;
    },
    onTriggerEvent: function(depView, record, e, t) {
        if (!this.rendered)  {
            this.renderAndCollapse();
        }
        
        if (record !== this.dependencyRecord) {
            this.show(record, e.getXY());
        }
    },
    filterAllowedTypes: function(record) {
        var dependencyStore = this.taskStore && this.taskStore.getDependencyStore();
        if (!dependencyStore || !dependencyStore.allowedDependencyTypes)  {
            return true;
        }
        
        var allowed = dependencyStore.allowedDependencyTypes;
        var depType = dependencyStore.model.Type;
        for (var i = 0,
            l = allowed.length; i < l; i++) {
            var type = depType[allowed[i]];
            if (record.getId() == type)  {
                return true;
            }
            
        }
        return false;
    },
    buildTypeField: function() {
        var depClass = this.taskStore ? this.taskStore.getDependencyStore().model : Gnt.model.Dependency;
        var depType = depClass.Type;
        this.typesFilter = new Ext.util.Filter({
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var store = new Ext.data.ArrayStore({
                fields: [
                    {
                        name: 'id',
                        type: 'int'
                    },
                    'text'
                ],
                data: [
                    [
                        depType.EndToStart,
                        this.L('endToStartText')
                    ],
                    [
                        depType.StartToStart,
                        this.L('startToStartText')
                    ],
                    [
                        depType.EndToEnd,
                        this.L('endToEndText')
                    ],
                    [
                        depType.StartToEnd,
                        this.L('startToEndText')
                    ]
                ]
            });
        store.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            name: depClass.prototype.typeField,
            fieldLabel: this.L('typeText'),
            triggerAction: 'all',
            queryMode: 'local',
            editable: false,
            valueField: 'id',
            displayField: 'text',
            store: store
        });
    },
    onMouseClick: function(e) {
        if (this.collapsed || e.within(this.getEl()) || // ignore the click on the menus and combo-boxes (which usually floats as the direct child of <body> and
        // leaks through the `e.within(this.getEl())` check
        e.getTarget('.' + Ext.baseCSSPrefix + 'layer') || // if clicks should be ignored for any other element - it should have this class
        e.getTarget('.sch-ignore-click')) {
            return;
        }
        this.collapse();
    },
    // Always hide drag proxy on collapse
    afterCollapse: function() {
        delete this.dependencyRecord;
        // Currently the header is kept even after collapse, so need to hide the form completely
        this.hide();
        this.callParent(arguments);
        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.mun(Ext.getBody(), 'click', this.onMouseClick, this);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.plugin.exporter.AbstractExporter
 @extends Ext.util.Observable

 This class represents the base implementation of an exporter.
 An exporter extracts the provided component content and packs it into array of pages (based on provided export settings and implemented algorithm).
 The main entry point for an exporter that launches the extraction process is {@link #extractPages} method:

             exporter.extractPages(component, config, function (pages) {

                alert(pages.length + " extracted");

                ...

             }, me);


*/
Ext.define('Sch.plugin.exporter.AbstractExporter', {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.XTemplate'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    /**
     * @cfg {Number} pageHeaderHeight
     * Header height. Amount of space for {@link #headerTpl the page header}.
     */
    pageHeaderHeight: 41,
    /**
     * @cfg {Number} pageFooterHeight
     * Footer height. Amount of space for {@link #footerTpl the page footer}.
     */
    pageFooterHeight: 41,
    bufferedHeightMargin: 25,
    /**
     * @property {Boolean} isExporter
     * @readonly
     * `true` in this class to identify an object as an instantiated Exporter, or subclass thereof.
     */
    isExporter: true,
    /**
     * @property {Number} paperWidth
     * Paper width. Calculated based on provided page format and DPI resolution.
     */
    paperWidth: 0,
    /**
     * @property {Number} paperHeight
     * Paper height. Calculated based on provided page format and DPI resolution.
     */
    paperHeight: 0,
    /**
     * @property {Number} printHeight
     * Paper height that can be used for printing rows. Calculated as {@link #paperHeight} minus header heights.
     */
    printHeight: 0,
    lockedRowsHeight: 0,
    normalRowsHeight: 0,
    iterateTimeout: 10,
    /**
     * @cfg {String} tableSelector
     * The selector for the row container used for both normalGrid and lockedGrid.
     */
    tableSelector: undefined,
    /**
     * @property {Ext.dom.Element} currentPage
     * Current page being extracted.
     */
    currentPage: undefined,
    /**
     * @cfg {Function} headerTplDataFn
     * If specified the function result will be applied to {@link #getHeaderTplData} result.
     * To define the scope please use {@link #headerTplDataFnScope}.
     */
    headerTplDataFn: null,
    /**
     * @cfg {Function} footerTplDataFn
     * If specified the function result will be applied to {@link #getFooterTplData} result.
     * To define the scope please use {@link #footerTplDataFnScope}.
     */
    footerTplDataFn: null,
    /**
     * @cfg {Object} headerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    headerTplDataFnScope: null,
    /**
     * @cfg {Object} footerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    footerTplDataFnScope: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - name    : 'Exporter'
     */
    config: {
        /**
         * @cfg {String} exporterId
         * Exporter identifier. Has to be unique among other exporters when you register in in {@link Sch.plugin.Export} instance.
         */
        exporterId: 'abstractexporter',
        /**
         * Exporter name. By default will be taken from the class {@link #l10n locale}.
         * @cfg {String}
         */
        name: '',
        translateURLsToAbsolute: true,
        expandAllBeforeExport: false,
        /**
         * @cfg {String} headerTpl
         * Template of an extracted page header.
         */
        headerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        /**
         * @cfg {String/Ext.XTemplate} tpl
         * Template of an extracted page.
         */
        tpl: '<!DOCTYPE html>' + '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' + '<head>' + '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' + '<title>{title}</title>' + '{styles}' + '</head>' + '<body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">' + '{header}' + '<div id="{id}" class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">' + '{HTML}' + '</div>' + '{footer}' + '</body>' + '</html>',
        /**
         * @cfg {String} footerTpl
         * Template of an extracted page footer.
         */
        footerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        // Row visibility detection threshold (0.6 - means that when 60% of a row height is visible we consider it as visible)
        rowVisibilityThreshold: 0.6
    },
    //private placeholder for provided callback functions passed in extractPages
    callbacks: undefined,
    //private String errorMessage, when internally set this message will be displayed in a pop-up message.
    error: undefined,
    /**
     * @property {Object[]} extractedPages Collection of extracted pages.
     */
    extractedPages: undefined,
    /**
     * @property {Number} numberOfPages Total number of pages extracted.
     */
    numberOfPages: 0,
    // vertical offset of the very first row exported
    firstExportedRowOffset: 0,
    // Vertical offset of the secondary canvas. Initially equals to the negative "firstExportedRowOffset".
    // Though the value might change while pages getting extracted.
    secondaryCanvasOffset: 0,
    eventBoxes: null,
    dependencyPainter: null,
    dependenciesHtml: '',
    depViewBeforeRefreshDetacher: null,
    depView: null,
    collectRowsTimer: null,
    collectRowsTimerTimeout: 1,
    constructor: function(config) {
        var me = this;
        config = config || {};
        me.callParent(arguments);
        // initConfig thinks that we're trying to override methods so we have to delete following
        delete config.getUserHeaderTplData;
        delete config.getUserFooterTplData;
        me.initConfig(config);
        if (!config.tableSelector) {
            me.tableSelector = '.' + Ext.baseCSSPrefix + 'grid-item-container';
        }
        // get the exporter name from locale (if not provided explicitly)
        if (!config.name)  {
            me.setName(me.L('name'));
        }
        
    },
    destroy: function() {
        clearTimeout(this.collectRowsStepTimer);
        clearTimeout(this.collectRowsTimer);
        clearTimeout(this.scrollToTimer);
        this.callParent(arguments);
    },
    setHeaderTpl: function(tpl) {
        this.headerTpl = this.getTplInstance(tpl);
    },
    getHeaderTpl: function() {
        return this.headerTpl;
    },
    setTpl: function(tpl) {
        this.tpl = this.getTplInstance(tpl);
    },
    getTpl: function() {
        return this.tpl;
    },
    setFooterTpl: function(tpl) {
        this.footerTpl = this.getTplInstance(tpl);
    },
    getFooterTpl: function() {
        return this.footerTpl;
    },
    getTplInstance: function(tpl) {
        return (tpl && !tpl.isTemplate) ? new Ext.XTemplate(tpl, {
            disableFormats: true
        }) : tpl;
    },
    /**
     * @protected
     * Returns the CSS classes for BODY element of extracted page. Override this if you need to customize the CSS classes of exported pages.
     * @return {String} CSS classes.
     */
    getBodyClasses: function() {
        var re = new RegExp(Ext.baseCSSPrefix + 'ie\\d?|' + Ext.baseCSSPrefix + 'gecko', 'g'),
            result = document.body.className.replace(re, '');
        if (Ext.isIE) {
            result += ' sch-ie-export';
        }
        return result;
    },
    /**
     * @protected
     * Returns the CSS classes for element containing exported component. Override this if you need to customize exported pages CSS classes.
     * @return {String} CSS classes.
     */
    getComponentClasses: function() {
        return this.getComponent().el.dom.className;
    },
    /**
     * Sets the component being exported.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     */
    setComponent: function(component) {
        var me = this;
        me.component = component;
        me.view = component.getSchedulingView();
        me.normalGrid = component.normalGrid;
        me.lockedGrid = component.lockedGrid;
        me.normalView = component.normalGrid.view;
        me.lockedView = component.lockedGrid.view;
        me.lockedBodySelector = '#' + me.lockedView.getId();
        me.normalBodySelector = '#' + me.normalView.getId();
        me.lockedHeader = me.lockedGrid.headerCt;
        me.normalHeader = me.normalGrid.headerCt;
        me.headerHeight = me.normalHeader.getHeight();
        // page height w/o component headers
        me.printHeight = Math.floor(me.paperHeight) - me.headerHeight - (me.exportConfig.showHeader ? me.pageHeaderHeight : 0) - (me.exportConfig.showFooter ? me.pageFooterHeight : 0);
        me.saveComponentState(component);
        me.initDependencyPainter(component);
    },
    /**
     * Returns the component being exported.
     * @return {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} The component being exported.
     */
    getComponent: function() {
        return this.component;
    },
    /**
     * @private
     * Applies the selected paper size based on export configuration and {@link #paperSizes} config. Calculates {@link #paperWidth} and {@link #paperHeight} properties.
     */
    setPaperSize: function(pageSize, orientation) {
        var me = this;
        //size of paper we will be printing on. take orientation into account
        if (orientation === 'landscape') {
            me.paperWidth = pageSize.height;
            me.paperHeight = pageSize.width;
        } else {
            me.paperWidth = pageSize.width;
            me.paperHeight = pageSize.height;
        }
    },
    /**
     * @return {String} returns the format of the current export operation.
     */
    getPaperFormat: function() {
        return this.exportConfig.format;
    },
    /**
     * @private
     * Returns whether the component uses buffered rendering.
     * @return {boolean} `true` if the underlying component uses buffered rendering.
     */
    isBuffered: function() {
        return !!this.getBufferedRenderer();
    },
    /**
     * @private
     * Returns the normal grid buffered renderer instance (if the component uses buffered rendering).
     * @return {Ext.grid.plugin.BufferedRendererView} The normal grid buffered renderer instance.
     */
    getBufferedRenderer: function() {
        return this.view.bufferedRenderer;
    },
    /**
     * @protected
     * Applies the passed date range to the component.
     * @param {Object} config Export configuration.
     */
    setComponentRange: function(config) {
        var me = this,
            component = me.getComponent();
        // if we export a part of scheduler
        if (config.range !== 'complete') {
            var view = me.view,
                newStart, newEnd;
            switch (config.range) {
                case 'date':
                    newStart = new Date(config.dateFrom);
                    newEnd = new Date(config.dateTo);
                    // ensure that specified period has at least a day
                    if (Sch.util.Date.getDurationInDays(newStart, newEnd) < 1) {
                        newEnd = Sch.util.Date.add(newEnd, Sch.util.Date.DAY, 1);
                    };
                    break;
                case 'current':
                    var visibleSpan = view.getVisibleDateRange();
                    newStart = visibleSpan.startDate;
                    newEnd = visibleSpan.endDate || view.timeAxis.getEnd();
                    break;
                case 'completedata':
                    var span = component.getEventStore().getTotalTimeSpan();
                    newStart = span.start;
                    newEnd = span.end;
                    break;
            }
            // apply new time frame
            if (newStart && newEnd) {
                component.setTimeSpan(newStart, newEnd);
            }
        }
        me.ticks = component.timeAxis.getTicks();
        // if only currently visible rows have to be extracted
        if (config.rowsRange == 'visible') {
            // find effective currently visible rows range (an array: [startIndex, endIndex])
            config.rowsRange = me.findVisibleRowsRange();
        } else // all rows mode
        {
            config.rowsRange = null;
        }
    },
    /**
     * @protected
     * Get links to the stylesheets of current page.
     */
    getStylesheets: function() {
        var translate = this.getTranslateURLsToAbsolute(),
            styleSheetNodes = Ext.getHead().select('link[rel="stylesheet"], style', true),
            stylesString = '';
        styleSheetNodes.each(function(extEl) {
            var node = extEl.dom.cloneNode(true);
            // put absolute URL to node `href` attribute
            if (translate && node.href) {
                node.setAttribute('href', node.href);
            }
            stylesString += node.outerHTML;
            // Empty style tag will be copied in IE, so we need to use cssText
            // http://stackoverflow.com/questions/5227088/creating-style-node-adding-innerhtml-add-to-dom-and-ie-headaches
            if (Ext.isIE && node.styleSheet && /style/i.test(node.tagName)) {
                stylesString += '<style type="text/css">' + extEl.dom.styleSheet.cssText + '</style>';
            }
        });
        return stylesString;
    },
    // Since export is a sync operation for now, all plugins drawing lines & zones need to be temporarily adjusted
    // to draw their content synchronously.
    forEachTimeSpanPlugin: function(component, fn, scope) {
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var me = this;
            var plugins = [].concat(component.plugins, component.normalGrid.plugins, component.columnLinesFeature);
            for (var i = 0,
                l = plugins.length; i < l; i++) {
                var plugin = plugins[i];
                if (plugin instanceof Sch.feature.AbstractTimeSpan) {
                    fn.call(scope || me, plugin);
                }
            }
        }
    },
    setCellSize: function(cellSize) {
        var me = this;
        me.timeColumnWidth = cellSize[0];
        if (me.timeColumnWidth) {
            this.getComponent().setTimeColumnWidth(me.timeColumnWidth);
        }
        // change the row height only if value is provided
        if (cellSize.length > 1) {
            me.view.setRowHeight(cellSize[1]);
        }
    },
    findVisibleRowsRange: function() {
        var me = this,
            nodeCache = me.lockedView.all,
            startIndex = nodeCache.startIndex,
            endIndex = nodeCache.endIndex;
        var metVisibleNode = false,
            firstVisibleRowIndex = -1,
            lastVisibleRowIndex = -1;
        for (var i = startIndex; i <= endIndex; i++) {
            var node = nodeCache.item(i, true);
            if (me.isRowVisible(node, me.lockedBox)) {
                if (!metVisibleNode) {
                    firstVisibleRowIndex = i;
                    metVisibleNode = true;
                }
                lastVisibleRowIndex = i;
            } else if (metVisibleNode) {
                break;
            }
        }
        return [
            firstVisibleRowIndex,
            lastVisibleRowIndex
        ];
    },
    /**
     * @protected
     * Prepares the component to export. This includes setting requested time span, time column width etc.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     * @param {Object} config    Export configuration.
     */
    prepareComponent: function(component, config) {
        var me = this;
        component = component || me.getComponent();
        me.suspendInfiniteScroll(component);
        me.forEachTimeSpanPlugin(component, function(plugin) {
            plugin._renderDelay = plugin.renderDelay;
            plugin.renderDelay = 0;
        });
        component.getSchedulingView().timeAxisViewModel.suppressFit = true;
        component.timeAxis.autoAdjust = false;
        //expand grids in case they're collapsed
        component.normalGrid.expand();
        component.lockedGrid.expand();
        // remember view regions (to be able to decide on rows visibility if requested)
        me.lockedBox = me.lockedView.getBox();
        me.normalBox = me.normalView.getBox();
        // change timespan/tick width according to provided settings
        me.setComponentRange(config);
        // if row/column sizes provided
        config.cellSize && me.setCellSize(config.cellSize);
        // launch template method
        config.beforeExport && config.beforeExport(component, me.ticks);
        me.prepareColumns(config.columns);
        // For Tree grid, optionally expand all nodes
        if (me.expandAllBeforeExport && component.expandAll) {
            component.expandAll();
        }
        // resizes the component to fit it into specified paper size (depending on pagination rules)
        me.fitComponentIntoPage();
        //bug fix #2284 - MultiPage export does not sync timeaxis on first run
        me.view.timeAxisViewModel.setTickWidth(me.view.timeAxisViewModel.getTickWidth());
        //IE8 bug
        if (me.isBuffered() && Ext.isIE8) {
            me.normalView.bufferedRenderer.variableRowHeight = false;
            me.lockedView.bufferedRenderer.variableRowHeight = false;
        }
    },
    prepareColumns: function(columns) {
        var me = this;
        // If the list of columns to export is provided
        if (columns) {
            me.lockedGrid.headerCt.items.each(function(column) {
                // Show only passed columns
                if (Ext.Array.contains(columns, column)) {
                    column.show();
                } else {
                    column.hide();
                }
            });
        }
    },
    restoreComponent: function(component) {
        var me = this;
        component = component || me.getComponent();
        me.forEachTimeSpanPlugin(component, function(plugin) {
            plugin.renderDelay = plugin._renderDelay;
            delete plugin._renderDelay;
        });
        // if we stopped the dependency view refreshing we enable it back
        if (me.depViewBeforeRefreshDetacher) {
            me.depViewBeforeRefreshDetacher.destroy();
            me.depViewBeforeRefreshDetacher = null;
            me.depView.updateCanvasLayer();
        }
        // restore scheduler state
        me.restoreComponentState(component);
        me.restoreInfiniteScroll(component);
        //We need to update TimeAxisModel for layout fix #1334
        // component.getSchedulingView().timeAxisViewModel.update();
        // call template method
        me.exportConfig.afterExport && me.exportConfig.afterExport(component);
    },
    saveComponentState: function(component) {
        component = component || this.getComponent();
        var me = this,
            view = component.getSchedulingView(),
            normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid;
        var columns = [];
        lockedGrid.headerCt.items.each(function(column) {
            columns.push({
                column: column,
                visible: !column.isHidden()
            });
        });
        var timeAxisViewModel = view.timeAxisViewModel;
        // Store original tick width for the case described in #1624
        var originalTickWidth = timeAxisViewModel.originalTickWidth;
        // At the same time fix tick width so export would not change it
        var tickWidth = timeAxisViewModel.getTickWidth();
        timeAxisViewModel.setTickWidth(tickWidth, true);
        //values needed to restore original size/dates of component
        me.restoreSettings = {
            width: component.getWidth(),
            height: component.getHeight(),
            rowHeight: timeAxisViewModel.getViewRowHeight(),
            originalTickWidth: originalTickWidth,
            columnWidth: tickWidth,
            startDate: component.getStart(),
            endDate: component.getEnd(),
            normalWidth: normalGrid.getWidth(),
            normalLeft: normalGrid.getEl().getStyle('left'),
            lockedWidth: lockedGrid.getWidth(),
            lockedCollapse: lockedGrid.collapsed,
            normalCollapse: normalGrid.collapsed,
            columns: columns,
            autoAdjust: component.timeAxis.autoAdjust,
            suppressFit: timeAxisViewModel.suppressFit,
            startIndex: view.all.startIndex,
            lockedScrollX: me.lockedView.getScrollX(),
            normalScrollX: view.getScrollX(),
            scrollY: view.getScrollY()
        };
    },
    restoreComponentState: function(component) {
        var me = this;
        component = component || me.getComponent();
        var config = me.restoreSettings,
            view = component.getSchedulingView();
        component.timeAxis.autoAdjust = config.autoAdjust;
        component.normalGrid.show();
        component.setWidth(config.width);
        component.setHeight(config.height);
        component.setTimeSpan(config.startDate, config.endDate);
        component.setTimeColumnWidth(config.columnWidth, true);
        component.setRowHeight(config.rowHeight);
        // resote locked grid columns visibility
        Ext.Array.each(config.columns, function(item) {
            item.column.setVisible(item.visible);
        });
        component.lockedGrid.show();
        component.normalGrid.setWidth(config.normalWidth);
        component.normalGrid.getEl().setStyle('left', config.normalLeft);
        component.lockedGrid.setWidth(config.lockedWidth);
        view.timeAxisViewModel.suppressFit = config.suppressFit;
        view.timeAxisViewModel.setTickWidth(config.columnWidth);
        // restore original tick width value (#1624)
        view.timeAxisViewModel.originalTickWidth = config.originalTickWidth;
        if (config.lockedCollapse) {
            component.lockedGrid.collapse();
        }
        if (config.normalCollapse) {
            component.normalGrid.collapse();
        }
        // restore scroll position
        me.restoreComponentScroll(config);
        if (me.getBufferedRenderer()) {
            if (Ext.isIE8) {
                me.normalView.bufferedRenderer.variableRowHeight = true;
                me.lockedView.bufferedRenderer.variableRowHeight = true;
            }
        }
    },
    restoreComponentScroll: function(restoreSettings) {
        var me = this;
        me.lockedView.setScrollX(restoreSettings.lockedScrollX);
        me.normalView.scrollTo(restoreSettings.normalScrollX, restoreSettings.scrollY);
    },
    /**
     * Extracts the component content. On completion calls specified callback function providing an array of extracted pages as an argument.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component Component content of which to be extracted
     * @param {Object} config Configuration object. May contain the following properties:
     * @param {String} config.format Page format
     * @param {String} config.orientation Page orientation (either `portrait` or `landscape`)
     * @param {String} config.range Range of the panel to be exported. Options are `complete`, `current`, `date`. When `date` is specified there also has to be specified next two configs.
     * @param {Date} config.dateFrom Range start date. Used only when `config.range` is `date`
     * @param {Date} config.dateTo Range end date. Used only when `config.range` is `date`
     * @param {Boolean} config.showHeader Flag saying that page numbers header has to be shown
     * @param {Function} callback Function which is called after extraction of pages has completed. The callback will have the following arguments:
     * @param {Function} callback.pages An array with extracted pages
     * @param {Object} [scope] Scope for the callback function
     */
    extractPages: function(component, config, callback, scope) {
        var me = this;
        if (!callback) {
            throw 'Sch.plugin.exporter.AbstractExporter: [extractPages] "callback" has to be provided.';
        }
        // stop garbage collecting
        me.enableGarbageCollector = Ext.enableGarbageCollector;
        Ext.enableGarbageCollector = false;
        Ext.dom.GarbageCollector.pause();
        // keep provided export config
        me.exportConfig = config;
        me.normalRows = [];
        me.lockedRows = [];
        me.extractedPages = [];
        me.numberOfPages = 0;
        me.lockedRowsHeight = 0;
        me.normalRowsHeight = 0;
        me.firstExportedRowOffset = 0;
        me.secondaryCanvasOffset = 0;
        me._abort = false;
        // calculates paper sizes based on provided parameters and DPI
        me.setPaperSize(config.pageSize, config.orientation);
        // stores references to the component, its elements and makes a backup of its pre-export state
        me.setComponent(component, config);
        // prepares component to exporting (applies provided timespan etc.)
        me.prepareComponent(component, config);
        me.callbacks = {
            success: callback,
            scope: scope || me
        };
        // fetch all component rows into temporary arrays
        // and call 'onRowsCollected' to collect them into pages and call 'onPagesExtracted' on completion
        me.collectRowsTimer = setTimeout(function() {
            clearTimeout(me.collectRowsTimer);
            me.collectRows(me._onRowsCollected, me, config);
        }, me.collectRowsTimerTimeout);
    },
    /**
     * @protected
     * Finishes exporting process. Restores the component to its initial state and returns extracted pages by calling a provided callback.
     * @param  {Object[]} [pages] Extracted pages. If omitted then will take collected pages from {@link #extractedPages} array.
     */
    onPagesExtracted: function(pages) {
        var me = this;
        pages = me.renderPages(pages);
        // restore panel to initial state
        me.restoreComponent();
        // and return results
        me.submitPages(pages);
    },
    submitPages: function(pages) {
        var me = this,
            callbacks = me.callbacks;
        callbacks.success.call(callbacks.scope, pages);
        // resume garbage collecting
        Ext.enableGarbageCollector = me.enableGarbageCollector;
        Ext.dom.GarbageCollector.resume();
    },
    // returns an Ext.Element
    getCurrentPage: function() {
        return this.currentPage;
    },
    // page should be Ext.Element
    setCurrentPage: function(page) {
        this.currentPage = page;
    },
    getExpectedNumberOfPages: function() {
        throw 'Sch.plugin.exporter.AbstractExporter: [getExpectedNumberOfPages] Abstract method called.';
    },
    /**
     * Commits a filled page. Pushes the page into {@link #extractedPages resulted set of pages}.
     * Calls {@link #preparePageToCommit} for the final page DOM tweaking.
     * @param [config] An optional configuration object. Will also be passed to {@link #preparePageToCommit} method.
     */
    commitPage: function(config) {
        var me = this;
        me.numberOfPages++;
        var pageBody = me.preparePageToCommit(config);
        me.fireEvent('beforecommitpage', me, pageBody, me.numberOfPages, me.getExpectedNumberOfPages());
        var page = Ext.apply({
                html: pageBody.dom.innerHTML,
                number: me.numberOfPages
            }, config);
        me.extractedPages.push(page);
        me.fireEvent('commitpage', me, page, me.numberOfPages, me.getExpectedNumberOfPages());
    },
    /**
     * @protected
     * Collects the locked grid row.
     * @param  {Element} item The locked grid row
     * @param  {Ext.data.Model} recordIndex Index of the record corresponding to the row.
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectLockedRow: function(item, recordIndex) {
        var height = Ext.fly(item).getHeight();
        this.lockedRowsHeight += height;
        var result = {
                height: height,
                row: item.cloneNode(true),
                record: this.lockedView.getRecord(recordIndex)
            };
        this.lockedRows.push(result);
        return result;
    },
    /**
     * @protected
     * Collects the normal grid row.
     * @param  {Element} item The normal grid row
     * @param  {Number} recordIndex Index of the record corresponding to the row.
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectNormalRow: function(item, recordIndex) {
        var height = Ext.fly(item).getHeight();
        this.normalRowsHeight += height;
        var result = {
                height: height,
                row: item.cloneNode(true),
                record: this.normalView.getRecord(recordIndex)
            };
        this.normalRows.push(result);
        // if there is a dependency view
        // once row is collected let's remember related events coordinates to be able to render dependencies properly
        if (this.depView && this.depView.getDependencyStore()) {
            this.fillRecordRelatedBoxes(result.record);
        }
        return result;
    },
    _onRowsCollected: function() {
        var me = this,
            depView = me.depView;
        // if there is a dependency view
        if (depView && depView.getDependencyStore()) {
            me.renderDependencies();
        }
        me.onRowsCollected.apply(me, arguments);
    },
    onRowsCollected: function() {
        throw 'Sch.plugin.exporter.AbstractExporter: [onRowsCollected] Abstract method called.';
    },
    _abort: false,
    abort: function() {
        this._abort = function() {
            this.restoreComponent();
        };
    },
    /**
     * @private
     * Iterates by calling provided function asynchronously with a delay.
     * The delay duration is specified by {@link #iterateTimeout} config.
     * @param  {Function} fn    Function implementing a single iteration step.
     * @param  {Function} fn.next Callback function to be called to run the next iteration step.
     * This will cause `fn` function launch. All arguments passed to {@link #fn.next} will be transfered to {@link #fn}.
     * @param  {[type]}   [scope] Scope for the callback function
     */
    iterateAsync: function(fn, scope) {
        var me = this;
        scope = scope || me;
        var next = function() {
                var args = arguments;
                // run iteration step asynchronously w/ delay
                var interval = setInterval(function() {
                        clearInterval(interval);
                        !me._abort ? fn.apply(scope, [].concat.apply([
                            next
                        ], args)) : me._abort();
                    }, me.iterateTimeout);
            };
        next.apply(me, Ext.Array.slice(arguments, 2));
    },
    callAsync: function(fn, scope) {
        scope = scope || this;
        var interval = setInterval(function() {
                clearInterval(interval);
                fn.apply(scope, Ext.Array.slice(arguments, 2));
            }, this.iterateTimeout);
    },
    canStartRowsCollecting: function() {
        var cmp = this.getComponent(),
            depView = cmp.getDependencyView();
        // if we have dependency view we need to have its canvas rendered before we start collecting rows
        return !depView || depView.getDependencyCanvas();
    },
    depViewRefreshBlocker: function() {
        return false;
    },
    /**
     * @protected
     * Collects rows from the component. Launches the provided callback and passes collected rows as its arguments.
     * @param callback {Function} The callback function when extraction of rows has finished.
     */
    collectRows: function(callback, scope, config) {
        var me = this,
            startIndex = 0;
        // check if we're ready for rows collecting
        if (!me.canStartRowsCollecting()) {
            var args = Ext.Array.slice(arguments, 0);
            me.collectRowsTimer = setTimeout(function() {
                clearTimeout(me.collectRowsTimer);
                me.collectRows.apply(me, args);
            }, me.collectRowsTimerTimeout);
            return;
        }
        var depView = me.getComponent().getDependencyView();
        // if we have dependency view onboard
        // stop real dependency painter to not interfere, since we're gonna use the copy of it
        if (me.depView) {
            me.depViewBeforeRefreshDetacher = depView.on({
                beforerefresh: me.depViewRefreshBlocker,
                destroyable: true
            });
        }
        var needToScroll = me.isBuffered();
        // if rows to extract range is provided
        if (config.rowsRange) {
            // we know for sure index to start from
            startIndex = config.rowsRange[0];
            // if the range is inside the set of currently rendered rows we don't need to scroll
            needToScroll = !(config.rowsRange[0] >= me.view.all.startIndex && config.rowsRange[1] <= me.view.all.endIndex);
        }
        if (needToScroll) {
            // scroll to start index before rows collecting
            me.scrollToTimer = setTimeout(function() {
                me.scrollTo(startIndex, function() {
                    // fill firstExportedRowOffset value ..used to shift the secondary canvas vertically from page to page
                    startIndex && me.initFirstExportedRowOffset(startIndex);
                    me.iterateAsync(me.collectRowsStep, me, startIndex, callback, scope, config);
                });
            }, 1);
        } else {
            // fill firstExportedRowOffset value ..used to shift the secondary canvas vertically from page to page
            startIndex && me.initFirstExportedRowOffset(startIndex);
            me.collectRowsStepTimer = setTimeout(function() {
                me.collectRowsStep(null, startIndex, callback, scope, config);
            }, 1);
        }
    },
    initFirstExportedRowOffset: function(firstExportedRowIndex) {
        this.firstExportedRowOffset = this.view.el.getScrollTop() - this.view.el.getTop() + Ext.fly(this.view.getNode(firstExportedRowIndex)).getTop();
    },
    isRowVisible: function(rowNode, visibleBox) {
        var nodeEl = Ext.fly(rowNode),
            nodeTop = nodeEl.getTop(),
            nodeHeight = nodeEl.getHeight(),
            nodeBottom = nodeTop + nodeHeight,
            nodeThreshold = (1 - this.getRowVisibilityThreshold()) * nodeHeight;
        return nodeTop + nodeThreshold > visibleBox.top && nodeBottom - nodeThreshold < visibleBox.bottom;
    },
    collectRowsStep: function(next, startIndex, callback, scope, config) {
        var me = this,
            endIndex = me.normalView.all.endIndex,
            count = me.component.store.getCount(),
            rowsRange = config.rowsRange,
            normalRows = me.normalView.all.slice(startIndex),
            lockedRows = me.lockedView.all.slice(startIndex),
            i = 0;
        var lastIndex;
        // If we collect only visible rows
        if (rowsRange) {
            lastIndex = rowsRange[1];
        }
        var collected = false;
        for (var index = startIndex; i < normalRows.length; i++) {
            if (index > lastIndex) {
                collected = true;
                break;
            }
            lockedRows[i] && me.collectLockedRow(lockedRows[i], index, config);
            me.collectNormalRow(normalRows[i], index, config);
            index++;
        }
        me.fireEvent('collectrows', me, startIndex, index, count);
        // if we are in the buffered mode (and not collected all the requested rows yet)
        // we need to scroll further
        if (!collected && me.isBuffered()) {
            if (endIndex + 1 < count) {
                me.callAsync(function() {
                    me.scrollTo(endIndex + 1, function() {
                        next(endIndex + 1, callback, scope, config);
                    });
                });
            } else {
                me.callAsync(function() {
                    me.scrollTo(0, function() {
                        callback.call(scope || me, me.lockedRows, me.normalRows);
                    });
                });
            }
        } else // if we already collected all the needed rows - invoke the final step
        {
            callback.call(scope || me, me.lockedRows, me.normalRows);
        }
    },
    /**
     * @private
     * Fills extracted pages `html` property before submitting them.
     * @param  {Array} [pages] Array of pages. By default {@link #extractedPages} is used.
     * @return {Array} Array of pages.
     */
    renderPages: function(pages) {
        var me = this;
        pages = pages || me.extractedPages;
        for (var i = 0,
            l = pages.length; i < l; i++) {
            var page = pages[i];
            page.html = me.applyPageTpl(page);
        }
        return pages;
    },
    /**
     * @protected
     * Builds HTML content of the page by applying provided page data to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the page.
     */
    applyPageTpl: function(pageInfo) {
        var me = this;
        return me.getTpl().apply(me.getPageTplData(pageInfo));
    },
    /**
     * @protected
     * Builds HTML content of the page header by applying provided page data to the {@link #headerTpl header template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the header.
     */
    applyHeaderTpl: function(pageInfo) {
        var me = this,
            headerTpl = me.getHeaderTpl();
        if (me.exportConfig.showHeader && headerTpl) {
            // if function was provided to alter tpl data
            var fn = me.headerTplDataFn;
            var alterData = fn && fn.call(me.headerTplDataFnScope || me, pageInfo);
            return headerTpl.apply(Ext.apply(me.getHeaderTplData(pageInfo), alterData));
        }
        return '';
    },
    /**
     * @protected
     * Builds HTML content of the page footer by applying provided page data to the {@link #footerTpl footer template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the footer.
     */
    applyFooterTpl: function(pageInfo) {
        var me = this,
            footerTpl = me.getFooterTpl();
        if (me.exportConfig.showFooter && footerTpl) {
            // if function was provided to alter tpl data
            var fn = me.footerTplDataFn;
            var alterData = fn && fn.call(me.footerTplDataFnScope || me, pageInfo);
            return footerTpl.apply(Ext.apply(me.getFooterTplData(pageInfo), alterData));
        }
        return '';
    },
    /**
     * @protected
     * Function to provide data for the {@link #headerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page header (page width)
     * @return {Number} return.height height of the page header
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getHeaderTplData: function(pageInfo) {
        var me = this;
        return {
            width: me.paperWidth,
            height: me.pageHeaderHeight,
            totalPages: me.numberOfPages,
            pageNo: pageInfo.number
        };
    },
    /**
     * @protected
     * Function to provide data for the {@link #footerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page footer (page width)
     * @return {Number} return.height height of the page footer
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getFooterTplData: function(pageInfo) {
        var me = this;
        return {
            width: me.paperWidth,
            height: me.pageFooterHeight,
            totalPages: me.numberOfPages,
            pageNo: pageInfo.number
        };
    },
    /**
     * @protected
     * Provides data to be applied to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object}      Data to be applied to the {@link #tpl page template}:
     * @return {String} return.bodyClasses         copied BODY element CSS classes
     * @return {String} return.bodyHeight          height of the HTML content of the extracted page
     * @return {String} return.componentClasses    copied the component element CSS classes
     * @return {String} return.styles              stylesheet links
     * @return {String} return.showHeader          `true` if the header has to be shown
     * @return {String} return.showFooter          `true` if the footer has to be shown
     * @return {String} return.header              the header content
     * @return {String} return.HTML                HTML content of the extracted page
     * @return {String} return.footer              the footer content
     * @return {String} return.totalWidth          the page width
     * @return {String} return.pageNo              the page number
     * @return {String} return.totalPages          total number of pages
     * @return {String} return.title               the page title
     */
    getPageTplData: function(pageInfo) {
        var me = this;
        return {
            id: me.getComponent().id,
            bodyClasses: me.getBodyClasses(),
            bodyHeight: me.printHeight + me.headerHeight,
            componentClasses: me.getComponentClasses(),
            styles: me.getStylesheets(),
            showHeader: me.exportConfig.showHeader,
            showFooter: me.exportConfig.showFooter,
            header: me.applyHeaderTpl(pageInfo),
            HTML: pageInfo.html,
            footer: me.applyFooterTpl(pageInfo),
            totalWidth: me.paperWidth,
            pageNo: pageInfo.number,
            totalPages: me.numberOfPages,
            title: pageInfo.number + ' of ' + me.numberOfPages
        };
    },
    /**
     * @protected
     * Resizes the component to fit it into specified paper size, export settings etc. (depending on implemented pagination rules).
     */
    fitComponentIntoPage: Ext.emptyFn,
    /**
     * @private
     * Function that retrieves the table body of the locked grid.
     * @param {Ext.dom.Element} [element] The fragment root for the selector. Defaults to current page.
     * @return {HTMLElement} Table body element of the locked grid.
     */
    getLockedGridBody: function(element) {
        element = element || this.getCurrentPage();
        return element.down(this.lockedBodySelector + ' ' + this.tableSelector, true);
    },
    /**
     * @private
     * Retrieves the table body of the normal grid.
     * @param {Ext.dom.Element} [element] The root element to retrieve from. Defaults to current page.
     * @return {HTMLElement} Table body element of the normal grid.
     */
    getNormalGridBody: function(element) {
        element = element || this.getCurrentPage();
        return element.down(this.normalBodySelector + ' ' + this.tableSelector, true);
    },
    emptyLockedGrid: function(element) {
        Ext.fly(this.getLockedGridBody(element)).select(this.lockedView.getItemSelector()).remove();
    },
    fillGrids: function(lockedRows, normalRows, clone, append) {
        var me = this;
        me.fillLockedGrid(lockedRows, clone, append);
        me.fillNormalGrid(normalRows, clone, append);
    },
    fillLockedGrid: function(rows, clone, append) {
        var me = this;
        if (!append)  {
            me.emptyLockedGrid();
        }
        
        me.appendRows(me.getLockedGridBody(), rows || me.lockedRows, clone);
    },
    fillNormalGrid: function(rows, clone, append) {
        var me = this;
        if (!append)  {
            me.emptyNormalGrid();
        }
        
        me.appendRows(me.getNormalGridBody(), rows || me.normalRows, clone);
    },
    appendRows: function(domNode, children, clone) {
        for (var i = 0,
            l = children.length; i < l; i++) {
            domNode.appendChild(clone ? children[i].row.cloneNode(true) : children[i].row);
        }
    },
    emptyNormalGrid: function(element) {
        Ext.fly(this.getNormalGridBody(element)).select(this.normalView.getItemSelector()).remove();
    },
    getRowHeight: function() {
        return this.view.timeAxisViewModel.getViewRowHeight();
    },
    /**
     * @private
     * Returns full width and height of both grids.
     * @return {Object} Object containing `width` and `height` properties.
     */
    getTotalSize: function() {
        return {
            width: this.getTotalWidth(),
            height: this.getTotalHeight()
        };
    },
    /**
     * @private
     * Returns full height of the component.
     * @return {Number} Full height of the component.
     */
    getTotalHeight: function() {
        var me = this,
            viewHeight;
        if (me.isBuffered()) {
            viewHeight = me.bufferedHeightMargin + me.normalRowsHeight;
        } else {
            viewHeight = me.lockedView.getEl().down(me.tableSelector).getHeight();
        }
        return me.headerHeight + viewHeight;
    },
    /**
     * @private
     * Returns full width of the component.
     * @return {Number} Full width of both grids.
     */
    getTotalWidth: function() {
        var splitWidth = this.component.split ? this.component.down('splitter').getWidth() : 0;
        return this.getLockedGridWidth() + splitWidth + this.normalGrid.body.down(this.tableSelector).getWidth();
    },
    getLockedGridWidth: function() {
        return this.lockedHeader.getEl().first().getWidth();
    },
    getNormalGridWidth: function() {
        return this.normalHeader.getEl().first().getWidth();
    },
    /**
     * @protected
     * Performs last changes to {@link #getCurrentPage the current page} being extracted before it's pushed into {@link #extractedPages} array.
     * @param {Object} [config] Optional configuration object.
     * @return {Ext.dom.Element} element Element holding the page.
     */
    preparePageToCommit: function() {
        //create empty div that will temporarily hold our panel current HTML
        var frag = this.getCurrentPage(),
            component = this.component,
            lockedGrid = component.lockedGrid,
            normalGrid = component.normalGrid,
            secondaryCanvas = frag.down('.sch-secondary-canvas', true);
        frag.select('.sch-remove').remove();
        var get = function(id) {
                return frag.down('#' + id, true);
            },
            elapseWidth = function(el) {
                if (el)  {
                    el.style.width = '100%';
                }
                
            },
            elapseHeight = function(el) {
                if (el)  {
                    el.style.height = '100%';
                }
                
            };
        var normalBody = frag.down(this.normalBodySelector, true);
        normalBody.style.top = '0px';
        var lockedBody = frag.down(this.lockedBodySelector, true);
        lockedBody.style.top = '0px';
        // remove transform:translate3d(...) from views item container element
        // otherwise it might mess top coordinate of the exported rows (checked in: 015_export_current_view)
        var lockedItemsContainer;
        if (lockedItemsContainer = this.getLockedGridBody()) {
            if (Ext.isIE9m) {
                lockedItemsContainer.style.top = '';
            } else {
                lockedItemsContainer.style.transform = '';
            }
        }
        var normaItemsContainer;
        if (normaItemsContainer = this.getNormalGridBody()) {
            if (Ext.isIE9m) {
                normaItemsContainer.style.top = '';
            } else {
                normaItemsContainer.style.transform = '';
            }
        }
        if (secondaryCanvas) {
            secondaryCanvas.style.top = this.secondaryCanvasOffset + 'px';
            Ext.fly(secondaryCanvas).select('.sch-column-line').setHeight(this.normalRowsHeight);
        }
        // we elapse some elements width and/or height
        var lockedElements = [
                get(component.id + '-targetEl'),
                get(component.id + '-innerCt'),
                get(lockedGrid.id),
                get(lockedGrid.body.id),
                get(lockedGrid.view.el.id)
            ];
        Ext.Array.each(lockedElements, elapseHeight);
        elapseWidth(lockedElements[0]);
        elapseWidth(lockedElements[1]);
        if (!Ext.isIE) {
            elapseWidth(get(normalGrid.headerCt.id));
        } else {
            var el = get(normalGrid.headerCt.id);
            if (el)  {
                el.style.width = '';
            }
            
        }
        Ext.Array.each([
            get(normalGrid.id),
            get(normalGrid.body.id),
            get(normalGrid.getView().id)
        ], function(el) {
            if (el) {
                el.style.height = el.style.width = '100%';
            }
        });
        return frag;
    },
    /**
     * Starts a new page. Initializes {@link #currentPage} with a copy of the component that will
     * be filled with collected rows based on implemented pagination rules.
     * @param  {Ext.dom.Element} [pageEl] Element to make a copy of. This is optional by default will make a copy of {@link #getComponent the component}.
     */
    startPage: function(pageEl) {
        var me = this;
        // make a detached copy of the component body
        var copy = (pageEl || me.getComponent().body).dom.cloneNode(true);
        copy.id = '';
        // and put it into storedFragment
        me.setCurrentPage(Ext.get(copy));
    },
    scrollTo: function(position, callback, scope) {
        var me = this;
        if (me.component.ensureVisible) {
            var record = me.component.store.getAt(position);
            me.component.ensureVisible(record, {
                callback: function() {
                    if (callback && this.isLocked === false) {
                        callback.apply(scope || me);
                    }
                },
                select: false,
                focus: false,
                animate: false
            });
        } else {
            me.lockedView.bufferedRenderer.scrollTo(position, false, function() {
                me.normalView.bufferedRenderer.scrollTo(position, false, callback, scope || me);
            });
        }
    },
    removeNode: function(el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        } else {
            if (el.elements) {
                for (var i = 0; i < el.elements.length; i++) {
                    var elem = el.elements[i];
                    elem.parentNode.removeChild(elem);
                }
            }
        }
    },
    //private
    restoreInfiniteScroll: function(panel) {
        var view = panel.getSchedulingView();
        if (panel.infiniteScroll && view.rendered) {
            // restore saved time span and scroll position
            panel.timeAxis.setTimeSpan(this._oldStart, this._oldEnd);
            view.setScrollX(this._oldScrollX);
            // enable back infiniteScroll mode event listeners
            view.bindInfiniteScrollListeners();
        }
    },
    //private
    suspendInfiniteScroll: function(panel) {
        var view = panel.getSchedulingView();
        // unbind events reacting on scroll specific to infiniteScroll mode
        if (panel.infiniteScroll && view.rendered) {
            view.unbindInfiniteScrollListeners();
            // remember current time span and scroll position
            this._oldStart = panel.timeAxis.getStart();
            this._oldEnd = panel.timeAxis.getEnd();
            this._oldScrollX = view.getScrollX();
            var span = panel.getEventStore().getTotalTimeSpan();
            panel.setTimeSpan(span.start, span.end);
        }
    },
    dependencyPainterMembers: {
        getItemBox: function(primaryView, task) {
            var me = this,
                box = me.exporter.eventBoxes[task.internalId];
            return box || this.callParent(arguments);
        }
    },
    // Cretes a copy of the component dependency painter
    // that we're gonna use instead of the component's one
    initDependencyPainter: function(component) {
        var me = this,
            depView = component.getDependencyView();
        // if there is a dependency view
        if (depView) {
            // clone real painter
            me.dependencyPainter = depView.clonePainter();
            // and override its "exporter" property and "getItemBox" method
            Ext.override(me.dependencyPainter, Ext.apply({}, {
                exporter: me
            }, me.dependencyPainterMembers));
        }
        me.depView = depView;
        me.eventBoxes = {};
    },
    fillRecordRelatedBoxes: function(record) {
        var me = this,
            view = me.normalView,
            painter = me.depView.painter,
            dependencyStore = me.depView.getDependencyStore();
        var events = record.getEvents();
        for (var j = 0; j < events.length; j++) {
            var task = events[j];
            // Ignore events that does not belong to timeaxis
            if (view.timeAxis.isRangeInAxis(task) && dependencyStore.getEventDependencies(task).length) {
                var box = painter.getItemBox(view, task);
                for (var i = 0; i < box.length; i++) {
                    // WARNING view.bufferedRenderer.bodyTop is private
                    // dependency painter doesn't take bufferedRenderer.bodyTop into account
                    // but we need to do it
                    if (view.bufferedRenderer) {
                        box[i].top += view.bufferedRenderer.bodyTop;
                        box[i].bottom += view.bufferedRenderer.bodyTop;
                    }
                    // we want all tasks to be considered as visible
                    box[i].rendered = true;
                }
                me.eventBoxes[task.internalId] = box;
            }
        }
    },
    renderDependencies: function() {
        var me = this,
            depView = me.depView;
        if (depView.getDrawDependencies()) {
            me.dependenciesHtml = me.dependencyPainter.generatePaintMarkup(depView.getPrimaryView(), depView.getDependencyStore().getRange());
        } else {
            me.dependenciesHtml = '';
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.plugin.exporter.SinglePage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts all scheduler data to fit in a single page.

 The exporterId of this exporter is `singlepage`
 */
Ext.define('Sch.plugin.exporter.SinglePage', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Single page'
     */
    config: {
        exporterId: 'singlepage'
    },
    getExpectedNumberOfPages: function() {
        return 1;
    },
    getPaperFormat: function() {
        var me = this,
            realSize = me.getTotalSize(),
            dpi = me.exportConfig.DPI,
            width = Ext.Number.toFixed(realSize.width / dpi, 1),
            height = Ext.Number.toFixed(realSize.height / dpi, 1);
        return width + 'in*' + height + 'in';
    },
    onRowsCollected: function() {
        var me = this;
        me.startPage();
        me.fillGrids();
        me.commitPage();
        me.onPagesExtracted();
    },
    getPageTplData: function() {
        var me = this,
            realSize = me.getTotalSize();
        return Ext.apply(me.callParent(arguments), {
            bodyHeight: realSize.height,
            totalWidth: realSize.width
        });
    },
    getHeaderTplData: function(pageInfo) {
        var me = this;
        return Ext.apply(me.callParent(arguments), {
            width: me.getTotalWidth(),
            height: me.pageHeaderHeight
        });
    },
    getFooterTplData: function(pageInfo) {
        var me = this;
        return Ext.apply(me.callParent(arguments), {
            width: me.getTotalWidth(),
            height: me.pageHeaderHeight
        });
    },
    fitComponentIntoPage: function() {
        var me = this,
            lockedGrid = me.lockedGrid;
        lockedGrid.setWidth(lockedGrid.headerCt.getEl().first().getWidth());
    },
    preparePageToCommit: function() {
        var me = this,
            frag = me.callParent(arguments),
            secondaryCanvas = frag.select('.sch-secondary-canvas').first(),
            zones = secondaryCanvas.select('.sch-zone'),
            lines = secondaryCanvas.select('.sch-column-line'),
            height = me.getTotalHeight();
        secondaryCanvas.setTop(0);
        zones.setHeight(height);
        lines.setHeight(height);
        var depsCt = frag.selectNode('.sch-dependencyview-ct');
        if (depsCt) {
            depsCt.innerHTML = me.dependenciesHtml;
            //move the dependencies div to match the position of the dependency lines
            depsCt.style.top = '0px';
            depsCt.style.left = '0px';
            depsCt.style.visibility = 'visible';
        }
        // hiding dependencies
        var normalGrid = me.component.normalGrid,
            tableWidth = normalGrid.el.down(me.tableSelector).getWidth(),
            id = normalGrid.getView().id,
            el = frag.select('#' + id).first().dom;
        el.style.width = tableWidth + 'px';
        var normalView = frag.selectNode('#' + me.normalView.id);
        //remove scrollbar
        normalView.style.overflow = 'hidden';
        var splitter = frag.selectNode('.' + Ext.baseCSSPrefix + 'splitter');
        if (splitter)  {
            splitter.style.height = '100%';
        }
        
        return frag;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.plugin.exporter.MultiPage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts pages in a vertical and horizontal order.

 The exporterId of this exporter is `multipage`
 */
Ext.define('Sch.plugin.exporter.MultiPage', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values

        - name : 'Multi pages'
     */
    config: {
        exporterId: 'multipage'
    },
    rowPageIndex: 0,
    columnPageIndex: 0,
    pagesPerColumn: 0,
    depsTopOffset: 0,
    onRowsCollected: function(lockedRows, normalRows) {
        var me = this;
        me.depsTopOffset = -me.firstExportedRowOffset;
        // reset row/column page counters
        me.rowPageIndex = 0;
        me.columnPageIndex = 0;
        me.pagesPerColumn = 0;
        // - build page frame (skeleton) for each page column,
        me.buildPageFrames(function() {
            // - build pages by filling grids w/ collected rows
            // - finish exporting by launching `onPagesExtracted`
            me.buildPages(me.onPagesExtracted, me, lockedRows, normalRows);
        });
    },
    /**
     * Builds pages using collected rows. Uses {@link #pagesFrames page frames} built by {@link #buildPageFrames} method.
     * Calls provided function on pages building completion.
     * @param  {Function} callback Function to be called on building completion.
     * @param  {Object}   [scope] Scope for the specified function. By default set to this exporter instance.
     */
    buildPages: function(callback, scope, lockedRows, normalRows) {
        var me = this,
            frame = me.pageFrames[0];
        // start new column page based on specified frame
        me.startPage(frame, true);
        // handle each collected row w/ `rowIteratorStep` method
        this.iterateAsync(me.rowIteratorStep, me, {
            rowIndex: 0,
            pageFrame: frame,
            rowsHeight: 0,
            leftHeight: this.printHeight,
            lockeds: [],
            normals: [],
            lockedRows: lockedRows,
            normalRows: normalRows,
            callback: callback,
            scope: scope || me
        });
    },
    /**
     * Processes a collected row and decides on its distribution between pages.
     * @param  {Function} next    A callback function to call to proceed w/ a next row.
     * @param  {Object}   context Processing context:
     * @param  {Object}   context.rowIndex Zero based index of the row.
     */
    rowIteratorStep: function(next, context) {
        var me = this,
            rowIndex = context.rowIndex,
            lockedRows = context.lockedRows,
            normalRows = context.normalRows,
            leftHeight = context.leftHeight,
            lockeds = context.lockeds,
            normals = context.normals,
            async = true;
        // if we have rows to handle
        if (rowIndex < normalRows.length) {
            var lockedRow = lockedRows[rowIndex],
                normalRow = normalRows[rowIndex];
            // if row fits into current page
            if (normalRow.height <= leftHeight) {
                // gather rows into temp arrays
                lockeds.push(lockedRow);
                normals.push(normalRow);
                context.leftHeight -= normalRow.height;
                context.rowsHeight += normalRow.height;
                async = false;
            } else // ..if doesn't fit
            {
                // flush temp arrays to fill page with gathered rows
                me.fillGrids(lockeds, normals, context.pageFrame);
                // and start a new page
                me.commitPage({
                    rowsHeight: context.rowsHeight
                });
                me.startPage(context.pageFrame);
                context.lockeds = [
                    lockedRow
                ];
                context.normals = [
                    normalRow
                ];
                context.leftHeight = me.printHeight - normalRow.height;
                context.rowsHeight = normalRow.height;
            }
            context.rowIndex++;
        }
        // if we have more column pages to build
        else if (me.columnPageIndex < me.pageFrames.length) {
            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({
                rowsHeight: context.rowsHeight
            });
            // me.columnPageIndex is 1-based so it points to the neaxt frame in me.pageFrames array
            context.pageFrame = me.pageFrames[me.columnPageIndex];
            // start new column page based on specified frame
            me.startPage(context.pageFrame, true);
            context.leftHeight = me.printHeight;
            context.rowsHeight = 0;
            context.lockeds = [];
            context.normals = [];
            context.rowIndex = 0;
        } else // if we ran out of rows & columns then we finished
        {
            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({
                rowsHeight: context.rowsHeight
            });
            // run specified callback on completion
            context.callback.call(context.scope);
            return;
        }
        // handle next row
        if (async) {
            next(context);
        } else {
            me.rowIteratorStep(next, context);
        }
    },
    fillGrids: function(lockeds, normals, frame) {
        var me = this,
            hasLockedGrid = me.lockedColumnPages[me.columnPageIndex - 1],
            hasNormalGrid = !hasLockedGrid || (hasLockedGrid && hasLockedGrid.leftWidth);
        if (hasLockedGrid) {
            me.fillLockedGrid(lockeds, true);
            me.removeHiddenLockedColumns(hasLockedGrid);
        }
        if (hasNormalGrid) {
            me.fillNormalGrid(normals, true);
            me.removeInvisibleEvents(-frame.normalGridOffset, -frame.normalGridOffset + frame.normalGridWidth);
        }
    },
    /**
     * @protected
     * Builds a page frame, a DOM-"skeleton" for a future pages.
     * @param  {Number} colIndex Zero based index of page column to build frame for.
     * @param  {Number} offset   Proper normal grid offset for the page column.
     * @return {Ext.dom.Element} Column page frame.
     */
    buildPageFrame: function(colIndex, offset) {
        var me = this,
            lockedCols = me.lockedColumnPages[colIndex];
        // if this page column has locked grid
        if (lockedCols) {
            me.lockedGrid.setWidth(me.showLockedColumns(lockedCols.start, lockedCols.end) + (lockedCols.startOffset || 0));
            // if there is some room after locked grid let's show normal grid
            if (lockedCols.leftWidth) {
                me.normalGrid.show();
            } else // otherwise we hide normal grid
            {
                me.normalGrid.hide();
            }
        } else // if no locked grid on the page
        {
            me.lockedGrid.setWidth(0);
            me.lockedGrid.hide();
            me.normalGrid.show();
        }
        // now after we set locked columns/grid and normal grid visibility
        // we clone the content of the component
        var copy = me.getComponent().body.dom.cloneNode(true);
        copy.id = '';
        copy = Ext.get(copy);
        copy.normalGridOffset = offset;
        copy.lockedGridOffset = lockedCols && lockedCols.startOffset || 0;
        copy.normalGridWidth = me.normalGrid.getWidth();
        copy.lockedGridWidth = me.lockedGrid.getWidth();
        // do some CSS-tweaks to shift locked grid
        copy.down(me.lockedBodySelector, true).style.position = '';
        copy.down('#' + me.lockedView.id, true).style.overflow = 'visible';
        // if normal grid is visible on this column page
        // do some CSS-tweaks to place normal grid to show only this page content
        if (!me.normalGrid.hidden) {
            var table = copy.select(me.normalBodySelector).first();
            table.dom.style.position = '';
            table.dom.style.top = '0px';
            var body = me.getNormalGridBody(copy);
            var header = copy.down('#' + me.normalView.headerCt.id, true);
            var secondaryCanvas = copy.down('.sch-secondary-canvas', true);
            var view = copy.down('#' + me.normalView.id, true);
            body.style.left = offset + 'px';
            header.style.left = offset + 'px';
            header.style.overflow = 'visible';
            secondaryCanvas.style.left = offset + 'px';
            view.style.overflow = 'visible';
        }
        return copy;
    },
    /**
     * @protected
     * Builds column page frames.
     * @param  {Function} callback A callback function to call on completion
     * @param  {Array[Ext.dom.Element]} callback.pageFrames An array of page frames built
     * @param  {[type]}   scope    A scope for the specified callback function
     */
    buildPageFrames: function(callback, scope) {
        var me = this;
        scope = scope || me;
        // markup locked columns ranges for page columns
        me.lockedColumnPages = me.calculateLockedColumnPages();
        var columnPagesNum = Math.ceil(me.getTotalWidth() / me.paperWidth),
            pageFrames = me.pageFrames = [];
        me.iterateAsync(function(next, colIndex, offset) {
            // on build completion we call provided function
            if (colIndex >= columnPagesNum) {
                callback.call(scope, pageFrames);
                return;
            }
            pageFrames.push(me.buildPageFrame(colIndex, offset));
            var lockedCols = me.lockedColumnPages[colIndex];
            // adjust normal grid offset for the next page column
            if (lockedCols) {
                offset -= lockedCols.leftWidth || 0;
            } else {
                offset -= me.paperWidth;
            }
            // let's build frame for next page column
            next(colIndex + 1, offset);
        }, me, 0, 0);
    },
    startPage: function(pattern, newColumnPage) {
        var me = this;
        if (newColumnPage) {
            me.depsTopOffset = -me.firstExportedRowOffset;
            // on the very first page commit step we know the exact number of row pages
            // let's keep that value
            if (me.columnPageIndex == 1) {
                me.pagesPerColumn = me.extractedPages.length;
            }
            me.rowPageIndex = 0;
            me.columnPageIndex++;
            me.secondaryCanvasOffset = me.firstExportedRowOffset;
        }
        me.rowPageIndex++;
        me.callParent(arguments);
        me.emptyNormalGrid();
        me.emptyLockedGrid();
    },
    commitPage: function(cfg) {
        var me = this;
        me.callParent([
            Ext.apply({
                row: me.rowPageIndex,
                column: me.columnPageIndex
            }, cfg)
        ]);
        // shift the secondary canvas vertically by the sum of processed rows height
        me.secondaryCanvasOffset -= cfg.rowsHeight;
        // on next page dependencies will be shifted vertically based on this page height
        me.depsTopOffset -= cfg.rowsHeight;
    },
    getExpectedPagesPerColumn: function() {
        return this.pagesPerColumn || Math.ceil((this.normalRowsHeight || this.component.store.count() * this.component.getRowHeight()) / this.printHeight);
    },
    getExpectedColumnsNumber: function() {
        return this.pageFrames ? this.pageFrames.length : Math.ceil((this.lockedGrid.getWidth() + this.ticks.length * this.view.timeAxisViewModel.getTickWidth()) / this.paperWidth);
    },
    getExpectedNumberOfPages: function() {
        return this.getExpectedColumnsNumber() * this.getExpectedPagesPerColumn();
    },
    /**
     * @protected
     * Calculates which locked columns belong to which page.
     * @return {Array[Object]} Array of object
     */
    calculateLockedColumnPages: function() {
        var me = this,
            result = [],
            columns = me.lockedColumns,
            leftWidth = me.paperWidth,
            page;
        for (var i = 0,
            l = columns.length; i < l; i++) {
            var column = columns[i],
                width = column.width;
            page = page || {
                start: i,
                end: i
            };
            leftWidth -= width;
            // if column violated page width
            if (leftWidth < 0) {
                // push page
                result.push(page);
                if (leftWidth) {
                    page = {
                        start: i,
                        end: i
                    };
                }
                leftWidth = me.paperWidth - width + leftWidth;
            } else {
                page.end = i;
            }
        }
        // if we have unpushed column page
        if (page) {
            page.leftWidth = leftWidth;
            result.push(page);
        }
        return result;
    },
    getPageTplData: function(data) {
        return Ext.apply(this.callParent(arguments), {
            title: data.number + ' of ' + this.numberOfPages + ' (column: ' + data.column + ', row: ' + data.row + ')'
        });
    },
    showLockedColumns: function(startColumn, endColumn) {
        var me = this,
            columns = me.lockedColumns,
            width = 0;
        startColumn = startColumn || 0;
        endColumn = endColumn || columns.length - 1;
        for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            if (i >= startColumn && i <= endColumn) {
                column.column.show();
                width += column.width;
            } else {
                column.column.hide();
            }
        }
        return width;
    },
    removeInvisibleEvents: function(leftBorder, rightBorder) {
        var me = this,
            normalBody = me.getNormalGridBody(),
            eventSelector = me.normalView.eventSelector;
        Ext.Array.each(Ext.fly(normalBody).select(eventSelector).elements, function(el) {
            var start = parseInt(el.style.left, 10),
                end = start + parseInt(el.style.width, 10);
            if (end < leftBorder || start > rightBorder) {
                me.removeNode(el);
            }
        });
    },
    removeHiddenLockedColumns: function(lockedGrid) {
        var me = this,
            page = me.getCurrentPage(),
            tableBody = me.getLockedGridBody();
        for (var i = 0; i < me.lockedColumns.length; i++) {
            var column = me.lockedColumns[i].column;
            if (i < lockedGrid.start || i > lockedGrid.end) {
                var headerSelector = '#' + column.getId();
                var header = page.select(headerSelector);
                me.removeNode(header);
                var cellSelector = column.getCellSelector();
                var cells = Ext.fly(tableBody).select(cellSelector);
                me.removeNode(cells);
            }
        }
    },
    fitComponentIntoPage: function() {
        var me = this,
            component = me.getComponent();
        component.setWidth(me.paperWidth);
    },
    prepareComponent: function(component, config) {
        var me = this,
            columns = me.lockedColumns = [];
        me.callParent(arguments);
        // keep visible locked columns data
        me.lockedGrid.headerCt.items.each(function(column) {
            if (!column.hidden) {
                columns.push({
                    column: column,
                    width: column.getWidth()
                });
            }
        });
    },
    restoreComponentState: function() {
        this.callParent(arguments);
        // restore locked columns visibility
        this.showLockedColumns();
    },
    /**
     * @protected
     * Performs last changes to {@link #getCurrentPage the current page} being extracted before it's pushed into {@link #extractedPages} array.
     * This function will add dependencies to the output fragment.
     * @param {Object} [config] Optional configuration object.
     * @return {Ext.dom.Element} element Element holding the page.
     */
    preparePageToCommit: function() {
        var me = this,
            frag = me.callParent(arguments),
            splitter = frag.down('.' + Ext.baseCSSPrefix + 'splitter', true),
            depsCt = frag.selectNode('.sch-dependencyview-ct'),
            pageFrame = me.pageFrames[me.columnPageIndex - 1];
        if (splitter) {
            if (pageFrame.lockedHidden) {
                splitter.style.display = 'none';
                // fix normal grid position (it has "left" style equal to the splitter width)
                frag.down('.' + Ext.baseCSSPrefix + 'grid-inner-normal', true).style.left = 0;
            } else {
                Ext.fly(splitter).setHeight('100%');
            }
        }
        if (!pageFrame.normalHidden) {
            if (depsCt) {
                depsCt.innerHTML = me.dependenciesHtml;
                // move the dependencies div to match the position of the dependency lines
                depsCt.style.top = me.depsTopOffset + 'px';
                depsCt.style.visibility = 'visible';
            }
            var normalView = frag.selectNode('#' + me.normalView.id);
            if (normalView) {
                var tableWidth = me.normalGrid.el.down(me.tableSelector).getWidth();
                // hiding dependencies
                normalView.style.width = tableWidth + 'px';
                // remove scrollbars
                normalView.style.overflow = 'hidden';
            }
        }
        if (!pageFrame.lockedHidden) {
            var lockedView = frag.selectNode('#' + me.lockedView.id);
            if (lockedView) {
                // remove scrollbars
                lockedView.style.overflow = 'hidden';
            }
        }
        return frag;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.plugin.exporter.MultiPageVertical
 @extends Sch.plugin.exporter.AbstractExporter

  This class extracts pages in a vertical order. It fits all locked columns and the timeaxis on a single page and will generate
  new pages vertically down for the rows.

  The exporterId of this exporter is `multipagevertical`

  To adjust column widths for specific export cases the function {@link #fitLockedColumnWidth} can be overridden.

*/
Ext.define('Sch.plugin.exporter.MultiPageVertical', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Multi pages (vertically)'
     */
    config: {
        exporterId: 'multipagevertical'
    },
    minRowHeight: 20,
    minAverageColumnWidth: 100,
    visibleColumns: null,
    visibleColumnsWidth: 0,
    depsTopOffset: 0,
    onRowsCollected: function(lockedRows, normalRows) {
        var me = this;
        me.depsTopOffset = -me.firstExportedRowOffset;
        me.iterateAsync(function(next, rowIndex) {
            if (rowIndex === normalRows.length) {
                me.onPagesExtracted();
                return;
            }
            var index = rowIndex,
                spaceLeft = me.printHeight,
                rowsHeight = 0,
                lockeds = [],
                normals = [],
                newPage = false,
                normal, locked;
            me.startPage();
            while (!newPage && index < normalRows.length) {
                normal = normalRows[index];
                locked = lockedRows[index];
                spaceLeft -= normal.height;
                if (spaceLeft > 0) {
                    rowsHeight += normal.height;
                    locked && lockeds.push(locked);
                    normals.push(normal);
                    index++;
                } else {
                    newPage = true;
                }
            }
            me.fillGrids(lockeds, normals);
            me.commitPage({
                rowIndex: index,
                rowsHeight: rowsHeight
            });
            me.secondaryCanvasOffset -= rowsHeight;
            next(index);
        }, me, 0);
    },
    startPage: function() {
        var me = this;
        me.callParent(arguments);
        var view = me.getCurrentPage().select('#' + me.lockedView.id).first();
        view.dom.style.overflow = 'visible';
    },
    commitPage: function(pageData) {
        var me = this;
        me.callParent(arguments);
        if (me.depView && me.depView.getDependencyStore()) {
            // on next page dependencies will be shifted vertically based on this page height
            me.depsTopOffset -= pageData.rowsHeight;
        }
    },
    getExpectedNumberOfPages: function() {
        return Math.ceil(this.normalRowsHeight / this.printHeight);
    },
    prepareColumns: function(columns) {
        this.callParent(arguments);
        var me = this,
            visibleColumns = me.visibleColumns = [];
        me.visibleColumnsWidth = 0;
        me.lockedGrid.headerCt.items.each(function(column) {
            if (!column.hidden) {
                visibleColumns.push({
                    column: column,
                    width: column.getWidth()
                });
                me.visibleColumnsWidth += column.getWidth();
            }
        });
    },
    fitComponentIntoPage: function() {
        var me = this,
            component = me.getComponent(),
            view = component.getSchedulingView(),
            normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid,
            totalWidth = me.getTotalWidth(),
            ticks = me.ticks,
            timeColumnWidth = me.timeColumnWidth || view.timeAxisViewModel.getTickWidth();
        var lockedWidth = Math.floor((me.visibleColumnsWidth / totalWidth) * me.paperWidth);
        //correct lockedcolumn width if it is too small
        var visibleColumnCount = me.visibleColumns.length,
            preferedLockedWidth = visibleColumnCount * me.minAverageColumnWidth;
        //preferred locked width can never take more than half of the page
        preferedLockedWidth = preferedLockedWidth > me.paperWidth / 2 ? Math.floor(me.paperWidth / 2) : preferedLockedWidth;
        //if preferred width is wider than current locked width, then use preferred width
        lockedWidth = preferedLockedWidth > lockedWidth ? preferedLockedWidth : lockedWidth;
        var normalWidth = me.paperWidth - lockedWidth;
        var tickWidth = normalWidth / ticks.length;
        me.setRowHeight((tickWidth / timeColumnWidth) * me.getRowHeight());
        component.setWidth(me.paperWidth);
        normalGrid.setWidth(normalWidth);
        lockedGrid.setWidth(lockedWidth);
        //spread lockedcolums over the available width
        me.fitLockedColumnWidth(lockedWidth);
        component.setTimeColumnWidth(tickWidth);
    },
    setRowHeight: function(rowHeight) {
        var me = this;
        me.component.setRowHeight(rowHeight < me.minRowHeight ? me.minRowHeight : rowHeight);
    },
    /**
     * Function that fits locked columns based on the available width.
     *
     * @param {String} totalWidth int indicating the totalWidth available for the locked columns.
     */
    fitLockedColumnWidth: function(totalWidth) {
        var me = this,
            visibleColumns = this.visibleColumns;
        //Keep ratio
        var ratio = totalWidth / me.visibleColumnsWidth;
        if (visibleColumns.length) {
            for (var i = 0; i < visibleColumns.length; i++) {
                var column = visibleColumns[i],
                    currentWidth = column.width,
                    width = Math.floor(currentWidth * ratio);
                column.column.setWidth(width);
            }
            this._restoreColumnWidth = true;
        }
    },
    restoreComponentState: function(component) {
        var me = this;
        component = component || me.getComponent();
        // restore original columns width (since we fit them while exporting)
        if (this._restoreColumnWidth) {
            var visibleColumns = this.visibleColumns;
            for (var i = 0; i < visibleColumns.length; i++) {
                var cWrap = visibleColumns[i];
                cWrap.column.setWidth(cWrap.width);
            }
        }
        this.callParent(arguments);
    },
    preparePageToCommit: function() {
        var me = this,
            frag = me.callParent(arguments),
            depsCt = frag.selectNode('.sch-dependencyview-ct');
        if (depsCt) {
            depsCt.innerHTML = me.dependenciesHtml;
            //move the dependencies div to match the position of the dependency lines
            depsCt.style.top = me.depsTopOffset + 'px';
            depsCt.style.left = '0px';
            depsCt.style.visibility = 'visible';
        }
        // hiding dependencies
        var tableWidth = me.normalGrid.el.down(me.tableSelector).getWidth();
        var normalView = frag.selectNode('#' + me.normalView.id);
        normalView.style.width = tableWidth + 'px';
        //remove scrollbar
        normalView.style.overflow = 'hidden';
        var lockedView = frag.selectNode('#' + me.lockedView.id);
        //remove scrollbar
        lockedView.style.overflow = 'hidden';
        var splitter = frag.selectNode('.' + Ext.baseCSSPrefix + 'splitter');
        if (splitter)  {
            splitter.style.height = '100%';
        }
        
        return frag;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.widget.ResizePicker
@private
@extends Ext.Panel

Size picker widget for changing column width/rows height.

*/
Ext.define('Sch.widget.ResizePicker', {
    extend: 'Ext.Panel',
    alias: 'widget.dualrangepicker',
    width: 200,
    height: 200,
    border: true,
    collapsible: false,
    bodyStyle: 'position:absolute; margin:5px',
    verticalCfg: {
        height: 120,
        value: 24,
        increment: 2,
        minValue: 20,
        maxValue: 80,
        reverse: true,
        disabled: true
    },
    horizontalCfg: {
        width: 120,
        value: 100,
        minValue: 25,
        increment: 5,
        maxValue: 200,
        disable: true
    },
    initComponent: function() {
        var me = this;
        //me.addEvents('change', 'changecomplete', 'select');
        me.horizontalCfg.value = me.dialogConfig.columnWidth;
        me.verticalCfg.value = me.dialogConfig.rowHeight;
        me.verticalCfg.disabled = me.dialogConfig.scrollerDisabled || false;
        me.dockedItems = [
            me.vertical = new Ext.slider.Single(Ext.apply({
                dock: 'left',
                style: 'margin-top:10px',
                vertical: true,
                stateful: me.dialogConfig.stateful,
                stateId: 'exporter_resize_vertical',
                stateEvents: [
                    'change'
                ],
                listeners: {
                    change: me.onSliderChange,
                    changecomplete: me.onSliderChangeComplete,
                    scope: me
                }
            }, me.verticalCfg)),
            me.horizontal = new Ext.slider.Single(Ext.apply({
                dock: 'top',
                style: 'margin-left:28px',
                stateful: me.dialogConfig.stateful,
                stateId: 'exporter_resize_horizontal',
                stateEvents: [
                    'change'
                ],
                listeners: {
                    change: me.onSliderChange,
                    changecomplete: me.onSliderChangeComplete,
                    scope: me
                }
            }, me.horizontalCfg))
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.addCls('sch-ux-range-picker');
        me.valueHandle = me.body.createChild({
            cls: 'sch-ux-range-value',
            cn: {
                tag: 'span'
            }
        });
        me.valueSpan = me.valueHandle.down('span');
        var dd = new Ext.dd.DD(me.valueHandle);
        Ext.apply(dd, {
            startDrag: function() {
                me.dragging = true;
                this.constrainTo(me.body);
            },
            onDrag: function() {
                me.updateValuesFromHandles();
            },
            endDrag: function() {
                me.updateValuesFromHandles();
                me.dragging = false;
            }
        });
        me.setValues(me.getValues());
        me.callParent(arguments);
        me.body.on('click', me.onBodyClick, me);
    },
    onBodyClick: function(e, t) {
        var xy = [
                e.getXY()[0] - 8 - this.body.getX(),
                e.getXY()[1] - 8 - this.body.getY()
            ];
        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        this.updateValuesFromHandles();
        this.onSliderChangeComplete();
    },
    updateValuesFromHandles: function() {
        this.setValues(this.getValuesFromXY());
    },
    getAvailableWidth: function() {
        return this.body.getWidth() - 18;
    },
    getAvailableHeight: function() {
        return this.body.getHeight() - 18;
    },
    getValuesFromXY: function(xy) {
        xy = xy || [
            this.valueHandle.getLeft(true),
            this.valueHandle.getTop(true)
        ];
        var xFraction = xy[0] / this.getAvailableWidth();
        var yFraction = xy[1] / this.getAvailableHeight();
        var horizontalVal = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * xFraction);
        var verticalVal = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * yFraction) + this.verticalCfg.minValue;
        return [
            horizontalVal + this.horizontalCfg.minValue,
            verticalVal
        ];
    },
    getXYFromValues: function(values) {
        var xRange = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var yRange = this.verticalCfg.maxValue - this.verticalCfg.minValue;
        var x = Math.round((values[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / xRange);
        var verticalVal = values[1] - this.verticalCfg.minValue;
        var y = Math.round(verticalVal * this.getAvailableHeight() / yRange);
        return [
            x,
            y
        ];
    },
    updatePosition: function() {
        var values = this.getValues();
        var xy = this.getXYFromValues(values);
        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled) {
            this.valueHandle.setTop(this.dialogConfig.rowHeight);
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        }
        this.positionValueText();
        this.setValueText(values);
    },
    positionValueText: function() {
        var handleTop = this.valueHandle.getTop(true);
        var handleLeft = this.valueHandle.getLeft(true);
        this.valueSpan.setLeft(handleLeft > 30 ? -30 : 10);
        this.valueSpan.setTop(handleTop > 10 ? -20 : 20);
    },
    setValueText: function(values) {
        if (this.verticalCfg.disabled)  {
            values[1] = this.dialogConfig.rowHeight;
        }
        
        this.valueSpan.update('[' + values.toString() + ']');
    },
    setValues: function(values) {
        this.horizontal.setValue(values[0]);
        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled)  {
                this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - values[1]);
            }
            
        } else {
            if (!this.verticalCfg.disabled)  {
                this.vertical.setValue(values[1]);
            }
            
        }
        if (!this.dragging) {
            this.updatePosition();
        }
        this.positionValueText();
        this.setValueText(values);
    },
    getValues: function() {
        if (!this.verticalCfg.disabled) {
            var verticalVal = this.vertical.getValue();
            if (this.verticalCfg.reverse) {
                verticalVal = this.verticalCfg.maxValue - verticalVal + this.verticalCfg.minValue;
            }
            return [
                this.horizontal.getValue(),
                verticalVal
            ];
        }
        return [
            this.horizontal.getValue()
        ];
    },
    onSliderChange: function() {
        this.fireEvent('change', this, this.getValues());
        if (!this.dragging) {
            this.updatePosition();
        }
    },
    onSliderChangeComplete: function() {
        this.fireEvent('changecomplete', this, this.getValues());
    },
    afterLayout: function() {
        this.callParent(arguments);
        this.updatePosition();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.widget.ColumnPicker
 @private
 @extends Ext.form.field.ComboBox

 Columnpicker widget for picking columns from a panel.
 */
Ext.define('Sch.widget.ColumnPicker', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.Store'
    ],
    multiSelect: true,
    valueField: 'id',
    displayField: 'name',
    forceSelection: true,
    editable: false,
    listConfig: {
        cls: 'sch-columnpicker-list'
    },
    /**
     * @cfg {Ext.grid.column.Column[]} An array of columns to choose from
     */
    columns: null,
    /**
     * @cfg {String} columnEmptyText Text to show when column text is empty
     */
    columnEmptyText: null,
    columnEmptyRegExp: /&(nbsp|#160);/,
    initComponent: function() {
        this.store = new Ext.data.Store({
            proxy: 'memory',
            fields: [
                'id',
                'name',
                'column'
            ],
            data: this.processColumns(this.columns)
        });
        this.callParent(arguments);
    },
    processColumns: function(columns) {
        var me = this,
            data = [],
            value = [];
        Ext.Array.each(columns, function(column) {
            data.push({
                id: column.id,
                name: me.getColumnTitle(column),
                column: column
            });
            if (!column.isHidden()) {
                value.push(column.id);
            }
        });
        this.value = this.value || value;
        return data;
    },
    getColumnTitle: function(column) {
        var me = this;
        return column.text.match(me.columnEmptyRegExp) ? me.columnEmptyText : column.text;
    },
    getSelectedColumns: function() {
        var me = this,
            value = me.getValue();
        if (!Ext.isArray(value)) {
            value = [
                value
            ];
        }
        return Ext.Array.map(value, function(id) {
            return me.store.getById(id).get('column');
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.widget.ExportDialogForm
 @private
 @extends Ext.form.Panel

 Form for {@link Sch.widget.ExportDialog}. This is a private class and can be overridden by providing `formPanel` option to
 {@link Sch.plugin.Export#cfg-exportDialogConfig exportDialogConfig}.
 */
Ext.define('Sch.widget.ExportDialogForm', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.data.Store',
        'Ext.XTemplate',
        'Ext.form.field.Number',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Date',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Sch.widget.ResizePicker',
        'Sch.widget.ColumnPicker'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.export_dialog_form',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - formatFieldLabel         : 'Paper format',
            - orientationFieldLabel    : 'Orientation',
            - rangeFieldLabel          : 'Schedule range',
            - showHeaderLabel          : 'Show header',
            - showFooterLabel          : 'Show footer',
            - orientationPortraitText  : 'Portrait',
            - orientationLandscapeText : 'Landscape',
            - completeViewText         : 'Complete schedule',
            - currentViewText          : 'Visible schedule',
            - dateRangeText            : 'Date range',
            - dateRangeFromText        : 'Export from',
            - pickerText               : 'Resize column/rows to desired value',
            - dateRangeToText          : 'Export to',
            - exportersFieldLabel      : 'Control pagination',
            - adjustCols               : 'Adjust column width',
            - adjustColsAndRows        : 'Adjust column width and row height',
            - specifyDateRange         : 'Specify date range',
            - columnPickerLabel        : 'Select columns',
            - completeDataText         : 'Complete schedule (for all events)',
            - dpiFieldLabel            : 'DPI (dots per inch)',
            - rowsRangeLabel           : 'Rows range',
            - allRowsLabel             : 'All rows',
            - visibleRowsLabel         : 'Visible rows'
            - columnEmptyText          : '[no title]'
     */
    border: false,
    bodyPadding: '10 10 0 10',
    autoHeight: true,
    stateful: true,
    /**
     * @property {Ext.form.field.ComboBox} rangeField "Export range" field.
     */
    rangeField: null,
    resizerHolder: null,
    /**
     * @property {Sch.widget.ResizePicker} resizePicker "Resize column/rows to desired value" picker.
     */
    resizePicker: null,
    /**
     * @property {Ext.form.field.Date} "Export dateFromFieldfrom" field.
     */
    dateFromField: null,
    /**
     * @property {Ext.form.field.Date} dateToField "Export to" field.
     */
    dateToField: null,
    datesHolder: null,
    /**
     * @property {Sch.widget.ColumnPicker} columnPicker "Select columns for export" field.
     */
    columnPicker: null,
    /**
     * @property {Ext.form.field.ComboBox} rangeField "Rows range" field.
     */
    rowsRangeField: null,
    /**
     * @property {Ext.form.field.ComboBox} exportersField "Manage pagination" field.
     */
    exportersField: null,
    /**
     * @property {Ext.form.field.ComboBox} formatField "Paper format" field.
     */
    formatField: null,
    /**
     * @property {Ext.form.field.ComboBox} orientationField "Orientation" field.
     */
    orientationField: null,
    /**
     * @property {Ext.form.field.Number} dpiField "DPI (dots per inch)" field.
     */
    dpiField: null,
    /**
     * @property {Ext.form.field.Checkbox} showHeaderField "Show header" field.
     */
    showHeaderField: null,
    /**
     * @property {Ext.form.field.Checkbox} showFooterField "Show footer" field.
     */
    showFooterField: null,
    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date range fields ("Export from" and "Export to" fields).
     */
    dateRangeFormat: '',
    /**
     * @cfg {Object} columnPickerConfig Configuration for the "Select columns for export" field.
     */
    columnPickerConfig: null,
    /**
     * @cfg {Object} dpiFieldConfig Configuration for the "DPI (dots per inch)" field
     */
    dpiFieldConfig: null,
    /**
     * @cfg {Boolean} dateRangeRestriction Set to "false" to disable the maximum and minimum allowed value limits for the date range fields ("Export from" and "Export to" fields).
     */
    dateRangeRestriction: true,
    rangeFieldConfig: null,
    rowsRangeFieldConfig: null,
    formatFieldConfig: null,
    orientationFieldConfig: null,
    exportersFieldConfig: null,
    showHeaderFieldConfig: null,
    showFooterFieldConfig: null,
    dateFromFieldConfig: null,
    dateToFieldConfig: null,
    /**
     * @cfg {Boolean} showResizePicker Indicates if "Resize column/rows to desired value" panel should to be shown in the export dialog.
     */
    showResizePicker: false,
    /**
     * @cfg {Boolean} showColumnPicker Indicates if the "Select columns for export" field should to be shown in the export dialog.
     */
    showColumnPicker: true,
    /**
     * @cfg {Boolean} showDPIField Indicates if the "DPI (dots per inch)" field should to be shown in the export dialog.
     */
    showDPIField: true,
    /**
     * @cfg {Boolean} showShowHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     */
    showShowHeaderField: true,
    /**
     * @cfg {Boolean} showShowFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     */
    showShowFooterField: false,
    /**
     * @cfg {Boolean} showRowsRangeField Indicates if the "Rows range" field should be displayed in the export dialog.
     */
    showRowsRangeField: true,
    initComponent: function() {
        var me = this;
        me.fieldDefaults = Ext.apply({
            labelAlign: 'left',
            labelWidth: 120,
            anchor: '99%'
        }, me.fieldDefaults);
        me.items = me.createFields();
        me.callParent(arguments);
        // trigger fields `change` listeners to enable/disable related fields and do other UI cosmetics changes
        me.onRangeChange(me.rangeField, me.rangeField.getValue());
        me.onExporterChange(me.exportersField, me.exportersField.getValue());
    },
    isValid: function() {
        var me = this;
        if (me.rangeField.getValue() == 'date') {
            return me.dateFromField.isValid() && me.dateToField.isValid();
        }
        return true;
    },
    getValues: function(asString, dirtyOnly, includeEmptyText, useDataValues) {
        var result = this.callParent(arguments);
        result.showHeader = !!result.showHeader;
        result.showFooter = !!result.showFooter;
        result.onlyVisibleRows = !!result.onlyVisibleRows;
        if (this.resizePicker && this.rangeField.getValue() == 'current') {
            var cellSize = this.resizePicker.getValues();
            if (asString) {
                result += '&cellSize[0]=' + cellSize[0] + '&cellSize[1]=' + cellSize[1];
            } else {
                result.cellSize = cellSize;
            }
        }
        if (this.columnPicker) {
            result.columns = this.columnPicker.getSelectedColumns();
        }
        return result;
    },
    createFields: function() {
        var me = this,
            beforeLabelTextTpl = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">',
            afterLabelTextTpl = '<td><div class="sch-fieldcontainer-separator"></div></table>';
        // col/row resizer
        if (me.showResizePicker) {
            me.resizePicker = new Sch.widget.ResizePicker({
                dialogConfig: me,
                margin: '10 20'
            });
            me.resizerHolder = new Ext.form.FieldContainer({
                fieldLabel: me.scrollerDisabled ? me.L('adjustCols') : me.L('adjustColsAndRows'),
                labelAlign: 'top',
                hidden: true,
                labelSeparator: '',
                beforeLabelTextTpl: beforeLabelTextTpl,
                afterLabelTextTpl: afterLabelTextTpl,
                layout: 'vbox',
                defaults: {
                    flex: 1,
                    allowBlank: false
                },
                items: [
                    me.resizePicker
                ]
            });
        }
        // from date
        me.dateFromField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'datefield',
            fieldLabel: me.L('dateRangeFromText'),
            baseBodyCls: 'sch-exportdialogform-date',
            name: 'dateFrom',
            format: me.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank: false,
            maxValue: me.dateRangeRestriction && me.endDate || null,
            minValue: me.dateRangeRestriction && me.startDate || null,
            value: me.startDate
        }), me.dateFromFieldConfig));
        // till date
        me.dateToField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'datefield',
            fieldLabel: me.L('dateRangeToText'),
            name: 'dateTo',
            format: me.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls: 'sch-exportdialogform-date',
            allowBlank: false,
            maxValue: me.dateRangeRestriction && me.endDate || null,
            minValue: me.dateRangeRestriction && me.startDate || null,
            value: me.endDate
        }), me.dateToFieldConfig));
        // date fields holder
        me.datesHolder = new Ext.form.FieldContainer({
            fieldLabel: me.L('specifyDateRange'),
            labelAlign: 'top',
            hidden: true,
            labelSeparator: '',
            beforeLabelTextTpl: beforeLabelTextTpl,
            afterLabelTextTpl: afterLabelTextTpl,
            layout: 'vbox',
            defaults: {
                flex: 1,
                allowBlank: false
            },
            items: [
                me.dateFromField,
                me.dateToField
            ]
        });
        if (me.showColumnPicker) {
            me.columnPicker = new Sch.widget.ColumnPicker(me.applyStateful(Ext.apply({
                fieldLabel: me.L('columnPickerLabel'),
                columnEmptyText: me.L('columnEmptyText'),
                cls: 'sch-export-dialog-columns'
            }, me.columnPickerConfig)));
        }
        if (me.showDPIField) {
            me.dpiField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
                xtype: 'numberfield',
                fieldLabel: me.L('dpiFieldLabel'),
                cls: 'sch-export-dialog-dpi',
                minValue: 65,
                name: 'DPI',
                value: me.exportConfig.DPI,
                maxValue: 200
            }), me.dpiFieldConfig));
        }
        if (me.showShowHeaderField) {
            me.showHeaderField = Ext.ComponentManager.create(Ext.apply(me.applyStatefulFull({
                xtype: 'checkbox',
                fieldLabel: me.L('showHeaderLabel'),
                cls: 'sch-export-dialog-header',
                name: 'showHeader',
                checked: !!me.exportConfig.showHeader,
                checkedValue: true,
                uncheckedValue: false
            }), me.showHeaderFieldConfig));
        }
        if (me.showShowFooterField) {
            me.showFooterField = Ext.ComponentManager.create(Ext.apply(me.applyStatefulFull({
                xtype: 'checkbox',
                fieldLabel: me.L('showFooterLabel'),
                cls: 'sch-export-dialog-footer',
                name: 'showFooter',
                checked: !!me.exportConfig.showFooter,
                checkedValue: true,
                uncheckedValue: false
            }), me.showFooterFieldConfig));
        }
        me.formatField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'combobox',
            fieldLabel: me.L('formatFieldLabel'),
            value: me.exportConfig.format,
            triggerAction: 'all',
            forceSelection: true,
            editable: false,
            name: 'format',
            queryMode: 'local',
            store: me.pageFormats || [
                "A5",
                "A4",
                "A3",
                "Letter",
                "Legal"
            ]
        }), me.formatFieldConfig));
        me.orientationField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'combobox',
            fieldLabel: me.L('orientationFieldLabel'),
            value: me.exportConfig.orientation,
            triggerAction: 'all',
            forceSelection: true,
            editable: false,
            name: 'orientation',
            displayField: 'name',
            valueField: 'value',
            queryMode: 'local',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: [
                    {
                        name: me.L('orientationPortraitText'),
                        value: 'portrait'
                    },
                    {
                        name: me.L('orientationLandscapeText'),
                        value: 'landscape'
                    }
                ]
            }
        }), me.orientationFieldConfig));
        me.rangeField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'combobox',
            fieldLabel: me.L('rangeFieldLabel'),
            value: me.exportConfig.range,
            triggerAction: 'all',
            cls: 'sch-export-dialog-range',
            forceSelection: true,
            editable: false,
            name: 'range',
            queryMode: 'local',
            displayField: 'name',
            valueField: 'value',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: [
                    {
                        name: me.L('completeViewText'),
                        value: 'complete'
                    },
                    {
                        name: me.L('completeDataText'),
                        value: 'completedata'
                    },
                    {
                        name: me.L('dateRangeText'),
                        value: 'date'
                    },
                    {
                        name: me.L('currentViewText'),
                        value: 'current'
                    }
                ]
            }
        }), me.rangeFieldConfig));
        me.mon(me.rangeField, 'change', me.onRangeChange, me);
        me.exportersField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'combobox',
            fieldLabel: me.L('exportersFieldLabel'),
            value: me.defaultExporter,
            triggerAction: 'all',
            cls: 'sch-export-dialog-exporter',
            forceSelection: true,
            editable: false,
            name: 'exporterId',
            queryMode: 'local',
            displayField: 'name',
            valueField: 'value',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: Ext.Array.map(me.exporters, function(exporter) {
                    return {
                        name: exporter.getName(),
                        value: exporter.getExporterId()
                    };
                })
            }
        }), me.exportersFieldConfig));
        me.mon(me.exportersField, 'change', me.onExporterChange, me);
        if (me.showRowsRangeField) {
            me.rowsRangeField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
                xtype: 'combobox',
                fieldLabel: me.L('rowsRangeLabel'),
                value: me.exportConfig.rowsRange,
                triggerAction: 'all',
                cls: 'sch-export-dialog-rowsrange',
                forceSelection: true,
                editable: false,
                name: 'rowsRange',
                queryMode: 'local',
                displayField: 'name',
                valueField: 'value',
                store: {
                    fields: [
                        'name',
                        'value'
                    ],
                    data: [
                        {
                            name: me.L('allRowsLabel'),
                            value: 'all'
                        },
                        {
                            name: me.L('visibleRowsLabel'),
                            value: 'visible'
                        }
                    ]
                }
            }), me.rowsRangeFieldConfig));
        }
        var items = [];
        items.push(me.rangeField);
        if (me.resizerHolder) {
            items.push(me.resizerHolder);
        }
        items.push(me.datesHolder);
        if (me.columnPicker) {
            items.push(me.columnPicker);
        }
        if (me.rowsRangeField) {
            items.push(me.rowsRangeField);
        }
        items.push(me.exportersField, me.formatField, me.orientationField);
        if (me.dpiField) {
            items.push(me.dpiField);
        }
        if (me.showHeaderField) {
            items.push(me.showHeaderField);
        }
        if (me.showFooterField) {
            items.push(me.showFooterField);
        }
        return items;
    },
    // Applies configs to enable "stateful" mode for the field ("config" being provided).
    // Should be used for the "textfield" ancestors (numberfield/picker fields etc)
    applyStateful: function(config) {
        if (!this.stateful)  {
            return config;
        }
        
        var me = this,
            prefix = me.stateId || 'exporter';
        return Ext.applyIf(config, {
            stateful: true,
            stateId: prefix + '_' + config.name
        });
    },
    // Applies configs to enable "stateful" mode for the field ("config" being provided).
    // Should be used for the NON-"textfield" ancestors since they require implementing a pair of applyState/getState methods
    applyStatefulFull: function(config) {
        if (!this.stateful)  {
            return config;
        }
        
        var me = this;
        return Ext.apply(me.applyStateful(config), {
            stateEvents: [
                'change'
            ],
            applyState: me.applyFieldState,
            getState: me.getFieldState
        });
    },
    getFieldState: function() {
        return {
            value: this.getValue()
        };
    },
    applyFieldState: function(state) {
        if ('value' in state) {
            this.setValue(state.value);
        }
    },
    onRangeChange: function(field, newValue) {
        switch (newValue) {
            case 'complete':
            case 'completedata':
                this.datesHolder.hide();
                this.resizerHolder && this.resizerHolder.hide();
                break;
            case 'date':
                this.datesHolder.show();
                this.resizerHolder && this.resizerHolder.hide();
                break;
            case 'current':
                this.datesHolder.hide();
                if (this.resizerHolder) {
                    this.resizerHolder.show();
                    this.resizePicker.expand(true);
                };
                break;
        }
    },
    /**
     * @protected
     * This method is called after user selects an export mode in the corresponding field.
     * @param  {Ext.form.field.Field} field Reference to the form field
     * @param  {String} exporterId Selected exporter identifier
     */
    onExporterChange: function(field, exporterId) {
        switch (exporterId) {
            case 'singlepage':
                this.disableFields(true);
                break;
            default:
                this.disableFields(false);
        }
    },
    disableFields: function(value) {
        var me = this;
        me.formatField.setDisabled(value);
        me.orientationField.setDisabled(value);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.widget.ExportDialog
 @private
 @extends Ext.window.Window

 Widget for export options.

 */
Ext.define('Sch.widget.ExportDialog', {
    alternateClassName: 'Sch.widget.PdfExportDialog',
    extend: 'Ext.window.Window',
    requires: [
        'Ext.ProgressBar',
        'Sch.widget.ExportDialogForm'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: "widget.exportdialog",
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title            : 'Export Settings',
            - exportButtonText : 'Export',
            - cancelButtonText : 'Cancel',
            - progressBarText  : 'Exporting...'
     */
    width: 450,
    cls: 'sch-exportdialog',
    frame: false,
    layout: 'fit',
    draggable: true,
    constrain: true,
    /**
     * @cfg {Ext.Component} progressBar Progress bar component.
     */
    progressBar: null,
    /**
     * @cfg {Ext.Component} buttonsPanel Component with buttons controlling export.
     */
    buttonsPanel: null,
    /**
     * @cfg {Object} buttonsPanelScope
     * The scope for the {@link #buttonsPanel}
     */
    buttonsPanelScope: null,
    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date range fields ("Export from" and "Export to" fields).
     */
    /**
     * @cfg {Boolean} showHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     * @removed This config was renamed since the name was used by another existing property. Please use {@link #showShowHeaderField} instead.
     */
    /**
     * @cfg {Boolean} showShowHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     */
    /**
     * @cfg {Boolean} showFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     * @removed This config was renamed since the name was used by another existing property. Please use {@link #showShowFooterField} instead.
     */
    /**
     * @cfg {Boolean} showShowFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     */
    /**
     * @cfg {Boolean} showColumnPicker Indicates if the "Select columns for export" field should to be shown in the export dialog.
     */
    /**
     * @cfg {Object} columnPickerConfig Configuration for the "Select columns for export" field.
     */
    /**
     * @cfg {Boolean} showDPIField Indicates if the "DPI (dots per inch)" field should to be shown in the export dialog.
     */
    /**
     * @cfg {Object} dpiFieldConfig Configuration for the "DPI (dots per inch)" field
     */
    /**
     * @cfg {Boolean} showResizePicker Indicates if "Resize column/rows to desired value" panel should to be shown in the export dialog.
     */
    /**
     * @cfg {Boolean} dateRangeRestriction Set to "false" to disable the maximum and minimum allowed value limits for the date range fields ("Export from" and "Export to" fields).
     */
    /**
     * @cfg {Object} doExportFnScope Set the scope for the doExportFn.
     */
    doExportFnScope: null,
    /**
     * @cfg doExportFn The function to be called by the export buttonhandler. This function will be automatically set when using Sch.plugin.Export plugin.
     *
     * @param exportConfig
     * @param successFn
     * @param failFn
     */
    doExportFn: function(exportConfig, successFn, failFn) {
        throw 'Sch.widget.ExportDialog: doExportFn needs to be set in the config';
    },
    form: null,
    defaultFormXType: 'export_dialog_form',
    exportButtonConfig: null,
    cancelButtonConfig: null,
    formConfigs: 'pageFormats,startDate,endDate,rowHeight,columnWidth,defaultExporter,exporters,' + 'dateRangeFormat,exportConfig,showColumnPicker,columnPickerConfig,showDPIField,dpiFieldConfig,showShowHeaderField,' + 'showShowFooterField,showResizePicker,stateful,stateId,dateRangeRestriction,showRowsRangeField,' + 'rowsRangeFieldConfig,rangeFieldConfig,formatFieldConfig,orientationFieldConfig,exportersFieldConfig',
    constructor: function(config) {
        Ext.apply(this, config);
        this.title = this.title || this.L('title');
        this.callParent(arguments);
    },
    // Some form configs can be provided directly to the dialog.
    // Their names are listed in "formConfigs" property.
    mapFormConfigs: function() {
        this.form = this.form || {};
        var form = this.form;
        var names = this.formConfigs.split(',');
        for (var i = 0,
            n = names.length; i < n; i++) {
            var name = names[i];
            if (this.hasOwnProperty(name) && !form.hasOwnProperty(name)) {
                form[name] = this[name];
            }
        }
        // TODO: backward compatibility
        if (this.hasOwnProperty('showFooterField') && !form.hasOwnProperty('showShowFooterField')) {
            form.showShowFooterField = this.showFooterField;
        }
        // TODO: backward compatibility
        if (this.hasOwnProperty('showHeaderField') && !form.hasOwnProperty('showShowHeaderField')) {
            form.showShowHeaderField = this.showHeaderField;
        }
    },
    initComponent: function() {
        var me = this;
        if (!me.form || !me.form.isForm) {
            me.mapFormConfigs();
            me.form = me.buildForm();
        }
        Ext.apply(me, {
            items: {
                items: [
                    me.form,
                    me.progressBar || me.buildProgressBar()
                ]
            },
            fbar: me.buildButtons(me.buttonsPanelScope || me)
        });
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        if (me.form.resizePicker) {
            me.relayEvents(me.form.resizePicker, [
                'change',
                'changecomplete',
                'select'
            ]);
        }
        me.callParent(arguments);
    },
    /**
     * Create Dialog's buttons.
     *
     * @param {Object} buttonsScope Scope for the buttons.
     * @return {Object[]} buttons Array containing buttons definition for Exporting/Cancelling export.
     */
    buildButtons: function(buttonsScope) {
        var me = this;
        return [
            Ext.apply({
                xtype: 'button',
                scale: 'medium',
                itemId: 'export',
                text: me.L('exportButtonText'),
                handler: me.onExportButtonPress,
                scope: buttonsScope || me
            }, me.exportButtonConfig),
            Ext.apply({
                xtype: 'button',
                scale: 'medium',
                itemId: 'cancel',
                text: me.L('cancelButtonText'),
                handler: me.onCancelButtonPress,
                scope: buttonsScope || me
            }, me.cancelButtonConfig)
        ];
    },
    onExportButtonPress: function() {
        if (this.form.isValid()) {
            var config = this.form.getValues();
            // disable export button and siaply progress bar
            this.beforeExport();
            // convert strings to dates before passing date range to doExport method
            var dateFormat = this.dateRangeFormat || Ext.Date.defaultFormat;
            if (config.dateFrom && !Ext.isDate(config.dateFrom)) {
                config.dateFrom = Ext.Date.parse(config.dateFrom, dateFormat);
            }
            if (config.dateTo && !Ext.isDate(config.dateTo)) {
                config.dateTo = Ext.Date.parse(config.dateTo, dateFormat);
            }
            this.doExportFn.call(this.doExportFnScope || this, config, this.onExportSuccess, this.onExportFailure);
        }
    },
    afterExport: function() {
        var btn = this.down('#export');
        btn && btn.enable();
        this.progressBar && this.progressBar.hide();
    },
    beforeExport: function() {
        var btn = this.down('#export');
        btn && btn.disable();
        this.progressBar && this.progressBar.show();
    },
    onExportSuccess: function() {
        this.afterExport();
    },
    onExportFailure: function() {
        this.afterExport();
    },
    onCancelButtonPress: function() {
        this.destroy();
    },
    /**
     * Build the {@link Sch.widget.ExportDialogForm} for the dialog window.
     *
     * @param {Object} config Config object for the form, containing field names and values.
     * @return {Sch.widget.ExportDialogForm} form
     */
    buildForm: function(config) {
        this.form = Ext.apply(this.form || {}, config);
        return Ext.ComponentManager.create(this.form, this.defaultFormXType);
    },
    buildProgressBar: function() {
        return this.progressBar = new Ext.ProgressBar({
            text: this.L('progressBarText'),
            animate: true,
            hidden: true,
            margin: '4px 10px 10px 10px'
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.plugin.Export
 @extends Ext.util.Observable

 A plugin (ptype = 'scheduler_export') generating PDF/PNG out of a scheduler panel. NOTE: This plugin will make an AJAX request to the server, POSTing
 the HTML to be exported. The {@link #printServer} URL must therefore be on the same domain as your application.

 ##Configuring/usage

 To use this plugin, add it to your scheduler as any other plugin. It is also required to have [PhantomJS][1] and [Imagemagick][2]
 installed on the server. The complete process of setting up a backend for the plugin can be found in the readme file inside export examples
 as well as on our [blog][3]. Note that the export feature is currently not supported if your store is buffered.

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore : resourceStore,
            eventStore    : eventStore,

            plugins       : [
                Ext.create('Sch.plugin.Export', {
                    printServer : 'server.php'
                })
            ]
        });

 The Scheduler instance will be extended with two new methods:

 - {@link #showExportDialog}, which shows export settings dialog

        scheduler.showExportDialog();

 - {@link #doExport} which actually performs the export operation using {@link #exportConfig} or provided config object :

        scheduler.doExport({
            format      : "A5",
            orientation : "landscape",
            range       : "complete",
            showHeader  : true,
            exporterId  : "singlepage"
        });


##Export options

 In the current state, the plugin gives few options to modify the look and feel of the generated PDF document through a dialog window :

 {@img scheduler/images/export_dialog.png 2x}

If no changes are made to the form, the {@link #exportConfig} will be used.

###Schedule range

 This setting controls the timespan visible on the exported document. The following options are available here :

 {@img scheduler/images/export_dialog_ranges.png 2x}

####Complete schedule

 Whole current timespan of the panel will be visible in the exported document.

####Complete schedule (for all events)

 The timespan will be adjusted to include all the events registered in the event store.

####Date range

 User can select the start and end dates visible on the exported document.

 {@img scheduler/images/export_dialog_ranges_date.png 2x}

####Visible schedule

 Timespan of the exported document/image will be set to the currently visible part of the time axis.

###Select columns

 This field allows to pick the locked grid columns to be exported:

 {@img scheduler/images/export_dialog_columns.png 2x}

###Rows range

 This setting controls rows to be included into the exported document. The following options are available here :

 {@img scheduler/images/export_dialog_row_ranges.png 2x}


####All rows

 All the panel rows will be included (default mode).

####Visible rows

 Only currently visible part of rows will be included into the result document.

##Control pagination

 This field allows to pick an exporter implementing needed way of pagination. The default exporter is `Multi pages`.

 {@img scheduler/images/export_modes.png 2x}

 Options:

-  `Single page`. Creates an export that fits one single page.

-  `Multi pages`. Creates an export that creates pages in both vertical and horizontal direction.

-  `Multi pages (vertically)`. Creates an export that creates pages in vertical direction.

##Paper Format

 This combo gives control of the size of the generated document/image by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`). Default format is `A4`.

 {@img scheduler/images/export_dialog_format.png 2x}

###Orientation

 This setting defines the orientation of the generated document/image.

 {@img scheduler/images/export_dialog_orientation.png 2x}

 Default option is the `portrait` (vertical) orientation :

 {@img scheduler/images/export_dialog_portrait.png 2x}

 Second option is the `landscape` (horizontal) orientation :

 {@img scheduler/images/export_dialog_landscape.png 2x}

##DPI (dots per inch)

 This field controls the DPI value to use for paper format related calculations:

 {@img scheduler/images/export_dialog_dpi.png 2x}

##Show header

 This option allows to show a header to a page displaying the page number:

 {@img scheduler/images/export_show_header.png 2x}

##Custom export styling

 A special "sch-export" CSS class is added to the body of the exported pages so that you can have special
 styles in your exported chart.

 [1]: http://www.phantomjs.org
 [2]: http://www.imagemagick.org
 [3]: http://bryntum.com/blog

 */
Ext.define('Sch.plugin.Export', {
    extend: 'Ext.util.Observable',
    alternateClassName: 'Sch.plugin.PdfExport',
    alias: 'plugin.scheduler_export',
    mixins: [
        'Ext.AbstractPlugin',
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.XTemplate',
        'Sch.plugin.exporter.SinglePage',
        'Sch.plugin.exporter.MultiPage',
        'Sch.plugin.exporter.MultiPageVertical',
        'Sch.widget.ExportDialog'
    ],
    lockableScope: 'top',
    /**
     * @cfg {Object} pageSizes
     * Definition of all available paper sizes.
     */
    pageSizes: {
        A5: {
            width: 5.8,
            height: 8.3
        },
        A4: {
            width: 8.3,
            height: 11.7
        },
        A3: {
            width: 11.7,
            height: 16.5
        },
        Letter: {
            width: 8.5,
            height: 11
        },
        Legal: {
            width: 8.5,
            height: 14
        }
    },
    /**
     * @cfg {Number} DPI
     * DPI (Dots per inch) resolution.
     */
    DPI: 72,
    /**
     * @cfg {String}
     * URL of the server responsible for running the export steps.
     */
    printServer: undefined,
    /**
     * @cfg {Number}
     * The timeout in milliseconds to be used for print requests to server.
     */
    timeout: 60000,
    /**
     * @cfg headerTpl
     * @inheritdoc Sch.plugin.exporter.AbstractExporter
     * @localdoc See details on default value {@link Sch.plugin.exporter.AbstractExporter#headerTpl here}
     */
    headerTpl: null,
    /**
     * @cfg {Function} headerTplDataFn
     * If defined provides data for the {@link #headerTpl}.
     * To define the scope please use {@link #headerTplDataFnScope}.
     * @return {Object} Header template data.
     */
    headerTplDataFn: null,
    /**
     * @cfg {Object} headerTplDataFnScope Scope for the {@link #headerTplDataFn} function.
     */
    headerTplDataFnScope: null,
    /**
     * @cfg {String} tpl
     * Template of extracted page.
     */
    tpl: null,
    /**
     * @cfg footerTpl
     * @inheritdoc Sch.plugin.exporter.AbstractExporter
     * @localdoc See details on default value {@link Sch.plugin.exporter.AbstractExporter#footerTpl here}
     */
    footerTpl: null,
    /**
     * @cfg {Function} footerTplDataFn
     * If defined provides data for the {@link #footerTpl}.
     * To define the scope please use {@link #footerTplDataFnScope}.
     * @return {Object} Footer template data.
     */
    footerTplDataFn: null,
    /**
     * @cfg {Object} footerTplDataFnScope Scope for the {@link #footerTplDataFn} function.
     */
    footerTplDataFnScope: null,
    /**
     * @cfg {String}
     * Class name of the dialog used to change export settings.
     */
    exportDialogClassName: 'Sch.widget.ExportDialog',
    /**
     * @cfg {Object}
     * Config object for the {@link #exportDialogClassName}. Use this to override default values for the export dialog.
     */
    exportDialogConfig: {},
    /**
     * @cfg {Object}
     * Config object to apply to each {@link Sch.plugin.exporter.AbstractExporter exporter} being registered.
     */
    exporterConfig: null,
    /**
     * @cfg {Object}
     * Default export configuration.
     */
    exportConfig: {
        format: 'A4',
        orientation: 'portrait',
        range: 'complete',
        rowsRange: 'all',
        showHeader: true,
        showFooter: false
    },
    /**
     * @cfg {Boolean} expandAllBeforeExport Only applicable for tree views, set to true to do a full expand prior to the export. Defaults to false.
     */
    expandAllBeforeExport: false,
    /**
     * @cfg {Boolean} translateURLsToAbsolute `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
     */
    translateURLsToAbsolute: true,
    /**
     * @cfg {Boolean}
     * If set to true, open new window with the generated document after the operation has finished.
     */
    openAfterExport: true,
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the export plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @param {Object[]} ticks The ticks gathered by plugin to export.
     * @template
     * @method beforeExport
     */
    beforeExport: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the export plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @template
     * @method afterExport
     */
    afterExport: Ext.emptyFn,
    /**
     * @cfg {String}
     * Format of the exported file, selectable from `pdf` or `png`. By default plugin exports panel contents to PDF
     * but PNG file format is also available.
     */
    fileFormat: 'pdf',
    /**
     * @cfg {String}
     * The exporterId of the default exporter to be used.
     * The corresponding export mode will be selected in {@link Sch.widget.ExportDialog export dialog} by default.
     */
    defaultExporter: 'multipage',
    /**
     * @cfg {Sch.plugin.exporter.AbstractExporter[]/Object[]}
     * The list of available exporters.
     * If no value is provided the list will be filled automatically (see {@link #buildExporters}).
     */
    exporters: undefined,
    callbacks: undefined,
    currentAjaxRequest: undefined,
    hideExportDialogTimeout: 1000,
    /**
     * @event hidedialogwindow
     * Fires to hide the dialog window.
     * @param {Object} response Full server response.
     */
    /**
     * @event showdialogerror
     * Fires to show error in the dialog window.
     * @param {Ext.window.Window} dialog The dialog used to change export settings.
     * @param {String} message Error message to show in the dialog window.
     * @param {Object} response Full server response.
     */
    /**
     * @event updateprogressbar
     * Fires when a progressbar of the {@link #exportDialogClassName dialog} should update its value.
     * @param {Number} value Value (between 0 and 1) to set on the progressbar.
     */
    /**
     * @event beforeexport
     * Fires before the exporting is started. Return `false` to cancel exporting.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component A scheduler panel to be exported.
     * @param {Object} config Export configuration.
     */
    /**
     * @event exportstart
     * @private
     * Fires when the exporting is started
     * @param {Sch.plugin.Export} plugin The plugin instance.
     */
    /**
     * @event afterexport
     * @private
     * Fires when the exporting is done
     * @param {Sch.plugin.Export} component The plugin instance.
     */
    /**
     */
    constructor: function(config) {
        var me = this;
        config = config || {};
        me.exportersIndex = {};
        if (config.exportDialogConfig) {
            Ext.Object.each(this.exportConfig, function(k, v, o) {
                var configK = config.exportDialogConfig[k];
                if (configK) {
                    o[k] = configK;
                }
            });
        }
        me.callParent([
            config
        ]);
        me.setFileFormat(me.fileFormat);
        // if no exporters specified let's set the list of available by default
        if (!me.exporters) {
            me.exporters = me.buildExporters();
        }
        // instantiate exporters instances in case there were provided just objects w/ xclass
        me.initExporters();
        // listen to exporters events
        me.bindExporters();
    },
    init: function(scheduler) {
        var me = this;
        scheduler.showExportDialog = Ext.Function.bind(me.showExportDialog, me);
        scheduler.doExport = Ext.Function.bind(me.doExport, me);
        me.scheduler = scheduler;
    },
    initExporters: function() {
        var me = this,
            exporters = me.exporters;
        for (var i = 0; i < exporters.length; i++) {
            // instantiate the exporter if needed
            if (!exporters[i].isExporter) {
                exporters[i] = me.createExporter(exporters[i]);
            }
        }
    },
    bindExporters: function() {
        var exporters = this.exporters;
        for (var i = 0; i < exporters.length; i++) {
            this.bindExporter(exporters[i]);
        }
    },
    bindExporter: function(exporter) {
        var me = this;
        me.mon(exporter, {
            commitpage: me.onPageCommit,
            collectrows: me.onRowCollected,
            scope: me
        });
    },
    unbindExporter: function(exporter) {
        var me = this;
        me.mun(exporter, {
            commitpage: me.onPageCommit,
            collectrows: me.onRowCollected,
            scope: me
        });
    },
    /**
     * @protected
     * Provides the list of available exporter instances.
     * This method is used to build the default state of the list when no {@link #exporters} provided.
     * @returns {Sch.plugin.exporter.AbstractExporter[]/String[]} List of exporters.
     */
    buildExporters: function() {
        return [
            'Sch.plugin.exporter.SinglePage',
            'Sch.plugin.exporter.MultiPage',
            'Sch.plugin.exporter.MultiPageVertical'
        ];
    },
    /**
     * @protected
     * Returns config for an exporter being initialized.
     * Override this to provide custom options for exporters being created.
     */
    getExporterConfig: function(className, config) {
        var me = this;
        var result = Ext.apply({
                translateURLsToAbsolute: me.translateURLsToAbsolute,
                expandAllBeforeExport: me.expandAllBeforeExport,
                DPI: me.DPI
            }, me.exporterConfig);
        if (me.headerTpl)  {
            result.headerTpl = me.headerTpl;
        }
        
        if (me.headerTplDataFn) {
            result.headerTplDataFn = me.headerTplDataFn;
            result.headerTplDataFnScope = me.headerTplDataFnScope;
        }
        if (me.tpl)  {
            result.tpl = me.tpl;
        }
        
        if (me.footerTpl)  {
            result.footerTpl = me.footerTpl;
        }
        
        if (me.footerTplDataFn) {
            result.footerTplDataFn = me.footerTplDataFn;
            result.footerTplDataFnScope = me.footerTplDataFnScope;
        }
        return result;
    },
    // @protected
    createExporter: function(className, config) {
        var me = this,
            exporterConfig = me.getExporterConfig(className, config);
        if (Ext.isObject(className)) {
            return Ext.create(Ext.apply(exporterConfig, className));
        } else {
            return Ext.create(className, Ext.apply(exporterConfig, config));
        }
    },
    /**
     * Adds an exporter.
     * @param  {Sch.plugin.exporter.AbstractExporter/String} [exporter] An exporter to add.
     * Might be provided as {@link Sch.plugin.exporter.AbstractExporter} instance or as a class name string plus a configuration object:
     *
     *   plugin.registerExporter('MyExporter', { foo : 'bar' });
     *
     * Can be ommited to use configuration object only:
     *
     *   plugin.registerExporter({ xclass : 'MyExporter', foo : 'bar' });
     *
     * @param  {Object} [config]    A configuration object
     */
    registerExporter: function(exporter, config) {
        if (!(exporter instanceof Sch.plugin.exporter.AbstractExporter)) {
            exporter = this.createExporter.apply(this, arguments);
        }
        this.exporters.push(exporter);
        this.bindExporter(exporter);
    },
    /**
     * Function that returns an exporter instance based on provided exporterId.
     *
     * @param {String} exporterId string indicating the registered exporter.
     *
     * @return {Sch.plugin.exporter.AbstractExporter} an instance of the exporter.
     */
    getExporter: function(exporterId) {
        if (!exporterId)  {
            return;
        }
        
        var result = this.exportersIndex[exporterId];
        if (result)  {
            return result;
        }
        
        result = this.exportersIndex[exporterId] = Ext.Array.findBy(this.exporters, function(i) {
            return i.getExporterId() == exporterId;
        });
        return result;
    },
    /**
     * Function that returns all registered exporters.
     *
     * @return {Object} an Object containing registered exporters.
     */
    getExporters: function() {
        return this.exporters;
    },
    /**
     * Function for setting the {@link #fileFormat} of exporting panel. Can be either `pdf` or `png`.
     *
     * @param {String} format format of the file to set. Can take either `pdf` or `png`.
     */
    setFileFormat: function(format) {
        this.fileFormat = format;
    },
    /**
     * Instantiates and shows a new {@link #exportDialogClassName} class using {@link #exportDialogConfig} config.
     * This popup should give user possibility to change export settings.
     */
    showExportDialog: function() {
        var me = this,
            activeDialog = me.getActiveExportDialog();
        // only one active dialog is allowed
        if (activeDialog) {
            activeDialog.destroy();
        }
        // create export dialog window
        me.setActiveExportDialog(me.buildExportDialog());
        activeDialog = me.getActiveExportDialog();
        activeDialog.on('destroy', me.onExportDialogDestroy, me);
        // if the dialog has a progress bar onboard
        if (activeDialog.progressBar) {
            // let's track the export progress change and update it
            activeDialog.mon(me, {
                updateprogressbar: me.onExportProgress,
                scope: me
            });
        }
        activeDialog.show();
    },
    buildExportDialog: function() {
        return Ext.create(this.exportDialogClassName, this.buildExportDialogConfig());
    },
    buildExportDialogConfig: function() {
        var me = this,
            view = me.scheduler.getSchedulingView();
        return Ext.apply({
            // on submit button press we launch export
            doExportFn: me.doExport,
            doExportFnScope: me,
            // form related configs
            startDate: me.scheduler.getStart(),
            endDate: me.scheduler.getEnd(),
            rowHeight: view.timeAxisViewModel.getViewRowHeight(),
            columnWidth: view.timeAxisViewModel.getTickWidth(),
            defaultExporter: me.defaultExporter,
            // TODO: move "DPI" config to "exportConfig" container and get rid of this Ext.apply()
            exportConfig: Ext.apply(me.exportConfig, {
                DPI: me.DPI
            }),
            exporters: me.exporters,
            pageFormats: me.getPageFormats(),
            columnPickerConfig: {
                // Columns ignored in export should not be available to pick
                columns: me.scheduler.lockedGrid.query('gridcolumn[ignoreInExport!=true]')
            }
        }, me.exportDialogConfig);
    },
    onExportDialogDestroy: function() {
        this.cancelExport();
        this.setActiveExportDialog(null);
    },
    onExportProgress: function(value, description) {
        var activeDialog = this.getActiveExportDialog(),
            progressBar = activeDialog && activeDialog.progressBar;
        if (progressBar) {
            progressBar.updateProgress(value);
            if (typeof description == 'string') {
                progressBar.updateText(description);
            }
        }
    },
    showError: function(error) {
        Ext.Msg.alert('', error || this.L('generalError'));
    },
    getPageFormats: function() {
        var pageSizes = this.pageSizes,
            sizes = [];
        Ext.Object.each(pageSizes, function(key, value) {
            sizes.push({
                width: value.width,
                height: value.height,
                name: key
            });
        });
        // let's sort page sizes by width and return array of names
        return Ext.Array.map(sizes.sort(function(a, b) {
            return a.width - b.width;
        }), function(size) {
            return size.name;
        });
    },
    getExportConfig: function(config) {
        var me = this;
        var result = Ext.apply({
                fileFormat: me.fileFormat,
                exporterId: me.defaultExporter,
                beforeExport: Ext.Function.bind(me.beforeExport, me),
                afterExport: Ext.Function.bind(me.afterExport, me)
            }, config, me.exportConfig);
        // get effective DPI
        result.DPI = result.DPI || me.DPI;
        // get page size for provided paper format
        result.pageSize = Ext.apply({}, me.pageSizes[result.format]);
        // covert page size to pixels
        result.pageSize.width *= result.DPI;
        result.pageSize.height *= result.DPI;
        return result;
    },
    /**
     * Function performing the export operation using provided config. After getting data
     * from the scheduler an XHR request to {@link #printServer} will be made with the following JSON encoded data :
     *
     * * `html`        - array of HTML strings containing data of each page
     * * `format`      - paper size of the exported file
     * * `orientation` - orientation of the exported file
     * * `range`       - range of the exported file
     * * `fileFormat`  - file format of the exported file
     *
     * @param {Object} [conf] Config options for exporting. If not provided, {@link #exportConfig} is used. Possible parameters are :
     * @param {String} [conf.format]            - format of the exported document/image, selectable from the {@link #pageSizes} list.
     * @param {String} [conf.orientation]       - orientation of the exported document/image. Either `portrait` or `landscape`.
     * @param {String} [conf.range]             - range of the panel to be exported. Selectable from `complete`, `current`, `date`.
     * @param {Boolean} [conf.showHeader]       - boolean value defining if exported pages should have row/column numbers added in the headers.
     * @param {String} [conf.exporterId]        - string value defining which exporter to use.
     *
     * @param {Function} [callback] Optional function that will be called after successful response from export backend script.
     * @param {Function} [errback] Optional function that will be called if export backend script returns error.
     */
    doExport: function(conf, callback, errback, scope) {
        var me = this,
            component = me.scheduler,
            config = me.getExportConfig(conf);
        me.callbacks = {
            success: callback,
            failure: errback,
            scope: scope || me
        };
        var exporter = me.exporter = me.getExporter(config.exporterId);
        if (me.fireEvent('beforeexport', component, exporter, config) !== false) {
            me.myBeforeExport();
            me.exporter.extractPages(component, config, function(pages) {
                me.onPagesExtracted(pages, component, exporter, config);
            }, me);
        }
    },
    /**
     * Aborts any ongoing export operation
     */
    cancelExport: function() {
        // if window is destroyed, cancel any ongoing ajax request
        if (this.currentAjaxRequest) {
            Ext.Ajax.abort(this.currentAjaxRequest);
            this.currentAjaxRequest = null;
        } else {
            if (this.exporter)  {
                this.exporter.abort();
            }
            
        }
        this.scheduler.getEl().unmask();
    },
    onPagesExtracted: function(pages, component, exporter, config) {
        this.fireEvent('updateprogressbar', 0.8, this.L('requestingPrintServer'));
        this.doRequest(pages, config);
    },
    onRowCollected: function(exporter, startIndex, endIndex, total) {
        this.fireEvent('updateprogressbar', 0.2 * (endIndex + 1) / total, Ext.String.format(this.L('fetchingRows'), endIndex + 1, total));
    },
    onPageCommit: function(exporter, page, pageNum, total) {
        total = Math.max(pageNum, total);
        this.fireEvent('updateprogressbar', 0.2 + 0.6 * pageNum / total, Ext.String.format(this.L('builtPage'), pageNum, total));
    },
    /**
     * @private
     * Method that is called after the server responds successfully.
     * The exported file is shown if {@link #openAfterExport} config is set to `true` (default).
     */
    onExportSuccess: function(result) {
        var me = this,
            activeDialog = me.getActiveExportDialog(),
            callbacks = me.callbacks,
            fn = callbacks && callbacks.success,
            scope = callbacks && callbacks.scope || me;
        //set progress to 100%
        me.fireEvent('updateprogressbar', 1);
        me.myAfterExport();
        fn && fn.apply(scope, arguments);
        me.hideExportDialogTimer = setTimeout(function() {
            me.fireEvent('hidedialogwindow', result);
            activeDialog && activeDialog.destroy();
        }, me.hideExportDialogTimeout);
        if (me.openAfterExport) {
            me.openAfterExportTimer = setTimeout(function() {
                window.open(result.url, 'ExportedPanel');
            }, 0);
        }
    },
    /**
     * @private
     * Function that is called when the exportserver returned failure. This function will fire the event showdialogerror.
     * When provided in doExport the callback failure is called.
     *
     * @param {String} message Error message provided with the failure.
     * @param {Object} result object when the failure is a serverside failure.
     */
    onExportFailure: function(message, result) {
        var me = this,
            dialog = this.getActiveExportDialog(),
            callbacks = me.callbacks,
            fn = callbacks && callbacks.failure,
            scope = callbacks && callbacks.scope || me;
        fn && fn.call(scope, message);
        me.fireEvent('showdialogerror', dialog, message, result);
        me.showError(message);
        me.myAfterExport();
    },
    /**
     * @protected
     * Launches a request to the {@link #printServer print server}.
     * On return {@link #onRequestSuccess} or {@link #onRequestFailure} will be called with the returned response.
     * @param {Array} exportedPages An array of paginated component content.
     * @param {Object} config Export configuration.
     */
    doRequest: function(exportedPages, config) {
        var me = this,
            component = me.scheduler;
        if (!me.test && !me.debug) {
            if (me.printServer) {
                var ajaxConfig = {
                        method: 'POST',
                        url: me.printServer,
                        timeout: me.timeout,
                        params: Ext.apply({
                            html: {
                                array: Ext.JSON.encode(exportedPages)
                            },
                            startDate: component.getStartDate(),
                            endDate: component.getEndDate(),
                            format: me.exporter.getPaperFormat(),
                            orientation: config.orientation,
                            range: config.range,
                            fileFormat: me.fileFormat
                        }, this.getParameters()),
                        success: me.onRequestSuccess,
                        failure: me.onRequestFailure,
                        scope: me
                    };
                Ext.apply(ajaxConfig, this.getAjaxConfig(ajaxConfig));
                this.currentAjaxRequest = Ext.Ajax.request(ajaxConfig);
            } else {
                me.onExportFailure('Print server URL is not defined, please specify printServer config');
            }
        } else {
            if (me.debug) {
                var pages = exportedPages || [];
                for (var i = 0,
                    l = pages.length; i < l; i++) {
                    var w = window.open();
                    w.document.write(pages[i].html);
                    w.document.close();
                }
            }
            me.onExportSuccess(me.testResponse || {
                success: true,
                url: 'foo',
                htmlArray: exportedPages
            });
        }
    },
    /**
     * @protected
     * Runs on request succesful completion.
     * @param  {Object} response Server response.
     */
    onRequestSuccess: function(response) {
        this.currentAjaxRequest = null;
        var me = this,
            result;
        try {
            result = Ext.JSON.decode(response.responseText);
        } catch (e) {
            me.onExportFailure('Wrong server response received');
            return;
        }
        if (result.success) {
            me.onExportSuccess(result);
        } else {
            me.onExportFailure(result.msg, result);
        }
    },
    /**
     * @protected
     * Runs on request failure.
     * @param  {Object} response Server response.
     */
    onRequestFailure: function(response) {
        this.currentAjaxRequest = null;
        var me = this,
            msg = response.status === 200 ? response.responseText : response.statusText;
        me.onExportFailure(msg, response);
    },
    /**
     * @template
     * This method can be used to apply additional parameters to the 'params' property of the export {@link Ext.Ajax XHR} request.
     * By default this method returns an empty object.
     * @return {Object}
     */
    getParameters: function() {
        return {};
    },
    /**
     * This method can be used to return any extra configuration properties applied to the {@link Ext.Ajax#request} call.
     * @template
     * @param {Object} config The proposed Ajax configuration settings. You may read any properties from this object, but modify it at your own risk.
     * @return {Object}
     */
    getAjaxConfig: function(config) {
        return {};
    },
    /**
     * Returns the active export dialog window instance.
     * @return {Sch.widget.ExportDialog} Active export dialog window instance.
     */
    getActiveExportDialog: function() {
        return this.win;
    },
    setActiveExportDialog: function(dialog) {
        this.win = dialog;
    },
    // myBeforeExport the body, hiding panel to allow changing it's parameters in the background.
    myBeforeExport: function() {
        this.fireEvent('exportstart', this);
        var mask = this.scheduler.getEl().mask();
        mask.addCls('sch-export-mask');
        var activeDialog = this.getActiveExportDialog(),
            progressBar = activeDialog && activeDialog.progressBar;
        // if export dialog is used and progress bar is there, let's make it visible
        if (progressBar) {
            progressBar.show();
        }
    },
    //
    myAfterExport: function() {
        this.fireEvent('afterexport', this);
        this.scheduler.getEl().unmask();
    },
    destroy: function() {
        this.callParent(arguments);
        clearTimeout(this.openAfterExportTimer);
        clearTimeout(this.hideExportDialogTimer);
        if (this.getActiveExportDialog()) {
            this.getActiveExportDialog().destroy();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * @private
 *
 * @class Gnt.plugin.exporter.mixin.DependencyPainter
 *
 * This mixin class handles the rendering of dependencies for the exporters.
 *
 */
Ext.define('Gnt.plugin.exporter.mixin.DependencyPainter', {
    fillRecordRelatedBoxes: function(task) {
        if (task.hasDependencies()) {
            var me = this,
                view = me.normalView,
                painter = view.getDependencyView().painter;
            var box = painter.getItemBox(me.normalView, task);
            if (box) {
                // WARNING view.bufferedRenderer.bodyTop is private
                // dependency painter doesn't take bufferedRenderer.bodyTop into account
                // but we need to do it
                if (view.bufferedRenderer) {
                    box.top += view.bufferedRenderer.bodyTop;
                    box.bottom += view.bufferedRenderer.bodyTop;
                }
                // we want all tasks to be considered as visible
                box.rendered = true;
                me.eventBoxes[task.internalId] = box;
            }
        }
    },
    onClassMixedIn: function(targetClass) {
        // We need to override existing "fillRecordRelatedBoxes" method
        // By default mixins do not allow this that's why we use "onClassMixedIn"
        targetClass.addMember('fillRecordRelatedBoxes', this.prototype.fillRecordRelatedBoxes);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.plugin.exporter.SinglePage
 @extends Sch.plugin.exporter.SinglePage

 This class extracts all scheduler data to fit in a single page.

 The exporterId of this exporter is `singlepage`
 */
Ext.define('Gnt.plugin.exporter.SinglePage', {
    extend: 'Sch.plugin.exporter.SinglePage',
    mixins: [
        'Gnt.plugin.exporter.mixin.DependencyPainter'
    ]
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.plugin.exporter.MultiPage
 @extends Sch.plugin.exporter.MultiPage

 This class extracts pages in a vertical and horizontal order.

 The exporterId of this exporter is `multipage`
 */
Ext.define('Gnt.plugin.exporter.MultiPage', {
    extend: 'Sch.plugin.exporter.MultiPage',
    mixins: [
        'Gnt.plugin.exporter.mixin.DependencyPainter'
    ],
    normalGridOffset: 0,
    onRowsCollected: function() {
        var me = this;
        me.normalGridOffset = 0;
        me.callParent(arguments);
    },
    startPage: function(pattern, newColumnPage) {
        var me = this;
        me.normalGridOffset = pattern.normalGridOffset;
        me.callParent(arguments);
    },
    /**
     * @protected
     * Builds a page frame, a DOM-"skeleton" for a future pages.
     * @param  {Number} colIndex Zero based index of page column to build frame for.
     * @param  {Number} offset   Proper normal grid offset for the page column.
     * @return {Ext.dom.Element} Column page frame.
     */
    buildPageFrame: function(colIndex, offset) {
        var me = this;
        var copy = me.callParent(arguments);
        // remember locked/normal grids visibility
        copy.normalHidden = me.normalGrid.hidden;
        copy.lockedHidden = me.lockedGrid.hidden;
        return copy;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.plugin.exporter.MultiPageVertical
 @extends Sch.plugin.exporter.MultiPageVertical

 This class extracts pages in a vertical order. It fits all locked columns and the timeaxis on a single page and will generate
 new pages vertically down for the rows.

 The exporterId of this exporter is `multipagevertical`

 To adjust column widths for specific export cases the function {@link #fitLockedColumnWidth} can be overridden.

 */
Ext.define('Gnt.plugin.exporter.MultiPageVertical', {
    extend: 'Sch.plugin.exporter.MultiPageVertical',
    mixins: [
        'Gnt.plugin.exporter.mixin.DependencyPainter'
    ]
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.plugin.Export
@extends Sch.plugin.Export

A plugin (ptype = 'gantt_export') for generating PDF/PNG out of a Gantt panel. NOTE: This plugin will make an Ajax request to the server, POSTing
 the HTML to be exported. The {@link #printServer} url must therefore be on the same domain as your application.

#Configuring/usage

To use this plugin, add it to your Gantt as any other plugin. It is also required to have [PhantomJS][1] and [Imagemagick][2]
installed on the server. The complete process of setting up a backend for this plugin can be found in the readme file inside export examples
as well as on our [blog][3]. Note that the export feature is currently not supported if your store is buffered.

    var gantt = Ext.create('Sch.panel.Gantt', {
        ...

        plugins         : [
            Ext.create('Gnt.plugin.Export', {
                // default values
                printServer: 'server.php'
            })
        ]
    });

Gantt will be extended with three new methods:

* {@link #setFileFormat}, which allows setting the format to which panel should be exported. Default format is `pdf`.

* {@link #showExportDialog}, which shows export settings dialog

        gantt.showExportDialog();

* {@link #doExport} which actually performs the export operation using {@link #defaultConfig} or provided config object :

        gantt.doExport(
            {
                format: "A5",
                orientation: "landscape",
                range: "complete",
                showHeader: true,
                exporterId: 'singlepage'
            }
        );

#Export options

In the current state, plugin gives few options to modify the look and feel of the generated document/image throught a dialog window :

{@img scheduler/images/export_dialog.png}

If no changes are made to the form, the {@link #defaultConfig} will be used.

##Export Range

This setting controls the timespan visible on the exported document/image. Three options are available here :

{@img scheduler/images/export_dialog_ranges.png}

###Complete schedule

Whole current timespan will be visible on the exported document.

###Date range

User can select the start and end dates (from the total timespan of the panel) visible on the exported document/image.

{@img scheduler/images/export_dialog_ranges_date.png}

###Current view

Timespan of the exported document will be set to the currently visible part of the time axis. User can control
the width of the time column and height of row.

{@img scheduler/images/export_dialog_ranges_current.png}

##Paper Format

This combo gives control of the size of the generated PDF document by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`).
Generated PDF has a fixed DPI value of 72. Dafault format is `A4`.

{@img scheduler/images/export_dialog_format.png}

##Orientation

This setting defines the orientation of the generated document.

{@img scheduler/images/export_dialog_orientation.png}

Default option is the `portrait` (horizontal) orientation :

{@img scheduler/images/export_dialog_portrait.png}

Second option is the `landscape` (vertical) orientation :

{@img scheduler/images/export_dialog_landscape.png}


##Custom export styling
A special "sch-export" CSS class is added to the body of the exported pages so that you can have special
styles in your exported chart.

[1]: http://www.phantomjs.org
[2]: http://www.imagemagick.org
[3]: http://bryntum.com/blog

*/
Ext.define('Gnt.plugin.Export', {
    extend: 'Sch.plugin.Export',
    alias: 'plugin.gantt_export',
    alternateClassName: 'Gnt.plugin.PdfExport',
    requires: [
        'Gnt.plugin.exporter.SinglePage',
        'Gnt.plugin.exporter.MultiPage',
        'Gnt.plugin.exporter.MultiPageVertical'
    ],
    buildExporters: function() {
        return [
            'Gnt.plugin.exporter.SinglePage',
            'Gnt.plugin.exporter.MultiPage',
            'Gnt.plugin.exporter.MultiPageVertical'
        ];
    },
    //override added to turn off vertical resizer in the dialog
    showExportDialog: function() {
        this.exportDialogConfig.scrollerDisabled = true;
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.Printable
@extends Sch.plugin.Export

Plugin (ptype = 'scheduler_printable') printing an Ext Scheduler instance. To use this plugin, add it to the scheduler as a usual plugin. The plugin will add an additional `print` method to the scheduler.

Please note that this plugin may in some cases not generate a perfect picture for example in Firefox, due to various limitations in the browsers print implementation.
If you require a high quality print in that case, you should use the Export plugin instead and first export to PDF. Chrome, IE10+ will give the best results.

The print plugin will open a print dialog. In the dialog there is a DPI field. The DPI (dots per inch) is a ratio how many browser pixels correspond to a `paper` inch.
The default is set on 72 dots. Depending on the screen resolution, this value can be increased or decreased.
Run some test prints, and adjust the DPI until the generated pages fit the print paper nicely.

In the browser print settings the `Background Graphics` option should be set to on.

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Printable', {
                // default values
                docType             : '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">',
                autoPrintAndClose   : true
            })
        ]
    });

    ...

    scheduler.print();

In the opened print window, a special 'sch-print-body' CSS class will be added to the BODY element. You can use this to
further customize the printed contents.

 */
Ext.define('Sch.plugin.Printable', {
    extend: 'Sch.plugin.Export',
    requires: [
        'Ext.XTemplate'
    ],
    alternateClassName: [
        'Sch.plugin.Print'
    ],
    alias: [
        'plugin.scheduler_printable',
        'plugin.scheduler_print'
    ],
    /**
     * @cfg {String} docType This is the DOCTYPE to use for the print window. It should be the same DOCTYPE as on your application page.
     */
    docType: '<!DOCTYPE HTML>',
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the print plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method beforePrint
     */
    beforePrint: function() {},
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the print plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method afterPrint
     */
    afterPrint: function() {},
    exportDialogConfig: {
        showDPIField: true
    },
    /**
     * @cfg {Boolean} removeSecondaryCanvas set to true to remove columnlines
     */
    removeSecondaryCanvas: false,
    /**
     * @cfg {Boolean} wrapHeaders set to true to wrap the headers with a sch-print-header-wrap cls class for additional markup.
     */
    wrapHeaders: false,
    /**
     * @cfg {Boolean} autoPrintAndClose True to automatically call print and close the new window after printing. Default value is `true`
     */
    autoPrintAndClose: true,
    // private, the template for the new windowfg
    mainTpl: '{docType}' + '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' + '<head>' + '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' + '<title>{title}</title>' + '{styles}' + '</head>' + '<body class="sch-print-body {bodyClasses}">' + '<div class="sch-print-ct" style="width:{totalWidth}px">' + '<tpl for="pages">{html}</tpl>' + '</div>' + '<script type="text/javascript">' + '{setupScript}' + '</script>' + '</body>' + '</html>',
    pageTpl: '{header}' + '<div class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">{HTML}</div>' + '{footer}' + '<div style="page-break-after:always;"></div>',
    // Script executed in the newly open window, to automatically invoke window.print()
    setupScriptTpl: "window.onload = function(){ " + "document._loaded  = true;" + "if ({autoPrintAndClose}) {" + "window.print();" + "if (!{isChrome}) window.close();" + "}" + '}',
    openAfterExport: false,
    DPI: 72,
    /**
     * @cfg {Boolean} fakeBackgroundColor True to reset background-color of events and enable use of border-width to fake background color (borders print by default in every browser).
     */
    fakeBackgroundColor: false,
    // This method is not used and doesn't make any sense for the print feature so it's overridden with an empty function
    doRequest: function() {},
    constructor: function(config) {
        Ext.apply(this, config);
        if (!this.mainTpl.isTemplate) {
            this.mainTpl = new Ext.XTemplate(this.mainTpl);
        }
        this.callParent(arguments);
        this.exportDialogConfig = Ext.applyIf({
            l10n: {
                title: this.L('dialogTitle'),
                exportButtonText: this.L('exportButtonText')
            }
        }, this.exportDialogConfig);
    },
    init: function(scheduler) {
        this.callParent(arguments);
        // decorate scheduler with "print" method
        scheduler.print = Ext.Function.bind(this.print, this);
    },
    getExporterConfig: function(className, config) {
        var me = this,
            result = me.callParent(arguments);
        return Ext.apply(result, {
            tpl: me.pageTpl
        });
    },
    getExportConfig: function(config) {
        var me = this,
            result = me.callParent(arguments);
        return Ext.apply(result, {
            beforeExport: Ext.Function.bind(me.beforePrint, me),
            afterExport: Ext.Function.bind(me.afterPrint, me)
        });
    },
    buildExporters: function() {
        return [
            'Sch.plugin.exporter.MultiPage',
            'Sch.plugin.exporter.MultiPageVertical'
        ];
    },
    onPagesExtracted: function(pages, component, exporter, config) {
        this.fireEvent('updateprogressbar', 0.8, this.L('requestingPrintServer'));
        this.printPages(pages, component, exporter, config);
    },
    print: function() {
        this.showExportDialog();
    },
    // Adds print cls
    onBeforePageCommit: function(exporter, pageBody, pageNumber, totalNumberOfPages) {
        var component = this.scheduler,
            lockedGrid = component.lockedGrid,
            normalGrid = component.normalGrid,
            get = function(s) {
                return pageBody.select('#' + s).first();
            };
        var normalBody = pageBody.select(exporter.normalBodySelector).first(),
            normalHeader = get(normalGrid.headerCt.id),
            lockedBody = pageBody.select(exporter.lockedBodySelector).first(),
            lockedHeader = get(lockedGrid.headerCt.id);
        normalBody.addCls([
            'sch-print-normal-rows-ct',
            this.fakeBackgroundColor ? ' sch-print-fake-background' : ''
        ]);
        lockedBody.addCls('sch-print-locked-rows-ct');
        if (this.removeSecondaryCanvas) {
            pageBody.select('.sch-secondary-canvas').remove();
        }
        if (this.fakeBackgroundColor) {
            var events = normalBody.select('.sch-event');
            events.each(function(item) {
                item.setStyle('border-right-width', item.dom.style.width);
            });
        }
        normalHeader.addCls('sch-print-normalheader');
        lockedHeader.addCls('sch-print-lockedheader');
        if (this.wrapHeaders) {
            normalHeader.wrap('<div class="sch-print-header-wrap"></div>');
            lockedHeader.wrap('<div class="sch-print-header-wrap"></div>');
        }
    },
    prepareMainTplData: function(data) {
        return data;
    },
    printPages: function(pages, component, exporter, config) {
        if (!this.mainTpl || !this.mainTpl.isTemplate) {
            this.mainTpl = new Ext.XTemplate(this.mainTpl, {
                compiled: true,
                disableFormats: true
            });
        }
        var styles = exporter.getStylesheets(),
            body = document.body;
        var html = this.mainTpl.apply(this.prepareMainTplData({
                docType: this.docType,
                htmlClasses: body.parentNode.className,
                bodyClasses: body.className,
                title: component.title || '',
                styles: styles,
                totalWidth: exporter.paperWidth,
                setupScript: this.setupScriptTpl.replace('{autoPrintAndClose}', this.autoPrintAndClose).replace('{isChrome}', Ext.isChrome),
                pages: pages
            }));
        var win = window.open('', 'printgrid');
        // this crazy case (there's a window but win.document is null) happens sometimes in IE10 during testing in automation mode
        if (!win || !win.document)  {
            return false;
        }
        
        // Assign to this for testability, need a reference to the opened window
        this.printWindow = win;
        win.document.write(html);
        win.document.close();
        this.onExportSuccess({
            success: true,
            url: 'foo',
            htmlArray: [
                html
            ]
        });
    },
    bindExporter: function(exporter) {
        var me = this;
        me.callParent(arguments);
        me.mon(exporter, {
            beforecommitpage: me.onBeforePageCommit,
            scope: me
        });
    },
    unbindExporter: function(exporter) {
        var me = this;
        me.callParent(arguments);
        me.mun(exporter, {
            beforecommitpage: me.onBeforePageCommit,
            scope: me
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.plugin.Printable
 @extends Sch.plugin.Printable

 Plugin (ptype = 'gantt_printable') for printing an Ext Gantt instance. To use this plugin, add it to the scheduler as a usual plugin. The plugin will add an additional `print` method to the ganttpanel.

 Please note that this plugin may in some cases not generate a perfect picture for example in Firefox, due to various limitations in the browsers print implementation.
 If you require a high quality print in that case, you should use the Export plugin instead and first export to PDF. Chrome, IE10+ will give the best results.

 The print plugin will open a print dialog. In the dialog there is a DPI field. The DPI (dots per inch) is a ratio how many browser pixels correspond to a `paper` inch.
 The default is set on 72 dots. Depending on the screen resolution, this value can be increased or decreased.
 Run some test prints, and adjust the DPI until the generated pages fit the print paper nicely.

 In the browsers print settings the `Background Graphics` option should be set to on.

        var gantt = Ext.create('Gnt.panel.Gantt', {

            plugins             : [
                Ext.create("Gnt.plugin.Printable")
            ],
            ...
        })

        gantt.print();


 In the opened print window, a special 'sch-print-body' CSS class will be added to the BODY element. You can use this to
 further customize the printed contents.

 */
Ext.define('Gnt.plugin.Printable', {
    extend: 'Sch.plugin.Printable',
    alias: 'plugin.gantt_printable',
    requires: [
        'Gnt.plugin.exporter.MultiPage',
        'Gnt.plugin.exporter.MultiPageVertical'
    ],
    buildExporters: function() {
        return [
            'Gnt.plugin.exporter.MultiPage',
            'Gnt.plugin.exporter.MultiPageVertical'
        ];
    },
    // override added to turn off vertical resizer in the dialog
    showExportDialog: function() {
        this.exportDialogConfig.scrollerDisabled = true;
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.plugin.TaskContextMenu
@extends Ext.menu.Menu

Plugin (ptype = 'gantt_taskcontextmenu') for showing a context menu when right clicking a task:

{@img gantt/images/context-menu.png}

You can add it to your gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        plugins             : [
            Ext.create("Gnt.plugin.TaskContextMenu")
        ],
        ...
    })


To customize the content of the menu, subclass this plugin and provide your own implementation of the `createMenuItems` method.
You can also customize various handlers for menu items, like `addTaskAbove`, `deleteTask` etc. For example:

    Ext.define('MyProject.plugin.TaskContextMenu', {
        extend     : 'Gnt.plugin.TaskContextMenu',

        createMenuItems : function () {
            this.on('beforeshow', this.onMyBeforeShow, this);

            return this.callParent().concat({
                text        : 'My handler',

                handler     : this.onMyHandler,
                scope       : this
            });
        },

        onMyHandler : function () {
            // the task on which the right click have occured
            var task        = this.rec;

            ...
        },

        onMyBeforeShow : function() {
            // Allow delete only based on some condition
            var isDeleteAllowed = this.rec.get('AllowDelete');

            this.down('#deleteTask').setVisible(isDeleteAllowed);
        }
    });

    var gantt = Ext.create('Gnt.panel.Gantt', {
        selModel : new Ext.selection.TreeModel({ ignoreRightMouseSelection : false }),
        plugins             : [
            Ext.create("MyProject.plugin.TaskContextMenu")
        ],
        ...
    })

Note that when using right click to show the menu you should set the 'ignoreRightMouseSelection' to false on your selection model (as seen in the source above).

*/
Ext.define("Gnt.plugin.TaskContextMenu", {
    extend: 'Ext.menu.Menu',
    alias: 'plugin.gantt_taskcontextmenu',
    xtype: 'gantt_taskcontextmenu',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_taskcontextmenu',
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    lockableScope: 'top',
    requires: [
        'Gnt.model.Task'
    ],
    plain: true,
    /**
     * @cfg {String/String[]} triggerEvent
     * The Gantt panel event(s) upon which the menu shall be shown. Might be provided as an array of multiple event names.
     * By defaults the menu is shown when right-clicking a row or task bar and when right-clicking an empty area in the grid.
     * You can change this to 'taskcontextmenu' if you want the menu to be shown only when right clicking a task bar.
     */
    triggerEvent: [
        'rowcontextmenu',
        'containercontextmenu',
        'rowlongpress',
        'containerlongpress'
    ],
    hideEvent: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - newTaskText         : 'New task'
     - deleteTask          : 'Delete task(s)'
     - editLeftLabel       : 'Edit left label'
     - editRightLabel      : 'Edit right label'
     - add                 : 'Add...'
     - deleteDependency    : 'Delete dependency...'
     - addTaskAbove        : 'Task above'
     - addTaskBelow        : 'Task below'
     - addMilestone        : 'Milestone'
     - addSubtask          : 'Sub-task'
     - addSuccessor        : 'Successor'
     - addPredecessor      : 'Predecessor'
     - splitTask           : 'Split task'
     */
    grid: null,
    /**
     * @property {Gnt.model.Task} rec The task model, for which the menu was activated
     */
    rec: null,
    triggerEventXY: null,
    lastHighlightedItem: null,
    taskEditorInjected: false,
    config: {
        /**
         * @cfg {Number} splitDuration Split duration to be used when "Split task" menu item is called.
         * Set this to zero to enable automatic split duration calculation depending on active zoom level.
         * In this mode the split duration is calculated as a clicked tick duration restricted by
         * {@link #minSplitDuration} and {@link #maxSplitDuration} values.
         */
        splitDuration: 0,
        /**
         * @cfg {String} splitDurationUnit Split duration unit to be used when "Split task" menu item is called
         * See {@link #splitDuration} for details.
         */
        splitDurationUnit: 'd',
        /**
         * @cfg {Number} maxSplitDuration Maximum allowed split duration (use {@link #maxSplitDurationUnit} to define unit for this value).
         * The value is used upon automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        maxSplitDuration: 1,
        /**
         * @cfg {String} maxSplitDurationUnit Maximum allowed split duration unit.
         * See {@link #maxSplitDuration} for details.
         */
        maxSplitDurationUnit: 'd',
        /**
         * @cfg {Number} minSplitDuration Minimum allowed split duration (use {@link #minSplitDurationUnit} to define unit for this value).
         * The value is used upon automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        minSplitDuration: 1,
        /**
         * @cfg {String} minSplitDurationUnit Minimum allowed split duration unit.
         * See {@link #minSplitDuration} for details.
         */
        minSplitDurationUnit: 'h'
    },
    initComponent: function() {
        var hideEvent = this.hideEvent;
        this.defaults = this.defaults || {};
        this.defaults.scope = this;
        this.triggerEvent = [].concat(this.triggerEvent);
        if (hideEvent) {
            if (!Ext.isArray(hideEvent)) {
                hideEvent = [
                    hideEvent
                ];
            }
        }
        // In IE task context menu cannot be blurred on click in scheduling area,
        // because we prevent row focusing to avoid loosing scroll position
        // (in Sch.mixin.TimelinePanel.patchNavigationModel method).
        // So we help to do it by hiding the menu on "itemclick" event
        // TODO: get rid of this after IE focusing issue is solved
        if (Ext.isIE) {
            hideEvent = hideEvent || [];
            hideEvent.push('itemclick');
        }
        this.hideEvent = hideEvent;
        this.buildMenuItems();
        this.callParent(arguments);
    },
    init: function(grid) {
        this.grid = grid;
        this.bindTriggerEvent();
        this.bindHideEvent();
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    isNotProject: function(task) {
        return !task || !task.isProject;
    },
    isReadOnly: function(task) {
        return this.getCmp().isReadOnly() || (task && task.isReadOnly());
    },
    /**
     * This method is being called during plugin initialization. Override if you need to customize the items in the menu.
     * The method should return an array of menu items, which will be used as the value of the `items` property.
     *
     * Each menu item is decorated with an itemId property for testability.
     *
     * @return {Array}
     */
    createMenuItems: function() {
        var me = this;
        return [
            {
                handler: this.deleteTask,
                requiresTask: true,
                itemId: 'deleteTask',
                text: this.L('deleteTask'),
                isValidAction: function(task) {
                    return !me.isReadOnly(task);
                }
            },
            {
                handler: this.editLeftLabel,
                requiresTask: true,
                itemId: 'editLeftLabel',
                text: this.L('editLeftLabel'),
                isValidAction: function(task) {
                    return me.grid.getSchedulingView().getLeftEditor() && !me.isReadOnly(task);
                }
            },
            {
                handler: this.editRightLabel,
                requiresTask: true,
                itemId: 'editRightLabel',
                text: this.L('editRightLabel'),
                isValidAction: function(task) {
                    return me.grid.getSchedulingView().getRightEditor() && !me.isReadOnly(task);
                }
            },
            {
                handler: this.toggleMilestone,
                requiresTask: true,
                itemId: 'toggleMilestone',
                text: this.L('convertToMilestone'),
                isValidAction: function(task) {
                    return this.isNotProject(task) && !me.isReadOnly(task);
                }
            },
            {
                handler: this.splitTask,
                requiresTask: true,
                itemId: 'splitTask',
                isValidAction: function(task, triggerDomEvent) {
                    return task && !me.isReadOnly(task) && task.getStartDate() && task.getEndDate() && !task.isMilestone() && task.isLeaf() && triggerDomEvent && triggerDomEvent.getTarget('.sch-gantt-task-bar');
                },
                text: this.L('splitTask')
            },
            {
                text: this.L('add'),
                itemId: 'addTaskMenu',
                menu: {
                    plain: true,
                    defaults: {
                        scope: this
                    },
                    items: [
                        {
                            handler: this.addTaskAboveAction,
                            requiresTask: true,
                            itemId: 'addTaskAbove',
                            text: this.L('addTaskAbove'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addTaskBelowAction,
                            itemId: 'addTaskBelow',
                            text: this.L('addTaskBelow'),
                            isValidAction: function(task) {
                                return (task && me.isNotProject(task) && !me.isReadOnly(task.parentNode)) || (!task && !me.isReadOnly());
                            }
                        },
                        {
                            handler: this.addMilestone,
                            itemId: 'addMilestone',
                            requiresTask: true,
                            text: this.L('addMilestone'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addSubtask,
                            requiresTask: true,
                            itemId: 'addSubtask',
                            text: this.L('addSubtask'),
                            isValidAction: function(task) {
                                return !me.isReadOnly(task);
                            }
                        },
                        {
                            handler: this.addSuccessor,
                            requiresTask: true,
                            itemId: 'addSuccessor',
                            text: this.L('addSuccessor'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addPredecessor,
                            requiresTask: true,
                            itemId: 'addPredecessor',
                            text: this.L('addPredecessor'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        }
                    ]
                }
            },
            {
                text: this.L('deleteDependency'),
                requiresTask: true,
                itemId: 'deleteDependencyMenu',
                isValidAction: function(task) {
                    return task && !me.isReadOnly(task) && task.getAllDependencies().length > 0;
                },
                menu: {
                    plain: true,
                    listeners: {
                        beforeshow: this.populateDependencyMenu,
                        // highlight dependencies on mouseover of the menu item
                        mouseover: this.onDependencyMouseOver,
                        // unhighlight dependencies on mouseout of the menu item
                        mouseleave: this.onDependencyMouseOut,
                        scope: this
                    }
                }
            }
        ];
    },
    // backward compat
    buildMenuItems: function() {
        this.items = this.createMenuItems();
    },
    bindGridEvents: function(events, fn, scope) {
        scope = scope || this;
        var grid = this.getCmp();
        if (events) {
            for (var i = events.length - 1; i >= 0; i--) {
                grid.on(events[i], fn, scope);
            }
        }
    },
    bindTriggerEvent: function() {
        this.bindGridEvents(this.triggerEvent, this.onTriggerEvent);
    },
    bindHideEvent: function() {
        this.bindGridEvents(this.hideEvent, this.onHideEvent);
    },
    onHideEvent: function() {
        this.hide();
    },
    swallowNextClickEvent: function() {
        Ext.getBody().on('click', function(e) {
            e.stopPropagation();
        }, null, {
            single: true,
            capture: true
        });
    },
    populateDependencyMenu: function(menu) {
        // HACK http://www.sencha.com/forum/showthread.php?296359-Disabled-Menuitem-still-shows-its-menu&p=1082213#post1082213
        if (menu.up('menuitem').isDisabled())  {
            return false;
        }
        
        var grid = this.getCmp(),
            taskStore = grid.getTaskStore(),
            dependencies = this.rec.getAllDependencies(),
            depStore = grid.dependencyStore;
        menu.removeAll();
        if (!dependencies.length)  {
            return false;
        }
        
        var taskId = this.rec.getId() || this.rec.internalId;
        Ext.Array.each(dependencies, function(dependency) {
            var fromId = dependency.getSourceId(),
                task = taskStore.getModelById(fromId == taskId ? dependency.getTargetId() : fromId);
            if (task) {
                menu.add({
                    dependency: dependency,
                    text: Ext.String.htmlEncode(Ext.util.Format.ellipsis(task.getName(), 30)),
                    scope: this,
                    handler: function(menuItem) {
                        depStore.remove(menuItem.dependency);
                    },
                    disabled: this.isReadOnly(this.rec)
                });
            }
        }, this);
    },
    onDependencyMouseOver: function(menu, item, e) {
        if (item) {
            var schedulingView = this.getCmp().getSchedulingView();
            if (this.lastHighlightedItem) {
                schedulingView.unhighlightDependency(this.lastHighlightedItem.dependency);
            }
            this.lastHighlightedItem = item;
            schedulingView.highlightDependency(item.dependency);
        }
    },
    onDependencyMouseOut: function(menu, e) {
        if (this.lastHighlightedItem) {
            this.getCmp().getSchedulingView().unhighlightDependency(this.lastHighlightedItem.dependency);
        }
    },
    onTriggerEvent: function() {
        var context = this.getTriggerEventContext.apply(this, arguments);
        // Only trigger menu on longpress actions if not using a mouse
        if (!context.e.type.match('longpress') || context.e.pointerType !== 'mouse') {
            this.activateMenu(context.record, context.e);
        }
    },
    getTriggerEventContext: function() {
        var result = {};
        // loop over arguments forward searching for the task
        for (var i = 0,
            l = arguments.length - 1; i <= l; i++) {
            if (arguments[i] instanceof Gnt.model.Task) {
                result.record = arguments[i];
                break;
            }
        }
        // loop over arguments backward searching for the event
        for (i = arguments.length - 1; i >= 0; i--) {
            if (arguments[i] instanceof Ext.EventObjectImpl) {
                result.e = arguments[i];
                break;
            }
        }
        return result;
    },
    activateMenu: function(rec, e) {
        // Do not show menu for the root node of task store
        if (this.getCmp().taskStore.getRootNode() === rec) {
            return;
        }
        // The click event on a grid cell will trigger a focus event and context menu will hide
        if (e.type.match('longpress')) {
            this.swallowNextClickEvent();
        }
        e.stopEvent();
        this.rec = rec;
        this.triggerEventXY = e.getXY();
        this.configureMenuItems(e);
        this.showAt(e.getXY());
        // force the menu focusing
        // w/o this the menu will never hide when clicking other grid rows
        this.focus();
    },
    addTaskEditorEntry: function() {
        this.insert(0, {
            text: this.L('taskInformation'),
            itemId: 'taskEditor',
            requiresTask: true,
            handler: function() {
                this.getCmp().getTaskEditor(this.rec).showTask(this.rec);
            },
            isValidAction: function(task) {
                return this.getCmp().getTaskEditor(task);
            },
            scope: this
        });
        // remember that we added the entry
        this.taskEditorInjected = true;
    },
    setTaskEditorEntryLabel: function(task) {
        var taskEditor = this.down('#taskEditor');
        if (task && taskEditor) {
            taskEditor.setText(task.isProject ? this.L('projectInformation') : this.L('taskInformation'));
        }
    },
    configureMenuItems: function(triggerEvent) {
        var rec = this.rec;
        if (this.getCmp().getTaskEditor()) {
            if (!this.taskEditorInjected)  {
                this.addTaskEditorEntry();
            }
            
            // set proper task editor menu entry title
            this.setTaskEditorEntryLabel(rec);
        }
        Ext.Array.each(this.query('menuitem'), function(item) {
            // the menu entry has to be disabled:
            // - if it requires a task to be selected
            // - or it's not valid (dependends on its "isValidAction" result)
            var disable = (item.requiresTask && !rec) || (item.isValidAction && !item.isValidAction.call(item.scope || item, rec, triggerEvent));
            item.setDisabled(disable);
        });
        var toggleMilestone = this.down('#toggleMilestone');
        if (rec && toggleMilestone) {
            toggleMilestone.setText(rec.isMilestone() ? this.L('convertToRegular') : this.L('convertToMilestone'));
        }
    },
    copyTask: function(original) {
        var model = original && original.self || this.getCmp().getTaskStore().getModel();
        var newTask = new model({
                leaf: true
            });
        newTask.setPercentDone(0);
        newTask.setName(this.L('newTaskText', this.texts));
        newTask.set(newTask.startDateField, (original && original.getStartDate()) || null);
        newTask.set(newTask.endDateField, (original && original.getEndDate()) || null);
        newTask.set(newTask.durationField, (original && original.getDuration()) || null);
        newTask.set(newTask.durationUnitField, (original && original.getDurationUnit()) || 'd');
        return newTask;
    },
    // Actions follow below
    // ---------------------------------------------
    /**
     * Handler for the "add task above" menu item
     */
    addTaskAbove: function(newTask) {
        var task = this.rec;
        if (task) {
            task.addTaskAbove(newTask);
        } else {
            this.getCmp().taskStore.getRootNode().appendChild(newTask);
        }
    },
    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelow: function(newTask) {
        var task = this.rec;
        if (task) {
            task.addTaskBelow(newTask);
        } else {
            this.getCmp().taskStore.getRootNode().appendChild(newTask);
        }
    },
    /**
     * Handler for the "delete task" menu item
     */
    deleteTask: function() {
        var toDelete = this.getCmp().getSelectedRows().slice();
        if (this.rec && !Ext.Array.contains(toDelete, this.rec)) {
            toDelete.push(this.rec);
        }
        this.getCmp().getTaskStore().removeTasks(toDelete);
    },
    /**
     * Handler for the "edit left label" menu item
     */
    editLeftLabel: function() {
        this.getCmp().getSchedulingView().editLeftLabel(this.rec);
    },
    /**
     * Handler for the "edit right label" menu item
     */
    editRightLabel: function() {
        this.getCmp().getSchedulingView().editRightLabel(this.rec);
    },
    /**
     * Handler for the "add task above" menu item
     */
    addTaskAboveAction: function() {
        this.addTaskAbove(this.copyTask(this.rec));
    },
    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelowAction: function() {
        this.addTaskBelow(this.copyTask(this.rec));
    },
    /**
     * Handler for the "add subtask" menu item
     */
    addSubtask: function() {
        var task = this.rec;
        // we create a new task using the selected task as a pattern
        // but only if it's not a project ..since nested projects are not supported
        var copy = this.copyTask(this.isNotProject(task) && task);
        task.addSubtask(copy);
    },
    /**
     * Handler for the "add successor" menu item
     */
    addSuccessor: function() {
        var task = this.rec;
        task.addSuccessor(this.copyTask(task));
    },
    /**
     * Handler for the "add predecessor" menu item
     */
    addPredecessor: function() {
        var task = this.rec;
        task.addPredecessor(this.copyTask(task));
    },
    /**
     * Handler for the "add milestone" menu item
     */
    addMilestone: function() {
        var task = this.rec,
            newTask = this.copyTask(task);
        task.addTaskBelow(newTask);
        newTask.setStartEndDate(task.getEndDate(), task.getEndDate());
    },
    /**
     * Handler for the "Convert to milestone" menu item
     */
    toggleMilestone: function() {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular();
        } else {
            this.rec.convertToMilestone();
        }
    },
    /**
     * @protected
     * Returns a date for the task splitting.
     * Returns start date of the tick being clicked if the tick duration is less than {@link #maxSplitDuration} or {@link #maxSplitDuration} is zero.
     * When the tick duration is greater than {@link #maxSplitDuration} returns `context.date` rounded based on active time axis resolution unit.
     *
     * Override this method if you want to implement another way of the split date calculating.
     * See also: {@link #getSplitDuration}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Date}      Returns a date to be used to split.
     */
    getSplitDate: function(context) {
        var task = context.task,
            date = context.date,
            tick = context.tick,
            timeAxis = context.timeAxis,
            maxDuration = this.getMaxSplitDuration(),
            result;
        if (tick) {
            result = tick.getStartDate();
            // we use tick duration if it's less than maximal allowed split size
            if (maxDuration) {
                maxDuration = task.getUnitConverter().convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit());
                if (maxDuration < tick.getEndDate() - tick.getStartDate())  {
                    result = null;
                }
                
            }
        }
        // otherwise round clicked datetime relative to task start using active time axis resolution unit
        return result || timeAxis.roundDate(date, task.getStartDate());
    },
    /**
     * @protected
     * Returns a duration for the task splitting.
     * Returns duration of the tick being clicked constrained by {@link #minSplitDuration} and {@link #maxSplitDuration} values.
     * Override this method if you want to implement another way of the split duration calculating.
     * See also: {@link #getSplitDate}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Number}      Returns split duration.
     */
    getSplitDuration: function(context) {
        if (this.splitDuration)  {
            return this.splitDuration;
        }
        
        var task = context.task,
            pos = context.pos,
            date = context.date,
            tick = context.tick;
        if (tick) {
            // let's get tick length in MS as initial duration
            var result = task.calculateDuration(tick.getStartDate(), tick.getEndDate(), Sch.util.Date.MILLI),
                converter = task.getUnitConverter(),
                minDuration = this.getMinSplitDuration(),
                maxDuration = this.getMaxSplitDuration();
            // if we have to constrain duration
            if (minDuration || maxDuration) {
                if (maxDuration) {
                    result = Math.min(result, converter.convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit()));
                }
                if (minDuration) {
                    result = Math.max(result, converter.convertDurationToMs(minDuration, this.getMinSplitDurationUnit()));
                }
            }
            // turn duration to proper duration unit
            return converter.convertMSDurationToUnit(result, this.getSplitDurationUnit(task, pos, date, tick));
        }
    },
    /**
     * @protected
     * Returns a duration unit for the task splitting.
     * Returns {@link #splitDurationUnit} when {@link #splitDuration} provided or `ms`.
     * Override this method if you want to implement another way of the split duration unit defining.
     * See also: {@link #getSplitDate}, {@link #getSplitDuration}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {String}      Returns split duration unit.
     */
    getSplitDurationUnit: function(context) {
        // if we have constant "splitDuration" set then we use "splitDurationUnit"
        // otherwise let's use milliseconds
        return this.splitDuration ? this.splitDurationUnit : Sch.util.Date.MILLI;
    },
    /**
     * Handler for the "Split task" menu item
     */
    splitTask: function() {
        var me = this,
            view = me.grid.getSchedulingView(),
            cursorDate = view.getDateFromX(me.triggerEventXY[0]),
            timeAxis = view.timeAxis;
        var context = {
                task: me.rec,
                pos: me.triggerEventXY,
                date: cursorDate,
                timeAxis: timeAxis,
                tick: timeAxis.getAt(Math.floor(timeAxis.getTickFromDate(cursorDate)))
            };
        context.task.split(me.getSplitDate(context), me.getSplitDuration(context), me.getSplitDurationUnit(context));
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.plugin.taskeditor.BaseEditor
*/
Ext.define('Gnt.plugin.taskeditor.BaseEditor', {
    extend: 'Ext.window.Window',
    requires: [
        'Ext.window.MessageBox'
    ],
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    lockableScope: 'top',
    closeOnBlur: true,
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.TaskEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.TaskEditor',
    /**
     * @property {Boolean} isTaskEditor
     * @readonly
     * Indicates that the class extends {@link Gnt.plugin.taskeditor.BaseEditor} class.
     */
    isTaskEditor: true,
    /**
     * @property {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor widget contained by the plugin.
     */
    taskEditor: null,
    /**
     * @cfg {Object} panelConfig Configuration for {@link Gnt.widget.taskeditor.BaseEditor} instance.
     */
    panelConfig: null,
    height: 340,
    width: 600,
    layout: 'card',
    constrain: true,
    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'taskdblclick'.
     */
    triggerEvent: 'taskdblclick',
    closeAction: 'hide',
    modal: true,
    gantt: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     * If this config is not provided plugin will try to retrieve assignments store from {@link Gnt.panel.Gantt} instance.
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     * If this config is not provided plugin will try to retrieve resources store from {@link Gnt.panel.Gantt} instance.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     * If this config is not provided plugin will try to retrieve tasks store from {@link Gnt.panel.Gantt} instance.
     * **Note:** Task store is required if task doesn't belong to any task store yet.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.model.Task} task The task to show in the task editor.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Task Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
     */
    /**
     * @cfg {Boolean} [monitorDataUpdates=false]
     *
     * Whether to actively monitor data updates or not, if set to true then Ok button (if present) will be enabled
     * only if there're data changes introduced in the Task Editor and those changes are valid.
     */
    monitorDataUpdates: false,
    /**
     * @cfg {Number} monitorDataUpdatesInterval
     *
     * Timeout to use to monitor data updates.
     */
    monitorDataUpdatesInterval: 500,
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore',
    taskFilters: null,
    /**
     * @event loadtask
     * Fires after task loading complete.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
     * @param {Gnt.model.Task} task The loaded task.
     *
     *
     * This event can be used to do additional data loading if task editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdatetask} event to have an example of how to implement custom data saving.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          panelConfig : {
     *              items       : customForm
     *          },
     *          listeners   : {
     *              // populate custom form with task values
     *              loadtask : function (taskeditor, task) {
     *                  customForm.loadRecord(task);
     *              },
     *              ....
     *          }
     *      });
     */
    /**
     * @event validate
     * Fires when task validation occurs. Take a look at example of using this event {@link Gnt.widget.taskeditor.TaskEditor#event-validate here}.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
     */
    /**
     * @event beforeupdatetask
     * Fires before task updating occurs. Return false to prevent the update.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
     * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
     *                      if (buttonId == 'yes') {
     *                          // here we continue updating asynchronously after user click "Yes" button
     *                          proceedCallback();
     *                          me.hide();
     *                      }
     *                  });
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     * **Note:** If a custom confirmation window messes with the default error message box you can disable it by overriding {@link #method-showErrorMessage} method. Example:
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // prevent default error message box showing
     *          showErrorMessage : Ext.emptyFn,
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.create('Ext.window.Window', {
     *                      title   : 'Complex confirmation',
     *                      width   : 100,
     *                      height  : 100,
     *                      items   : [....]
     *                  }).show();
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     */
    /**
     * @event afterupdatetask
     * Fires after task updating is finished.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
     *
     * This event can be used to do some extra processing after task was updated by task editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadtask} event to have an example of how to implement custom data loading.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  // foo - is the name of custom task field
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          panelConfig : {
     *              items       : customForm
     *          },
     *          listeners   : {
     *              afterupdatetask : function (taskeditor) {
     *                  // update form fields to loaded task
     *                  customForm.updateRecord();
     *              },
     *              ....
     *          }
     *      });
     */
    constructor: function(config) {
        config = config || {};
        this.taskFilters = [];
        // we need to apply config to let locale()
        // know about legacy locales since it will check them in 'this'
        Ext.apply(this, config);
        this.title = this.L('title');
        // by default we make 'Ok', 'Cancel' buttons
        if (!config.buttons) {
            this.buttons = [
                '->',
                {
                    itemId: 'teOkBtn',
                    text: this.L('okText'),
                    handler: this.onOkClick,
                    scope: this
                },
                {
                    text: this.L('cancelText'),
                    handler: this.close,
                    scope: this
                }
            ];
        }
        this.callParent([
            config
        ]);
        this.addCls('gnt-taskeditor-window');
        if (this.closeOnBlur) {
            this.on('show', this.onFirstShow, this, {
                single: true
            });
        }
    },
    /**
     * Displays the error message box on validation fail.
     * Override this method to customize the dialog.
     */
    showErrorMessage: function() {
        !Ext.Msg.isVisible() && Ext.Msg.alert(this.L('alertCaption'), this.L('alertText'));
    },
    onOkClick: function() {
        // Show our alert only if singleton Ext.Msg is not yet visible
        !this.completeEditing() && this.showErrorMessage();
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    init: function(cmp) {
        // if assignmentStore or resourceStore wasn't defined as configuration options
        // during plugin constructing we get them from Gnt.panel.Gantt instance
        this.assignmentStore = this.assignmentStore || cmp.getAssignmentStore();
        this.resourceStore = this.resourceStore || cmp.getResourceStore();
        this.taskStore = this.taskStore || cmp.getTaskStore();
        // build taskEditor widget
        this.buildTaskEditor(Ext.apply(this.buildTaskEditorConfig(cmp), this.panelConfig));
        this.add(this.taskEditor);
        this.mon(cmp, this.triggerEvent, this.onTriggerEvent, this);
        this.gantt = cmp;
    },
    // Prepares a configuration object to instantiate the taskEditor widget
    buildTaskEditorConfig: function(cmp) {
        var result = {
                width: null,
                height: null,
                border: false,
                showBaseline: cmp.enableBaseline,
                showRollup: cmp.showRollupTasks,
                allowParentTaskDependencies: cmp.allowParentTaskDependencies
            };
        var configs = this.taskEditorConfigs.split(',');
        // let's map some configuration options from plugin to taskEditor
        for (var i = 0; i < configs.length; i++) {
            var cfg = configs[i];
            if (typeof this[cfg] !== 'undefined') {
                result[cfg] = this[cfg];
            }
        }
        return result;
    },
    /**
     * @protected
     * Builds the task editor widget instance being used by the plugin.
     * By default this method creates {@link Gnt.widget.taskeditor.TaskEditor} instance and puts a reference to the instance to {@link #taskEditor} property.
     * Override this if you want to instantiate your custom class instead.
     * @param  {Object} cfg Configuration of the task editor widget being instantiated
     */
    buildTaskEditor: function(cfg) {
        this.taskEditor = Ext.create(this.taskEditorCls, cfg);
        var indicator = this.taskEditor.eventIndicator;
        this.relayEvents(this.taskEditor, [
            'load' + indicator,
            'validate',
            'beforeupdate' + indicator,
            'afterupdate' + indicator
        ]);
    },
    onTriggerEvent: function(gantt, task) {
        this.showTask(task);
    },
    /**
     * Shows window and loads task into the task editor.
     * @param {Gnt.model.Task} task Task to load.
     */
    showTask: function(task) {
        if (this.taskEditor && task && this.matchFilters(task)) {
            this.taskEditor.loadTask(task);
            var readOnly = this.gantt.isReadOnly();
            //  take into account the gantt readOnly state (the task being loaded readOnly and isEditable logic is supported on the widgets level)
            if (readOnly != this.taskEditor.setReadOnly()) {
                this.taskEditor.setReadOnly(readOnly);
            }
            this.down('#teOkBtn').setVisible(!readOnly);
            this.show();
        }
    },
    matchFilters: function(task) {
        if (!task)  {
            return;
        }
        
        for (var i = 0; i < this.taskFilters.length; i++) {
            var filter = this.taskFilters[i];
            if (!filter.fn.call(filter.scope, task))  {
                return false;
            }
            
        }
        return true;
    },
    addFilter: function(fn, scope) {
        this.taskFilters.push({
            fn: fn,
            scope: scope || this
        });
    },
    validate: function() {
        if (this.taskEditor) {
            return this.taskEditor.validate();
        }
    },
    /**
     * This function is a shorthand for the following typical steps:
     *
     *      if (!taskEditor.validate()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      } else {
     *          if (taskEditor.updateTask()) taskEditor.hide();
     *      }
     *
     * Instead of above code you can write:
     *
     *      if (!taskEditor.completeEditing()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      }
     *
     * @return {Boolean} true if validation successfully passed and record was successfully updated as well.
     */
    completeEditing: function() {
        if (this.taskEditor) {
            var activeTab = this.taskEditor.getActiveTab();
            // Force any active editing to complete first
            if (activeTab.editingPlugin && activeTab.editingPlugin.completeEdit) {
                activeTab.editingPlugin.completeEdit();
            }
            if (!this.taskEditor.validate())  {
                return false;
            }
            
            if (this.taskEditor.updateTask()) {
                this.hide();
                return true;
            }
            return false;
        }
    },
    /**
     * Persists the values in this task editor into corresponding {@link Gnt.model.Task}
     * object provided to {@link #showTask}.
     * Internally just calls {@link Gnt.widget.taskeditor.TaskEditor#updateTask updateTask} method of task editor panel.
     */
    updateTask: function() {
        if (this.taskEditor) {
            return this.taskEditor.updateTask();
        }
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.startDataUpdatesMonitoring();
    },
    onFirstShow: function() {
        if (this.zIndexManager.mask) {
            this.mon(this.zIndexManager.mask, 'click', function() {
                if (this.isVisible()) {
                    this.hide();
                }
            }, this);
        }
    },
    startDataUpdatesMonitoring: function() {
        var me = this,
            okBtn = me.down('#teOkBtn'),
            timerId = true;
        function monitor() {
            if (timerId && okBtn && me.taskEditor) {
                okBtn.setDisabled(!me.taskEditor.isDataChanged() || !me.taskEditor.isDataValid());
                timerId = Ext.Function.defer(monitor, me.monitorDataUpdatesInterval);
            }
        }
        function unmonitor() {
            timerId !== true && clearTimeout(timerId);
            timerId = true;
        }
        if (me.monitorDataUpdates && okBtn) {
            me.on({
                'show': monitor,
                'hide': unmonitor,
                'destroy': unmonitor
            });
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.util.Data', {
    singleton: true,
    // Copies a collection of records performing a copy of each model.
    // Each model in the resulting set keeps a link to its original instance in the originalRecord property.
    // Copied models have their "phantom" property set to false.
    // To apply changes made in the copy to its original data, {@link #applyCloneChanges} can be used.
    //
    // @param {Ext.data.Store/Ext.util.MixedCollection/Ext.data.Model[]} dataSet Collection of records to copy.
    // @param {Function} [fn] The function to be called at each model copying iteration.
    // @param {Ext.data.Model} fn.cloned The newly created copy of the model.
    // @param {Ext.data.Model} fn.original The original model.
    // @param {Mixed} [scope] The scope for fn function call. By default it`s the dataSet.
    // @return {Ext.data.Model[]} Array of cloned records.
    cloneModelSet: function(dataSet, fn, scope) {
        var data = [],
            cloned;
        var process = function(record) {
                // clone the record
                cloned = record.copy();
                cloned.phantom = false;
                // keep link to original record
                cloned.originalRecord = record;
                // if callback is set
                if (fn) {
                    if (fn.call(scope || dataSet, cloned, record) === false)  {
                        return;
                    }
                    
                }
                data.push(cloned);
            };
        if (dataSet.each) {
            dataSet.each(process);
        } else {
            Ext.Array.each(dataSet, process);
        }
        return data;
    },
    applyCloneChanges: function(cloneStore, originalStore, fn, scope) {
        var toRemove = [];
        var autoSyncSuspended = originalStore.autoSyncSuspended;
        // suspend automatic sync calls we will call sync() manually in the end of changes applying
        if (originalStore.autoSync && !autoSyncSuspended)  {
            originalStore.suspendAutoSync();
        }
        
        // first apply deleted records
        var removed = cloneStore.getRemovedRecords();
        for (var i = 0,
            l = removed.length; i < l; i++) {
            if (removed[i].originalRecord) {
                toRemove.push(removed[i].originalRecord);
            }
        }
        if (toRemove.length) {
            originalStore.remove(toRemove);
            cloneStore.removed.length = 0;
        }
        // let`s get updated & added records
        var modified = cloneStore.getModifiedRecords(),
            originalRecord, data, added;
        // and loop over them
        for (i = 0 , l = modified.length; i < l; i++) {
            // original instance of modified record
            originalRecord = modified[i].originalRecord;
            // new data
            data = modified[i].getData();
            delete data[modified[i].idProperty];
            // if it`s modification of existing record
            if (originalRecord) {
                // let`s update it
                originalRecord.beginEdit();
                for (var field in data) {
                    originalRecord.set(field, data[field]);
                }
                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }
                originalRecord.endEdit();
            } else // new record creation
            {
                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }
                added = originalStore.add(data);
                // let`s bind our record to effective one
                modified[i].originalRecord = added && added[0];
            }
            modified[i].commit(true);
        }
        // enable autoSync back and call sync to persist changes
        if (originalStore.autoSync && !autoSyncSuspended) {
            originalStore.resumeAutoSync();
            originalStore.sync();
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.taskeditor.BaseEditor
 @extends Ext.tab.Panel

 This is the baseclass for editors, it keeps the references to the stores and the loaded task instances.

 */
Ext.define('Gnt.widget.taskeditor.BaseEditor', {
    extend: 'Ext.tab.Panel',
    requires: [
        'Gnt.util.Data'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    margin: '5 0 0 0',
    height: 340,
    width: 600,
    layout: 'fit',
    border: false,
    plain: false,
    defaults: {
        margin: 5,
        border: false
    },
    eventIndicator: 'task',
    /**
     * @cfg {Gnt.model.Task} task The task to edit.
     */
    task: null,
    //private a buffer for the task
    taskBuffer: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is a required option if the task being edited doesn't belong to any task store.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #resourceStore}).
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #assignmentStore}).
     */
    resourceStore: null,
    tabBar: {
        cls: 'gnt-taskeditor-header'
    },
    clonedStores: null,
    /**
     * @event beforeupdatetask
     * Fires before task updating occurs. Return `false` to prevent the update.
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor widget instance.
     * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
     *                      if (buttonId == 'yes') {
     *                          // here we continue updating asynchronously after user click "Yes" button
     *                          proceedCallback();
     *                          me.hide();
     *                      }
     *                  });
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     */
    /**
     * @event afterupdatetask
     * Fires after a task has been updated.
     *
     * This event can be used to do some extra processing after task was updated by task editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadtask} event to have an example of how to implement custom data loading.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  // foo - is the name of custom task field
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          items       : customForm,
     *          listeners   : {
     *              afterupdatetask : function (taskeditor) {
     *                  // update form fields to loaded task
     *                  customForm.updateRecord();
     *              },
     *              ....
     *          }
     *      });
     *
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor instance.
     */
    /**
     * @event validate
     * Fires when task validating occurs.
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor instance.
     * @param {Ext.Component} tabToFocus The tab panel item where one or more invalid fields was detected.
     *
     * Fires during a {@link #method-validate} method call when task validation occurs.
     * Return `false` to make the validation fail, but take care of marking invalid component somehow (to let user know of error)
     * since normally invalid components are being highlighted during validate call.
     * For example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          items       : {
     *              title   : 'Some custom tab',
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          },
     *          listeners   : {
     *              validate    : function (taskeditor, tabToFocus) {
     *                  var field = taskeditor.down('#enter-your-name');
     *                  // if validation of our field failed
     *                  if (!field.isValid()) {
     *                      // if no other tabs with some invalid control
     *                      if (!tabToFocus) {
     *                          var activeTab = taskeditor.getActiveTab();
     *                          // if our field is not placed at currently active tab
     *                          if (!field.isDescendantOf(activeTab)) {
     *                              // then we'll switch to tab where our field resides
     *                              taskeditor.setActiveTab(taskeditor.getTabByComponent(field));
     *                          }
     *                      }
     *                      // return false since validation failed
     *                      return false;
     *                  }
     *              }
     *          }
     *      });
     *
     */
    /**/
    constructor: function(config) {
        var me = this;
        config = config || {};
        Ext.apply(me, config);
        // Prepare empty store clones (data loading occurs in loadTask() method).
        if (!me.clonedStores) {
            me.clonedStores = (me.task || me.taskStore) ? me.cloneStores() : {};
        }
        var items = me.buildItems(config);
        var its = me.items;
        // user defined tabs go after our predefined ones
        if (its) {
            items.push.apply(items, Ext.isArray(its) ? its : [
                its
            ]);
            delete config.items;
        }
        me.items = items;
        // if we have the only tab let's hide the tabBar
        if (me.items.length <= 1) {
            config.tabBar = config.tabBar || {};
            Ext.applyIf(config.tabBar, {
                hidden: true
            });
        }
        this.callParent([
            config
        ]);
    },
    buildItems: function() {
        return [];
    },
    cloneTaskBranch: function(task, taskCopy) {
        task = task || this.task;
        var me = this,
            taskStore = me.getTaskStore(),
            root = taskStore && taskStore.getRoot(),
            clonedStores = me.clonedStores,
            taskClone, lastTask;
        // loop over task parents till the root node
        task.bubble(function(task) {
            if (task !== root) {
                var copy = taskCopy[task.getId()];
                // stop if we met already copied task
                if (copy) {
                    // we attach cloned tasks to existing copy
                    if (lastTask)  {
                        copy.appendChild(lastTask);
                    }
                    
                    // "result.branch" will be empty in this case
                    lastTask = null;
                    return false;
                } else {
                    copy = me.cloneTask(task);
                    taskCopy[task.getId()] = copy;
                    copy.taskStore = clonedStores.taskStore;
                }
                if (lastTask) {
                    copy.appendChild(lastTask);
                } else {
                    taskClone = copy;
                }
                lastTask = copy;
            }
        });
        return {
            branch: lastTask,
            task: taskClone
        };
    },
    cloneRelevantTasks: function(task) {
        task = task || this.task;
        var me = this,
            taskCopy = {};
        // clone task with its parents
        var cloned = me.cloneTaskBranch(task, taskCopy),
            taskBuffer = cloned.task,
            tasks = [
                cloned.branch
            ];
        // clone predecessors
        Ext.Array.each(task.predecessors, function(d) {
            var cloned = me.cloneTaskBranch(d.getSourceTask(), taskCopy);
            if (cloned.branch)  {
                tasks.push(cloned.branch);
            }
            
        });
        // clone successors
        Ext.Array.each(task.successors, function(d) {
            var cloned = me.cloneTaskBranch(d.getTargetTask(), taskCopy);
            if (cloned.branch)  {
                tasks.push(cloned.branch);
            }
            
        });
        return {
            task: taskBuffer,
            tasks: tasks
        };
    },
    /**
     * Loads task data into task editor.
     * @param {Gnt.model.Task} task Task to load to editor.
     */
    loadTask: function(task) {
        if (!task)  {
            return;
        }
        
        // clone stores ..if they were not cloned yet
        this.clonedStores = this.cloneStores({
            task: task
        });
        // fill cloned stores with data
        this.loadClonedStores(this.clonedStores, task);
    },
    // We need fake taskStore to give task copy ability to ask it for the project calendar
    cloneTaskStore: function(task, config) {
        var store = this.getTaskStore();
        if (!store)  {
            return null;
        }
        
        var copy = new store.self(Ext.apply({
                isCloned: true,
                // TODO: ideally we need to clone calendar manager as well
                // but this is not that trivial since adding records to a calendar manager
                // automatically causes calendars creation
                calendarManager: store.calendarManager,
                // Ticket #1815:
                // Important, not to confuse the StoreManager
                storeId: null,
                calendar: store.getCalendar(),
                model: store.model,
                weekendsAreWorkdays: store.weekendsAreWorkdays,
                cascadeChanges: store.cascadeChanges,
                batchSync: false,
                recalculateParents: false,
                skipWeekendsDuringDragDrop: store.skipWeekendsDuringDragDrop,
                moveParentAsGroup: store.moveParentAsGroup,
                enableDependenciesForParentTasks: store.enableDependenciesForParentTasks,
                availabilitySearchLimit: store.availabilitySearchLimit,
                // Switch auto normalization, since it might corrupt parent nodes auto-calculated fields (Effort etc.)
                // because we don't clone all the children
                autoNormalizeNodes: false,
                dependenciesCalendar: store.dependenciesCalendar,
                proxy: {
                    type: 'memory',
                    reader: {
                        type: 'json'
                    }
                }
            }, config));
        // on bind different calendar to the original task store we do the same for the copy
        this.mon(store, {
            calendarset: function(store, calendar) {
                copy.setCalendar(calendar);
            }
        });
        return copy;
    },
    cloneDependencyStore: function(task, config) {
        var taskStore = this.getTaskStore();
        var store = this.dependencyStore || taskStore && taskStore.getDependencyStore();
        if (!store)  {
            return null;
        }
        
        return new store.self(Ext.apply({
            isCloned: true,
            model: store.model,
            strictDependencyValidation: store.strictDependencyValidation,
            allowedDependencyTypes: store.allowedDependencyTypes,
            proxy: {
                type: 'memory',
                reader: {
                    type: 'json'
                }
            }
        }, config));
    },
    cloneAssignmentStore: function(task, config) {
        var taskStore = this.getTaskStore();
        var store = this.assignmentStore || taskStore && taskStore.getAssignmentStore();
        if (!store)  {
            return null;
        }
        
        return new store.self(Ext.apply({
            isCloned: true,
            model: store.model,
            proxy: {
                type: 'memory',
                reader: {
                    type: 'json'
                }
            }
        }, config));
    },
    cloneResourceStore: function(task, config) {
        var taskStore = this.getTaskStore();
        var store = this.resourceStore || taskStore && taskStore.getResourceStore();
        if (!store)  {
            return null;
        }
        
        return new store.self(Ext.apply({
            isCloned: true,
            model: store.model,
            proxy: {
                type: 'memory',
                reader: {
                    type: 'json'
                }
            }
        }, config));
    },
    cloneStores: function(config) {
        config = config || {};
        var task = config.task || this.task,
            clonedStores = this.clonedStores || {},
            resourceStore = clonedStores.resourceStore || this.cloneResourceStore(task, config && config.resourceStore),
            assignmentStore = clonedStores.assignmentStore || this.cloneAssignmentStore(task, config && config.assignmentStore),
            dependencyStore = clonedStores.dependencyStore || this.cloneDependencyStore(task, config && config.dependencyStore);
        var taskStore = clonedStores.taskStore || this.cloneTaskStore(task, Ext.apply({
                assignmentStore: assignmentStore,
                resourceStore: resourceStore,
                dependencyStore: dependencyStore
            }, config && config.taskStore));
        resourceStore.taskStore = taskStore;
        Ext.apply(clonedStores, {
            resourceStore: resourceStore,
            assignmentStore: assignmentStore,
            dependencyStore: dependencyStore,
            taskStore: taskStore
        });
        return clonedStores;
    },
    getTaskStore: function(task) {
        task = task || this.task;
        return this.taskStore || task && task.getTaskStore();
    },
    loadClonedStores: function(clonedStores, task) {
        // copy relevant tasks for TaskStore clone
        var me = this,
            data = me.cloneRelevantTasks(task),
            tasks = data.tasks,
            taskBuffer = data.task;
        taskBuffer.taskStore.on({
            update: function(store, record, operation) {
                if (record === taskBuffer && operation == Ext.data.Model.EDIT) {
                    me.onTaskUpdated.call(me, record);
                    record.fireEvent(me.eventIndicator + 'updated', record);
                }
            }
        });
        // fill task store clone w/ related task copies
        clonedStores.taskStore.setRootNode({
            expanded: true,
            children: tasks
        });
        me.loadClonedDependencyStore(clonedStores, task);
        me.loadClonedResourceStore(clonedStores, task);
        me.loadClonedAssignmentStore(clonedStores, task);
        me.taskBuffer = taskBuffer;
    },
    loadClonedDependencyStore: function(clonedStores, task) {
        clonedStores = clonedStores || this.clonedStores;
        clonedStores.dependencyStore && clonedStores.dependencyStore.loadData(Gnt.util.Data.cloneModelSet(task.getAllDependencies(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    loadClonedResourceStore: function(clonedStores) {
        clonedStores = clonedStores || this.clonedStores;
        clonedStores.resourceStore && clonedStores.resourceStore.loadData(Gnt.util.Data.cloneModelSet(this.resourceStore || this.getTaskStore().getResourceStore(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    loadClonedAssignmentStore: function(clonedStores, task) {
        clonedStores = clonedStores || this.clonedStores;
        clonedStores.assignmentStore && clonedStores.assignmentStore.loadData(Gnt.util.Data.cloneModelSet(task.getAssignments(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    cloneTask: function(task) {
        return task.copy(task.getId(), false);
    },
    /**
     * Returns the task editor tab that contains specified component.
     * @return {Ext.Component} Tab containing specified component or `undefined` if item is not found.
     */
    getTabByComponent: function(component) {
        var result;
        this.items.each(function(el) {
            if (component === el || component.isDescendantOf(el)) {
                result = el;
                return false;
            }
        }, this);
        return result;
    },
    /**
     * Checks data loaded or entered to task editor for errors.
     * Calls isValid methods of taskForm, dependencyGrid, advancedForm (if corresponding objects are presented at the task editor).
     * In case some of calls returns `false` switch active tab so that user can view invalid object.
     * Validation can be customized by handling {@link #event-validate} event.
     *
     * Returns `false` in that case.
     * @return {Boolean} Returns `true` if all components are valid.
     */
    validate: function() {
        var result,
            activeTab = this.getActiveTab(),
            invalidTabs = [],
            tabToActivate;
        result = this.doValidate(function(tab) {
            invalidTabs.push(tab);
        });
        if (!result && activeTab && !Ext.Array.contains(invalidTabs, activeTab)) {
            tabToActivate = invalidTabs[0];
            this.setActiveTab(tabToActivate);
        } else if (!result && activeTab) {
            tabToActivate = activeTab;
        } else if (!result) {
            tabToActivate = invalidTabs[0];
        }
        // validation result
        return (this.fireEvent('validate', this, tabToActivate) !== false) && result;
    },
    /**
     * Persists the values in this task editor into corresponding {@link Gnt.model.Task} object provided to showTask.
     * @return {Boolean} Returns `true` if task was updated. Returns False if some {@link #beforeupdatetask} listener returns False.
     */
    updateTask: function() {
        var me = this,
            result = false;
        if (me.fireEvent('beforeupdate' + me.eventIndicator, me, function() {
            me.doUpdateTask();
        }) !== false) {
            me.doUpdateTask();
            me.fireEvent('afterupdate' + me.eventIndicator, me);
            result = true;
        }
        return result;
    },
    onDestroy: function() {
        if (this.clonedStores.taskStore) {
            this.clonedStores.taskStore.destroy();
        }
        this.callParent(arguments);
    },
    doValidate: function() {
        return true;
    },
    isDataValid: function() {
        return this.doValidate();
    },
    isDataChanged: function() {
        return false;
    },
    doUpdateTask: function() {
        throw 'Abstract method called';
    },
    /**
     * Updates underlying components readOnly state as reaction on either the editor readOnly state change
     * or the task being editing update.
     * @protected
     */
    updateReadOnly: function() {
        throw 'Abstract method called';
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.updateReadOnly();
    },
    onTaskUpdated: function() {
        this.updateReadOnly();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.taskeditor.BaseForm
 @extends Ext.form.Panel

 A mixin with common functionality for the taskform {@link Gnt.widget.taskeditor.TaskEditor}.

 */
Ext.define('Gnt.widget.taskeditor.BaseForm', {
    extend: 'Ext.form.Panel',
    /**
     * @cfg {Boolean} highlightTaskUpdates `true` to highlight fields updates initiated by changes of another fields.
     */
    highlightTaskUpdates: true,
    /**
     * @cfg {Gnt.model.Task} task A task to load to the form.
     */
    /**
     * @property {Gnt.model.Task} task The task loaded in the form.
     */
    task: null,
    /**
     * @cfg {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    /**
     * @property {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    taskBuffer: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is required option if task being loaded isn't yet belong to any task store.
     */
    taskStore: null,
    taskListeners: null,
    autoScroll: true,
    defaults: {
        labelWidth: 110
    },
    bodyPadding: 5,
    border: false,
    layout: 'anchor',
    defaultType: 'textfield',
    initComponent: function() {
        // if task provided on construction step
        if (this.task) {
            // get actual field names from task
            this.fieldNames = this.getFieldNames(this.task);
        }
        // if no fields definition provided we make default fields set
        if (!this.items) {
            this.buildFields();
        }
        this.callParent(arguments);
        if (this.task) {
            this.loadRecord(this.task, this.taskBuffer);
        }
    },
    getFieldNames: function(task) {
        if (!task)  {
            return;
        }
        
        var result = {};
        for (var i in this.fieldNames) {
            result[i] = task[i];
        }
        return result;
    },
    // Renames form fields according to provided task model.
    renameFields: function(task) {
        var newFields = this.getFieldNames(task);
        if (!newFields)  {
            return;
        }
        
        var form = this.getForm(),
            changed = false,
            field;
        for (var i in this.fieldNames) {
            field = form.findField(this.fieldNames[i]);
            // check if field name should be changed
            if (field && newFields[i] && newFields[i] != field.name) {
                changed = true;
                field.name = newFields[i];
            }
        }
        // if something was changed
        if (changed) {
            // keep new fields' names dictionary
            this.fieldNames = newFields;
        }
    },
    /**
     * Suppress task updates invoking by form fields. Calls setSuppressTaskUpdate() of each field that supports this method.
     * @param {Boolean} state Suppress or allow task updating.
     */
    setSuppressTaskUpdate: function(state) {
        var fields = this.getForm().getFields();
        fields.each(function(field) {
            // if field contains setTask() method
            field.setSuppressTaskUpdate && field.setSuppressTaskUpdate(state);
        });
    },
    isDataChanged: function() {
        return this.isDirty();
    },
    buildTaskBuffer: function(task) {
        var me = this;
        me.taskBuffer = task.copy();
        // since copy() doesn't copy taskStore let`s copy it ourself
        me.taskBuffer.taskStore = task.taskStore;
    },
    /**
     * Loads an Gnt.model.Task into this form.
     * @param {Gnt.model.Task} task The record to edit.
     * @param {Gnt.model.Task} [taskBuffer] The record to be used as a buffer to keep changed values of fields which implement {@link Gnt.field.mixin.TaskField}
     * mixin interface. This parameter can be used in case when you want to implement two form instances instantly
     * reflecting changes of each other:
     *
     *      // create 1st TaskForm instance
     *      var taskForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load record into 1st form
     *      taskForm.loadRecord(someTask);
     *
     *      // create 2nd TaskForm instance
     *      var anotherForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load the same record into 2nd form
     *      // and set to share taskBuffer with 1st form to immediately refect changes of each other
     *      anotherForm.loadRecord(someTask, taskForm.taskBuffer);
     */
    loadRecord: function(task, taskBuffer) {
        var me = this;
        // if new or another task loading
        if (task && task !== me.task) {
            // let's rename form fields according to task model
            me.renameFields(task);
        }
        me.task = task;
        me.taskBuffer = taskBuffer;
        // if no pre-created taskBuffer provided, let`s create it
        if (!me.taskBuffer) {
            me.buildTaskBuffer(task);
        }
        // destroy previous task listeners if any
        me.taskListeners && me.taskListeners.destroy();
        // listen to 'taskupdated' event and update fields "readonly" state
        me.taskListeners = me.mon(me.taskBuffer, {
            taskupdated: me.onTaskUpdated,
            destroyable: true,
            scope: me
        });
        var form = me.getForm();
        // following code is modified implementation
        // of Ext.form.Basic setValues() method
        form._record = task;
        this.suspendLayouts();
        var data = task.getData();
        form.getFields().each(function(field) {
            if (field.getName() in data) {
                // if field contains setTask() method
                // we gonna use it since setTask() execute setValue()
                if (field.setTask) {
                    field.setTask(me.taskBuffer);
                } else {
                    // set field value
                    field.setValue(data[field.getName()]);
                }
                // and set its readOnly state depending on gantt readOnly state and task.isEditable() result
                me.updateFieldReadOnly(field);
                if (form.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        });
        this.resumeLayouts(true);
        this.fireEvent('afterloadrecord', this, task);
    },
    updateFieldReadOnly: function(field) {
        var me = this;
        if (!field.disabled) {
            // Having forceReadOnly=true on a field disables TaskField and BaseForm logic that switches the field readOnly state
            // depending on the task being edited isEditable() result or the form readOnly state
            if (!field.forceReadOnly) {
                var isTaskField = field.isTaskField;
                // if the form is readOnly
                if (me.getReadOnly()) {
                    // we set the field readOnly too
                    field.setReadOnly(true);
                    // if it's a TaskField we suspend its own readOnly mechanism to prevent it from enabling the field back
                    isTaskField && field.suspendReadOnlyUpdate();
                } else // if the form is editable
                {
                    // if it's not a TaskField we take the task.isEditable() result into account
                    if (!isTaskField) {
                        var isEditable = me.taskBuffer.isEditable(field.name);
                        if (this.editable === false) {
                            if (isEditable && field.inputEl) {
                                field.inputEl.dom.readOnly = true;
                            }
                        }
                        field.setReadOnly(!isEditable);
                    } else {
                        field.resumeReadOnlyUpdate();
                        field.updateReadOnly(me.taskBuffer);
                    }
                }
            }
        }
    },
    // Updates readonly state of all the form fields
    updateReadOnly: function() {
        var me = this,
            form = me.getForm(),
            data = me.taskBuffer.getData();
        form.getFields().each(function(field) {
            if (field.getName() in data)  {
                me.updateFieldReadOnly(field);
            }
            
        });
    },
    /**
     * Applies the values from this form into the passed {@link Gnt.model.Task} object.
     * If the task is not specified, it will attempt to update (if it exists) the record provided to {@link #loadRecord}.
     * @param {Gnt.model.Task} [task] The record to apply change to.
     */
    updateRecord: function(task) {
        var me = this;
        task = task || me.task;
        if (task && me.fireEvent('beforeupdaterecord', me, task, me.updateRecordFn) !== false) {
            me.setSuppressTaskUpdate(true);
            me.updateRecordFn.call(me, task);
            me.setSuppressTaskUpdate(false);
            me.fireEvent('afterupdaterecord', me, task);
            return true;
        }
        return false;
    },
    updateRecordWithFieldValue: function(task, field) {
        var modelField = task.getField(field.name);
        // if the field has applyChanges() method
        // we use it to apply changes to the task
        if (field.applyChanges) {
            field.applyChanges(task);
        }
        // if there is a matching model field and the form field is supposed to be submittable (not displayfield or smth)
        else if (modelField && field.name in this.getForm().getFieldValues()) {
            task.set(field.name, field.getValue());
        }
    },
    /**
     * A function that iterates the form fields and applies to changes to it. Override this function for custom logic.
     * @param task
     */
    updateRecordFn: function(task) {
        var me = this;
        task.beginEdit();
        me.getForm().getFields().each(function(field) {
            me.updateRecordWithFieldValue(task, field);
        });
        task.endEdit();
    },
    // Applies "task", "taskStore", "highlightTaskUpdates" and "readOnly" configs to a field
    initFieldDefinition: function(field, cfg) {
        var me = this;
        var commonParams = {
                taskStore: me.taskStore,
                task: me.task,
                highlightTaskUpdates: me.highlightTaskUpdates
            };
        // if field isn't already read only then let's take into account Task.isEditable() result
        if (!field.readOnly && me.task) {
            commonParams.readOnly = !me.task.isEditable(field.name);
        }
        return Ext.apply(field, commonParams, cfg);
    },
    // Gets the task field value
    getTaskFieldValue: function(field) {
        var me = this,
            task = this.task;
        return task ? task.get(me.fieldNames[field]) : '';
    },
    onTaskUpdated: function(task, field) {
        // let's update fields "readonly" status after task data has been modified
        this.updateReadOnly();
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.updateReadOnly();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.taskeditor.ProjectForm
 @extends Gnt.widget.taskeditor.BaseForm

 This form is used to edit the project properties.
 By default it supports editing of the following fields:

 - the name of the project (project title)
 - the start date of the project
 - the end date of the project
 - the calendar assigned to the project
 - the dependency status, whether the project allows external tasks dependencies

 * **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

 ## Extending the default field set

 The default field set can be overwritten using the {@link #items} config.
 In case you want to keep the default fields and add some new custom fields, you can use the code below:

            // Extend the standard ProjectForm class
            Ext.define('MyProjectForm', {
                    extend : 'Gnt.widget.taskeditor.ProjectForm',

                    constructor : function(config) {
                        this.callParent(arguments);

                        // add some custom field
                        this.add({
                            fieldLabel  : 'Foo',
                            name        : 'Name',
                            width       : 200
                        });
                    }
            });

            // create customized form
            var form = new MyProjectForm({...});

 */
Ext.define('Gnt.widget.taskeditor.ProjectForm', {
    // This form by default contains various "standard" fields of the project
    // and it "knows" about their "applyChanges" methods (for our fields),
    // and about renamed field names
    // This form can be also used with any other set of fields, provided
    // as the "items" config
    extend: 'Gnt.widget.taskeditor.BaseForm',
    alias: 'widget.projectform',
    requires: [
        'Gnt.model.Project',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Gnt.field.Calendar',
        'Gnt.field.StartDate',
        'Gnt.field.EndDate',
        'Gnt.field.ReadOnly',
        'Ext.form.field.Checkbox'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: [
        'Gnt.widget.ProjectForm'
    ],
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be added to this container.
     *
     * **Note:** By default this form provide pre-configured set of fields. Using this option will overwrite that field set.
     */
    /**
     * @cfg {Boolean} [showCalendar=true] `true` to show calendarField.
     */
    showCalendar: false,
    /**
     * @cfg {Object} l10n
     *    A object, purposed for the class localization. Contains the following keys/values:
     *
     * @cfg {String} l10n.nameText                'Name'
     * @cfg {String} l10n.datesText               'Dates'
     * @cfg {String} l10n.startText               'Start'
     * @cfg {String} l10n.finishText              'Finish'
     * @cfg {String} l10n.calendarText            'Calendar'
     * @cfg {String} l10n.allowDependenciesText   'AllowDependencies'
     * @cfg {String} l10n.readOnlyText            'ReadOnly'
     */
    /**
     * @cfg {Object} nameConfig A config object to be applied to the `Name` field.
     */
    nameConfig: null,
    /*
     * @cfg {Object} readOnlyConfig A config object to be applied to the `ReadOnly` field.
     */
    readOnlyConfig: null,
    /**
     * @cfg {Object} allowDependenciesConfig A config object to be applied to the `AllowDependencies` field.
     */
    allowDependenciesConfig: null,
    /**
     * @cfg {Object} startConfig A config object to be applied to the `Start` field.
     */
    startConfig: null,
    /**
     * @cfg {Object} finishConfig A config object to be applied to the `Finish` field.
     */
    finishConfig: null,
    /**
     * @cfg {Object} calendarConfig A config object to be applied to the `Calendar` field.
     */
    calendarConfig: null,
    constructor: function(config) {
        config = config || {};
        var model = config.taskStore && config.taskStore.projectModel && config.taskStore.projectModel.prototype || Gnt.model.Project.prototype;
        // default field names
        this.fieldNames = {
            calendarIdField: model.calendarIdField,
            readOnlyField: model.readOnlyField,
            allowDependenciesField: model.allowDependenciesField,
            startDateField: model.startDateField,
            endDateField: model.endDateField,
            nameField: model.nameField,
            descriptionField: model.descriptionField
        };
        this.callParent(arguments);
        this.addBodyCls('gnt-projecteditor-projectform');
    },
    // Builds default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.fieldNames;
        me.items = me.items || [];
        me.items.push({
            xtype: 'fieldset',
            title: me.L('projectText'),
            layout: 'vbox',
            defaults: {
                allowBlank: false
            },
            items: [
                me.initFieldDefinition({
                    xtype: 'textfield',
                    fieldLabel: me.L('nameText'),
                    name: f.nameField,
                    labelWidth: 110,
                    flex: 1,
                    value: me.getTaskFieldValue(f.nameField)
                }, me.nameConfig),
                me.initFieldDefinition({
                    xtype: 'readonlyfield',
                    fieldLabel: me.L('readOnlyText'),
                    name: f.readOnlyField,
                    labelWidth: 110,
                    flex: 1,
                    value: me.getTaskFieldValue(f.readOnlyField)
                }, me.readOnlyConfig),
                me.initFieldDefinition({
                    xtype: 'checkboxfield',
                    fieldLabel: me.L('allowDependenciesText'),
                    name: f.allowDependenciesField,
                    labelWidth: 110,
                    flex: 1,
                    value: me.getTaskFieldValue(f.allowDependenciesField)
                }, me.allowDependenciesConfig)
            ]
        }, me.initFieldDefinition({
            xtype: 'fieldset',
            title: me.L('datesText'),
            layout: 'hbox',
            defaults: {
                labelWidth: 110,
                allowBlank: false,
                margin: '5 5 5 0'
            },
            items: [
                me.initFieldDefinition({
                    xtype: 'startdatefield',
                    fieldLabel: me.L('startText'),
                    width: 260,
                    name: f.startDateField,
                    value: me.getTaskFieldValue(f.startDateField)
                }, me.startConfig),
                me.initFieldDefinition({
                    xtype: 'enddatefield',
                    fieldLabel: me.L('finishText'),
                    flex: 1,
                    labelWidth: 110,
                    name: f.endDateField,
                    value: me.getTaskFieldValue(f.endDateField)
                }, me.finishConfig)
            ]
        }));
        if (me.showCalendar) {
            me.items.push({
                xtype: 'fieldset',
                layout: 'hbox',
                defaults: {
                    labelWidth: 110,
                    allowBlank: false,
                    margin: '5 0 5 0'
                },
                items: [
                    me.initFieldDefinition({
                        xtype: 'calendarfield',
                        fieldLabel: this.L('calendarText'),
                        width: 260,
                        name: f.calendarIdField,
                        value: me.getTaskFieldValue(f.calendarIdField)
                    }, me.calendarConfig)
                ]
            });
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.taskeditor.ProjectEditor
 @extends Gnt.widget.taskeditor.BaseEditor

 A widget used to display and edit project information.
 By default the widget is an Ext.tab.Panel instance which can contain the following tabs:

 - General information
 - Description

 You can easily add new custom tabs using {@link #items} config.

 # General

 Contains a customizable {@link Gnt.widget.ProjectForm form} instance for viewing and editing the following project data:

 - the name of the project
 - the start date of the project
 - the end date of the project
 - the readOnly status of the project
 - the allowDependencies status of the project

 ### Project form customization

 There is a {@link #projectFormConfig} config which can be used to customize the form panel.

        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // Configure the form located in the "General" tab
            projectFormConfig : {
                // turn off fields highlighting
                highlightTaskUpdates : false,
                // alter panel margin
                margin : 20
            }
        });

 ### Fields configuration

 The {@link Gnt.widget.ProjectForm} class has a config for each field presented at the `General` tab.
 And using {@link #projectFormConfig} we can get access for those options to setup fields.
 For example:

        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // setup form located at "General" tab
            projectFormConfig : {
                // set Baseline Finish Date field invisible
                allowDependenciesConfig : {
                    hidden : true
                }
            }
        });

 Here are some more configs for other fields:

 - {@link Gnt.widget.ProjectForm#nameConfig nameConfig} (the name of the project field)
 - {@link Gnt.widget.ProjectForm#startConfig startConfig} (the start date of the project field)
 - {@link Gnt.widget.ProjectForm#finishConfig finishConfig} (the end date of the project field)

 Please see {@link Gnt.widget.ProjectForm} class to see the full list of available config options.

 ### Extending the General field set

 If you want to add a new field to the `General` tab you will have to extend the {@link Gnt.widget.ProjectForm ProjectForm} class.
 After that you will need to configure the project editor to use your extended class:

        // extend standard ProjectForm class
        Ext.define('MyProjectForm', {
            extend : 'Gnt.widget.taskeditor.ProjectForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // Let task editor know which class to use
        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // to use MyProjectForm to build the "General" tab
            projectFormClass : 'MyProjectForm'
        });

 #Description

 Contains an {@link Ext.form.field.HtmlEditor} HTML editor instance for viewing and editing a freetext description about the Project.

You can enable/disable this tab by setting the {@link #showDescription} option.
To rename this tab you can use the `descriptionText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #descriptionConfig} config.

 */
Ext.define('Gnt.widget.taskeditor.ProjectEditor', {
    extend: 'Gnt.widget.taskeditor.BaseEditor',
    alias: 'widget.projecteditor',
    requires: [
        'Gnt.widget.taskeditor.ProjectForm',
        'Ext.form.field.HtmlEditor'
    ],
    alternateClassName: [
        'Gnt.widget.ProjectEditor'
    ],
    eventIndicator: 'project',
    /**
     * @event loadproject
     * Fires after project has been loaded into the editor.
     *
     * This event can be used to do additional data loading if project editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdateproject} event to have an example of how to implement custom data saving.
     *
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor widget instance.
     * @param {Gnt.model.Project} project The project.
     */
    /**
     * @event beforeupdateproject
     * Fires before project updating occurs. Return `false` to prevent the update.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor widget instance.
     * @param {Function} proceedCallback The function which can be called manually to continue project updating. Example:
     */
    /**
     * @event afterupdateproject
     * Fires after a project has been updated.
     *
     * This event can be used to do some extra processing after project was updated by project editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadproject} event to have an example of how to implement custom data loading.
     *
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor instance.
     */
    /**
     * @event validate
     * Fires when task validating occurs.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The task editor instance.
     * @param {Ext.Component} tabToFocus The tab panel item where one or more invalid fields was detected.
     *
     * Fires during a {@link #method-validate} method call when task validation occurs.
     * Return `false` to make the validation fail, but take care of marking invalid component somehow (to let user know of error)
     * since normally invalid components are being highlighted during validate call.
     */
    /**
     * @cfg {Gnt.model.Project} task The project to edit.
     */
    /**
     * @cfg {String} projectFormClass Class representing the form in the `General` tab.
     *
     * This option supposed to be used to implement a custom form in the `General` tab content.
     */
    projectFormClass: 'Gnt.widget.taskeditor.ProjectForm',
    /**
     * @cfg {Boolean} showDescription `true` to display a `Description` tab.
     */
    showDescription: true,
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be **appended** after default tabs to this container.
     * For example:
     *
     *      var projectEditor = Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
     *          items: [{
     *              title   : "Some custom tab",
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          }]
     *      });
     */
    /**
     * @cfg {Object} projectFormConfig Configuration options to be supplied to the `General` tab.
     * For possible options take a look at the {@link Gnt.widget.ProjectForm}.
     */
    projectFormConfig: null,
    /**
     * @cfg {Object} descriptionConfig Configuration options for the HTML-editor placed in the `Description` tab.
     * For possible options take a look at the {@link Ext.form.field.HtmlEditor}.
     */
    descriptionConfig: null,
    /**
     * @property {Ext.panel.Panel} descriptionPanel The `Description` tab.
     * Please use {@link #descriptionEditor} to access an enclosed HTML-editor.
     */
    descriptionPanel: null,
    /**
     * @property {Ext.form.field.HtmlEditor} descriptionEditor The HTML-editor presented in the `Description` tab.
     * To specify setting for the HTML-editor please use {@link #descriptionConfig}.
     */
    descriptionEditor: null,
    /**
     * @property {Gnt.widget.ProjectForm} projectForm The `General` tab project form.
     * By default it's a {@link Gnt.widget.ProjectForm} instance but it might be customized by using {@link #projectFormClass} option.
     */
    projectForm: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - generalText         : 'General',
     - descriptionText     : 'Description',
     */
    buildItems: function() {
        var me = this,
            items = [],
            project = this.task;
        // create ProjectForm instance
        me.projectForm = Ext.create(me.projectFormClass, Ext.applyIf(me.projectFormConfig || {}, {
            task: project,
            taskStore: me.taskStore
        }));
        items.push(me.projectForm);
        // create description panel
        if (me.showDescription) {
            // create notes HtmlEditor instance
            me.descriptionEditor = Ext.create('Ext.form.field.HtmlEditor', Ext.apply({
                listeners: {
                    // we need this to draw content of HtmlEditor properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: function(el) {
                        me.descriptionEditor.setValue(me.task.get(me.task.descriptionField));
                    }
                },
                readOnly: project && !project.isEditable(project.descriptionField),
                isDataChanged: function() {
                    return this.isDirty();
                }
            }, me.descriptionConfig));
            // we have to wrap it to panel since it's gonna be tab in TabPanel
            // (to avoid some render bugs)
            me.descriptionPanel = Ext.create('Ext.panel.Panel', {
                border: false,
                layout: 'fit',
                items: me.descriptionEditor
            });
            items.push(me.descriptionPanel);
        }
        // make sure that each panel has its title
        if (!me.projectForm.title)  {
            me.projectForm.title = me.L('generalText');
        }
        
        if (me.descriptionPanel && !me.descriptionPanel.title)  {
            me.descriptionPanel.title = this.L('descriptionText');
        }
        
        return items;
    },
    /**
     * Loads project data into the project editor.
     * **Note**, it's an alias for the {@link #loadTask} method.
     * @param {Gnt.model.Project} project Project to load to the editor.
     */
    loadProject: function(project) {
        this.loadTask.apply(this, arguments);
    },
    loadTask: function(project) {
        if (!project)  {
            return;
        }
        
        this.task = project;
        var projectForm = this.projectForm;
        // on task loading step let's suppress task updating
        projectForm.setSuppressTaskUpdate(true);
        projectForm.getForm().reset();
        this.callParent(arguments);
        projectForm.loadRecord(project, this.taskBuffer);
        if (this.descriptionEditor) {
            this.descriptionEditor.setValue(project.getDescription());
        }
        this.setReadOnly(project.isReadOnly());
        // enable 'projectupdated' event processing back
        projectForm.setSuppressTaskUpdate(false);
        this.fireEvent('loadproject', this, project);
    },
    setReadOnly: function(readOnly) {
        var me = this,
            project = me.task;
        if (project) {
            if (me.descriptionEditor) {
                me.descriptionEditor.setReadOnly(readOnly || !project.isEditable(project.descriptionField));
            }
        }
    },
    onTaskUpdated: function(record) {
        this.setReadOnly(record.isReadOnly());
    },
    /**
     * Persists editor data into the project instance.
     * **Note**, this is an alias for the {@link #updateTask} method.
     * @param {Gnt.model.Project} project Project to load to the editor.
     */
    updateProject: function() {
        this.updateTask();
    },
    // Since we do not need dependencies/assignments and resources copies
    // we override following methods to not fullfil corresponding store clones w/ data
    loadClonedDependencyStore: Ext.emptyFn,
    loadClonedResourceStore: Ext.emptyFn,
    loadClonedAssignmentStore: Ext.emptyFn,
    doValidate: function(invalidComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.projectForm && !this.projectForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.projectForm));
        }
        return result;
    },
    doUpdateTask: function() {
        var project = this.task;
        this.projectForm && this.projectForm.updateRecord();
        this.descriptionEditor && project.set(project.descriptionField, this.descriptionEditor.getValue());
    },
    isDataChanged: function(changedComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.projectForm && this.projectForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.projectForm));
        }
        if (this.descriptionEditor && this.descriptionEditor.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.descriptionEditor));
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.plugin.taskeditor.ProjectEditor
@extends Gnt.plugin.taskeditor.BaseEditor

A plugin (ptype = 'gantt_projecteditor') which shows a {@link Gnt.widget.taskeditor.ProjectEditor} in a window when a user double-clicks
{@link Gnt.model.Project a task of project type} bar in the gantt chart.

You can enable this plugin in your Gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        ...
        plugins : ['gantt_projecteditor']
        ...
    });

*/
Ext.define('Gnt.plugin.taskeditor.ProjectEditor', {
    extend: 'Gnt.plugin.taskeditor.BaseEditor',
    alternateClassName: [
        'Gnt.plugin.ProjectEditor'
    ],
    requires: [
        'Gnt.widget.taskeditor.ProjectEditor'
    ],
    alias: 'plugin.gantt_projecteditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_projecteditor',
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.ProjectEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.ProjectEditor',
    /**
     * @cfg {Gnt.model.Task} task The task to show in the task editor.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Project Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
            - generalText         : 'General'
     */
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore,projectFormClass,showDescription,projectFormConfig,descriptionConfig',
    /**
     * @event loadproject
     * Fires after project loading complete.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance used for editing.
     * @param {Gnt.model.Project} project The loaded project.
     */
    /**
     * @event validate
     * Fires when project validation occurs. Take a look at example of using this event {@link Gnt.widget.taskeditor.TaskEditor#event-validate here}.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance.
     */
    /**
     * @event beforeupdateproject
     * Fires before project updating occurs. Return false to prevent the update.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance used for editing.
     * @param {Function} proceedCallback The function which can be called manually to continue project updating. Example:
     */
    /**
     * @event afterupdateproject
     * Fires after project updating is finished.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance.
     *
     */
    constructor: function(config) {
        this.callParent(arguments);
        this.addCls('gnt-projecteditor-window');
        // filter out all except project records
        this.addFilter(function(task) {
            return task && task.isProject;
        });
    },
    init: function(cmp) {
        this.callParent(arguments);
        // decorate the component with a reference to the plugin
        cmp.projectEditor = this;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.widget.taskeditor.TaskForm
@extends Gnt.widget.taskeditor.BaseForm

{@img gantt/images/taskeditor-form.png}

This form is used to edit the task properties.
By default it supports editing of the following fields:

 - the name of the task (task title)
 - the start date of the task
 - the end date of the task
 - the task duration
 - the task effort
 - the current status of a task, expressed as the percentage completed
 - the baseline start date of the task (editing of this field is optional)
 - the baseline end date of the task (editing of this field is optional)
 - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)
 - the calendar assigned to task
 - the scheduling mode for the task

* **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

## Extending the default field set

The default field set can be overwritten using the {@link #items} config.
In case you want to keep the default fields and add some new custom fields, you can use the code below:

    // Extend the standard TaskForm class
    Ext.define('MyTaskForm', {
        extend : 'Gnt.widget.taskeditor.TaskForm',

        constructor : function(config) {
            this.callParent(arguments);

            // add some custom field
            this.add({
                fieldLabel  : 'Foo',
                name        : 'Name',
                width       : 200
            });
        }
    });

    // create customized form
    var form = new MyTaskForm({...});

*/
Ext.define('Gnt.widget.taskeditor.TaskForm', {
    // This form by default contains various "standard" fields of the task
    // and it "knows" about their "applyChanges" methods (for our fields),
    // and about renamed field names
    // This form can be also used with any other set of fields, provided
    // as the "items" config
    extend: 'Gnt.widget.taskeditor.BaseForm',
    alias: 'widget.taskform',
    requires: [
        'Gnt.model.Task',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Ext.form.field.Date',
        'Ext.form.field.Checkbox',
        'Gnt.field.Percent',
        'Gnt.field.StartDate',
        'Gnt.field.EndDate',
        'Gnt.field.Duration',
        'Gnt.field.Effort',
        'Gnt.field.BaselineStartDate',
        'Gnt.field.BaselineEndDate'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: [
        'Gnt.widget.TaskForm'
    ],
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be added to this container.
     *
     * For example:
     *
        var myForm  = new Gnt.widget.taskeditor.TaskForm({
            items       : [
                {
                    xtype       : 'calendarfield',
                    fieldLabel  : 'Calendar',
                    name        : 'CalendarId'
                },
                {
                    xtype       : 'displayfield',
                    fieldLabel  : "WBS",
                    name        : 'wbsCode'
                }
            ],
            task        : myTask,
            taskStore   : myTaskStore
        });


     *
     * **Note:** By default this form provide pre-configured set of fields. Using this option will overwrite that field set.
     */
    /**
     * @cfg {Boolean} [showGeneral=true] `true` to display general fields.
     */
    showGeneral: true,
    /**
     * @cfg {Boolean} [showBaseline=true] `true` to display baseline fields.
     */
    showBaseline: true,
    /**
     * @cfg {Boolean} [editBaseline=false] `true` to allow editing of baseline fields.
     */
    editBaseline: false,
    /**
     * @cfg {Object} l10n
     *    A object, purposed for the class localization. Contains the following keys/values:
     *
     * @cfg {String} l10n.taskNameText            'Name'
     * @cfg {String} l10n.durationText            'Duration'
     * @cfg {String} l10n.datesText               'Dates'
     * @cfg {String} l10n.baselineText            'Baseline'
     * @cfg {String} l10n.startText               'Start'
     * @cfg {String} l10n.finishText              'Finish'
     * @cfg {String} l10n.percentDoneText         'Percent Complete'
     * @cfg {String} l10n.baselineStartText       'Start'
     * @cfg {String} l10n.baselineFinishText      'Finish'
     * @cfg {String} l10n.baselinePercentDoneText 'Percent Complete'
     * @cfg {String} l10n.effortText              'Effort'
     * @cfg {String} l10n.invalidEffortText       'Invalid effort value'
     */
    /**
     * @cfg {Object} taskNameConfig A config object to be applied to the `Name` field.
     */
    taskNameConfig: null,
    /**
     * @cfg {Object} durationConfig A config object to be applied to the `Duration` field.
     */
    durationConfig: null,
    /**
     * @cfg {Object} startConfig A config object to be applied to the `Start` field.
     */
    startConfig: null,
    /**
     * @cfg {Object} finishConfig A config object to be applied to the `Finish` field.
     */
    finishConfig: null,
    /**
     * @cfg {Object} percentDoneConfig A config object to be applied to the `Percent Complete` field.
     */
    percentDoneConfig: null,
    /**
     * @cfg {Object} baselineStartConfig A config object to be applied to the `Start` field of the `Baseline` fields container.
     */
    baselineStartConfig: null,
    /**
     * @cfg {Object} baselineFinishConfig A config object to be applied to the `Finish` field of the `Baseline` fields container.
     */
    baselineFinishConfig: null,
    /**
     * @cfg {Object} baselinePercentDoneConfig A config object to be applied to the `Percent Complete` field of the `Baseline` fields container.
     */
    baselinePercentDoneConfig: null,
    /**
     * @cfg {Object} effortConfig A config object to be applied to the `Effort` field.
     */
    effortConfig: null,
    constructor: function(config) {
        config = config || {};
        this.showBaseline = config.showBaseline;
        this.editBaseline = config.editBaseline;
        var model = config.taskStore ? config.taskStore.model.prototype : Gnt.model.Task.prototype;
        // default field names
        this.fieldNames = {
            baselineEndDateField: model.baselineEndDateField,
            baselinePercentDoneField: model.baselinePercentDoneField,
            baselineStartDateField: model.baselineStartDateField,
            calendarIdField: model.calendarIdField,
            readOnlyField: model.readOnlyField,
            clsField: model.clsField,
            draggableField: model.draggableField,
            durationField: model.durationField,
            durationUnitField: model.durationUnitField,
            effortField: model.effortField,
            effortUnitField: model.effortUnitField,
            endDateField: model.endDateField,
            manuallyScheduledField: model.manuallyScheduledField,
            nameField: model.nameField,
            percentDoneField: model.percentDoneField,
            resizableField: model.resizableField,
            rollupField: model.rollupField,
            schedulingModeField: model.schedulingModeField,
            startDateField: model.startDateField,
            noteField: model.noteField,
            constraintTypeField: model.constraintTypeField,
            constraintDateField: model.constraintDateField
        };
        this.callParent(arguments);
        this.addBodyCls('gnt-taskeditor-taskform');
    },
    // Builds default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.fieldNames;
        me.items = me.items || [];
        if (me.showGeneral) {
            me.items.push(me.initFieldDefinition({
                xtype: 'textfield',
                fieldLabel: me.L('taskNameText'),
                name: f.nameField,
                labelWidth: 110,
                allowBlank: false,
                flex: 1,
                value: me.getTaskFieldValue(f.nameField)
            }, me.nameConfig), {
                xtype: 'fieldcontainer',
                layout: 'hbox',
                defaults: {
                    labelWidth: 110,
                    allowBlank: false
                },
                items: [
                    me.initFieldDefinition({
                        xtype: 'percentfield',
                        fieldLabel: me.L('percentDoneText'),
                        name: f.percentDoneField,
                        margin: '0 0 0 8',
                        //width       : 200,
                        flex: 1,
                        value: me.getTaskFieldValue(f.percentDoneField)
                    }, me.percentDoneConfig),
                    me.initFieldDefinition({
                        xtype: 'durationfield',
                        fieldLabel: me.L('durationText'),
                        name: f.durationField,
                        //width       : 200,
                        flex: 1,
                        value: me.getTaskFieldValue(f.durationField)
                    }, me.durationConfig)
                ]
            }, {
                xtype: 'fieldset',
                title: me.L('datesText'),
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        layout: 'anchor',
                        flex: 1,
                        margin: '0 8 0 0',
                        defaults: {
                            labelWidth: 110
                        },
                        items: [
                            me.initFieldDefinition({
                                xtype: 'startdatefield',
                                fieldLabel: me.L('startText'),
                                width: '100%',
                                allowBlank: false,
                                name: f.startDateField,
                                value: me.getTaskFieldValue(f.startDateField)
                            }, me.startConfig),
                            me.initFieldDefinition({
                                xtype: 'effortfield',
                                fieldLabel: me.L('effortText'),
                                name: f.effortField,
                                invalidText: me.L('invalidEffortText'),
                                width: '100%',
                                allowBlank: true,
                                value: me.getTaskFieldValue(f.effortField)
                            }, me.effortConfig)
                        ]
                    },
                    me.initFieldDefinition({
                        xtype: 'enddatefield',
                        fieldLabel: me.L('finishText'),
                        flex: 1,
                        labelWidth: 110,
                        allowBlank: false,
                        name: f.endDateField,
                        value: me.getTaskFieldValue(f.endDateField)
                    }, me.finishConfig)
                ]
            });
        }
        if (me.showBaseline) {
            me.items.push({
                xtype: 'fieldset',
                title: me.L('baselineText'),
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        layout: 'anchor',
                        flex: 1,
                        margin: '0 8 0 0',
                        defaults: {
                            labelWidth: 110,
                            cls: 'gnt-baselinefield'
                        },
                        items: [
                            me.initFieldDefinition({
                                xtype: 'baselinestartdatefield',
                                fieldLabel: me.L('baselineStartText'),
                                name: f.baselineStartDateField,
                                value: me.getTaskFieldValue(f.baselineStartDateField),
                                width: '100%',
                                readOnly: !me.editBaseline,
                                // Setting forceReadOnly to true disables TaskField and BaseForm logic that switches the field readOnly state
                                // depending on the task being edited isEditable() result or the form readOnly state
                                forceReadOnly: !me.editBaseline
                            }, me.baselineStartConfig),
                            me.initFieldDefinition({
                                xtype: 'percentfield',
                                fieldLabel: me.L('baselinePercentDoneText'),
                                width: '100%',
                                name: f.baselinePercentDoneField,
                                value: me.getTaskFieldValue(f.baselinePercentDoneField),
                                readOnly: !me.editBaseline,
                                forceReadOnly: !me.editBaseline
                            }, me.baselinePercentDoneConfig)
                        ]
                    },
                    me.initFieldDefinition({
                        xtype: 'baselineenddatefield',
                        fieldLabel: me.L('baselineFinishText'),
                        name: f.baselineEndDateField,
                        cls: 'gnt-baselinefield',
                        flex: 1,
                        labelWidth: 110,
                        value: me.getTaskFieldValue(f.baselineEndDateField),
                        readOnly: !me.editBaseline,
                        forceReadOnly: !me.editBaseline
                    }, me.baselineFinishConfig)
                ]
            });
        }
    },
    updateRecordWithFieldValue: function(task, field) {
        var me = this;
        // Constraint related fields require different approach
        if (field.name != me.fieldNames.constraintTypeField && field.name != me.fieldNames.constraintDateField) {
            return this.callParent(arguments);
        }
    },
    updateRecordFn: function(task) {
        var me = this,
            fieldNames = me.fieldNames,
            form = me.getForm(),
            constraintTypeField = form.findField(fieldNames.constraintTypeField),
            constraintDateField = form.findField(fieldNames.constraintDateField);
        task.beginEdit();
        this.callParent(arguments);
        // apply constraints if corresponding fields was shown
        // and task has constraint mixin mixed
        if (constraintTypeField && constraintDateField && task.setConstraint) {
            task.setConstraint(constraintTypeField.getValue(), constraintDateField.getValue());
        }
        task.endEdit();
    },
    buildTaskBuffer: function(task) {
        this.callParent(arguments);
        // "isEditable" result depends on the task parent nodes readonly state
        // so if some of the task parents is readonly
        // we simply return true
        if (!task.getReadOnly() && task.isReadOnly()) {
            this.taskBuffer.isReadOnly = function() {
                return true;
            };
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.taskeditor.AdvancedForm
 @extends Gnt.widget.taskeditor.TaskForm

 This form represents the `Advanced` tab of {@link Gnt.widget.taskeditor.TaskEditor the task editor widget}.
 By default it supports editing of the following fields:

 - calendar assigned to the task
 - scheduling mode for the task
 - manually scheduled flag
 - WBS code
 - rollup flag
 - constraint type
 - constraint date
 - read only flag

 * **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

 ## Extending the default field set

 The default field set can be overwritten using the {@link #items} config.
 In case you want to keep the default fields and add some new custom fields, you can use the code below:

 // Extend the standard AdvancedForm class
 Ext.define('MyAdvancedForm', {
        extend : 'Gnt.widget.taskeditor.AdvancedForm',

        constructor : function(config) {
            this.callParent(arguments);

            // add some custom field
            this.add({
                fieldLabel  : 'Foo',
                name        : 'Name',
                width       : 200
            });
        }
    });

 // create customized form
 var form = new MyAdvancedForm({...});

 */
Ext.define('Gnt.widget.taskeditor.AdvancedForm', {
    extend: 'Gnt.widget.taskeditor.TaskForm',
    alias: 'widget.advanced_taskform',
    requires: [
        'Gnt.model.Task',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Ext.form.field.Date',
        'Gnt.field.SchedulingMode',
        'Gnt.field.ManuallyScheduled',
        'Gnt.field.Calendar',
        'Gnt.field.ConstraintType',
        'Gnt.field.ConstraintDate',
        'Gnt.field.ReadOnly'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: [
        'Gnt.widget.AdvancedForm'
    ],
    /**
     * @hide
     * @cfg showGeneral
     */
    showGeneral: false,
    /**
     * @hide
     * @cfg showBaseline
     */
    showBaseline: false,
    /**
     * @hide
     * @cfg editBaseline
     */
    editBaseline: false,
    /**
     * @cfg {Boolean} showCalendar `true` to show `Calendar` field.
     */
    showCalendar: true,
    /**
     * @cfg {Boolean} showManuallyScheduled `true` to show `ManuallyScheduled` field.
     */
    showManuallyScheduled: true,
    /**
     * @cfg {Boolean} showSchedulingMode `true` to show `Scheduling Mode` field.
     */
    showSchedulingMode: true,
    /**
     * @cfg {Boolean} showWbsCode `true` to show `WBS code` field.
     */
    showWbsCode: true,
    /**
     * @cfg {Boolean} showRollup `true` to show `Rollup` field.
     */
    showRollup: false,
    /**
     * @cfg {Boolean} showConstraint `true` to show `Constraint Type`, `Constraint Date` fields.
     */
    showConstraint: true,
    /**
     * @cfg {Boolean} showReadOnly `true` to show `ReadOnly field`.
     */
    showReadOnly: false,
    /**
     * @cfg {Object} l10n
     *    A object, purposed for the class localization. Contains the following keys/values:
     *
     * @cfg {String} l10n.calendarText            'Calendar'
     * @cfg {String} l10n.manuallyScheduled       'Manually Scheduled'
     * @cfg {String} l10n.schedulingModeText      'Scheduling Mode'
     * @cfg {String} l10n.wbsCodeText             'WBS code'
     * @cfg {String} l10n."Constraint Type"       'Constraint Type'
     * @cfg {String} l10n."Constraint Date"       'Constraint Date'
     * @cfg {String} l10n.readOnlyText            'ReadOnly'
     */
    /**
     * @cfg {Object} calendarConfig A config object to be applied to the `Calendar` field.
     */
    calendarConfig: null,
    /**
     * @cfg {Object} manuallyScheduledConfig A config object to be applied to the `Manually Scheduled` field.
     */
    manuallyScheduledConfig: null,
    /**
     * @cfg {Object} schedulingModeConfig A config object to be applied to the `Scheduling Mode` field.
     */
    schedulingModeConfig: null,
    /**
     * @cfg {Object} wbsCodeConfig A config object to be applied to the `WBS code` field.
     */
    wbsCodeConfig: null,
    /**
     * @cfg {Object} rollupConfig A config object to be applied to the `Rollup` field.
     */
    rollupConfig: null,
    /**
     * @cfg {Object} constraintTypeConfig A config object to be applied to the `Constraint Type` field.
     */
    constraintTypeConfig: null,
    /**
     * @cfg {Object} constraintDateConfig A config object to be appied to the `Constraint Date` field.
     */
    constraintDateConfig: null,
    defaults: {
        labelWidth: 110,
        flex: 1
    },
    // neptune theme has some troubles aligning this form, set custom padding to fit fields to visible area
    bodyPadding: '5 5 0 0',
    /*
     * @cfg {Object} readOnlyConfig A config object to be applied to the `ReadOnly` field.
     */
    readOnlyConfig: null,
    constructor: function(config) {
        this.callParent(arguments);
        this.addBodyCls('gnt-taskeditor-advancedtaskform');
    },
    // Builds default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.fieldNames;
        me.items = me.items || [];
        if (me.showCalendar) {
            me.items.push(me.initFieldDefinition({
                xtype: 'calendarfield',
                fieldLabel: this.L('calendarText'),
                name: f.calendarIdField,
                value: me.getTaskFieldValue(f.calendarIdField)
            }, me.calendarConfig));
        }
        if (me.showManuallyScheduled) {
            me.items.push(me.initFieldDefinition({
                xtype: 'manuallyscheduledfield',
                fieldLabel: me.L('manuallyScheduledText'),
                name: f.manuallyScheduledField,
                value: me.getTaskFieldValue(f.manuallyScheduledField)
            }, me.manuallyScheduledConfig));
        }
        if (me.showSchedulingMode) {
            me.items.push(me.initFieldDefinition({
                xtype: 'schedulingmodefield',
                fieldLabel: me.L('schedulingModeText'),
                name: f.schedulingModeField,
                value: me.getTaskFieldValue(f.schedulingModeField),
                allowBlank: false
            }, me.schedulingModeConfig));
        }
        if (me.showWbsCode) {
            me.items.push(me.initFieldDefinition({
                xtype: 'textfield',
                fieldLabel: me.L('wbsCodeText'),
                name: 'wbsCode',
                forceReadOnly: true,
                readOnly: true,
                value: me.task && me.task.getWBSCode()
            }, me.wbsCodeConfig));
        }
        if (me.showRollup) {
            this.items.push(me.initFieldDefinition({
                xtype: 'checkboxfield',
                fieldLabel: this.L('rollupText'),
                name: f.rollupField,
                // TO fix Ext JS 6.0.2 bug
                // https://www.sencha.com/forum/showthread.php?310395
                uncheckedValue: false,
                value: me.getTaskFieldValue(f.rollupField)
            }, me.rollupConfig));
        }
        if (me.showReadOnly) {
            this.items.push(me.initFieldDefinition({
                xtype: 'readonlyfield',
                fieldLabel: me.L('readOnlyText'),
                name: f.readOnlyField,
                value: me.getTaskFieldValue(f.readOnlyField)
            }, me.readOnlyConfig));
        }
        if (me.showConstraint) {
            me.items.push(me.initFieldDefinition({
                xtype: 'constrainttypefield',
                fieldLabel: me.L("Constraint Type"),
                name: f.constraintTypeField,
                value: me.getTaskFieldValue(f.constraintTypeField)
            }, me.constraintTypeConfig), me.initFieldDefinition({
                xtype: 'constraintdatefield',
                fieldLabel: me.L("Constraint Date"),
                name: f.constraintDateField,
                value: me.getTaskFieldValue(f.constraintDateField)
            }, me.constraintDateConfig));
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.widget.AssignmentEditGrid
@extends Ext.grid.Panel

A widget used to display and edit the task assignments.
You can find this widget at the `Resources` tab of {@link Gnt.widget.taskeditor.TaskEditor}.
There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#assignmentGridConfig assignmentGridConfig} object
available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} (if you use TaskEditor by plugin).

{@img gantt/images/assignment-edit-grid2.png}

{@img gantt/images/assignment-edit-grid1.png}

You can also use this grid in your components, standalone:

    // the task store of the project
    var taskStore           = myGanttPanel.taskStore

    var assignmentGrid      = new Gnt.widget.AssignmentEditGrid({
        assignmentStore         : taskStore.assignmentStore,
        resourceStore           : taskStore.resourceStore,

        // identifier of task which assignments have to be displayed
        taskId                  : 100,
        // turn off in-place resource adding
        addResources            : false,

        renderTo                : Ext.getBody(),

        width                   : 800,
        height                  : 600
    })

*/
Ext.define('Gnt.widget.AssignmentEditGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.assignmenteditgrid',
    requires: [
        'Ext.data.JsonStore',
        'Ext.window.MessageBox',
        'Ext.form.field.ComboBox',
        'Ext.grid.plugin.CellEditing',
        'Gnt.util.Data',
        'Gnt.data.AssignmentStore',
        'Gnt.data.ResourceStore',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     */
    resourceStore: null,
    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly: false,
    cls: 'gnt-assignmentgrid',
    /**
     * @cfg {Number} defaultAssignedUnits Default amount of units. This value applies for new assignments.
     */
    defaultAssignedUnits: 100,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - confirmAddResourceTitle : 'Confirm',
            - confirmAddResourceText  : 'No resource &quot;{0}&quot; in storage yet. Would you like to add it?',
            - noValueText             : 'Please select resource to assign',
            - noResourceText          : 'No resource &quot;{0}&quot; in storage'
     */
    /**
     * @cfg {Mixed} confirmAddResourceText A title for the confirmation window when a new resource is about to be added.
     * If you set this to `false`, no confirmation window will be displayed.
     * In this mode, for every "unknown" resource name entered into the combobox field, a new resource will be created.
     * @removed 2.5 Please use {@link #confirmAddResource} and {@link #l10n} instead.
     */
    /**
     * @cfg {Boolean} confirmAddResource False to not display a confirmation window before adding a new resource.
     */
    confirmAddResource: true,
    /**
     * @cfg {Boolean} addResources `true` to enable in-place resource adding.
     */
    addResources: true,
    /**
     * @property {String/Number} taskId Identifier of the task to which the assignments belong.
     */
    /**
     * @cfg {String/Number} taskId The task id indicating which assignments to load.
     * **Note**, that if the task doesn't have an identifier yet (a 'phantom' record), you can use its phantomId instead.
     */
    taskId: null,
    refreshTimeout: 100,
    // copy of resource store
    resourceDupStore: null,
    // copy of resource store used for resources combobox
    // (this store is affected by filters so we don't use `resourceDupStore` to always have "clean" copy there)
    resourceComboStore: null,
    assignmentUnitsEditor: null,
    constructor: function(config) {
        Ext.apply(this, config);
        var assignmentStore = config.assignmentStore;
        var taskStore = config.taskStore || assignmentStore.getTaskStore();
        // Use an Gnt.data.AssignmentStore instance since
        // we need it to play this role in case we link grid with TaskForm.taskBuffer
        this.store = config.store || new assignmentStore.self({
            model: assignmentStore.model,
            taskStore: taskStore
        });
        var resourceStore = taskStore.getResourceStore();
        this.resourceDupStore = config.resourceDupStore || new resourceStore.self({
            model: resourceStore.model,
            taskStore: taskStore
        });
        // resource combo store
        this.resourceComboStore = new Ext.data.JsonStore({
            autoDestroy: true,
            model: this.resourceDupStore.model
        });
        if (config.addResources !== undefined) {
            this.addResources = config.addResources;
        }
        this.columns = this.buildColumns();
        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }
        this.callParent(arguments);
    },
    suspendRefreshResources: function() {
        this.refreshResourcesSuspended++;
    },
    resumeRefreshResources: function() {
        this.refreshResourcesSuspended--;
    },
    refreshResources: function() {
        if (!this.refreshResourcesSuspended && !this.isDestroyed) {
            this.loadResources();
        }
    },
    suspendRefreshAssignments: function() {
        this.refreshAssignmentsSuspended++;
    },
    resumeRefreshAssignments: function() {
        this.refreshAssignmentsSuspended--;
    },
    refreshAssignments: function() {
        if (!this.refreshAssignmentsSuspended && !this.isDestroyed) {
            this.loadTaskAssignments();
        }
    },
    initComponent: function() {
        this.loadResources();
        var refreshResources = Ext.Function.createBuffered(this.refreshResources, this.refreshTimeout, this, []);
        this.mon(this.resourceStore, {
            add: refreshResources,
            remove: refreshResources,
            load: refreshResources,
            clear: refreshResources
        });
        this.loadTaskAssignments();
        var refreshAssignments = Ext.Function.createBuffered(this.refreshAssignments, this.refreshTimeout, this, []);
        this.mon(this.assignmentStore, {
            add: refreshAssignments,
            remove: refreshAssignments,
            load: refreshAssignments,
            clear: refreshAssignments
        });
        this.callParent(arguments);
    },
    loadResources: function(justResources) {
        if (!this.resourceStore)  {
            return false;
        }
        
        // make a copy of resourceStore
        var data = Gnt.util.Data.cloneModelSet(this.resourceStore);
        // clone data to not affect real store
        this.resourceDupStore.loadData(data);
        this.resourceComboStore.loadData(data);
        // we reload assignments as well since they depend on resources list
        if (!justResources) {
            this.loadTaskAssignments();
        }
        return true;
    },
    afterRender: function() {
        var task;
        this.callParent(arguments);
        // if taskId was provided at construction
        if (this.taskId) {
            var taskStore = this.taskStore || this.assignmentStore.getTaskStore();
            // trying to get task
            task = taskStore && taskStore.getModelById(this.taskId);
        }
        if (task) {
            this.setEditableFields(task);
        }
    },
    getUnitsEditor: function() {
        if (!this.readOnly) {
            // in readOnly mode we dont have cellEditing plugin instance and thus we don't have getEditor method at all
            if (!this.assignmentUnitsEditor)  {
                this.assignmentUnitsEditor = this.down('assignmentunitscolumn').getEditor();
            }
            
        }
        return this.assignmentUnitsEditor;
    },
    setEditableFields: function(task) {
        var unitsEditor = this.getUnitsEditor();
        if (unitsEditor) {
            switch (task.getSchedulingMode()) {
                case 'DynamicAssignment':
                    unitsEditor.setReadOnly(true);
                    break;
                default:
                    unitsEditor.setReadOnly(false);
            }
        }
    },
    /**
     * Disable the cellediting plugin
     * @param readOnly
     */
    setReadOnly: function(readOnly) {
        if (this.cellEditing) {
            if (readOnly) {
                this.cellEditing.disable();
            } else {
                this.cellEditing.enable();
            }
        }
    },
    /**
     * Loads task assignments from {@link #assignmentStore}.
     *
     * @param {Mixed} [taskId] The task id indicating which assignments to load.
     * If this parameter is not specified then it will use current {@link #property-taskId} value (identifier provided to this function before (if any)
     * or initially specified by {@link #cfg-taskId} config).
     * **Note**, that if the task doesn't have an identifier yet (a 'phantom' record), you can use the task phantomId instead.
     *
     * @return {Boolean} False if {@link #assignmentStore} doesn't yet exist or if no task identifier has been provided.
     * Otherwise returns `true`.
     */
    loadTaskAssignments: function(taskId) {
        taskId = taskId || this.taskId;
        if (!taskId)  {
            return false;
        }
        
        var taskStore = this.taskStore || this.assignmentStore.getTaskStore(),
            task = taskStore && taskStore.getModelById(taskId),
            taskAssignments;
        if (task) {
            taskAssignments = task.getAssignments();
        } else {
            if (!this.assignmentStore)  {
                return false;
            }
            
            // grab assignments for this task only
            taskAssignments = this.assignmentStore.queryBy(function(a) {
                return a.getTaskId() == taskId;
            });
        }
        this.taskId = taskId;
        var store = this.store,
            resStore = this.resourceDupStore,
            // clone assignments to not affect real records
            data = Gnt.util.Data.cloneModelSet(taskAssignments, function(copiedAssignment, srcAssignment) {
                // get original resource Id
                var resId = srcAssignment.getResourceId();
                // get cloned version of that resource
                var clonedRes = resStore.queryBy(function(resource) {
                        var r = resource.originalRecord;
                        return (r.getId() || r.internalId) == resId;
                    });
                if (clonedRes.getCount()) {
                    clonedRes = clonedRes.first();
                    // and bind cloned resource to copy of assignment instead of real resource
                    copiedAssignment.setResourceId(clonedRes.getId() || clonedRes.internalId);
                }
            });
        // load data to the store
        store.loadData(data);
        if (task && this.rendered) {
            this.setEditableFields(task);
        }
        return true;
    },
    /**
     * Adds a new assignment record and starts the editor.
     *
     * @param {Gnt.model.Assignment/Object} [newAssignment] The new assignment to be added.
     * If this parameter is not provided, a new record will be created using the TaskId of the current task,
     * empty ResourceId field and Units field set to {@link #defaultAssignedUnits} amount.
     * @param {Boolean} [doNotActivateEditor=False] `true` to just insert record without activating editor after insertion.
     *
     * @return {Gnt.model.Assignment[]} The records that were added.
     */
    insertAssignment: function(newAssignment, doNotActivateEditor) {
        if (!newAssignment || !newAssignment.isModel) {
            newAssignment = new this.store.model(newAssignment);
            if (!newAssignment) {
                newAssignment.setUnits(this.defaultAssignedUnits);
            }
        }
        // Fix for Ext.Editor bug when it tries to retrieve a value from the cell
        // when the corresponding field initial value is 'undefined'
        // ..problem is the cell might also contain invalid text tooltip
        if (newAssignment.getResourceId() === undefined) {
            newAssignment.setResourceId(null);
        }
        newAssignment.setTaskId(this.taskId);
        this.store.insert(0, newAssignment);
        var me = this,
            oldValidator = newAssignment.isValid;
        newAssignment.isValid = function() {
            return oldValidator.apply(this, arguments) && me.isValidAssignment(this);
        };
        // there might be no cellEditing if the grid is in readOnly mode
        if (!doNotActivateEditor && this.cellEditing) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 0
            });
        }
        return newAssignment;
    },
    /**
     * Checks if the data in the grid store is valid.
     * @return {Boolean}
     */
    isValid: function() {
        var result = true;
        this.store.each(function(record) {
            if (!record.isValid()) {
                result = false;
                return false;
            }
        });
        return result;
    },
    /**
     * Returns an array of task assignment error messages.
     * @return {String[]} Array of error messages.
     */
    getAssignmentErrors: function(assignment) {
        var resourceId = assignment.getResourceId();
        if (!resourceId)  {
            return [
                this.L('noValueText')
            ];
        }
        
        if (!this.resourceDupStore.getModelById(resourceId)) {
            return [
                Ext.String.format(this.L('noResourceText'), resourceId)
            ];
        }
    },
    isValidAssignment: function(assignment) {
        return !this.getAssignmentErrors(assignment);
    },
    // @private
    buildPlugins: function() {
        var cellEditing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
                clicksToEdit: 1
            });
        var oldStartEdit = cellEditing.startEdit;
        cellEditing.startEdit = function() {
            this.completeEdit();
            return oldStartEdit.apply(this, arguments);
        };
        cellEditing.on({
            beforeedit: this.onEditingStart,
            scope: this
        });
        return [
            cellEditing
        ];
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        return this.callParent(arguments);
    },
    onEditingStart: function(ed, e) {
        var model = this.store.model.prototype;
        if (e.field == model.resourceIdField) {
            this.assignment = e.record;
            // keep resourceId of record being edited
            this.resourceId = e.record.getResourceId();
            this.resourceComboStore.loadData(this.resourceDupStore.getRange());
            // and re-apply filter to refresh dataset
            this.resourceComboStore.filter(this.resourcesFilter);
        }
    },
    resourceRender: function(value, meta, assignment) {
        var errors = this.getAssignmentErrors(assignment);
        if (errors && errors.length) {
            meta.tdCls = Ext.baseCSSPrefix + 'form-invalid';
            meta.tdAttr = 'data-errorqtip="' + errors.join('<br>') + '"';
        } else {
            meta.tdCls = '';
            meta.tdAttr = 'data-errorqtip=""';
        }
        var record = this.resourceDupStore.getModelById(value);
        return Ext.String.htmlEncode((record && record.getName()) || value);
    },
    // filters resources store to exclude resources that already assigned to the task.
    filterResources: function(resource) {
        var resourceId = resource.getId(),
            resourceField = this.store.model.prototype.resourceIdField,
            show = true;
        // record that is being edited should always be presented in combobox dataset
        if (resourceId !== this.resourceId) {
            // filter out already assigned resources
            this.store.each(function(assignment) {
                if (resourceId == assignment.get(resourceField)) {
                    show = false;
                    return false;
                }
            });
        }
        return show;
    },
    onResourceComboAssert: function(combo) {
        var rawValue = combo.getRawValue();
        if (rawValue) {
            var idx = this.resourceDupStore.findExact(combo.displayField, rawValue);
            var record = idx !== -1 ? this.resourceDupStore.getAt(idx) : false;
            // if no matching record in store
            if (!record) {
                var assignment = this.assignment;
                var me = this;
                // callback to proceed with resource creation
                var addResource = function(deferred) {
                        var model = me.resourceStore.model,
                            newResource = {};
                        // let`s add a new record with such name
                        newResource[model.prototype.nameField] = rawValue;
                        newResource = new model(newResource);
                        // set resource Id equal to internalId
                        // we need filled Id to combobox proper working
                        newResource.setId(newResource.internalId);
                        // push to store
                        var added = me.resourceDupStore.add(newResource);
                        if (added && added.length) {
                            if (!deferred) {
                                combo.getStore().add(newResource);
                                // and set combobox value
                                combo.setValue(added[0].getId());
                            } else {
                                assignment.setResourceId(added[0].getId());
                            }
                        }
                    };
                // if confirmation required
                if (this.confirmAddResource) {
                    var text = Ext.String.format(this.L('confirmAddResourceText'), Ext.String.htmlEncode(rawValue));
                    var messageBox = Ext.Msg.confirm(this.L('confirmAddResourceTitle'), text, function(buttonId) {
                            if (buttonId == 'yes') {
                                addResource(true);
                            }
                        });
                    // TODO: get rid of this HACK after sencha fixes https://www.sencha.com/forum/showthread.php?308705-Wrong-MessageBox-z-index&p=1127575
                    setTimeout(function() {
                        messageBox.toFront();
                    }, 1);
                } else {
                    addResource();
                }
            } else {
                combo.select(record, true);
            }
        }
    },
    buildColumns: function() {
        var me = this;
        // task name column editor
        this.resourceCombo = new Ext.form.field.ComboBox({
            queryMode: 'local',
            store: this.resourceComboStore,
            allowBlank: false,
            editing: this.addResources,
            validateOnChange: false,
            autoSelect: false,
            forceSelection: !this.addResources,
            valueField: this.resourceComboStore.model.prototype.idProperty,
            displayField: this.resourceComboStore.model.prototype.nameField,
            queryCaching: false,
            listConfig: {
                // HTML encode combobox items
                getInnerTpl: function() {
                    return '{' + this.displayField + ':htmlEncode}';
                }
            }
        });
        this.resourcesFilter = Ext.create('Ext.util.Filter', {
            filterFn: this.filterResources,
            scope: this
        });
        if (this.addResources) {
            // add new resource record to combo store before assertValue call
            Ext.Function.interceptBefore(this.resourceCombo, 'assertValue', function() {
                me.onResourceComboAssert(this);
            });
        }
        return [
            {
                xtype: 'resourcenamecolumn',
                editor: this.resourceCombo,
                dataIndex: this.assignmentStore.model.prototype.resourceIdField,
                renderer: this.resourceRender,
                scope: this
            },
            {
                xtype: 'assignmentunitscolumn',
                assignmentStore: this.assignmentStore,
                dataIndex: this.assignmentStore.model.prototype.unitsField
            }
        ];
    },
    saveResources: function() {
        Gnt.util.Data.applyCloneChanges(this.resourceDupStore, this.resourceStore);
    },
    /**
     * Persists task assignments to {@link #assignmentStore}.
     * @return {Boolean} `false` if saving error occures. Otherwise returns `true`.
     */
    saveTaskAssignments: function() {
        // suspend the grid reacting on resource and assignment store changes
        // during applying changes to these stores
        this.suspendRefreshAssignments();
        this.suspendRefreshResources();
        // first we have to save resources in case of *new* resource assignment
        this.saveResources();
        var model = this.store.model,
            comboStore = this.resourceDupStore,
            result = true;
        Gnt.util.Data.applyCloneChanges(this.store, this.assignmentStore, function(data) {
            // get assigned resource
            var resource = comboStore.getById(this.getResourceId());
            // and its original record
            if (!resource || !resource.originalRecord) {
                // normally it should`t occur this way since we had to save resources at first
                result = false;
                return;
            }
            var r = resource.originalRecord;
            // now let's use real resource ID for saving
            data[model.prototype.resourceIdField] = r.getId() || r.internalId;
        });
        this.resumeRefreshAssignments();
        this.resumeRefreshResources();
        return result;
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    isDataValid: function() {
        var result = true;
        this.store.each(function(record) {
            if (!record.isValid()) {
                result = false;
                return false;
            }
        });
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.widget.DependencyGrid
 @extends Ext.grid.Panel

 A widget used to display and edit the dependencies of a task.
 This widget is used as the `Predecessors` tab of the {@link Gnt.widget.taskeditor.TaskEditor}.
 There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#dependencyGridConfig dependencyGridConfig} object
 available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} classes.

 {@img gantt/images/dependency-grid.png}

 You can create an instance of the grid like this:

 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo : Ext.getBody()
        });

 To load data into the grid you can use the {@link #loadDependencies} method:

 // create grid
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo : Ext.getBody()
        });

 // load data
 dependencyGrid.loadDependencies(someTask);

 * **Note:** If you plan to use this grid for tasks that don't belong to any taskStore you should specify a {@link #dependencyStore}:

 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo        : Ext.getBody(),
            dependencyStore : dependencyStore
        });

 Let's make our example more interesting by adding toolbar with buttons for editing:

 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo        : Ext.getBody(),
            dependencyStore : dependencyStore,

            // toolbar with buttons
            tbar            : {
                items   : [
                    {
                        xtype       : 'button',
                        iconCls     : 'gnt-action-add',
                        text        : 'Add',
                        handler     : function() {
                            dependencyGrid.insertDependency();
                        }
                    },
                    {
                        xtype       : 'button',
                        iconCls     : 'gnt-action-remove',
                        text        : 'Remove',
                        handler     : function() {
                            var recs = dependencyGrid.getSelectionModel().getSelection();
                            if (recs && recs.length) {
                                dependencyGrid.store.remove(recs);
                            }
                        }
                    }
                ]
            }
        });

 #Set grid direction

 By default this grid displays predecessors of a task. To display successors instead, set the {@link #cfg-direction} config to 'successors'.
 Example:

 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            // set grid to display successors
            direction : 'successors'
        });

 #Embedded checks

 This class contains embedded transitivity and cycle detection algorithms. It runs them every time a new dependency is being added.
 * **For example**: There is `Task A`->`Task B` and `Task B`->`Task C` dependencies.
 In this case dependency `Task A`->`Task C` will be **transitive** and therefore will be considered invalid.
 And dependency `Task C`->`Task A` (or `Task B`->`Task A`) will form a **cycle** and will also be considered invalid.

 */
Ext.define('Gnt.widget.DependencyGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.dependencygrid',
    requires: [
        'Ext.data.JsonStore',
        'Ext.grid.plugin.CellEditing',
        'Ext.form.field.ComboBox',
        'Ext.util.Filter',
        'Gnt.model.Dependency',
        'Gnt.util.Data',
        'Gnt.field.Duration'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly: false,
    /**
     * @cfg {Boolean} showCls Whether to show the column for `Cls` field of the dependencies.
     */
    showCls: false,
    cls: 'gnt-dependencygrid',
    /**
     * @property {Gnt.model.Task} task A task dependencies of which are displayed.
     * @readonly
     */
    task: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A store with dependencies.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.model.Task} taskModel A task model class.
     * **Note:** This setting might be required when the grid shows dependencies of a task which subclasses {@link Gnt.model.Task}
     * and does not belong to any task store (and task store is not specified in dependency store as well).
     */
    taskModel: null,
    /**
     * @property {String} direction The type of dependencies that are displayed in the grid. Either 'predecessors' or 'successors'.
     * @readonly
     * **Note:** You should use this property for *reading only*.
     */
    /**
     * @cfg {String} direction Defines what kind of dependencies will be displayed in a grid. Either 'predecessors' or 'successors'.
     */
    direction: 'predecessors',
    oppositeStore: null,
    taskStoreListeners: null,
    refreshTimeout: 100,
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `true` to include parent tasks in the list of possible predecessors/successors.
     * @removed The panel now takes {@link Gnt.data.DependencyStore#allowParentTaskDependencies} setting into account.
     */
    allowParentTaskDependencies: false,
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false` then "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    /**
     * @cfg {Object} l10n
     * A object, purposed for class localization. Contains the following keys/values:

     - idText                      : 'ID',
     - taskText                    : 'Task Name',
     - blankTaskText               : 'Please select task',
     - invalidDependencyText       : 'Invalid dependency',
     - parentChildDependencyText   : 'Dependency between child and parent found',
     - duplicatingDependencyText   : 'Duplicating dependency found',
     - transitiveDependencyText    : 'Transitive dependency',
     - cyclicDependencyText        : 'Cyclic dependency',
     - typeText                    : 'Type',
     - lagText                     : 'Lag',
     - clsText                     : 'CSS class',
     - endToStartText              : 'Finish-To-Start',
     - startToStartText            : 'Start-To-Start',
     - endToEndText                : 'Finish-To-Finish',
     - startToEndText              : 'Start-To-Finish'
     */
    /**
     * @property {Gnt.field.Duration} lagEditor Editor instance used for the `Lag` column editing.
     */
    lagEditor: null,
    /**
     * @property {Ext.form.field.ComboBox} typesCombo Editor instance used for the `Type` column editing.
     */
    typesCombo: null,
    constructor: function(config) {
        config = config || {};
        // map locales from legacy configs
        Ext.Array.each([
            'idText',
            'taskText',
            'blankTaskText',
            'invalidDependencyText',
            'parentChildDependencyText',
            'duplicatingDependencyText',
            'transitiveDependencyText',
            'cyclicDependencyText',
            'typeText',
            'lagText',
            'clsText',
            'endToStartText',
            'startToStartText',
            'endToEndText',
            'startToEndText'
        ], function(prop) {
            if (prop in config)  {
                this[prop] = config[prop];
            }
            
        }, this);
        this.store = config.store || new Ext.data.JsonStore({
            autoDestroy: true,
            model: config.dependencyStore ? config.dependencyStore.model : 'Gnt.model.Dependency'
        });
        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }
        this.direction = config.direction || this.direction;
        // tweak to fill taskModel automatically if not provided
        if (!config.taskModel) {
            config.taskModel = Ext.ClassManager.get('Gnt.model.Task');
            if (config.dependencyStore) {
                var taskStore = config.dependencyStore.getTaskStore();
                if (taskStore)  {
                    config.taskModel = taskStore.model;
                }
                
            }
        }
        if (config.oppositeStore) {
            this.setOppositeStore(config.oppositeStore);
        }
        this.callParent([
            config
        ]);
    },
    initComponent: function() {
        if (this.task) {
            this.setTask(this.task);
            this.loadDependencies(this.task);
        }
        if (!this.title) {
            this.title = this.direction === 'predecessors' ? this.L('predecessorsText') : this.L('successorsText');
        }
        this.columns = this.buildColumns();
        this.callParent(arguments);
    },
    destroy: function() {
        if (this.deferredStoreBind) {
            this.tasksCombo.un('render', this.bindTaskStore, this);
        }
        this.tasksCombo.destroy();
        this.typesCombo.destroy();
        this.lagEditor.destroy();
        this.callParent(arguments);
        this.cellEditing.destroy();
    },
    setTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.task = task;
        var dependencyStore = task.dependencyStore || task.getTaskStore().dependencyStore;
        if (dependencyStore && dependencyStore !== this.dependencyStore) {
            if (this.dependencyStore) {
                this.mun(this.dependencyStore, this.onDependencyStoreDataChanged, this);
            }
            this.dependencyStore = dependencyStore;
            if (this.typesCombo) {
                this.typesCombo.store.filter(this.typesFilter);
            }
            this.mon(this.dependencyStore, this.onDependencyStoreDataChanged, this);
        }
        this.setReadOnly(task.isReadOnly());
    },
    /**
     * Disable the cellediting plugin
     * @param readOnly
     */
    setReadOnly: function(readOnly) {
        if (this.cellEditing) {
            if (readOnly) {
                this.cellEditing.disable();
            } else {
                this.cellEditing.enable();
            }
        }
    },
    onDependencyStoreDataChanged: function() {
        this.loadDependencies();
    },
    buildPlugins: function() {
        var cellEditing = this.cellEditing = new Ext.grid.plugin.CellEditing({
                clicksToEdit: 1
            });
        cellEditing.on({
            beforeedit: this.onEditingStart,
            edit: this.onEditingDone,
            scope: this
        });
        return [
            cellEditing
        ];
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments);
    },
    onEditingStart: function(ed, e) {
        var model = this.store.model.prototype;
        switch (e.field) {
            case model.lagField:
                this.lagEditor.durationUnit = e.record.getLagUnit();
                break;
            case model.typeField:
                this.typesCombo.store.filter(this.typesFilter);
                // if set of dependency types is restricted and allowed number of types is less than 2
                // we won't show dropdown list
                if (this.typesCombo.store.count() < 2)  {
                    return false;
                }
                ;
                break;
            case model.fromField:
                if (this.direction == 'predecessors') {
                    this.activeDependency = e.record;
                    this.refilterTasksCombo();
                };
                break;
            case model.toField:
                if (this.direction != 'predecessors') {
                    this.activeDependency = e.record;
                    this.refilterTasksCombo();
                };
                break;
        }
    },
    onEditingDone: function(ed, e) {
        var model = this.store.model.prototype;
        if (e.field == model.lagField) {
            e.record.setLagUnit(this.lagEditor.durationUnit);
        }
        // after editing we refresh view since some records could become invalid
        this.getView().refreshView();
    },
    // dependency type column renderer
    dependencyTypeRender: function(value) {
        var type = this.store.model.Type;
        switch (value) {
            case type.EndToStart:
                return this.L('endToStartText');
            case type.StartToStart:
                return this.L('startToStartText');
            case type.EndToEnd:
                return this.L('endToEndText');
            case type.StartToEnd:
                return this.L('startToEndText');
        }
        return value;
    },
    // Returns list of dependency errors, used at task column renderer
    taskValidate: function(value, depRec) {
        if (!value) {
            return [
                this.L('blankTaskText')
            ];
        }
        if (!depRec.isValid()) {
            var errors = this.getDependencyErrors(depRec);
            if (errors && errors.length) {
                return errors;
            }
            return [
                this.L('invalidDependencyText')
            ];
        }
    },
    // Task name column renderer
    taskRender: function(value, meta, depRec) {
        var errors = this.taskValidate(value, depRec),
            record;
        if (errors && errors.length) {
            meta.tdCls = Ext.baseCSSPrefix + 'form-invalid';
            meta.tdAttr = 'data-errorqtip="' + errors.join('<br>') + '"';
        } else {
            meta.tdCls = '';
            meta.tdAttr = 'data-errorqtip=""';
        }
        var taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (taskStore) {
            record = taskStore.getModelById(value);
            return (record && Ext.String.htmlEncode(record.getName())) || '';
        }
        return '';
    },
    filterTasks: function(record) {
        var taskId = record.getId(),
            preserveTaskId, fromId, toId;
        if (this.direction === 'predecessors') {
            fromId = taskId;
            toId = this.task.getId();
            preserveTaskId = this.activeDependency && this.activeDependency.getSourceId();
        } else {
            toId = taskId;
            fromId = this.task.getId();
            preserveTaskId = this.activeDependency && this.activeDependency.getTargetId();
        }
        // 1) we don't filter out the task used in the dependency being edited (it's kept in this.activeDependency)
        // 2) other than that we simply filter out all the tasks that build invalid dependencies
        return !this.activeDependency || taskId == preserveTaskId || this.isValidDependency(fromId, toId);
    },
    refilterTasksCombo: function() {
        this.tasksCombo.getStore().addFilter(this.tasksFilter);
    },
    bindTaskStore: function() {
        var taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (taskStore) {
            if (!this.taskStoreListeners) {
                // merge multiple refreshes to single one
                var refreshTasks = Ext.Function.createBuffered(this.bindTaskStore, this.refreshTimeout, this, []);
                this.taskStoreListeners = this.mon(taskStore, {
                    nodeappend: refreshTasks,
                    nodeinsert: refreshTasks,
                    noderemove: refreshTasks,
                    update: refreshTasks,
                    refresh: refreshTasks,
                    clear: refreshTasks,
                    'nodestore-datachange-end': refreshTasks,
                    scope: this,
                    destroyable: true
                });
            }
            // make new store for the tasks dropdown list
            var store = new Ext.data.JsonStore({
                    autoDestroy: true,
                    model: taskStore.model,
                    sorters: taskStore.model.prototype.nameField
                });
            var root = taskStore.getRoot();
            // load tasks from tasks store
            store.loadData(Gnt.util.Data.cloneModelSet(taskStore.toArray(), function(rec, src) {
                if (src === root || src.hidden || src.isReadOnly())  {
                    return false;
                }
                
                // set phantomId as Id for records without Id
                // we need it since combo's valueField is 'Id'
                if (!src.getId()) {
                    rec.setId(src.getId());
                }
            }));
            this.tasksFilter = new Ext.util.Filter({
                id: 'dependencygrid-tasksfilter',
                filterFn: this.filterTasks,
                scope: this
            });
            // and apply filter to it
            store.filter(this.tasksFilter);
            this.tasksCombo.bindStore(store);
        }
    },
    buildTasksCombo: function() {
        var me = this;
        return new Ext.form.field.ComboBox({
            queryMode: 'local',
            allowBlank: false,
            editing: false,
            forceSelection: true,
            valueField: this.taskModel.prototype.idProperty,
            displayField: this.taskModel.prototype.nameField,
            queryCaching: false,
            listConfig: {
                // HTML encode combobox items
                getInnerTpl: function() {
                    return '{' + this.displayField + ':htmlEncode}';
                }
            },
            validator: function(value) {
                if (!value) {
                    return me.L('blankTaskText');
                }
                return true;
            }
        });
    },
    filterAllowedTypes: function(record) {
        if (!this.dependencyStore || !this.dependencyStore.allowedDependencyTypes)  {
            return true;
        }
        
        var allowed = this.dependencyStore.allowedDependencyTypes;
        var depType = this.store.model.Type;
        for (var i = 0,
            l = allowed.length; i < l; i++) {
            var type = depType[allowed[i]];
            if (record.getId() == type)  {
                return true;
            }
            
        }
        return false;
    },
    buildTypesCombo: function() {
        var depType = this.store.model.Type;
        // https://www.sencha.com/forum/showthread.php?300987-How-re-filter-chained-store.&viewfull=1#post1103214
        // assign id to filter fn to use filter(this.typesFilter)
        this.typesFilter = new Ext.util.Filter({
            id: 'typesfilter',
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var store = new Ext.data.ArrayStore({
                fields: [
                    {
                        name: 'id',
                        type: 'int'
                    },
                    'text'
                ],
                data: [
                    [
                        depType.EndToStart,
                        this.L('endToStartText')
                    ],
                    [
                        depType.StartToStart,
                        this.L('startToStartText')
                    ],
                    [
                        depType.EndToEnd,
                        this.L('endToEndText')
                    ],
                    [
                        depType.StartToEnd,
                        this.L('startToEndText')
                    ]
                ]
            });
        // and apply filter to it
        store.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            triggerAction: 'all',
            queryMode: 'local',
            editable: false,
            valueField: 'id',
            displayField: 'text',
            store: store
        });
    },
    buildLagEditor: function() {
        return new Gnt.field.Duration({
            minValue: Number.NEGATIVE_INFINITY
        });
    },
    buildColumns: function() {
        var me = this,
            model = this.store.model.prototype,
            cols = [],
            taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
        // task name column editor
        this.tasksCombo = this.buildTasksCombo();
        // if no taskStore yet let`s defer its binding
        if (!taskStore) {
            this.deferredStoreBind = true;
            this.tasksCombo.on('render', this.bindTaskStore, this);
        } else // let`s build & bind combobox store
        {
            this.bindTaskStore();
        }
        var idColumn = {};
        var fromOrToField = model[this.direction === 'predecessors' ? "fromField" : "toField"];
        if (this.useSequenceNumber) {
            idColumn = {
                text: this.L('snText'),
                dataIndex: fromOrToField,
                renderer: function(value, meta, record) {
                    var store = me.dependencyStore && me.dependencyStore.getTaskStore(),
                        node = store && store.getModelById(record.get('From'));
                    return node ? node.getSequenceNumber() : '';
                },
                width: 50
            };
        } else {
            idColumn = {
                text: this.L('idText'),
                dataIndex: fromOrToField,
                width: 50
            };
        }
        cols.push(idColumn, {
            text: this.L('taskText'),
            dataIndex: fromOrToField,
            flex: 1,
            editor: this.tasksCombo,
            renderer: function(value, meta, depRec) {
                return me.taskRender(value, meta, depRec);
            }
        });
        this.lagEditor = this.buildLagEditor();
        this.typesCombo = this.buildTypesCombo();
        cols.push({
            text: this.L('typeText'),
            dataIndex: model.typeField,
            width: 120,
            renderer: this.dependencyTypeRender,
            scope: this,
            editor: this.typesCombo
        }, {
            text: this.L('lagText'),
            dataIndex: model.lagField,
            width: 100,
            editor: this.lagEditor,
            renderer: function(value, meta, record) {
                return me.lagEditor.valueToVisible(value, record.get(model.lagUnitField), 2);
            }
        }, {
            text: this.L('clsText'),
            dataIndex: model.clsField,
            hidden: !this.showCls,
            width: 100
        });
        return cols;
    },
    /**
     * Creates new record and starts process of its editing.
     * @param {Gnt.model.Dependency/Object} [newRecord] New dependency to be added.
     * @param {Boolean} [doNotActivateEditor=false] `true` to just insert record without starting the editing after insertion.
     * @return {Gnt.model.Dependency[]} The records that were added.
     */
    insertDependency: function(newRecord, doNotActivateEditor) {
        if (!this.dependencyStore)  {
            return;
        }
        
        var taskId = this.task.getId(),
            model = this.store.model.prototype,
            newRec = {},
            me = this;
        if (newRecord) {
            newRec = newRecord;
        } else {
            newRec[model.typeField] = this.typesCombo.store.getAt(0).getId();
            newRec[model.lagField] = 0;
            newRec[model.lagUnitField] = 'd';
        }
        if (this.direction === 'predecessors') {
            newRec[model.toField] = taskId;
        } else {
            newRec[model.fromField] = taskId;
        }
        var added = this.store.insert(0, newRec);
        if (added.length) {
            // bind our dependency validator to not bother original dependency store
            var oldValidator = added[0].isValid;
            added[0].isValid = function() {
                return oldValidator.call(this, false) && me.isValidDependency(this);
            };
        }
        if (!doNotActivateEditor) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 1
            });
        }
        return added;
    },
    onOppositeStoreChange: function() {
        this.getView().refreshView();
    },
    setOppositeStore: function(store) {
        // this can be made public after resolving the problem with transitivity detection
        //
        // Sets store with opposite to the grid dependencies direction.
        // This can be used for example to implement two grids one with predecessors and another one with successors of the task.
        // Grids will work in conjunction and validation of one grid will instantly react on changes made in another one.
        // @param {Ext.data.Store} store Store with dependencies.
        // @example
        //      var predecessorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'predecessors',
        //          dependencyStore : dependencyStore,
        //          task            : task
        //      });
        //
        //      var successorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'successors',
        //          dependencyStore : dependencyStore,
        //          // set predecessors grid store as opposite to successors
        //          oppositeStore   : predecessorsGrid.store,
        //          task            : task
        //      });
        //
        //      // set successors grid store as opposite to predecessors
        //      predecessorsGrid.setOppositeStore(successorsGrid.store);
        //
        var listeners = {
                update: this.onOppositeStoreChange,
                datachanged: this.onOppositeStoreChange,
                scope: this
            };
        if (this.oppositeStore) {
            this.mun(this.oppositeStore, listeners);
        }
        this.oppositeStore = store;
        // on opposite store changes we will refresh grid view
        // since it can affect rows validity
        this.mon(this.oppositeStore, listeners);
    },
    /**
     * Loads task dependencies to grid store.
     * @param {Gnt.model.Task} task Task dependencies of which should be loaded.
     */
    loadDependencies: function(task) {
        var me = this;
        task = task || this.task;
        if (!task)  {
            return;
        }
        
        if (this.task !== task) {
            this.setTask(task);
        }
        var data;
        if (this.direction === 'predecessors') {
            data = task.getIncomingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = task.getOutgoingDependencies(true);
            }
        } else {
            data = task.getOutgoingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = task.getIncomingDependencies(true);
            }
        }
        // let`s clone it to not affect real data
        // we save changes only by saveDependencies() call
        var result = Gnt.util.Data.cloneModelSet(data, function(rec) {
                // validate record by our own validator
                var oldValidator = rec.isValid;
                rec.isValid = function() {
                    return oldValidator.call(this, false) && me.isValidDependency(this);
                };
            });
        this.store.loadData(result);
        this.fireEvent('loaddependencies', this, this.store, result, task);
    },
    /*
     * Gets an array of error messages for provided dependency.
     */
    getDependencyErrors: function(fromId, toId) {
        var me = this,
            depStore = me.dependencyStore,
            errors = [],
            dependency, type;
        if (fromId instanceof Gnt.model.Dependency) {
            dependency = fromId;
            fromId = me.task.getId();
            toId = fromId;
            type = dependency.getType();
            if (me.direction === 'predecessors') {
                fromId = dependency.getSourceId();
            } else {
                toId = dependency.getTargetId();
            }
        }
        if (dependency) {
            me.store.each(function(dep) {
                // check duplicating records
                if ((fromId == dep.getSourceId()) && (toId == dep.getTargetId()) && (dep !== dependency)) {
                    errors.push(me.L('duplicatingDependencyText'));
                    return false;
                }
            });
            if (errors.length)  {
                return errors;
            }
            
        }
        // let's ask dependency store to validate the dependency
        // we have to provide list of records that we're gonna add to the dependency store
        var toAdd = me.store.getRange();
        // ..minus dependency that we're validating (if we validating dependency instance)
        dependency && toAdd.splice(Ext.Array.indexOf(toAdd, dependency), 1);
        // and list of existing ..old dependencies ..that we plan to remove/replace
        var oldDependencies = me.task[me.direction];
        // run validation
        var error = depStore.getDependencyError(fromId, toId, type, toAdd, oldDependencies);
        if (error) {
            switch (error) {
                case -3:
                case -8:
                case -5:
                case -6:
                    return [
                        me.L('transitiveDependencyText')
                    ];
                case -4:
                case -7:
                    return [
                        me.L('cyclicDependencyText')
                    ];
                case -9:
                    return [
                        me.L('parentChildDependencyText')
                    ];
            }
            return [
                this.L('invalidDependencyText')
            ];
        }
        return errors;
    },
    /*
     * Checks if the dependency is valid.
     */
    isValidDependency: function() {
        return !this.getDependencyErrors.apply(this, arguments).length;
    },
    /*
     * Checks if the grid is valid.
     */
    isValid: function() {
        var result = true;
        this.store.each(function(record) {
            if (!record.isValid()) {
                result = false;
                return false;
            }
        });
        return result;
    },
    /**
     * Applies all changes that have been made to grid data to dependency store.
     */
    saveDependencies: function() {
        if (!this.dependencyStore || !this.isValid())  {
            return;
        }
        
        // push changes from grid store to real dependencyStore
        Gnt.util.Data.applyCloneChanges(this.store, this.dependencyStore);
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    isDataValid: function() {
        return this.isValid();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Gnt.widget.taskeditor.TaskEditor
@extends Gnt.widget.taskeditor.BaseEditor

A widget used to display and edit task information.
By default the widget is an Ext.tab.Panel instance which can contain the following tabs:

 - General information
 - Predecessors
 - Resources
 - Advanced
 - Notes

You can easily add new custom tabs using {@link #items} config.

# General

{@img gantt/images/taskeditor-panel-general.png}

Contains a customizable {@link Gnt.widget.TaskForm form} instance for viewing and editing the following task data:

 - the name of the task
 - the start date of the task
 - the end date of the task
 - the task duration
 - the task effort
 - the current status of a task, expressed as the percentage completed
 - the baseline start date of the task (editing of this field is optional)
 - the baseline end date of the task (editing of this field is optional)
 - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)

### Task form customization

There is a {@link #taskFormConfig} config which can be used to customize the form panel.

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // Configure the form located in the "General" tab
            taskFormConfig : {
                // turn off fields highlighting
                highlightTaskUpdates : false,
                // alter panel margin
                margin : 20
            }
        });

### Fields configuration

The {@link Gnt.widget.TaskForm} class has a config for each field presented at the `General` tab.
And using {@link #taskFormConfig} we can get access for those options to setup fields.
For example:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // setup form located at "General" tab
            taskFormConfig : {
                // set Baseline Finish Date field invisible
                baselineFinishConfig : {
                    hidden : true
                }
            }
        });

Here are some more configs for other fields:

 - {@link Gnt.widget.TaskForm#taskNameConfig taskNameConfig} (the name of the task field)
 - {@link Gnt.widget.TaskForm#startConfig startConfig} (the start date of the task field)
 - {@link Gnt.widget.TaskForm#finishConfig finishConfig} (the end date of the task field)
 - {@link Gnt.widget.TaskForm#durationConfig durationConfig} (the task duration field)

Please see {@link Gnt.widget.TaskForm} class to see the full list of available config options.

### Extending the General field set

If you want to add a new field to the `General` tab you will have to extend the {@link Gnt.widget.TaskForm TaskForm} class.
After that you will need to configure the task editor to use your extended class:

        // extend standard TaskForm class
        Ext.define('MyTaskForm', {
            extend : 'Gnt.widget.taskeditor.TaskForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // Let task editor know which class to use
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // to use MyTaskForm to build the "General" tab
            taskFormClass : 'MyTaskForm'
        });

#Predecessors

Contains a {@link Gnt.widget.DependencyGrid grid} instance displaying the predecessors for the task.
You can add, edit or remove dependencies of the task using this panel.

{@img gantt/images/taskeditor-panel-predecessors.png}

You can enable/disable this tab by setting the {@link #showDependencyGrid} option.
To rename this tab you can use `dependencyText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #dependencyGridConfig} config.
To change make this tab display successors instead of predecessors - use the following code:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            l10n : {
                // here we change tab title
                dependencyText : 'Successors'
            },
            // here is the grid config
            dependencyGridConfig : {
                // set grid to display successors
                direction : 'successors'
            }
        });

### Customizing the dependency grid class

You can also configure the task editor to use a custom class to build this tab using the {@link #dependencyGridClass} option.
If you need to add an extra column to the grid, you can do it like this:

        // extend standard DependencyGrid
        Ext.define('MyDependencyGrid', {
            extend: 'Gnt.widget.DependencyGrid',

            // extend buildColumns method to append extra column
            buildColumns : function () {
                // add custom column as last one
                return this.callParent(arguments).concat({
                    header    : 'Foo',
                    dataIndex : 'foo',
                    width     : 100
                });
            }
        });

        // setup task editor
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // to use extended class to build tab
            dependencyGridClass : 'MyDependencyGrid'
        });

#Resources

Contains a {@link Gnt.widget.AssignmentEditGrid grid} instance displaying the task assignments.
It allows you to add, edit or remove task assignments.

{@img gantt/images/taskeditor-panel-resources2.png}

It also supports inline resource adding (for more details, take a look at the {@link Gnt.widget.AssignmentEditGrid#addResources} config.

{@img gantt/images/taskeditor-panel-resources1.png}

You can enable/disable this tab by setting the {@link #showAssignmentGrid} option.
To rename this tab you can use the `resourcesText` property of {@link #l10n} config.
Customizing the grid can be done via the {@link #assignmentGridConfig} config.

Example:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            assignmentStore : assignmentStore,
            resourceStore : resourceStore,
            l10n : {
                // rename tab
                resourcesText : 'Assignments'
            },
            // here is grid the config
            assignmentGridConfig : {
                // disable in-place resources adding
                addResources : false
            }
        });

### Customizing the assignment grid class

You can use a custom grid class for this tab by using the {@link #assignmentGridClass} option.
Example: if you need to add extra column to the grid you can do it like this:

        // Extend the standard AssignmentGrid
        Ext.define('MyAssignmentGrid', {
            extend: 'Gnt.widget.AssignmentEditGrid',

            // extend buildColumns method to append extra column
            buildColumns : function () {
                // add custom column as last one
                return this.callParent(arguments).concat({
                    header       : 'Foo',
                    dataIndex    : 'foo',
                    width        : 100
                });
            }
        });

        // setup task editor
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // use extended class
            assignmentGridClass : 'MyAssignmentGrid'
        });

#Advanced

Contains a {@link Gnt.widget.AdvancedForm form} instance which can be customized, allowing the user to view and edit the following task data:

 - calendar assigned to the task
 - scheduling mode for the task
 - manually scheduled flag
 - WBS code
 - rollup flag
 - constraint type
 - constraint date
 - read only flag

{@img gantt/images/taskeditor-panel-advanced.png}

You can enable/disable this tab by setting the {@link #showAdvancedForm} option.
To rename this tab you can use the `advancedText` property of {@link #l10n} config.

Customizing the form itself can be done via the {@link #advancedFormConfig} config. For example this is how form content can be overwritten:

        Ext.create("Gnt.widget.taskeditor.TaskEditor", {
            advancedFormConfig: {
                items: [
                     // new fields that will go here
                     // will replace standard presented in the "Advanced" tab
                     ...
                ]
            }
        });

### Customizing the form class

You can use your own custom class to build this tab by using the {@link #advancedFormClass} config:
For example if you need to add some extra field you can do it like this:

        // Extend standard TaskForm class
        Ext.define('MyAdvancedForm', {
            extend : 'Gnt.widget.taskeditor.AdvancedForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // setup task editor
        Ext.create("Gnt.widget.taskeditor.TaskEditor", {
            // to use new class to build the "Advanced" tab
            advancedFormClass: 'MyAdvancedForm',
        });

#Notes

Contains an {@link Ext.form.field.HtmlEditor HTML editor instance} for viewing and editing a freetext note about the task.

{@img gantt/images/taskeditor-panel-notes.png}

You can enable/disable this tab by setting the {@link #showNotes} option.
To rename this tab you can use the `notesText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #notesConfig} config.

*/
Ext.define('Gnt.widget.taskeditor.TaskEditor', {
    extend: 'Gnt.widget.taskeditor.BaseEditor',
    alias: 'widget.taskeditor',
    requires: [
        'Ext.form.field.HtmlEditor',
        'Ext.layout.container.Table',
        'Gnt.widget.taskeditor.TaskForm',
        'Gnt.widget.taskeditor.AdvancedForm',
        'Gnt.widget.AssignmentEditGrid',
        'Gnt.widget.DependencyGrid'
    ],
    alternateClassName: [
        'Gnt.widget.TaskEditor'
    ],
    /**
     * @event loadtask
     * Fires after task has been loaded into the editor.
     *
     * This event can be used to do additional data loading if task editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdatetask} event to have an example of how to implement custom data saving.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          items       : customForm,
     *          listeners   : {
     *              // populate custom form with task values
     *              loadtask : function (taskeditor, task) {
     *                  customForm.loadRecord(task);
     *              },
     *              ....
     *          }
     *      });
     *
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor widget instance.
     * @param {Gnt.model.Task} task The task.
     */
    /**
     * @cfg {String} taskFormClass Class representing the form in the `General` tab.
     *
     * This option supposed to be used to implement a custom form in the `General` tab content.
     */
    taskFormClass: 'Gnt.widget.taskeditor.TaskForm',
    /**
     * @cfg {String} advancedFormClass Class representing the form in the `Advanced` tab.
     *
     * This option supposed to be used to implement a custom form in the `Advanced` tab content.
     */
    advancedFormClass: 'Gnt.widget.taskeditor.AdvancedForm',
    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display the `Resources` tab.
     */
    showAssignmentGrid: true,
    /**
     * @cfg {Boolean} showDependencyGrid `true` to display the `Predecessors` tab.
     */
    showDependencyGrid: true,
    /**
     * @cfg {Boolean} allowParentTaskDependencies `false` to hide a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `false` as well) and also exclude parent tasks from the list
     * of possible predecessors.
     */
    allowParentTaskDependencies: true,
    /**
     * @cfg {Boolean} showNotes `true` to display the `Notes` tab.
     */
    showNotes: true,
    /**
     * @cfg {Boolean} showAdvancedForm `true` to display the `Advanced` tab.
     */
    showAdvancedForm: true,
    /**
     * @cfg {Boolean} showRollup `true` to display rollup field on the `Advanced` tab.
     */
    showRollup: false,
    /**
     * @cfg {Boolean} showReadOnly `false` to hide readonly field on the `Advanced` tab.
     */
    showReadOnly: true,
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be **appended** after default tabs to this container.
     * For example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          items: [{
     *              title   : "Some custom tab",
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          }]
     *      });
     */
    /**
     * @cfg {Boolean} showBaseline `true` to display baseline fields in the `General` tab.
     */
    showBaseline: true,
    /**
     * @cfg {Object} taskFormConfig Configuration options to be supplied to the `General` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     */
    taskFormConfig: null,
    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    dependencyGridClass: 'Gnt.widget.DependencyGrid',
    /**
     * @cfg {Object} dependencyGridConfig Configuration options for the `Predecessors` tab.
     * For possible options take a look at the {@link Gnt.widget.DependencyGrid}.
     *
     */
    dependencyGridConfig: null,
    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    assignmentGridClass: 'Gnt.widget.AssignmentEditGrid',
    /**
     * @cfg {Object} assignmentGridConfig Configuration options for the `Resources` tab.
     * For possible options take a look at the {@link Gnt.widget.AssignmentEditGrid}.
     *
     */
    assignmentGridConfig: null,
    /**
     * @cfg {Object} advancedFormConfig Configuration options for the `Advanced` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     *
     */
    advancedFormConfig: null,
    /**
     * @cfg {Object} notesConfig Configuration options for the HTML-editor placed in the `Notes` tab.
     * For possible options take a look at the {@link Ext.form.field.HtmlEditor}.
     */
    notesConfig: null,
    /**
     * @property {Ext.panel.Panel} notesPanel The `Notes` tab.
     * Please use {@link #notesEditor} to access an enclosed HTML-editor.
     */
    notesPanel: null,
    /**
     * @property {Ext.form.field.HtmlEditor} notesEditor The HTML-editor presented in the `Notes` tab.
     * To specify setting for the HTML-editor please use {@link #notesConfig}.
     */
    notesEditor: null,
    /**
     * @property {Gnt.widget.TaskForm} taskForm The `General` tab task form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it might be customized by using {@link #taskFormClass} option.
     */
    taskForm: null,
    /**
     * @property {Gnt.widget.AssignmentEditGrid} assignmentGrid The grid used for the `Resources` tab.
     *
     */
    assignmentGrid: null,
    /**
     * @property {Gnt.widget.DependencyGrid} dependencyGrid The `Predecessors` tab instance.
     *
     */
    dependencyGrid: null,
    /**
     * @property {Gnt.widget.TaskForm} advancedForm The `Advanced` tab form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it can be customized by using {@link #advancedFormClass} option.
     *
     */
    advancedForm: null,
    margin: 0,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - generalText         : 'General',
            - resourcesText       : 'Resources',
            - dependencyText      : 'Predecessors',
            - addDependencyText   : 'Add new',
            - dropDependencyText  : 'Remove',
            - notesText           : 'Notes',
            - advancedText        : 'Advanced',
            - wbsCodeText         : 'WBS code',
            - addAssignmentText   : 'Add new',
            - dropAssignmentText  : 'Remove'
     */
    buildItems: function() {
        var me = this,
            items = [];
        var clonedStores = me.clonedStores || {};
        me.taskFormConfig = me.taskFormConfig || {};
        Ext.applyIf(me.taskFormConfig, {
            showBaseline: me.showBaseline,
            showRollup: false
        });
        //we show it here
        // create TaskForm instance
        me.taskForm = Ext.create(me.taskFormClass, Ext.apply({
            task: me.task,
            border: false,
            taskStore: me.taskStore
        }, me.taskFormConfig));
        items.push(me.taskForm);
        // create DependencyGrid instance
        if (me.showDependencyGrid) {
            me.dependencyGrid = Ext.create(me.dependencyGridClass, Ext.apply({
                allowParentTaskDependencies: me.allowParentTaskDependencies,
                taskModel: me.taskStore.model,
                task: me.task,
                margin: 0,
                border: false,
                tbar: {
                    layout: 'auto',
                    items: [
                        {
                            xtype: 'button',
                            iconCls: 'gnt-action-add',
                            text: me.L('addDependencyText'),
                            itemId: 'add-dependency-btn',
                            handler: function() {
                                me.dependencyGrid.insertDependency();
                            }
                        },
                        {
                            xtype: 'button',
                            iconCls: 'gnt-action-remove',
                            text: me.L('dropDependencyText'),
                            itemId: 'drop-dependency-btn',
                            disabled: true,
                            handler: function() {
                                var recs = me.dependencyGrid.getSelectionModel().getSelection();
                                if (recs && recs.length) {
                                    me.dependencyGrid.store.remove(recs);
                                }
                            }
                        }
                    ]
                },
                listeners: {
                    selectionchange: function(sm, sel) {
                        var grid = me.dependencyGrid;
                        if (!grid.dropDepBtn) {
                            grid.dropDepBtn = grid.down('#drop-dependency-btn');
                        }
                        grid.dropDepBtn && grid.dropDepBtn.setDisabled(!sel.length);
                    }
                }
            }, me.dependencyGridConfig));
            items.push(me.dependencyGrid);
        }
        // if AssignmentGrid required
        if (me.showAssignmentGrid && me.assignmentStore && me.resourceStore) {
            // clone assignment and resource stores if they were not copied before
            if (!clonedStores.assignmentStore)  {
                clonedStores.assignmentStore = me.cloneAssignmentStore(me.task);
            }
            
            if (!clonedStores.resourceStore)  {
                clonedStores.resourceStore = me.cloneResourceStore(me.task);
            }
            
            // create AssignmentGrid instance
            me.assignmentGrid = Ext.create(me.assignmentGridClass, Ext.apply({
                assignmentStore: me.assignmentStore,
                resourceStore: me.resourceStore,
                border: false,
                margin: 0,
                // we use clone of assignment store as assignmentGrid.store
                store: clonedStores.assignmentStore,
                resourceDupStore: clonedStores.resourceStore,
                tbar: {
                    layout: 'auto',
                    items: [
                        {
                            xtype: 'button',
                            iconCls: 'gnt-action-add',
                            text: me.L('addAssignmentText'),
                            itemId: 'add-assignment-btn',
                            handler: function() {
                                me.assignmentGrid.insertAssignment();
                            }
                        },
                        {
                            xtype: 'button',
                            iconCls: 'gnt-action-remove',
                            text: me.L('dropAssignmentText'),
                            itemId: 'drop-assignment-btn',
                            disabled: true,
                            handler: function() {
                                var recs = me.assignmentGrid.getSelectionModel().getSelection();
                                if (recs && recs.length) {
                                    me.assignmentGrid.store.remove(recs);
                                }
                            }
                        }
                    ]
                },
                listeners: {
                    // we need this to draw selection properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: {
                        fn: function(el) {
                            el.loadTaskAssignments(me.task.get(me.task.idProperty));
                        },
                        single: true
                    },
                    selectionchange: function(sm, sel) {
                        var grid = me.assignmentGrid;
                        if (!grid.dropBtn) {
                            grid.dropBtn = grid.down('#drop-assignment-btn');
                        }
                        grid.dropBtn && grid.dropBtn.setDisabled(!sel.length);
                    }
                }
            }, me.assignmentGridConfig));
            items.push(me.assignmentGrid);
        }
        // if advanced form required
        if (me.showAdvancedForm) {
            me.advancedFormConfig = me.advancedFormConfig || {};
            // create TaskForm instance for the "Advanced" tab form
            me.advancedForm = Ext.create(me.advancedFormClass, Ext.applyIf(me.advancedFormConfig, {
                showGeneral: false,
                showBaseline: false,
                showCalendar: true,
                showManuallyScheduled: true,
                showSchedulingMode: true,
                showWbsCode: true,
                showConstraint: true,
                showRollup: me.showRollup,
                showReadOnly: me.showReadOnly,
                layout: {
                    type: 'table',
                    columns: 2
                },
                border: false,
                margin: 0,
                task: me.task,
                taskStore: me.taskStore
            }));
            items.push(me.advancedForm);
        }
        // create notes panel
        if (me.showNotes) {
            // create notes HtmlEditor instance
            me.notesEditor = Ext.create('Ext.form.field.HtmlEditor', Ext.apply({
                listeners: {
                    // we need this to draw content of HtmlEditor properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: function(el) {
                        me.notesEditor.setValue(me.task.get(me.task.noteField));
                    }
                },
                readOnly: me.task && !me.task.isEditable(me.task.noteField),
                isDataChanged: function() {
                    return this.isDirty();
                }
            }, me.notesConfig));
            // we have to wrap it to panel since it's gonna be tab in TabPanel
            // (to avoid some render bugs)
            me.notesPanel = Ext.create('Ext.panel.Panel', {
                border: false,
                margin: 0,
                layout: 'fit',
                items: me.notesEditor
            });
            items.push(me.notesPanel);
        }
        // make sure that each panel has its title
        if (!me.taskForm.title)  {
            me.taskForm.title = me.L('generalText');
        }
        
        if (me.assignmentGrid && !me.assignmentGrid.title)  {
            me.assignmentGrid.title = me.L('resourcesText');
        }
        
        if (me.advancedForm && !me.advancedForm.title)  {
            me.advancedForm.title = me.L('advancedText');
        }
        
        if (me.notesPanel && !me.notesPanel.title)  {
            me.notesPanel.title = me.L('notesText');
        }
        
        return items;
    },
    bindDependencyGrid: function() {
        var depsClone = this.clonedStores.dependencyStore;
        var grid = this.dependencyGrid;
        // dependency grid store have to use cloned task store
        grid.store.taskStore = this.clonedStores.taskStore;
        if (depsClone) {
            this.mon(grid, {
                loaddependencies: function(grid, store) {
                    depsClone.loadData(store.getRange().concat(Gnt.util.Data.cloneModelSet(grid.oppositeData)));
                }
            });
            this.mon(grid.store, {
                add: function(store, records) {
                    depsClone.add(records);
                },
                remove: function(store, record) {
                    depsClone.remove(record);
                }
            });
            this.dependencyGridBound = true;
        }
    },
    /**
     * Loads task data into task editor.
     * @param {Gnt.model.Task} task Task to load to editor.
     */
    loadTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.task = task;
        var me = this,
            taskForm = me.taskForm,
            dependencyGrid = me.dependencyGrid,
            assignmentGrid = me.assignmentGrid,
            readOnly = task.isReadOnly();
        // on task loading step let's suppress task updating
        taskForm.setSuppressTaskUpdate(true);
        taskForm.getForm().reset();
        me.callParent(arguments);
        var clonedStores = me.clonedStores,
            taskBuffer = me.taskBuffer;
        if (dependencyGrid) {
            if (!me.dependencyGridBound)  {
                me.bindDependencyGrid();
            }
            
            // we always load records into the grid event when tab is not visible
            // since we use its ability to load task dependencies to fill our dependency store clone with records
            dependencyGrid.loadDependencies(task);
            dependencyGrid.tab.setVisible(me.allowParentTaskDependencies || task.isLeaf());
        }
        if (assignmentGrid) {
            // we use clone of assignment store as assignmentGrid.store
            if (clonedStores.assignmentStore !== assignmentGrid.getStore())  {
                assignmentGrid.reconfigure(clonedStores.assignmentStore);
            }
            
            if (assignmentGrid.resourceDupStore !== clonedStores.resourceStore)  {
                assignmentGrid.resourceDupStore = clonedStores.resourceStore;
            }
            
            assignmentGrid.loadResources(true);
            // load task assignments to grid
            assignmentGrid.loadTaskAssignments(task.getId() || task.getPhantomId());
            assignmentGrid.task = taskBuffer;
        }
        taskForm.loadRecord(task, taskBuffer);
        if (me.advancedForm) {
            // disable 'taskupdated' event processing for advancedForm
            me.advancedForm.setSuppressTaskUpdate(true);
            var form = me.advancedForm.getForm();
            form.reset();
            // we point advancedForm.taskBuffer to taskForm.taskBuffer
            // it will allow them to share changes of each other
            me.advancedForm.loadRecord(task, taskForm.taskBuffer);
            var field = form.findField('wbsCode');
            if (field) {
                field.setValue(task.getWBSCode());
            }
            // enable 'taskupdated' event processing for advancedForm back
            me.advancedForm.setSuppressTaskUpdate(false);
        }
        // enable 'taskupdated' event processing back
        taskForm.setSuppressTaskUpdate(false);
        if (me.notesEditor) {
            me.notesEditor.setValue(task.getNote());
        }
        me.setReadOnly(readOnly);
        me.fireEvent('loadtask', me, task);
    },
    updateReadOnly: function() {
        var me = this,
            task = me.taskBuffer,
            widgetReadOnly = me.getReadOnly(),
            readOnly = widgetReadOnly || task.isReadOnly();
        if (task) {
            if (me.taskForm) {
                // we repeat the editor readOnly state on the taskForm
                if (widgetReadOnly != me.taskForm.getReadOnly()) {
                    me.taskForm.setReadOnly(widgetReadOnly);
                } else {
                    me.taskForm.updateReadOnly();
                }
            }
            if (me.assignmentGrid) {
                me.assignmentGrid.setReadOnly(readOnly);
                me.assignmentGrid.down('toolbar').setVisible(!readOnly);
            }
            if (me.dependencyGrid) {
                me.dependencyGrid.down('toolbar').setVisible(!readOnly);
            }
            if (me.notesEditor) {
                me.notesEditor.setReadOnly(readOnly || !task.isEditable(task.noteField));
            }
            if (me.advancedForm) {
                // we repeat the editor readOnly state on the advancedForm
                if (widgetReadOnly != me.advancedForm.getReadOnly()) {
                    me.advancedForm.setReadOnly(widgetReadOnly);
                } else {
                    me.advancedForm.updateReadOnly();
                }
            }
        }
    },
    doValidate: function(invalidComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.taskForm && !this.taskForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.taskForm), this.taskForm);
        }
        if (this.dependencyGrid && !this.dependencyGrid.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.dependencyGrid), this.dependencyGrid);
        }
        if (this.assignmentGrid && !this.assignmentGrid.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.assignmentGrid), this.assignmentGrid);
        }
        if (this.advancedForm && !this.advancedForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.advancedForm), this.advancedForm);
        }
        return result;
    },
    doUpdateTask: function() {
        this.taskForm && this.taskForm.updateRecord();
        this.advancedForm && this.advancedForm.updateRecord();
        this.notesEditor && this.task.set(this.task.noteField, this.notesEditor.getValue());
        this.assignmentGrid && this.assignmentGrid.saveTaskAssignments();
        this.dependencyGrid && this.dependencyGrid.saveDependencies();
    },
    isDataChanged: function(changedComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.taskForm && this.taskForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.taskForm));
        }
        if (this.dependencyGrid && this.dependencyGrid.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.dependencyGrid));
        }
        if (this.assignmentGrid && this.assignmentGrid.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.assignmentGrid));
        }
        if (this.advancedForm && this.advancedForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.advancedForm));
        }
        if (this.notesEditor && this.notesEditor.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.notesEditor));
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.plugin.taskeditor.TaskEditor
@extends Gnt.plugin.taskeditor.BaseEditor

{@img gantt/images/taskeditor-general.png}

A plugin (ptype = 'gantt_taskeditor') which shows a {@link Gnt.widget.taskeditor.TaskEditor} in a window when a user double-clicks a task bar in the gantt chart.

You can enable this plugin in your Gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        ...
        plugins : Ext.create("Gnt.plugin.TaskEditor", {
            // window title
            title : 'Task Editor'
        }),
        ...
    })


{@img gantt/images/taskeditor-general.png}

#Plugin customization
Essentially this widget extends Ext.window.Window so any regular window configs can be used for it.
Also it supports a lot of configs provided by the {@link Gnt.widget.taskeditor.TaskEditor} class.
So if you want to customize the task editor child components (task form, resources grid etc.) you can read
the {@link Gnt.widget.taskeditor.TaskEditor} guide and apply corresponding configs to the plugin.

Another way to customize the task editor panel is {@link #panelConfig} config. With it you can
customize any config of the task editor panel, even the ones not translated by this plugin
(like `title`, `width`, `height` etc). For example:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        title       : 'I am window title',
        // some window elements
        items       : [...],
        panelConfig : {
            title   : 'I am panel title'
            // append some tabs to task editor panel
            items   : [...]
        }
    });

* **Note:** Please see {@link Gnt.widget.taskeditor.TaskEditor} class for details on how to customize the components of the tabs.

#Buttons customization

By default the window has two buttons `Ok` and `Cancel` to apply and rollback changes respectively.
If you want to just rename them you can use {@link #l10n} config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        l10n : {
            okText      : 'Apply changes',
            cancelText  : 'Reject changes'
        }
    });

And if you need to implement custom buttons you can easily do it using `buttons` config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : [
            {
                text    : 'Show some alert',
                handler : function() {
                    alert('Some alert');
                }
            }
        ]
    });

And finally if you don't want any buttons at all you can overwrite `buttons` config with an empty array. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : []
    });


*/
Ext.define('Gnt.plugin.taskeditor.TaskEditor', {
    extend: 'Gnt.plugin.taskeditor.BaseEditor',
    alternateClassName: [
        'Gnt.plugin.TaskEditor'
    ],
    requires: [
        'Gnt.widget.taskeditor.TaskEditor'
    ],
    alias: 'plugin.gantt_taskeditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_taskeditor',
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.TaskEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.TaskEditor',
    height: 390,
    width: 600,
    /**
     * @cfg {String} taskFormClass Class instance of which will represent form in the `General` tab.
     *
     * This option supposed to be used to implement custom form in the `General` tab content.
     */
    /**
     * @cfg {String} advancedFormClass Class instance of which will represent form in the `Advanced` tab.
     *
     * This option supposed to be used to implement custom form in the `Advanced` tab content.
     */
    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display `Resources` tab.
     */
    /**
     * @cfg {Boolean} showDependencyGrid `true` to display `Predecessors` tab.
     */
    /**
     * @cfg {Boolean} allowParentTaskDependencies `false` to hide a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `false` as well) and also exclude parent tasks from the list
     * of possible predecessors. Normally this config is read from the {@link Gnt.panel.Gantt#allowParentTaskDependencies}. Defaults to `true`.
     */
    /**
     * @cfg {Boolean} showNotes `true` to display `Notes` tab.
     */
    /**
     * @cfg {Boolean} showAdvancedForm `true` to display `Advanced` tab.
     */
    /**
     * @cfg {Object} taskFormConfig Configuration of task form placed at `General` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     */
    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    /**
     * @cfg {Object} dependencyGridConfig Configuration of grid placed at `Predecessors` tab.
     * For possible options take a look at {@link Gnt.widget.DependencyGrid}.
     *
     * **Note:** This grid may not be created if {@link #showDependencyGrid} set to `false`.
     */
    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    /**
     * @cfg {Object} assignmentGridConfig Configuration of grid placed at `Resources` tab.
     * For possible options take a look at {@link Gnt.widget.AssignmentEditGrid}.
     *
     * **Note:** This grid may not be created if {@link #showAssignmentGrid} set to `false`
     * or {@link #assignmentStore} or {@link #resourceStore} is not specified.
     */
    /**
     * @cfg {Object} advancedFormConfig Configuration of task form placed at `Advanced` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     *
     * **Note:** This form may not be created if {@link #showAdvancedForm} set to `false`.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Task Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
            - generalText         : 'General',
            - resourcesText       : 'Resources',
            - dependencyText      : 'Predecessors',
            - addDependencyText   : 'Add new',
            - dropDependencyText  : 'Remove',
            - notesText           : 'Notes',
            - advancedText        : 'Advanced',
            - wbsCodeText         : 'WBS code',
            - addAssignmentText   : 'Add new',
            - dropAssignmentText  : 'Remove'
     */
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore,generalText,resourcesText,dependencyText,addDependencyText,' + 'dropDependencyText,notesText,advancedText,wbsCodeText,addAssignmentText,dropAssignmentText,showAssignmentGrid,showDependencyGrid,' + 'allowParentTaskDependencies,showNotes,showStyle,showAdvancedForm,taskFormClass,advancedFormClass,taskFormConfig,dependencyGridConfig,' + 'assignmentGridConfig,advancedFormConfig,styleFormConfig,dependencyGridClass,assignmentGridClass',
    constructor: function(config) {
        this.callParent(arguments);
        // filter out project records
        this.addFilter(function(task) {
            return task && !task.isProject;
        });
    },
    init: function(cmp) {
        this.callParent(arguments);
        // decorate the component with a reference to the plugin
        cmp.taskEditor = this;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.selection.SpreadsheetModel', {
    extend: 'Ext.grid.selection.SpreadsheetModel',
    uses: [
        'Gnt.column.WBS'
    ],
    alias: 'selection.gantt_spreadsheet',
    privates: {
        getNumbererColumnConfig: function() {
            var me = this;
            return {
                xtype: 'wbscolumn',
                text: '&nbsp;',
                width: me.rowNumbererHeaderWidth,
                editRenderer: '&#160;',
                tdCls: me.rowNumbererTdCls,
                cls: me.rowNumbererHeaderCls,
                // disabling all interactions
                sortable: false,
                //resizable  : false,
                draggable: false,
                hideable: false,
                menuDisabled: true,
                // to remove possibility to unlock column
                lockable: false,
                ignoreExport: true,
                locked: true
            };
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.template.CalendarDateInfo
 @extends Ext.XTemplate

 Template class showing the legend for the calendar widget
 */
Ext.define("Gnt.template.CalendarDateInfo", {
    extend: 'Ext.XTemplate',
    disableFormats: true,
    workingHoursText: null,
    nonWorkingText: null,
    basedOnText: null,
    overrideText: null,
    inCalendarText: null,
    dayInCalendarText: null,
    markup: '<div class="gnt-calendar-overridedate">' + '<tpl if="isWorkingDay">__WORKINGHOURS__ {date}:<tpl else>{date} __NONWORKING__</tpl>' + '</div>' + '<ul class="gnt-calendar-availabilities">' + '<tpl for="availability">' + '<li>{.}</li>' + '</tpl>' + '</ul>' + '<span class="gnt-calendar-overridesource"> __BASEDON__: ' + '<tpl if="override">__OVERRIDE__ "{name}" __INCALENDAR__ "{calendarName}"<tpl else>__DAYINCALENDAR__ "{calendarName}"</tpl>' + '</span>',
    constructor: function(config) {
        Ext.apply(this, config);
        this.markup = this.markup.replace('__WORKINGHOURS__', this.workingHoursText).replace('__NONWORKING__', this.nonWorkingText).replace('__BASEDON__', this.basedOnText).replace('__OVERRIDE__', this.overrideText).replace('__INCALENDAR__', this.inCalendarText).replace('__DAYINCALENDAR__', this.dayInCalendarText);
        this.callParent([
            this.markup
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Gnt.template.CalendarLegend
 @extends Ext.Template

 Template class showing the legend for the calendar widget
 */
Ext.define("Gnt.template.CalendarLegend", {
    extend: 'Ext.Template',
    disableFormats: true,
    markup: '<ul class="gnt-calendar-legend">' + '<li class="gnt-calendar-legend-item">' + '<div class="gnt-calendar-legend-itemstyle {workingDayCls}"></div>' + '<span class="gnt-calendar-legend-itemname">{workingDayText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li>' + '<div class="gnt-calendar-legend-itemstyle {nonWorkingDayCls}"></div>' + '<span class="gnt-calendar-legend-itemname">{weekendsText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li class="gnt-calendar-legend-override">' + '<div class="gnt-calendar-legend-itemstyle {overriddenDayCls}">31</div>' + '<span class="gnt-calendar-legend-itemname">{overriddenDayText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li class="gnt-calendar-legend-override">' + '<div class="gnt-calendar-legend-itemstyle {overriddenWeekDayCls}">31</div>' + '<span class="gnt-calendar-legend-itemname">{overriddenWeekText}</span>' + '<div style="clear: both"></div>' + '</li>' + '</ul>',
    constructor: function() {
        this.callParent([
            this.markup
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This class is handling the drawing of scheduled record dependencies
 */
Ext.define("Sch.view.dependency.Painter", {
    alias: 'schdependencypainter.default',
    mixins: [
        'Ext.mixin.Factoryable'
    ],
    uses: [
        'Ext.Array',
        'Ext.XTemplate',
        'Ext.dom.Query',
        'Sch.util.Date',
        'Sch.util.RectangularPathFinder',
        'Sch.template.Dependency'
    ],
    config: {
        /**
         * @cfg {String} selectedCls
         *
         * Selected line's CSS class
         */
        selectedCls: 'sch-dependency-selected',
        /**
         * @cfg {String} cls
         *
         * Line's optional/user defined CSS class
         */
        cls: '',
        /**
         * @cfg {Boolean} rtl
         *
         * true if application is running in RTL mode
         */
        rtl: false,
        /**
         * @cfg {String/Array/Ext.XTemplate} lineTpl
         *
         * Line template
         */
        lineTpl: null,
        /**
         * @cfg {String} canvasCls
         *
         * Canvas element CSS class
         */
        canvasCls: null,
        /**
         * @cfg {Object} pathFinderConfig
         *
         * Path finder instance configuration
         */
        pathFinderConfig: null,
        /**
         * @cfg {Number} realLineThickness
         *
         * The real dependency line thickness. Visually it will be always 1px, but actual line element with or height
         * is different to allow proper catching pointer events. By default it's set by CSS rules, but for the testing
         * purposes we might override the CSS rules with exact value.
         *
         * @private
         */
        realLineThickness: null
    },
    // Private
    pathFinder: null,
    dependencyIdAttr: 'data-sch-dependency-id',
    constructor: function(config) {
        var me = this;
        me.initConfig(config);
        me.pathFinder = me.createPathFinder(me.getPathFinderConfig());
        if (!me.getLineTpl()) {
            me.setLineTpl(new Sch.template.Dependency({
                rtl: me.getRtl()
            }));
        }
    },
    /**
     * Clones this painter
     *
     * @return {Sch.view.dependency.Painter}
     */
    clone: function() {
        var me = this;
        return new me.self(me.getConfig());
    },
    applyLineTpl: function(tpl) {
        return tpl instanceof Ext.XTemplate ? tpl : new Ext.XTemplate(tpl);
    },
    updatePathFinderConfig: function(config) {
        var me = this;
        if (me.pathFinder) {
            // In this case we are to re-create path finder instance since path finder type is changed
            if (config && 'type' in config && config.type !== me.pathFinder.type) {
                Ext.destroy(me.pathFinder);
                me.pathFinder = me.createPathFinder(config);
            } else // In this case we just update current painter configuration
            {
                me.pathFinder.setConfig(config);
            }
        }
    },
    /**
     * Create path finder instance
     *
     * @protected
     */
    createPathFinder: function(config) {
        return Sch.util.RectangularPathFinder.create(config);
    },
    /**
     * Returns painter canvas element {@link Ext.dom.Helper} specification
     *
     * @return {Mixed}
     */
    getCanvasSpecification: function() {
        return {
            tag: 'div',
            role: 'presentation',
            cls: this.getCanvasCls()
        };
    },
    /**
     * Draws dependencies on `el` whereas `el` is supposed to be a canvas created using {@getCanvasSpecification the provided specification}
     *
     * @param {Ext.view.View} primaryView See primary view interface in {Sch.view.dependency.View dependency view} description
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies
     * @param {Boolean} overwrite
     */
    paint: function(primaryView, canvasEl, dependencies, overwrite) {
        var me = this,
            markup = me.generatePaintMarkup(primaryView, dependencies);
        canvasEl = Ext.fly(canvasEl);
        if (overwrite) {
            var tmp = document.createElement('div');
            tmp.innerHTML = markup;
            canvasEl.syncContent(tmp);
        } else {
            canvasEl.insertHtml('beforeEnd', markup);
        }
    },
    /**
     * Generates paint markup
     *
     * @param {Ext.view.View} primaryView See primary view interface in {Sch.view.dependency.View dependency view} description
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies
     * @return {String}
     */
    generatePaintMarkup: function(primaryView, dependencies) {
        var me = this,
            lineDefs = me.getLineDefsForDependencies(primaryView, dependencies);
        if (!Ext.isArray(lineDefs)) {
            lineDefs = [
                lineDefs
            ];
        }
        return Ext.Array.map(lineDefs, function(lineDef) {
            var tplData = me.getLineTplData(lineDef);
            return tplData && me.getLineTpl().apply(tplData) || '';
        }).join('');
    },
    /**
     * Returns true if element passed is an element visualizing a dependency
     *
     * @param {HTMLElement/Ext.dom.Element/String} el
     * @return {Boolean}
     */
    isDependencyElement: function(el) {
        return Ext.fly(el).is('.sch-dependency');
    },
    /**
     * Retrieves the canvas elements representing a particular dependency or dependencies
     *
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies dependency record(s)
     * @return {Ext.CompositeElementLite/Ext.CompositeElement/false}
     */
    getElementsForDependency: function(canvasEl, dependencies) {
        var EDQ = Ext.dom.Query,
            me = this;
        if (dependencies && !Ext.isArray(dependencies)) {
            dependencies = [
                dependencies
            ];
        }
        return new Ext.dom.CompositeElementLite(Ext.Array.reduce(dependencies || [], function(result, dependency) {
            return result.concat(EDQ.select('[' + me.dependencyIdAttr + '="' + dependency.internalId + '"]', Ext.getDom(canvasEl)));
        }, []));
    },
    /**
     * Returns all the elements on the canvas representing the rendered dependencies
     *
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @return {Ext.CompositeElementLite/Ext.CompositeElement}
     */
    getDependencyElements: function(canvasEl) {
        var canvasDom = Ext.getDom(canvasEl);
        return new Ext.dom.CompositeElementLite(canvasDom && canvasDom.childNodes || []);
    },
    /**
     * If the element passed constitutes a dependency line then returns the dependency record id this element
     * represents, otherwise returns empty string
     *
     * @param {HTMLElement/Ext.dom.Element/String} el
     * @return {String}
     */
    getElementDependencyInternalId: function(el) {
        return Ext.fly(el).getAttribute(this.dependencyIdAttr);
    },
    /**
     * Highlight the elements representing a particular dependency
     *
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependency Dependency model instance
     * @param {String} [cls] The CSS class to use for highlighting. Defaults to the selected-state CSS class.
     */
    highlightDependency: function(canvasEl, dependency, cls) {
        var me = this;
        me.getElementsForDependency(canvasEl, dependency).addCls(cls || me.getSelectedCls());
    },
    /**
     * Remove highlight of the elements representing a particular dependency
     *
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependency Dependency model instance
     * @param {String} [cls] The CSS class to used for highlighting. Defaults to the selected-state CSS class.
     */
    unhighlightDependency: function(canvasEl, dependency, cls) {
        var me = this;
        me.getElementsForDependency(canvasEl, dependency).removeCls(cls || me.getSelectedCls());
    },
    /**
     * Gets selected (highlighted) dependency elements
     *
     * @param {String/HtmlElement/Ext.Element} canvasEl
     * @return {Ext.CompositeElementLite/Ext.CompositeElement/false}
     */
    getSelectedDependencyElements: function(canvasEl) {
        var me = this;
        return Ext.fly(canvasEl).select('.' + me.getSelectedCls());
    },
    /**
     * Remove highlighting from any dependency line currently highlighted
     * @param {String/HtmlElement/Ext.Element} canvasEl
     */
    clearSelectedDependencies: function(canvasEl) {
        var me = this;
        me.getDependencyElements(canvasEl).removeCls(me.getSelectedCls());
    },
    /**
     * Converts line definition into line data applicable to line template.
     *
     * @param {Object} lineDef
     * @return {Object|false}
     * @return {String}         return.id
     * @return {[Object]}       return.segments
     * @return {Object|Boolean} return.startArrow
     * @return {Object|Boolean} return.endArrow
     * @protected
     */
    getLineTplData: function(lineDef) {
        var me = this,
            rtl, realLineThickness, firstSegment, lastSegment, result;
        lineDef = Ext.apply({}, lineDef, me.getConfig());
        result = me.pathFinder.findPath(lineDef);
        if (result) {
            // Check if we only need to render one vertical line, due to both tasks being outside of view
            if (!lineDef.startBox.rendered && !lineDef.endBox.rendered) {
                for (var i = result.length - 1; i >= 0; i--) {
                    var line = result[i];
                    if (line.x1 === line.x2) {
                        result = [
                            line
                        ];
                        lineDef.startArrowSize = lineDef.endArrowSize = 0;
                        break;
                    }
                }
            }
            rtl = me.getRtl();
            realLineThickness = me.getRealLineThickness();
            firstSegment = result.length && result[0];
            lastSegment = result.length && result[result.length - 1];
            result = {
                cls: lineDef.cls || '',
                dependencyId: lineDef.dependencyId || '',
                isHighlighted: lineDef.isHighlighted,
                segments: Ext.Array.map(result, function(segment) {
                    var dir = me.getSegmentDir(segment),
                        result;
                    if (dir == 'horizontal') {
                        result = {
                            width: Math.abs(segment.x1 - segment.x2) + 1,
                            height: realLineThickness,
                            top: Math.min(segment.y1, segment.y2),
                            side: Math.min(segment.x1, segment.x2),
                            dir: dir
                        };
                    } else {
                        result = {
                            height: Math.abs(segment.y1 - segment.y2) + 1,
                            width: realLineThickness,
                            top: Math.min(segment.y1, segment.y2),
                            side: Math.min(segment.x1, segment.x2),
                            dir: dir
                        };
                    }
                    return result;
                }),
                startArrow: lineDef.startArrowSize && {
                    side: firstSegment.x1,
                    top: firstSegment.y1,
                    dir: me.convertSideToDir(lineDef.startSide, rtl)
                },
                endArrow: lineDef.endArrowSize && {
                    side: lastSegment.x2,
                    top: lastSegment.y2,
                    dir: me.convertSideToDir(lineDef.endSide, rtl)
                },
                realLineThickness: me.getRealLineThickness()
            };
        }
        return result;
    },
    /**
     * @param {Sch.view.SchedulingView}
     * @param {Sch.model.Dependency[]}
     * @return {Object[]}
     * @protected
     */
    getLineDefsForDependencies: function(primaryView, dependencies) {
        var EA = Ext.Array,
            me = this,
            viewId = primaryView.getId(),
            viewStartDate = primaryView.timeAxis.getStart(),
            viewEndDate = primaryView.timeAxis.getEnd(),
            cache = {},
            internalId;
        if (!Ext.isArray(dependencies)) {
            dependencies = [
                dependencies
            ];
        }
        return EA.reduce(dependencies || [], function(result, dependency) {
            var source = dependency.getSourceEvent(),
                target = dependency.getTargetEvent(),
                sourceBoxes, targetBoxes,
                dateRange = dependency.getDateRange();
            if (dateRange && Sch.util.Date.intersectSpans(dateRange.start, dateRange.end, viewStartDate, viewEndDate)) {
                // Getting source boxes
                internalId = source.internalId;
                if (!cache[internalId]) {
                    sourceBoxes = me.getItemBox(primaryView, source) || [];
                    if (!Ext.isArray(sourceBoxes)) {
                        sourceBoxes = [
                            sourceBoxes
                        ];
                    }
                    cache[internalId] = sourceBoxes;
                } else {
                    sourceBoxes = cache[internalId];
                }
                // Getting target boxes
                internalId = target.internalId;
                if (!cache[internalId]) {
                    targetBoxes = me.getItemBox(primaryView, target) || [];
                    if (!Ext.isArray(targetBoxes)) {
                        targetBoxes = [
                            targetBoxes
                        ];
                    }
                    cache[internalId] = targetBoxes;
                } else {
                    targetBoxes = cache[internalId];
                }
                // Create line definitions for each item box cartesian multiplication
                result = EA.reduce(sourceBoxes, function(result, sourceBox, sourceBoxIdx) {
                    return EA.reduce(targetBoxes, function(result, targetBox, targetBoxIdx) {
                        if (sourceBox && targetBox && (sourceBox.rendered || targetBox.rendered || sourceBox.relPos != targetBox.relPos)) {
                            result.push(me.createLineDef(primaryView, dependency, source, target, sourceBox, targetBox, null));
                        }
                        return result;
                    }, result);
                }, result);
            }
            return result;
        }, []);
    },
    /**
     * Returns all the boxes a painter shall take into account, which corresponds to the given record
     *
     * @param {Ext.data.Model} itemRecord
     * @return {Object/Object[]}
     * @protected
     */
    getItemBox: function(primaryView, itemRecord) {
        return primaryView.getItemBox(itemRecord);
    },
    /**
     * Creates dependency line definition recognized by path finder
     *
     * @param {Ext.view.View} primaryView
     * @param {Sch.model.Dependency} dependency
     * @param {Ext.data.Model} source
     * @param {Ext.data.Model} target
     * @param {Object} sourceBox
     * @param {Object} targetBox
     * @param {Object[]/null} otherBoxes
     * @return {Object}
     * @protected
     */
    createLineDef: function(primaryView, dependency, source, target, sourceBox, targetBox, otherBoxes) {
        var DEP_TYPE = dependency.self.Type,
            me = this,
            type = dependency.getType(),
            endShift = 0,
            horizontalMargin = me.pathFinder.getHorizontalMargin(),
            verticalMargin = me.pathFinder.getVerticalMargin(),
            bidirectional = dependency.getBidirectional(),
            startArrowMargin = bidirectional ? me.pathFinder.getStartArrowMargin() : 0,
            startArrowSize = bidirectional ? me.pathFinder.getStartArrowSize() : 0,
            endArrowMargin = me.pathFinder.getEndArrowMargin(),
            endArrowSize = me.pathFinder.getEndArrowSize(),
            startSide, endSide;
        switch (true) {
            case type == DEP_TYPE.StartToEnd:
                startSide = primaryView.getConnectorStartSide(source);
                endSide = primaryView.getConnectorEndSide(target);
                break;
            case type == DEP_TYPE.StartToStart:
                startSide = primaryView.getConnectorStartSide(source);
                endSide = primaryView.getConnectorStartSide(target);
                break;
            case type == DEP_TYPE.EndToStart:
                startSide = primaryView.getConnectorEndSide(source);
                endSide = primaryView.getConnectorStartSide(target);
                break;
            case type == DEP_TYPE.EndToEnd:
                startSide = primaryView.getConnectorEndSide(source);
                endSide = primaryView.getConnectorEndSide(target);
                break;
            default:
                throw 'Invalid dependency type: ' + dependency.getType();
        }
        // if we have source event on the same vertical level as the target one
        if (sourceBox.top === targetBox.top) {
            startArrowMargin = endArrowMargin = 0;
            // and they are too close to show the arrow(s), we hide arrow
            if (Math.abs(sourceBox.end - targetBox.start) < (endArrowSize + startArrowSize)) {
                startArrowSize = endArrowSize = 0;
            }
        }
        switch (true) {
            case (startSide == 'left' || startSide == 'right') && (endSide == 'left' || endSide == 'right'):
                verticalMargin = 2;
                horizontalMargin = 5;
                break;
            case (startSide == 'top' || startSide == 'bottom') && (endSide == 'top' || endSide == 'bottom'):
                verticalMargin = 7;
                horizontalMargin = 2;
        }
        var distance = Number.MAX_VALUE;
        var centerHorizontalPoint = {
                from: sourceBox.start + (sourceBox.end - sourceBox.start) / 2,
                to: targetBox.start + (targetBox.end - targetBox.start) / 2
            };
        var centerVerticalPoint = {
                from: sourceBox.top + (sourceBox.bottom - sourceBox.top) / 2,
                to: targetBox.top + (targetBox.bottom - targetBox.top) / 2
            };
        // if points are too close to show the arrow(s) they are hidden
        if ((startSide === 'top' && endSide === 'bottom' || startSide === 'bottom' && endSide === 'top') && centerHorizontalPoint.from === centerHorizontalPoint.to) {
            distance = Math.abs(sourceBox[startSide] - targetBox[endSide]);
        } else if ((startSide === 'left' && endSide === 'right' || startSide === 'right' && endSide === 'left') && centerVerticalPoint.from === centerVerticalPoint.to) {
            var sourceSide = startSide === 'left' ? 'start' : 'end';
            var targetSide = endSide === 'left' ? 'start' : 'end';
            if (primaryView.rtl) {
                sourceSide = sourceSide === 'start' ? 'end' : 'start';
                targetSide = targetSide === 'start' ? 'end' : 'start';
            }
            var startX = sourceBox[sourceSide];
            var endX = targetBox[targetSide];
            distance = Math.abs(startX - endX);
        }
        if (distance < (endArrowSize * endArrowMargin) * 2) {
            startArrowMargin = endArrowMargin = 0;
            if (distance <= endArrowSize * 2) {
                startArrowSize = endArrowSize = 0;
            }
        }
        return {
            startBox: sourceBox,
            startSide: startSide,
            startArrowSize: startArrowSize,
            startArrowMargin: startArrowMargin,
            endBox: targetBox,
            endSide: endSide,
            endArrowSize: endArrowSize,
            endArrowMargin: endArrowMargin,
            verticalMargin: verticalMargin,
            horizontalMargin: horizontalMargin,
            otherBoxes: otherBoxes,
            dependencyId: dependency.internalId,
            cls: dependency.getCls(),
            isHighlighted: dependency.isHighlighted
        };
    },
    // NOTE: this could be a non-persistent model field instead of property
    convertSideToDir: function(side, rtl) {
        return this.self.sideToDir[side + (rtl && '-rtl' || '')];
    },
    getSegmentDir: function(segment) {
        var dir = 'vertical';
        if (segment.y1 === segment.y2) {
            dir = 'horizontal';
        }
        return dir;
    },
    inheritableStatics: {
        /**
         * @private
         */
        sideToDir: {
            'left': 'right',
            'right': 'left',
            'top': 'down',
            'bottom': 'up',
            'left-rtl': 'left',
            'right-rtl': 'right',
            'top-rtl': 'down',
            'bottom-rtl': 'up'
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.view.dependency.Painter', {
    extend: 'Sch.view.dependency.Painter',
    alias: 'schdependencypainter.ganttdefault',
    createLineDef: function(primaryView, dependency, source, target, sourceBox, targetBox, otherBoxes) {
        var DEP_TYPE = dependency.self.Type,
            me = this,
            horizontalMargin = me.pathFinder.getHorizontalMargin(),
            ganttRowHeight = primaryView.getRowHeight(),
            result = me.callParent(arguments);
        result.verticalMargin = Math.floor((ganttRowHeight - (sourceBox.bottom - sourceBox.top)) / 2);
        if (// This dependency type
        dependency.getType() == DEP_TYPE.EndToStart && // Target box is below source box
        sourceBox.bottom < targetBox.top && // Horizontal gap between source box end and target box start is less then 5px
        (sourceBox.end - targetBox.start < horizontalMargin)) {
            result.startShift = target.isMilestone() ? 0 : (horizontalMargin - (targetBox.end - targetBox.start) / 2);
            result.endSide = 'top';
            result.verticalMargin = result.horizontalMargin = result.startArrowMargin = result.endArrowMargin = 0;
        }
        // Reversing start/end endpoints generate more Gantt-friendly arrows
        var endBox = result.endBox;
        var endSide = result.endSide;
        result.startArrowSize = result.endArrowSize;
        result.startArrowMargin = result.endArrowMargin;
        result.endArrowSize = 0;
        result.endArrowMargin = 0;
        result.endBox = result.startBox;
        result.endSide = result.startSide;
        result.startBox = endBox;
        result.startSide = endSide;
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Dependency view is the utilitary view working alongside the primary `item` view of an Ext.Component, the only
 * requirement for the primary `item` view is to support the following interface:
 *
 *  - isItemCanvasAvailable([layer : Number]) : Boolean
 *  - getItemCanvas(layer : Number, canvasSpec : Object) : Ext.dom.Element
 *  - getItemBox(itemModel) : Object/Object[] {top : Number, bottom : Number, start : Number, end : Number, rendered : Boolean}
 *  - getStartConnectorSide(itemModel) : ['top'/'bottom'/'left'/'right']
 *  - getEndConnectorSide(itemModel) : ['top'/'bottom'/'left'/'right']
 */
Ext.define('Sch.view.dependency.View', {
    alias: 'schdependencyview.base',
    mixins: [
        'Ext.mixin.Factoryable',
        'Ext.mixin.Observable'
    ],
    uses: [
        'Ext.data.StoreManager',
        'Ext.Array',
        'Ext.dom.CompositeElementLite',
        'Sch.view.dependency.Painter'
    ],
    config: {
        /**
         * @cfg {Sch.view.SchedulerGridView} primaryView (required)
         *
         * Primary view instance
         */
        primaryView: null,
        /**
         * @cfg {Sch.data.EventStore|String} dependencyStore
         *
         * Dependency store this view will work with, if none given then dependency store will be taken from the primary view.
         */
        dependencyStore: null,
        /**
         * @cfg {Boolean} drawDependencies
         *
         * Set to false to turn dependency drawing off
         *
         * @private
         */
        drawDependencies: true,
        /**
         * @cfg {Object} painterConfig
         *
         * Dependency painter instance config
         */
        painterConfig: {
            canvasCls: 'sch-dependencyview-ct'
        },
        /**
         * @cfg {Number} canvasLayer
         *
         * Dependency canvas layer position (i.e. z-index)
         *
         * @private
         */
        canvasLayer: 0,
        /**
         *
         * @cfg {String} overCls
         *
         * The CSS class to add to a dependency line when hovering over it
         */
        overCls: null
    },
    // private
    renderTimer: null,
    painter: null,
    primaryViewDetacher: null,
    primaryViewLockableDetacher: null,
    primaryViewElDetacher: null,
    dependencyStoreDetacher: null,
    constructor: function(config) {
        var me = this;
        // Just in case
        me.callParent([
            config
        ]);
        // Initializing observable mixin
        me.mixins.observable.constructor.call(me, config);
        // Since we do not inherit from the Ext.Component the call to `initConfig` is required
        me.initConfig(config);
        Ext.Assert && Ext.Assert.isObject(me.getPrimaryView(), 'Dependency view requires a primary view to be configured in');
        Ext.Assert && Ext.Assert.isFunctionProp(me.getPrimaryView(), 'isItemCanvasAvailable', 'Dependency view requires `Sch.mixin.GridViewCanvas` mixin to be mixed into scheduling view, or the corresponding interface to be implemented');
        Ext.Assert && Ext.Assert.isFunctionProp(me.getPrimaryView(), 'getItemCanvasEl', 'Dependency view requires `Sch.mixin.GridViewCanvas` mixin to be mixed into scheduling view, or the corresponding interface to be implemented');
        me.painter = me.createPainter(Ext.apply({}, {
            rtl: me.getPrimaryView().rtl
        }, me.getPainterConfig()));
        if (me.canDrawDependencies()) {
            me.startDrawDependencies();
        }
    },
    destroy: function() {
        this.stopDrawDependencies();
        if (Ext.isNumber(this.renderTimer)) {
            clearTimeout(this.renderTimer);
        }
    },
    destroyDetachers: function() {
        var me = this;
        Ext.destroyMembers(this, [
            'primaryViewDetacher',
            'primaryViewLockableDetacher',
            'primaryViewElDetacher',
            'dependencyStoreDetacher'
        ]);
    },
    destroyDependencyCanvas: function() {
        var me = this;
        if (me.isDependencyCanvasPresent()) {
            Ext.destroy(me.getDependencyCanvas());
        }
    },
    /**
     * Checks if the view is ready to draw dependencies
     *
     * @param {Boolean} ignoreDrawDependencies
     * @param {Boolean} ignoreDependencyCanvas
     * @param {Boolean} ignoreDependencyStore
     *
     * @return {Boolean}
     */
    canDrawDependencies: function(ignoreDrawDependencies, ignoreDependencyCanvas, ignoreDependencyStore) {
        var me = this;
        return !!(me.painter && (ignoreDrawDependencies || me.getDrawDependencies()) && (ignoreDependencyCanvas || me.isDependencyCanvasAvailable()) && (ignoreDependencyStore || me.getDependencyStore()));
    },
    startDrawDependencies: function() {
        var me = this,
            primaryView = me.getPrimaryView(),
            dependencyStore = me.getDependencyStore(),
            lockableView;
        me.primaryViewDetacher = primaryView.on(Ext.applyIf({
            destroyable: true
        }, me.getPrimaryViewListeners()));
        me.primaryViewElDetacher = primaryView.getEl().on(Ext.applyIf({
            destroyable: true
        }, me.getPrimaryViewElListeners()));
        // WARNING: view.grid and view.grid.ownerLockable are private properties
        lockableView = primaryView.grid.ownerLockable && primaryView.grid.ownerLockable.getView();
        if (primaryView != lockableView) {
            me.primaryViewLockableDetacher = lockableView.on(Ext.applyIf({
                destroyable: true
            }, me.getPrimaryViewLockableListeners()));
        }
        me.dependencyStoreDetacher = dependencyStore.on(Ext.applyIf({
            destroyable: true
        }, me.getDependencyStoreListeners()));
        me.scheduleAllDependenciesRendering();
    },
    stopDrawDependencies: function() {
        var me = this;
        me.destroyDetachers();
        me.destroyDependencyCanvas();
    },
    updatePrimaryView: function(newView, oldView) {
        var me = this,
            lockableView;
        if (oldView) {
            me.stopDrawDependencies();
        }
        if (newView) {
            if (!me.getDependencyStore() && newView.getEventStore()) {
                me.setDependencyStore(newView.getEventStore().getDependencyStore());
            }
            if (me.canDrawDependencies()) {
                me.startDrawDependencies();
            }
        }
    },
    applyDependencyStore: function(store) {
        return store && Ext.StoreMgr.lookup(store);
    },
    updateDependencyStore: function(newStore, oldStore) {
        var me = this;
        if (oldStore) {
            me.stopDrawDependencies();
        }
        if (newStore && me.canDrawDependencies()) {
            me.startDrawDependencies();
        }
    },
    updateDrawDependencies: function(newValue, oldValue) {
        var me = this;
        if (newValue && me.canDrawDependencies(true)) {
            me.startDrawDependencies();
        } else if (!newValue) {
            me.stopDrawDependencies();
        }
    },
    applyPainterConfig: function(config) {
        // Do not share single config instance among several dependency canvas instances
        return Ext.isObject(config) ? Ext.apply({}, config) : config;
    },
    updatePainterConfig: function(config) {
        var me = this;
        if (me.painter) {
            if (config) {
                config = Ext.apply({}, {
                    rtl: me.getPrimaryView().rtl
                }, config);
            }
            // In this case we are to re-create painter instance since painter type is changed
            if (config && 'type' in config && config.type !== me.painter.type) {
                Ext.destroy(me.painter);
                me.painter = me.createPainter(config);
            } else // In this case we just update current painter configuration
            {
                me.painter.setConfig(config);
            }
            // New config might provide as with new canvas specification, thus the current one should be
            // destroyed if any
            me.destroyDependencyCanvas();
            if (me.canDrawDependencies()) {
                me.scheduleAllDependenciesRendering();
            }
        }
    },
    updateCanvasLayer: function(layer) {
        var me = this;
        me.destroyDependencyCanvas();
        if (me.canDrawDependencies()) {
            me.scheduleAllDependenciesRendering();
        }
    },
    /**
     * Gets scheduling view listeners object
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewListeners: function() {
        var me = this;
        return {
            'itemadd': me.scheduleAllDependenciesRendering,
            'itemremove': me.scheduleAllDependenciesRendering,
            'itemupdate': me.onPrimaryViewItemUpdate,
            'refresh': me.scheduleAllDependenciesRendering,
            'bufferedrefresh': me.scheduleAllDependenciesRendering,
            // Row expander plugin events
            'expandbody': me.scheduleAllDependenciesRendering,
            'collapsebody': me.scheduleAllDependenciesRendering,
            // Bryntum custom event
            'eventrepaint': me.scheduleAllDependenciesRendering,
            scope: me
        };
    },
    /**
     * If scheduling view is part of the lockable grid then gets top level lockable view listeners object
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewLockableListeners: function() {
        var me = this;
        return {
            // Row expander plugin events
            'expandbody': me.scheduleAllDependenciesRendering,
            'collapsebody': me.scheduleAllDependenciesRendering,
            scope: me
        };
    },
    /**
     * Get's primary view element listeners
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewElListeners: function() {
        var me = this;
        return {
            'dblclick': me.onPrimaryViewDependencyElPointerEvent,
            'click': me.onPrimaryViewDependencyElPointerEvent,
            'contextmenu': me.onPrimaryViewDependencyElPointerEvent,
            'mouseover': me.onPrimaryViewDependencyElPointerEvent,
            'mouseout': me.onPrimaryViewDependencyElPointerEvent,
            delegate: '.sch-dependency',
            scope: me
        };
    },
    /**
     * Gets dependency store listeners
     *
     * @return {Object}
     * @protected
     */
    getDependencyStoreListeners: function() {
        var me = this;
        return {
            'add': me.onDependencyStoreAdd,
            'remove': me.onDependencyStoreRemove,
            'update': me.onDependencyStoreUpdate,
            'refresh': me.onDependencyStoreRefresh,
            'clear': me.onDependencyStoreClear,
            scope: me
        };
    },
    /**
     * Creates painter class instance
     *
     * @param {Object} config Painter config
     * @return {Sch.view.dependency.Painter}
     * @protected
     */
    createPainter: function(config) {
        return Sch.view.dependency.Painter.create(config);
    },
    /**
     * Clones currently using dependency painter
     *
     * @return {Sch.view.dependency.Painter/Null}
     * @public
     */
    clonePainter: function() {
        var me = this;
        return me.painter && me.painter.clone() || null;
    },
    /**
     * Checks if dependency canvas is available for drawing
     *
     * @return {Boolean}
     * @protected
     */
    isDependencyCanvasAvailable: function() {
        var primaryView = this.getPrimaryView();
        return primaryView && primaryView.isItemCanvasAvailable();
    },
    /**
     * Checks if dependency canvas is present in the DOM
     *
     * @return {Boolean}
     *
     * @protected
     */
    isDependencyCanvasPresent: function() {
        var me = this,
            primaryView = me.getPrimaryView();
        return primaryView && primaryView.isItemCanvasAvailable(me.getCanvasLayer());
    },
    /**
     * Returns dependency canvas element
     *
     * @reutrn {Ext.dom.Element}
     * @protected
     */
    getDependencyCanvas: function() {
        var me = this;
        return me.getPrimaryView().getItemCanvasEl(me.getCanvasLayer(), me.painter.getCanvasSpecification());
    },
    /**
     * Checks if dependency rendering has been scheduled
     *
     * @return {Boolean}
     * @protected
     */
    isDependencyRenderingScheduled: function() {
        return !!this.renderTimer;
    },
    /**
     * Schedules full dependency redrawing
     *
     * @protected
     */
    scheduleAllDependenciesRendering: function() {
        var me = this,
            hiddenParent;
        if (!me.isDependencyRenderingScheduled() && me.canDrawDependencies()) {
            me.renderTimer = setTimeout(function() {
                me.renderTimer = null;
                me.renderAllDependencies();
            });
        }
    },
    /**
     * Renders all the dependencies for the current view
     */
    renderAllDependencies: function() {
        var me = this,
            containerEl,
            hiddenParent = me.getPrimaryView().up("{isHidden()}");
        // If a parent container is hidden, stop and wait for it to become visible
        if (hiddenParent) {
            // just for isDependencyRenderingScheduled() returned correct state, in this case it's scheduled
            // but not on timer but on parent `show` event.
            me.renderTimer = true;
            this.mon(hiddenParent, 'show', function() {
                me.renderTimer = null;
                me.renderAllDependencies();
            }, null, {
                single: true
            });
        }
        // If parent container is visible, as well as we are visible then scheduling call to renderAllDependencies
        else if (me.canDrawDependencies() && me.fireEvent('beforerefresh', me) !== false) {
            containerEl = me.getDependencyCanvas();
            me.renderDependencies(me.getDependenciesToRender(), true);
            me.fireEvent('refresh', me);
        }
    },
    getDependenciesToRender: function() {
        return this.getDependencyStore().getRange();
    },
    /**
     * Renders dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     * @param {Boolean} [overwrite=false]
     */
    renderDependencies: function(dependencyRecords, overwrite) {
        var me = this;
        if (me.canDrawDependencies()) {
            me.painter.paint(me.getPrimaryView(), me.getDependencyCanvas(), dependencyRecords || [], overwrite);
        }
    },
    /**
     * Re-renders dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     */
    updateDependencies: function(dependencyRecords) {
        var me = this;
        // Clearing previous dependency elements
        me.clearDependencies(dependencyRecords);
        // Appending new dependency elements keeping everything else intact
        me.renderDependencies(dependencyRecords, false);
    },
    /**
     * Clears dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     */
    clearDependencies: function(dependencyRecords) {
        var me = this;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            Ext.destroy(me.getElementsForDependency(dependencyRecords));
        }
    },
    /**
     * Removes all drawn dependencies elements from the canvas
     */
    clearAllDependencies: function() {
        this.renderDependencies([], true);
    },
    // overwrite with nothing is the same is clear
    /**
     * Retrieve the elements representing a particular dependency or dependencies
     *
     * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencyRecords dependency record(s)
     * @return {Ext.CompositeElementLite/Ext.CompositeElement/false}
     */
    getElementsForDependency: function(dependencyRecords) {
        var me = this,
            result = false;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            result = me.painter.getElementsForDependency(me.getDependencyCanvas(), dependencyRecords);
        }
        return result;
    },
    /**
     * Returns dependency record corresponding to the given element
     *
     * @param {HTMLElement/Ext.dom.Element/String} el
     * @return {Sch.model.Dependency/Null}
     */
    getDependencyForElement: function(el) {
        var me = this,
            depStore = me.getDependencyStore(),
            dependency = null,
            depInternalId;
        if (depStore) {
            depInternalId = me.painter.getElementDependencyInternalId(el);
            dependency = depStore.getByInternalId(depInternalId);
        }
        return dependency;
    },
    /**
     * Returns all the elements representing the rendered dependencies
     *
     * @return {Ext.CompositeElementLite/Ext.CompositeElement/false}
     */
    getDependencyElements: function() {
        var me = this,
            result = false,
            canvasDom;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            result = me.painter.getDependencyElements(me.getDependencyCanvas());
        }
        return result;
    },
    /**
     * Highlight the elements representing a dependency
     *
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     * @param {String} [cls] The CSS class to use for highlighting. Defaults to the selected-state CSS class.
     */
    highlightDependency: function(record, cls) {
        var me = this;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            if (!(record instanceof Ext.data.Model)) {
                record = me.getDependencyStore().getById(record);
            }
            if (record) {
                me.painter.highlightDependency(me.getDependencyCanvas(), record, cls);
                // NOTE: It's not view's task to do this, but kept it for backward compatibility
                //       MVC way would be to add 'isHighlighted' non persistent field to the dependency model
                record.isHighlighted = true;
            }
        }
    },
    /**
     * Remove highlight of the elements representing a particular dependency
     *
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     * @param {String} [cls] The CSS class to use for highlighting. Defaults to the selected-state CSS class.
     */
    unhighlightDependency: function(record, cls) {
        var me = this;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            if (!(record instanceof Ext.data.Model)) {
                record = me.getDependencyStore().getById(record);
            }
            if (record) {
                me.painter.unhighlightDependency(me.getDependencyCanvas(), record, cls);
                // NOTE: It's not view's task to do that, but I've kept it for backward compatibility
                //       MVC way would be to add 'isHighlighted' non persistent field to the dependency model
                record.isHighlighted = false;
            }
        }
    },
    /**
     * Gets selected (highlighted) dependency elements
     *
     * @return {Ext.CompositeElementLite/Ext.CompositeElement/false}
     */
    getSelectedDependencyElements: function() {
        var me = this,
            result = false;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            result = me.painter.getSelectedDependencyElements(me.getDependencyCanvas());
        }
        return result;
    },
    /**
     * Remove highlighting from any dependency line currently highlighted
     */
    clearSelectedDependencies: function() {
        var me = this;
        if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
            me.painter.clearSelectedDependencies(me.getDependencyCanvas());
            // NOTE: It's not view's task to do that, but I've kept it for backward compatibility
            //       MVC way would be to add 'isHighlighted' non persistent field to the dependency model
            me.getDependencyStore().each(function(dependency) {
                dependency.isHighlighted = false;
            });
        }
    },
    onPrimaryViewItemUpdate: function(eventRecord, index, eventNode) {
        this.scheduleAllDependenciesRendering();
    },
    onPrimaryViewDependencyElPointerEvent: function(event, elDom, options) {
        var me = this,
            dependencyId, dependency;
        dependencyId = me.painter.getElementDependencyInternalId(elDom);
        dependency = me.getDependencyStore().getByInternalId(dependencyId);
        if (dependency) {
            var overCls = this.getOverCls();
            me.fireEvent('dependency' + event.type, me, dependency, event, elDom);
            if (overCls) {
                if (event.type === 'mouseover') {
                    this.highlightDependency(dependency, overCls);
                } else if (event.type === 'mouseout') {
                    this.unhighlightDependency(dependency, overCls);
                }
            }
        }
    },
    onDependencyStoreAdd: function(store, dependencies) {
        this.renderDependencies(dependencies);
    },
    onDependencyStoreRemove: function(store, dependencies) {
        this.clearDependencies(dependencies);
    },
    onDependencyStoreUpdate: function(store, dependency) {
        this.updateDependencies(dependency);
    },
    onDependencyStoreRefresh: function(store) {
        this.scheduleAllDependenciesRendering();
    },
    onDependencyStoreClear: function(store) {
        this.scheduleAllDependenciesRendering();
    }
});
/**
     * @event refresh
     *
     * Fires after the view has fully rendered all the dependencies in the underlying store.
     *
     * @param {Sch.view.Dependency} view The dependency view instance
     */
/**
     * @event dependencyclick
     *
     * Fires after clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencycontextmenu
     *
     * Fires after right clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencydblclick
     *
     * Fires after double clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencymouseover
     *
     * Fires when hovering over a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */
/**
     * @event dependencymouseout
     *
     * Fires when leaving a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.view.dependency.View', {
    extend: 'Sch.view.dependency.View',
    alias: 'schdependencyview.basegantt',
    requires: [
        'Gnt.view.dependency.Painter'
    ],
    /**
     * @deprecated 4.2
     */
    alternateClassName: 'Gnt.view.Dependency',
    config: {
        painterConfig: {
            type: 'ganttdefault'
        }
    },
    // Since there's only one task per row in Gantt panel we need to update dependencies only for the updated task
    // instead of full redraw as for Scheduler
    onPrimaryViewItemUpdate: function(taskRecord, index, eventNode) {
        this.updateDependencies(taskRecord.getAllDependencies());
    }
});
/**
     * @event beforednd
     *
     * Fires before a drag and drop operation is initiated, return false to cancel it
     *
     * @param {Gnt.view.dependency.View} The dependency view instance
     * @param {HTMLNode} node The node that's about to be dragged
     * @param {Ext.EventObject} e The event object
     */
/**
     * @event dndstart
     *
     * Fires when a dependency drag and drop operation starts
     *
     * @param {Gnt.view.dependency.View} The dependency view instance
     */
/**
     * @event drop
     *
     * Fires after a drop has been made on a receiving terminal
     *
     * @param {Gnt.view.dependency.View} The dependency view instance
     * @param {Mixed} fromId The source dependency record id
     * @param {Mixed} toId The target dependency record id
     * @param {Number} type The dependency type, see {@link Gnt.model.Dependency} for more information
     */
/**
     * @event afterdnd
     *
     * Always fires after a dependency drag and drop operation
     *
     * @param {Gnt.view.dependency.View} view The dependency view instance
     */

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.widget.Calendar
@extends Ext.picker.Date

{@img gantt/images/widget-calendar.png}

This a very simple subclass of the {@link Ext.picker.Date} which will show holidays and weekends from the provided calendar.
Any non-working time will be shown as disabled dates.

*/
Ext.define('Gnt.widget.Calendar', {
    extend: 'Ext.picker.Date',
    alias: 'widget.ganttcalendar',
    requires: [
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read the holidays from
     */
    calendar: null,
    /**
     * @cfg {Date} startDate The start date of the range to show holidays for.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate The end date of the range to show holidays for.
     */
    endDate: null,
    initComponent: function() {
        if (!this.calendar) {
            Ext.Error.raise('Required attribute "calendar" missing during initialization of `Gnt.widget.Calendar`');
        }
        if (!this.startDate) {
            Ext.Error.raise('Required attribute "startDate" missing during initialization of `Gnt.widget.Calendar`');
        }
        if (!this.endDate) {
            this.endDate = Sch.util.Date.add(this.startDate, Sch.util.Date.MONTH, 1);
        }
        this.setCalendar(this.calendar);
        this.minDate = this.value = this.startDate;
        this.callParent(arguments);
        // this method requires "this.format" presense which, starting from 4.2.1 is initialized in the parent "initComponent"
        this.injectDates();
    },
    injectDates: function() {
        var me = this;
        var disabledDates = me.disabledDates = [];
        Ext.Array.each(me.calendar.getHolidaysRanges(me.startDate, me.endDate), function(range) {
            range.forEachDate(function(date) {
                disabledDates.push(Ext.Date.format(date, me.format));
            });
        });
        me.setDisabledDates(disabledDates);
    },
    /**
     * Sets the calendar for this calendar picker
     *
     * @param {Gnt.data.Calendar} calendar The calendar
     */
    setCalendar: function(calendar) {
        var listeners = {
                update: this.injectDates,
                remove: this.injectDates,
                add: this.injectDates,
                load: this.injectDates,
                clear: this.injectDates,
                scope: this
            };
        if (this.calendar) {
            this.mun(calendar, listeners);
        }
        this.calendar = calendar;
        if (calendar) {
            this.mon(calendar, listeners);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.widget.calendar.AvailabilityGrid', {
    extend: 'Ext.grid.Panel',
    requires: [
        'Ext.Button',
        'Ext.data.Store',
        'Ext.grid.column.Date',
        'Ext.grid.plugin.CellEditing',
        'Ext.window.MessageBox'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendaravailabilitygrid',
    // input
    calendarDay: null,
    height: 160,
    addButton: null,
    removeButton: null,
    maxIntervalsNum: 5,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText         : 'Start',
            - endText           : 'End',
            - addText           : 'Add',
            - removeText        : 'Remove',
            - error             : 'Error'
     */
    initComponent: function() {
        // in ext 5 tbar is null, so apply/applyif wouldn't work
        if (!this.tbar) {
            this.tbar = this.buildToolbar();
        }
        Ext.applyIf(this, {
            store: new Ext.data.Store({
                fields: [
                    'startTime',
                    'endTime'
                ],
                autoDestroy: true,
                data: this.calendarDay.getAvailability()
            }),
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2
                })
            ],
            columns: [
                {
                    xtype: 'datecolumn',
                    header: this.L('startText'),
                    format: 'g:i a',
                    dataIndex: 'startTime',
                    flex: 1,
                    editor: {
                        xtype: 'timefield',
                        allowBlank: false,
                        initDate: '31/12/1899'
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('endText'),
                    format: 'g:i a',
                    dataIndex: 'endTime',
                    flex: 1,
                    editor: {
                        xtype: 'timefield',
                        allowBlank: false,
                        initDate: '31/12/1899'
                    }
                }
            ],
            listeners: {
                selectionchange: this.onAvailabilityGridSelectionChange,
                scope: this
            }
        });
        this.callParent(arguments);
    },
    buildToolbar: function() {
        this.addButton = new Ext.Button({
            text: this.L('addText'),
            iconCls: 'gnt-action-add',
            handler: this.addAvailability,
            scope: this
        });
        this.removeButton = new Ext.Button({
            text: this.L('removeText'),
            iconCls: 'gnt-action-remove',
            handler: this.removeAvailability,
            scope: this,
            disabled: true
        });
        return [
            this.addButton,
            this.removeButton
        ];
    },
    onAvailabilityGridSelectionChange: function(grid, selection) {
        this.removeButton.setDisabled(!selection.length);
    },
    setAvailability: function(availability) {
        this.store.loadData(availability);
        this.addButton.setDisabled(this.store.getCount() >= this.maxIntervalsNum);
    },
    addAvailability: function() {
        var store = this.getStore(),
            count = store.count();
        if (count >= this.maxIntervalsNum) {
            return;
        }
        store.add({
            startTime: new Date(0, 0, 0, 12, 0),
            endTime: new Date(0, 0, 0, 13, 0)
        });
        if (count + 1 >= this.maxIntervalsNum && this.addButton) {
            this.addButton.disable();
        }
    },
    removeAvailability: function() {
        var store = this.getStore(),
            count = store.getCount(),
            selection = this.getSelection();
        if (!selection.length)  {
            return;
        }
        
        store.remove(selection[0]);
        if (count < this.maxIntervalsNum && this.addButton) {
            this.addButton.enable();
        }
    },
    // output
    isValid: function(noMessage) {
        try {
            this.calendarDay.verifyAvailability(this.getIntervals());
        } catch (ex) {
            if (!noMessage) {
                Ext.MessageBox.show({
                    title: this.L('error'),
                    msg: ex,
                    modal: true,
                    icon: Ext.MessageBox.ERROR,
                    buttons: Ext.MessageBox.OK
                });
            }
            return false;
        }
        return true;
    },
    extractTimeFromDate: function(date) {
        return new Date(0, 0, 0, date.getHours(), date.getMinutes(), date.getSeconds());
    },
    // output
    getIntervals: function() {
        var intervals = [];
        var me = this;
        this.getStore().each(function(item) {
            var endTime = me.extractTimeFromDate(item.get('endTime'));
            // 12AM as the end time means 24:00
            if (endTime - new Date(0, 0, 0, 0, 0, 0) === 0)  {
                endTime = new Date(0, 0, 1, 0, 0);
            }
            
            intervals.push({
                startTime: me.extractTimeFromDate(item.get('startTime')),
                endTime: endTime
            });
        });
        return intervals;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.widget.calendar.DayEditor', {
    extend: 'Gnt.widget.calendar.AvailabilityGrid',
    requires: [
        'Ext.grid.plugin.CellEditing',
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendardayeditor',
    height: 160,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText           : 'Start',
            - endText             : 'End',
            - workingTimeText     : 'Working time',
            - nonworkingTimeText  : 'Non-working time'
     */
    initComponent: function() {
        var isWorkingDay = this.calendarDay.getIsWorkingDay();
        this.dockedItems = this.dockedItems || [
            {
                xtype: 'radiogroup',
                dock: 'top',
                name: 'dayType',
                padding: "0 5px",
                margin: 0,
                items: [
                    {
                        boxLabel: this.L('workingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: true,
                        checked: isWorkingDay
                    },
                    {
                        boxLabel: this.L('nonworkingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: false,
                        checked: !isWorkingDay
                    }
                ],
                listeners: {
                    change: this.onDayTypeChanged,
                    scope: this
                }
            }
        ];
        this.on('afterrender', this.myApplyState, this);
        this.callParent(arguments);
    },
    getDayTypeRadioGroup: function() {
        return this.down('radiogroup[name="dayType"]');
    },
    myApplyState: function() {
        if (!this.isWorkingDay()) {
            this.viewSetDisabled(true);
            this.addButton.disable();
        }
    },
    // we cannot use view.disable() because it blocks also radio buttons to switch working/non working day modes
    // http://www.sencha.com/forum/showthread.php?291799
    viewSetDisabled: function(disabled) {
        if (disabled) {
            this.getView().getEl().mask();
            this.getHeaderContainer().getEl().mask();
        } else {
            this.getView().getEl().unmask();
            this.getHeaderContainer().getEl().unmask();
        }
    },
    onDayTypeChanged: function(sender) {
        var value = sender.getValue();
        if (Ext.isArray(value.IsWorkingDay))  {
            return;
        }
        
        this.viewSetDisabled(!value.IsWorkingDay);
        this.addButton.setDisabled(!value.IsWorkingDay || this.getStore().getCount() >= this.maxIntervalsNum);
    },
    isWorkingDay: function() {
        return this.getDayTypeRadioGroup().getValue().IsWorkingDay;
    },
    isValid: function() {
        if (this.isWorkingDay())  {
            return this.callParent();
        }
        
        return true;
    },
    getIntervals: function() {
        if (!this.isWorkingDay())  {
            return [];
        }
        
        return this.callParent();
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.widget.calendar.WeekEditor', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.grid.Panel',
        'Gnt.data.Calendar',
        'Sch.util.Date',
        'Gnt.widget.calendar.AvailabilityGrid'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarweekeditor',
    weekName: null,
    startDate: null,
    endDate: null,
    // the availability array for the week being edited
    weekAvailability: null,
    // the `weekAvailability` of the calendar
    calendarWeekAvailability: null,
    // the `defaultWeekAvailability` of the calendar
    defaultWeekAvailability: null,
    backupWeekAvailability: null,
    layout: 'anchor',
    defaults: {
        border: false,
        anchor: '100%'
    },
    calendarDayModel: null,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - defaultTimeText    : 'Default time',
            - workingTimeText    : 'Working time',
            - nonworkingTimeText : 'Non-working time',
            - error              : 'Error',
            - noOverrideError    : "Week override contains only 'default' days - can't save it"
     */
    currentDayIndex: null,
    _weekDaysGrid: null,
    _availabilityGrid: null,
    initComponent: function() {
        this.backupWeekAvailability = [];
        this.items = [
            {
                xtype: 'radiogroup',
                padding: "0 5px",
                name: 'dayType',
                items: [
                    {
                        boxLabel: this.L('defaultTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 0
                    },
                    {
                        boxLabel: this.L('workingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 1
                    },
                    {
                        boxLabel: this.L('nonworkingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 2
                    }
                ],
                listeners: {
                    change: this.onDayTypeChanged,
                    scope: this
                }
            },
            {
                layout: 'column',
                padding: '0 0 5px 0',
                defaults: {
                    border: false
                },
                items: [
                    {
                        margin: '0 10px 0 5px',
                        columnWidth: 0.5,
                        items: this.getWeekDaysGrid()
                    },
                    {
                        columnWidth: 0.5,
                        margin: '0 5px 0 0',
                        items: this.getAvailabilityGrid()
                    }
                ]
            }
        ];
        this.callParent(arguments);
    },
    getWeekDaysGrid: function() {
        if (this._weekDaysGrid != null)  {
            return this._weekDaysGrid;
        }
        
        var DN = Ext.Date.dayNames;
        return this._weekDaysGrid = new Ext.grid.Panel({
            hideHeaders: true,
            height: 160,
            columns: [
                {
                    header: '',
                    dataIndex: 'name',
                    flex: 1
                }
            ],
            store: new Ext.data.Store({
                autoDestroy: true,
                fields: [
                    'id',
                    'name'
                ],
                idProperty: 'id',
                data: [
                    {
                        id: 1,
                        name: DN[1]
                    },
                    {
                        id: 2,
                        name: DN[2]
                    },
                    {
                        id: 3,
                        name: DN[3]
                    },
                    {
                        id: 4,
                        name: DN[4]
                    },
                    {
                        id: 5,
                        name: DN[5]
                    },
                    {
                        id: 6,
                        name: DN[6]
                    },
                    {
                        id: 0,
                        name: DN[0]
                    }
                ]
            }),
            listeners: {
                viewready: this.onWeekDaysListViewReady,
                selectionchange: this.onWeekDaysListSelectionChange,
                beforeselect: this.onWeekDaysListBeforeSelect,
                scope: this
            }
        });
    },
    getAvailabilityGrid: function() {
        if (!this._availabilityGrid) {
            this._availabilityGrid = new Gnt.widget.calendar.AvailabilityGrid({
                calendarDay: new this.calendarDayModel()
            });
        }
        return this._availabilityGrid;
    },
    getDayTypeRadioGroup: function() {
        if (!this.dayTypeRadioGroup)  {
            this.dayTypeRadioGroup = this.down('radiogroup[name="dayType"]');
        }
        
        return this.dayTypeRadioGroup;
    },
    getWeekAvailability: function() {
        return this.weekAvailability;
    },
    onWeekDaysListViewReady: function() {
        var weekDaysGrid = this.getWeekDaysGrid(),
            monday = weekDaysGrid.getStore().getAt(0);
        this.currentDayIndex = monday.getId();
        this.readFromData();
        weekDaysGrid.getSelectionModel().select(monday, false, true);
    },
    onWeekDaysListBeforeSelect: function() {
        if (!this.saveToData())  {
            return false;
        }
        
    },
    applyChanges: function(toWeekAvailability) {
        if (!this.saveToData())  {
            return false;
        }
        
        var weekAvailability = this.weekAvailability;
        var hasOverride = false;
        for (var i = 0; i < 7; i++) {
            var currentAvailability = weekAvailability[i];
            if (currentAvailability) {
                hasOverride = true;
                if (!toWeekAvailability[i])  {
                    toWeekAvailability[i] = currentAvailability;
                }
                
                toWeekAvailability[i].setIsWorkingDay(currentAvailability.getIsWorkingDay());
                toWeekAvailability[i].setAvailability(currentAvailability.getAvailability());
            } else {
                toWeekAvailability[i] = null;
            }
        }
        if (!hasOverride) {
            Ext.MessageBox.show({
                title: this.L('error'),
                msg: this.L('noOverrideError'),
                modal: true,
                icon: Ext.MessageBox.ERROR,
                buttons: Ext.MessageBox.OK
            });
            return false;
        }
        return true;
    },
    onWeekDaysListSelectionChange: function(view, records) {
        this.currentDayIndex = records[0].getId();
        this.readFromData();
    },
    // 0 - default, 1 - working , 2 - non-working
    getCurrentTypeOfWeekDay: function(index) {
        return this.weekAvailability[index] ? (this.weekAvailability[index].getIsWorkingDay() ? 1 : 2) : 0;
    },
    getCurrentWeekDay: function(index) {
        return this.weekAvailability[index] || this.calendarWeekAvailability[index] || this.defaultWeekAvailability[index];
    },
    saveToData: function() {
        var currentDayIndex = this.currentDayIndex;
        var type = this.getDayTypeRadioGroup().getValue().IsWorkingDay;
        var weekAvailability = this.weekAvailability;
        // default day - remove the element from `weekAvailability`
        if (type === 0) {
            weekAvailability[currentDayIndex] = null;
            return true;
        }
        var availabilityGrid = this.getAvailabilityGrid();
        // working day
        if (type == 1) {
            if (!availabilityGrid.isValid())  {
                return false;
            }
            
            if (!weekAvailability[currentDayIndex])  {
                weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
            }
            
            weekAvailability[currentDayIndex].setIsWorkingDay(true);
            weekAvailability[currentDayIndex].setAvailability(availabilityGrid.getIntervals());
            this.backupWeekAvailability[currentDayIndex] = null;
            return true;
        }
        // type == 2
        if (!weekAvailability[currentDayIndex])  {
            weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
        }
        
        weekAvailability[currentDayIndex].setIsWorkingDay(false);
        weekAvailability[currentDayIndex].setAvailability([]);
        return true;
    },
    copyDefaultWeekDay: function(index) {
        var copy = (this.calendarWeekAvailability[index] || this.defaultWeekAvailability[index]).copy();
        // copy should be a phantom
        copy.phantom = true;
        copy.beginEdit();
        copy.setType('WEEKDAYOVERRIDE');
        copy.setOverrideStartDate(this.startDate);
        copy.setOverrideEndDate(this.endDate);
        copy.setName(this.weekName);
        copy.endEdit();
        return copy;
    },
    readFromData: function(intervalsToRestore) {
        var day = this.getCurrentWeekDay(this.currentDayIndex);
        var type = this.getCurrentTypeOfWeekDay(this.currentDayIndex);
        var grid = this.getAvailabilityGrid();
        grid.setAvailability(intervalsToRestore || day.getAvailability());
        var group = this.getDayTypeRadioGroup();
        group.suspendEvents();
        group.setValue({
            IsWorkingDay: [
                type
            ]
        });
        group.resumeEvents();
        grid.setDisabled(type != 1);
    },
    onDayTypeChanged: function(sender, newValue, oldValue) {
        var value = sender.getValue();
        // ignore case when no radio buttons selected?
        // weird call with empty object as "newValue"
        if (value.IsWorkingDay == null || Ext.isArray(value.IsWorkingDay))  {
            return;
        }
        
        var weekAvailability = this.weekAvailability;
        var backupWeekAvailability = this.backupWeekAvailability;
        var currentDayIndex = this.currentDayIndex;
        var availabilityGrid = this.getAvailabilityGrid();
        var intervalsToRestore;
        if (oldValue.IsWorkingDay == 1)  {
            backupWeekAvailability[currentDayIndex] = availabilityGrid.getIntervals();
        }
        
        switch (value.IsWorkingDay) {
            case 0:
                weekAvailability[currentDayIndex] = null;
                break;
            case 1:
                if (!weekAvailability[currentDayIndex])  {
                    weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
                }
                ;
                intervalsToRestore = backupWeekAvailability[currentDayIndex];
                weekAvailability[currentDayIndex].setIsWorkingDay(true);
                break;
            case 2:
                if (!weekAvailability[currentDayIndex])  {
                    weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
                }
                ;
                weekAvailability[currentDayIndex].setAvailability([]);
                weekAvailability[currentDayIndex].setIsWorkingDay(false);
                break;
            default:
                throw "Unrecognized day type";
        }
        this.readFromData(intervalsToRestore);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.widget.calendar.DatePicker', {
    extend: 'Ext.picker.Date',
    alias: 'widget.gntdatepicker',
    workingDayCls: 'gnt-datepicker-workingday',
    nonWorkingDayCls: 'gnt-datepicker-nonworkingday',
    overriddenDayCls: 'gnt-datepicker-overriddenday',
    overriddenWeekDayCls: 'gnt-datepicker-overriddenweekday',
    weekOverridesStore: null,
    dayOverridesCalendar: null,
    // @OVERRIDE
    // Adds custom classes to certain day cells
    update: function() {
        this.callParent(arguments);
        this.refreshCssClasses();
    },
    refreshCssClasses: function() {
        var me = this,
            cells = me.cells.elements;
        this.removeCustomCls();
        for (var i = 0; i < me.numDays; i++) {
            // will contain number of ms since Epoch, so need to convert it into Date on the next line
            var timestamp = cells[i].firstChild.dateValue;
            cells[i].className += ' ' + this.getDateCls(new Date(timestamp));
        }
    },
    getDateCls: function(date) {
        var cls = "";
        if (date.getMonth() !== this.getActive().getMonth())  {
            return;
        }
        
        var dayOverridesCalendar = this.dayOverridesCalendar;
        if (dayOverridesCalendar.getOwnCalendarDay(date)) {
            cls += " " + this.overriddenDayCls;
            if (!dayOverridesCalendar.isWorkingDay(date))  {
                cls += " " + this.nonWorkingDayCls;
            }
            
        } else {
            // this will be an internal week override model instance from the weekStore
            var week = null;
            this.weekOverridesStore.each(function(internalWeekModel) {
                if (Ext.Date.between(date, internalWeekModel.get('startDate'), internalWeekModel.get('endDate'))) {
                    week = internalWeekModel;
                    return false;
                }
            });
            if (week) {
                cls += " " + this.overriddenWeekDayCls;
                var index = date.getDay(),
                    weekAvailability = week.get('weekAvailability');
                if (weekAvailability && weekAvailability[index] && !weekAvailability[index].getIsWorkingDay()) {
                    cls += " " + this.nonWorkingDayCls;
                }
            } else if (!dayOverridesCalendar.isWorkingDay(date)) {
                cls += " " + this.nonWorkingDayCls;
            }
        }
        return cls || this.workingDayCls;
    },
    removeCustomCls: function() {
        this.cells.removeCls([
            this.overriddenDayCls,
            this.nonWorkingDayCls,
            this.workingDayCls,
            this.overriddenWeekDayCls
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

 @class Gnt.widget.calendar.Calendar
 @extends Ext.form.Panel
 @aside guide gantt_calendars

 {@img gantt/images/calendar.png}

 This widget can be used to edit the calendar content. As the input it should receive an instance of the {@link Gnt.data.Calendar} class.
 Once the editing is done and user is happy with the result the {@link #applyChanges} method should be called. It will apply
 all the changes user made in UI to the calendar.

 Note, this widget does not have the "Ok", "Apply changes" etc button intentionally, as you might want to combine it with your widgets.
 See {@link Gnt.widget.calendar.CalendarWindow} for this widget embedded in the Ext.window.Window instance.


 */
Ext.define('Gnt.widget.calendar.Calendar', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.XTemplate',
        'Ext.data.Store',
        'Ext.grid.Panel',
        'Ext.grid.plugin.CellEditing',
        'Ext.layout.container.HBox',
        'Ext.layout.container.Column',
        'Ext.layout.container.Fit',
        'Ext.layout.container.Anchor',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Text',
        'Ext.tab.Panel',
        'Gnt.data.Calendar',
        'Gnt.model.Week',
        'Gnt.widget.calendar.DayEditor',
        'Gnt.widget.calendar.WeekEditor',
        'Gnt.widget.calendar.DatePicker',
        'Gnt.template.CalendarLegend',
        'Gnt.template.CalendarDateInfo'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendar',
    defaults: {
        border: false
    },
    /**
     * @cfg {String} workingDayCls class will be applied to all working days at legend block and datepicker
     */
    workingDayCls: 'gnt-datepicker-workingday',
    /**
     * @cfg {string} nonWorkingDayCls class will be applied to all non-working days at legend block and datepicker
     */
    nonWorkingDayCls: 'gnt-datepicker-nonworkingday',
    /**
     * @cfg {String} overriddenDayCls class will be applied to all overridden days at legend block and datepicker
     */
    overriddenDayCls: 'gnt-datepicker-overriddenday',
    /**
     * @cfg {String} overriddenWeekDayCls class will be applied to all overridden days inside overridden week at legend block and date picker
     */
    overriddenWeekDayCls: 'gnt-datepicker-overriddenweekday',
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar: null,
    calendarManager: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - dayOverrideNameHeaderText : 'Name',
     - overrideName        : 'Name',
     - startDate           : 'Start Date',
     - endDate             : 'End Date',
     - error               : 'Error',
     - dateText            : 'Date',
     - addText             : 'Add',
     - editText            : 'Edit',
     - removeText          : 'Remove',
     - workingDayText      : 'Working day',
     - weekendsText        : 'Weekends',
     - overriddenDayText   : 'Overridden day',
     - overriddenWeekText  : 'Overridden week',
     - workingTimeText     : 'Working time',
     - nonworkingTimeText  : 'Non-working time',
     - dayOverridesText    : 'Day overrides',
     - weekOverridesText   : 'Week overrides',
     - okText              : 'OK',
     - cancelText          : 'Cancel',
     - parentCalendarText  : 'Parent calendar',
     - noParentText        : 'No parent',
     - selectParentText    : 'Select parent',
     - newDayName          : '[Without name]',
     - calendarNameText    : 'Calendar name',
     - tplTexts            : {
            - tplWorkingHours : 'Working hours for',
            - tplIsNonWorking : 'is non-working',
            - tplOverride     : 'override',
            - tplInCalendar   : 'in calendar',
            - tplDayInCalendar: 'standard day in calendar'
        },
     - overrideErrorText   : 'There is already an override for this day',
     - overrideDateError   : 'There is already week override on this date: {0}',
     - startAfterEndError  : 'Start date should be less than end date',
     - weeksIntersectError : 'Week overrides should not intersect'
     */
    /**
     * @cfg {Object} dayGridConfig A custom config object to use when configuring the day overrides grid (Ext.grid.Panel instance).
     */
    dayGridConfig: null,
    /**
     * @cfg {Object} weekGridConfig A custom config object to use when configuring the week overrides grid (Ext.grid.Panel instance).
     */
    weekGridConfig: null,
    /**
     * @cfg {Object} datePickerConfig A custom config object to use when configuring the {@link Gnt.widget.calendar.DatePicker} instance.
     */
    datePickerConfig: null,
    /**
     * @cfg {Boolean} readOnly Set to true to disable editing
     */
    readOnly: false,
    /**
     * @property {Ext.grid.Panel} dayGrid Day overrides grid reference.
     */
    dayGrid: null,
    /**
     * @property {Ext.grid.Panel} weekGrid Week overrides grid reference.
     */
    weekGrid: null,
    /**
     * @property {Gnt.widget.calendar.DatePicker} datePicker Date picker reference.
     */
    datePicker: null,
    legendTpl: null,
    dateInfoTpl: null,
    dayOverridesCalendar: null,
    weekOverridesStore: null,
    // reference to a window with day override editor used only in tests for now
    currentDayOverrideEditor: null,
    calendarDayModel: null,
    scrollable: true,
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this;
        // compiles templates
        me.setupTemplates();
        var calendar = me.calendar;
        if (!calendar && me.calendarManager) {
            calendar = me.calendarManager.getProjectCalendar() || me.calendarManager.getRoot().firstChild;
        }
        //  we need "calendarDayModel" to build days override grid
        if (!me.calendarDayModel)  {
            me.calendarDayModel = calendar && calendar.getModel && calendar.getModel() || calendar.model;
        }
        
        // fills the panel "items"
        me.buildItems();
        me.bindListeners();
        me.callParent(arguments);
        me.projectCalendarCheckbox = me.down('#projectCalendarCheckbox');
        me.projectCalendarCheckbox.setVisible(me.calendarManager);
        me.setReadOnly(me.readOnly);
        // update the panel UI with active calendar data
        calendar && me.setCalendar(calendar);
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.cmbParentCalendar.setDisabled(readOnly);
        this.down('#calendarName').setDisabled(readOnly);
        if (this.calendarManager && this.calendarManager.getProjectCalendar() !== this.calendar) {
            this.projectCalendarCheckbox.setDisabled(readOnly);
        }
        // disable/enable grids editing plugins and toolbar buttons
        this.setGridReadOnly(this.dayGrid, readOnly);
        this.setGridReadOnly(this.weekGrid, readOnly);
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    /**
     * Returns true if the widget is currently read only.
     * @return {Boolean} readOnly
     */
    isReadOnly: function() {
        return this.getReadOnly();
    },
    setGridReadOnly: function(grid, readOnly) {
        var editingPlugin = grid.getPlugin('editingPlugin');
        // disable/enable grid editing plugin if any
        editingPlugin && editingPlugin[readOnly ? 'disable' : 'enable']();
        // disable/enable toolbar buttons we're aware of
        grid.down('#btnAdd').setDisabled(readOnly);
        grid.down('#btnEdit').setDisabled(readOnly);
        grid.down('#btnRemove').setDisabled(readOnly);
    },
    bindListeners: function() {
        var me = this;
        me.on('calendarset', me.onCalendarSet);
        me.on('afterrender', me.onCalendarSet);
        me.dayGrid.on({
            selectionchange: me.onDayGridSelectionChange,
            validateedit: me.onDayGridValidateEdit,
            edit: me.onDayGridEdit,
            scope: me
        });
        me.dayGrid.store.on({
            update: me.refreshView,
            remove: me.refreshView,
            add: me.refreshView,
            scope: me
        });
        me.weekGrid.on({
            selectionchange: me.onWeekGridSelectionChange,
            validateedit: me.onWeekGridValidateEdit,
            edit: me.onWeekGridEdit,
            scope: me
        });
        me.weekGrid.store.on({
            update: me.refreshView,
            remove: me.refreshView,
            add: me.refreshView,
            scope: me
        });
        me.datePicker.on({
            select: me.onDateSelect,
            scope: me
        });
    },
    buildItems: function() {
        this.dateInfoPanel = new Ext.Component({
            cls: 'gnt-calendar-dateinfo',
            margin: '20 10',
            flex: 1,
            border: false
        });
        this.cmbParentCalendar = new Ext.form.field.ComboBox({
            name: 'cmb_parentCalendar',
            fieldLabel: this.L('parentCalendarText'),
            labelAlign: 'top',
            store: {
                autoDestroy: true,
                fields: [
                    'Id',
                    'Name'
                ]
            },
            queryMode: 'local',
            displayField: 'Name',
            valueField: 'Id',
            anchor: '100%',
            editable: false,
            emptyText: this.L('selectParentText')
        });
        this.buildWeekGrid();
        this.buildDayGrid();
        this.buildDatePicker();
        this.items = [
            {
                xtype: 'container',
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        flex: 1,
                        margin: '15 5 15 15',
                        layout: 'anchor',
                        items: [
                            {
                                xtype: 'fieldcontainer',
                                defaults: {
                                    width: '100%'
                                },
                                layout: 'vbox',
                                items: [
                                    {
                                        xtype: 'textfield',
                                        itemId: 'calendarName',
                                        labelAlign: 'top',
                                        fieldLabel: this.L('calendarNameText')
                                    },
                                    {
                                        xtype: 'checkbox',
                                        itemId: 'projectCalendarCheckbox',
                                        fieldLabel: this.L('isProjectCalendarText')
                                    },
                                    this.cmbParentCalendar
                                ]
                            },
                            {
                                xtype: 'component',
                                padding: '10 0 0 0',
                                renderTpl: this.legendTpl,
                                anchor: '100%',
                                renderData: {
                                    workingDayText: this.L('workingDayText'),
                                    weekendsText: this.L('weekendsText'),
                                    overriddenDayText: this.L('overriddenDayText'),
                                    overriddenWeekText: this.L('overriddenWeekText'),
                                    workingDayCls: this.workingDayCls,
                                    nonWorkingDayCls: this.nonWorkingDayCls,
                                    overriddenDayCls: this.overriddenDayCls,
                                    overriddenWeekDayCls: this.overriddenWeekDayCls
                                }
                            }
                        ]
                    },
                    this.datePicker,
                    this.dateInfoPanel
                ]
            },
            {
                xtype: 'tabpanel',
                minHeight: 200,
                flex: 1,
                items: [
                    this.dayGrid,
                    this.weekGrid
                ]
            }
        ];
    },
    buildDayGrid: function() {
        var calendarDayModel = this.calendarDayModel.prototype;
        // create day overrides grid
        this.dayGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L('dayOverridesText'),
            itemId: 'dayGrid',
            tbar: [
                {
                    text: this.L('addText'),
                    itemId: 'btnAdd',
                    action: 'add',
                    iconCls: 'gnt-action-add',
                    handler: this.addDay,
                    scope: this
                },
                {
                    text: this.L('editText'),
                    itemId: 'btnEdit',
                    action: 'edit',
                    iconCls: 'gnt-action-edit',
                    handler: this.editDay,
                    scope: this
                },
                {
                    text: this.L('removeText'),
                    itemId: 'btnRemove',
                    action: 'remove',
                    iconCls: 'gnt-action-remove',
                    handler: this.removeDay,
                    scope: this
                }
            ],
            store: new Gnt.data.Calendar(),
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2,
                    pluginId: 'editingPlugin'
                })
            ],
            columns: [
                {
                    header: this.L('dayOverrideNameHeaderText'),
                    dataIndex: calendarDayModel.nameField,
                    flex: 1,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    header: this.L('dateText'),
                    dataIndex: calendarDayModel.dateField,
                    width: 100,
                    xtype: 'datecolumn',
                    editor: {
                        xtype: 'datefield'
                    }
                }
            ]
        }, this.dayGridConfig || {}));
        this.dayOverridesCalendar = this.dayGrid.store;
    },
    updateGrids: function() {
        this.dayGrid && this.fillDaysStore();
        this.weekGrid && this.fillWeeksStore();
    },
    buildWeekGrid: function() {
        // create week overrides grid
        this.weekGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L('weekOverridesText'),
            itemId: 'weekGrid',
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2,
                    pluginId: 'editingPlugin'
                })
            ],
            store: new Ext.data.Store({
                autoDestroy: true,
                model: 'Gnt.model.Week'
            }),
            tbar: [
                {
                    text: this.L('addText'),
                    itemId: 'btnAdd',
                    action: 'add',
                    iconCls: 'gnt-action-add',
                    handler: this.addWeek,
                    scope: this
                },
                {
                    text: this.L('editText'),
                    itemId: 'btnEdit',
                    action: 'edit',
                    iconCls: 'gnt-action-edit',
                    handler: this.editWeek,
                    scope: this
                },
                {
                    text: this.L('removeText'),
                    itemId: 'btnRemove',
                    action: 'remove',
                    iconCls: 'gnt-action-remove',
                    handler: this.removeWeek,
                    scope: this
                }
            ],
            columns: [
                {
                    header: this.L('overrideName'),
                    dataIndex: 'name',
                    flex: 1,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('startDate'),
                    dataIndex: 'startDate',
                    width: 100,
                    editor: {
                        xtype: 'datefield'
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('endDate'),
                    dataIndex: 'endDate',
                    width: 100,
                    editor: {
                        xtype: 'datefield'
                    }
                }
            ]
        }, this.weekGridConfig || {}));
        this.weekOverridesStore = this.weekGrid.store;
    },
    buildDatePicker: function() {
        this.datePicker = new Gnt.widget.calendar.DatePicker(Ext.apply({
            dayOverridesCalendar: this.dayGrid.store,
            weekOverridesStore: this.weekGrid.store,
            margin: '15 10 0 10',
            showToday: false
        }, this.datePickerConfig));
    },
    onCalendarSet: function() {
        // data is an array of objects and store is considered as containing a modified records
        this.weekOverridesStore.commitChanges();
    },
    setCalendar: function(calendar) {
        if (this.calendar) {
            this.mun(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            });
        }
        this.calendar = calendar;
        if (calendar) {
            this.mon(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            });
        }
        this.onCalendarChange();
        this.fireEvent('calendarset', calendar);
    },
    onParentChange: function() {
        this.updateComboBox();
    },
    updateComboBox: function() {
        var me = this,
            calendars = [];
        // Collect records for the combobox dropdown list, all calendars except the one being edited
        if (me.calendarManager) {
            var root = me.calendarManager.getRoot();
            var activeNode = me.calendarManager.getNodeByCalendar(me.calendar);
            root.cascadeBy(function(item) {
                var calendar = item.getCalendar();
                if (item !== root && item !== activeNode && !activeNode.contains(item)) {
                    calendars.push({
                        Id: calendar.calendarId,
                        Name: item.getName() || calendar.calendarId
                    });
                }
            });
        } else {
            calendars = me.calendar.getParentableCalendars();
        }
        // fill the combobx store
        this.cmbParentCalendar.store.loadData([
            {
                Id: -1,
                Name: this.L('noParentText')
            }
        ].concat(calendars));
        var parent = this.calendar && this.calendar.parent,
            parentId = parent && parent.calendarId;
        this.cmbParentCalendar.setValue(parentId || -1);
    },
    onCalendarChange: function() {
        this.updateComboBox();
        if (this.calendarManager) {
            var isProjectCalendar = this.calendar === this.calendarManager.getProjectCalendar();
            this.projectCalendarCheckbox.setDisabled(isProjectCalendar);
            this.projectCalendarCheckbox.setValue(isProjectCalendar);
        }
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView();
    },
    setupTemplates: function() {
        var tplTexts = this.L('tplTexts');
        if (!(this.dateInfoTpl instanceof Ext.Template)) {
            this.dateInfoTpl = new Gnt.template.CalendarDateInfo({
                workingHoursText: tplTexts.tplWorkingHours,
                nonWorkingText: tplTexts.tplIsNonWorking,
                basedOnText: tplTexts.tplBasedOn,
                overrideText: tplTexts.tplOverride,
                inCalendarText: tplTexts.tplInCalendar,
                dayInCalendarText: tplTexts.tplDayInCalendar
            });
        }
        if (!(this.legendTpl instanceof Ext.Template)) {
            this.legendTpl = new Gnt.template.CalendarLegend();
        }
    },
    afterRender: function() {
        this.callParent(arguments);
        this.onDateSelect(this.datePicker, new Date());
    },
    fillDaysStore: function() {
        // only filter days with type "DAY" that has "Date" set
        var dataTemp = Gnt.util.Data.cloneModelSet(this.calendar, function(calendarDay) {
                return (calendarDay.getType() == 'DAY' && calendarDay.getDate());
            });
        this.dayOverridesCalendar.loadData(dataTemp);
    },
    copyCalendarDay: function(calendarDay) {
        var copy = calendarDay.copy(null);
        copy.__COPYOF__ = calendarDay.getId();
        return copy;
    },
    fillWeeksStore: function() {
        var me = this;
        var data = [];
        this.calendar.forEachNonStandardWeek(function(nonStandardWeek) {
            var week = Ext.apply({}, nonStandardWeek);
            week.weekAvailability = Ext.Array.map(week.weekAvailability, function(day) {
                return day && me.copyCalendarDay(day) || null;
            });
            week.mainDay = me.copyCalendarDay(week.mainDay);
            data.push(week);
        });
        this.weekOverridesStore.loadData(data);
    },
    addDay: function() {
        var date = this.datePicker.getValue();
        // do not allow duplicate day overrides
        if (this.dayOverridesCalendar.getOwnCalendarDay(date)) {
            this.alert({
                msg: this.L('overrideErrorText')
            });
            return;
        }
        var dayModel = this.calendar.model;
        var dayProto = dayModel.prototype;
        var newDay = {};
        newDay[dayProto.nameField] = this.L('newDayName');
        newDay[dayProto.typeField] = 'DAY';
        newDay[dayProto.dateField] = date;
        newDay = new dayModel(newDay);
        //this.dayOverridesCalendar.insert(0, newDay);
        this.dayGrid.getStore().insert(0, newDay);
        this.dayGrid.getSelectionModel().select([
            newDay
        ], false, false);
    },
    editDay: function() {
        var me = this,
            selection = this.dayGrid.getSelection(),
            day = selection[0];
        if (day) {
            var editor = this.currentDayOverrideEditor = new Gnt.widget.calendar.DayEditor({
                    addText: this.L('addText'),
                    removeText: this.L('removeText'),
                    workingTimeText: this.L('workingTimeText'),
                    nonworkingTimeText: this.L('nonworkingTimeText'),
                    calendarDay: day
                });
            var editorWindow = Ext.create('Ext.window.Window', {
                    title: this.L('dayOverridesText'),
                    modal: true,
                    width: 280,
                    height: 260,
                    layout: 'fit',
                    items: editor,
                    buttons: [
                        {
                            text: this.L('okText'),
                            handler: function() {
                                if (editor.isValid()) {
                                    var calendarDay = editor.calendarDay;
                                    calendarDay.setIsWorkingDay(editor.isWorkingDay());
                                    calendarDay.setAvailability(editor.getIntervals());
                                    me.applyCalendarDay(calendarDay, day);
                                    me.refreshView();
                                    editorWindow.close();
                                }
                            }
                        },
                        {
                            text: this.L('cancelText'),
                            handler: function() {
                                editorWindow.close();
                            }
                        }
                    ]
                });
            editorWindow.show();
        }
    },
    removeDay: function() {
        var grid = this.dayGrid,
            selection = grid.getSelection();
        if (!selection[0])  {
            return;
        }
        
        grid.getStore().remove(selection[0]);
        this.refreshView();
    },
    refreshView: function() {
        var date = this.datePicker.getValue(),
            day = this.getCalendarDay(date),
            weekGrid = this.weekGrid,
            dayGrid = this.dayGrid,
            dayOverride = this.dayOverridesCalendar.getOwnCalendarDay(date),
            weekOverride;
        var name;
        // First check if there is an override on day level
        if (dayOverride) {
            dayGrid.getSelectionModel().select([
                dayOverride
            ], false, true);
            name = dayOverride.getName();
        } else {
            // Now check if there is an override on week level
            weekOverride = this.getWeekOverrideByDate(date);
            if (weekOverride) {
                weekGrid.getSelectionModel().select([
                    weekOverride
                ], false, true);
                name = weekOverride.get('name');
            }
        }
        var dayData = {
                name: name || day.getName(),
                date: Ext.Date.format(date, 'M j, Y'),
                calendarName: this.calendar.name || this.calendar.calendarId,
                availability: day.getAvailability(true),
                override: Boolean(dayOverride || weekOverride),
                isWorkingDay: day.getIsWorkingDay()
            };
        this.dateInfoPanel.update(this.dateInfoTpl.apply(dayData));
        this.down('#calendarName').setValue(this.calendar.name);
        this.datePicker.rendered && this.datePicker.refreshCssClasses();
    },
    onDayGridSelectionChange: function(grid, selection) {
        if (selection[0]) {
            this.datePicker.setValue(selection[0].getDate());
            this.refreshView();
        }
    },
    onDayGridEdit: function(editor, context) {
        if (context.field === 'Date') {
            context.grid.getStore().clearCache();
            this.datePicker.setValue(context.value);
        }
        this.refreshView();
    },
    onDayGridValidateEdit: function(editor, context) {
        var calendar = this.dayGrid.store;
        if (context.value && context.field === calendar.model.prototype.dateField && calendar.getOwnCalendarDay(context.value) && context.value !== context.originalValue) {
            this.alert({
                msg: this.L('overrideErrorText')
            });
            return false;
        }
    },
    onDateSelect: function() {
        this.refreshView();
    },
    getCalendarDay: function(date) {
        var day = this.dayOverridesCalendar.getOwnCalendarDay(date);
        if (day)  {
            return day;
        }
        
        day = this.getWeekOverrideDay(date);
        if (day)  {
            return day;
        }
        
        return this.calendar.weekAvailability[date.getDay()] || this.calendar.defaultWeekAvailability[date.getDay()];
    },
    getWeekOverrideDay: function(date) {
        var internalWeekModel = this.getWeekOverrideByDate(date),
            index = date.getDay();
        if (internalWeekModel == null)  {
            return null;
        }
        
        var weekAvailability = internalWeekModel.get('weekAvailability');
        if (!weekAvailability)  {
            return null;
        }
        
        return weekAvailability[index];
    },
    getWeekOverrideByDate: function(date) {
        var week = null;
        this.weekOverridesStore.each(function(internalWeekModel) {
            if (Ext.Date.between(date, internalWeekModel.get('startDate'), internalWeekModel.get('endDate'))) {
                week = internalWeekModel;
                return false;
            }
        });
        return week;
    },
    intersectsWithCurrentWeeks: function(startDate, endDate, except) {
        var result = false;
        this.weekOverridesStore.each(function(internalWeekModel) {
            if (internalWeekModel == except)  {
                return;
            }
            
            var weekStartDate = internalWeekModel.get('startDate');
            var weekEndDate = internalWeekModel.get('endDate');
            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    },
    addWeek: function() {
        var weekOverridesStore = this.weekOverridesStore;
        var startDate = this.datePicker.getValue();
        var endDate;
        // we are about to create a week override and we need to make sure it does not
        // intersect with already created week overrides. Also we'd like to make it 1w long initially
        // but in case there will be an intersection with current overrides we are ok to shorten it
        for (var duration = 7; duration > 0; duration--) {
            endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, duration);
            if (!this.intersectsWithCurrentWeeks(startDate, endDate))  {
                break;
            }
            
        }
        if (!duration) {
            this.alert({
                msg: Ext.String.format(this.L('overrideDateError'), Ext.Date.format(startDate, 'Y/m/d'))
            });
            return;
        }
        var mainDay = new this.calendar.model();
        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setName(this.L('newDayName'));
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);
        var newWeek = weekOverridesStore.insert(0, {
                name: this.L('newDayName'),
                startDate: startDate,
                endDate: endDate,
                weekAvailability: [],
                mainDay: mainDay
            })[0];
        this.weekGrid.getSelectionModel().select([
            newWeek
        ], false, false);
    },
    editWeek: function() {
        var selection = this.weekGrid.getSelection(),
            me = this;
        if (selection.length === 0)  {
            return;
        }
        
        var weekModel = selection[0];
        var editor = new Gnt.widget.calendar.WeekEditor({
                startDate: weekModel.get('startDate'),
                endDate: weekModel.get('endDate'),
                weekName: weekModel.get('name'),
                calendarDayModel: this.calendar.model,
                // keep the "weekModel" private and pass individual fields to the editor
                weekAvailability: weekModel.get('weekAvailability'),
                calendarWeekAvailability: this.calendar.weekAvailability,
                defaultWeekAvailability: this.calendar.defaultWeekAvailability
            });
        var editorWindow = Ext.create('Ext.window.Window', {
                title: this.L('weekOverridesText'),
                modal: true,
                width: 370,
                defaults: {
                    border: false
                },
                layout: 'fit',
                items: editor,
                buttons: [
                    {
                        // this property will be used in test to locate the button
                        action: 'ok',
                        text: this.L('okText'),
                        handler: function() {
                            if (editor.applyChanges(weekModel.get('weekAvailability'))) {
                                me.refreshView();
                                editorWindow.close();
                            }
                        }
                    },
                    {
                        text: this.L('cancelText'),
                        handler: function() {
                            editorWindow.close();
                        }
                    }
                ]
            });
        editorWindow.show();
    },
    removeWeek: function() {
        var selection = this.weekGrid.getSelection();
        if (selection[0]) {
            this.weekOverridesStore.remove(selection[0]);
            this.refreshView();
        }
    },
    onWeekGridSelectionChange: function(grid, selection) {
        if (selection[0]) {
            this.datePicker.setValue(selection[0].get('startDate'));
        }
    },
    onWeekGridEdit: function(editor, context) {
        var weekModel = context.record,
            startDate = weekModel.get('startDate'),
            endDate = weekModel.get('endDate');
        if (context.field == 'startDate' || context.field == 'endDate') {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    weekDay.setOverrideStartDate(startDate);
                    weekDay.setOverrideEndDate(endDate);
                }
            });
            this.datePicker.setValue(startDate);
        }
        //        if (context.field == 'name') {
        //            weekModel.setName(weekModel.getName());
        //            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function (weekDay) {
        //                if (weekDay) {
        //                    weekDay.setName(weekModel.get('name'));
        //                }
        //            });
        //        }
        this.refreshView();
    },
    alert: function(config) {
        config = config || {};
        Ext.MessageBox.show(Ext.applyIf(config, {
            title: this.L('error'),
            icon: Ext.MessageBox.WARNING,
            buttons: Ext.MessageBox.OK
        }));
    },
    onWeekGridValidateEdit: function(editor, context) {
        var weekModel = context.record,
            startDate = context.field == 'startDate' ? context.value : weekModel.get('startDate'),
            endDate = context.field == 'endDate' ? context.value : weekModel.get('endDate');
        if (startDate > endDate) {
            this.alert({
                msg: this.L('startAfterEndError')
            });
            return false;
        }
        if (this.intersectsWithCurrentWeeks(startDate, endDate, weekModel)) {
            this.alert({
                msg: this.L('weeksIntersectError')
            });
            return false;
        }
    },
    applyCalendarDay: function(from, to) {
        to.beginEdit();
        to.setName(from.getName());
        to.setIsWorkingDay(from.getIsWorkingDay());
        to.setDate(from.getDate());
        to.setOverrideStartDate(from.getOverrideStartDate());
        to.setOverrideEndDate(from.getOverrideEndDate());
        var fromAvailability = from.getAvailability(true);
        var toAvailability = to.getAvailability(true);
        if (fromAvailability + '' != toAvailability + '')  {
            to.setAvailability(from.getAvailability());
        }
        
        to.endEdit();
    },
    applySingleDay: function(copyDay, toAdd) {
        if (copyDay.__COPYOF__) {
            this.applyCalendarDay(copyDay, this.calendar.getModelById(copyDay.__COPYOF__));
        } else {
            if (copyDay.store) {
                copyDay.unjoin(copyDay.store);
            }
            // we reset id to not intersect w/ existing records
            copyDay.setId(null);
            toAdd.push(copyDay.getData());
        }
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     *
     */
    applyChanges: function() {
        var me = this;
        var calendar = this.calendar;
        var parent = this.down('combobox[name="cmb_parentCalendar"]').getValue(),
            newName = this.down('#calendarName').getValue(),
            setProjectCalendar = this.projectCalendarCheckbox.getValue();
        if (this.calendarManager) {
            var node = this.calendarManager.getModelById(calendar.calendarId);
            if (node) {
                node.setName(newName);
            }
            if (this.calendarManager.getProjectCalendar() !== calendar && setProjectCalendar) {
                this.projectCalendarCheckbox.setDisabled(true);
                this.calendarManager.setProjectCalendar(calendar);
            }
        }
        calendar.suspendEvents(true);
        calendar.suspendCacheUpdate++;
        calendar.name = newName;
        calendar.setParent(parent ? Gnt.data.Calendar.getCalendar(parent) : null);
        if (calendar.getProxy() && calendar.getProxy().extraParams) {
            calendar.getProxy().extraParams.calendarId = calendar.calendarId;
        }
        // days part
        Gnt.util.Data.applyCloneChanges(this.dayOverridesCalendar, calendar);
        var daysToAdd = [];
        var daysToRemove = [];
        var remainingWeekDays = {};
        // weeks part
        this.weekOverridesStore.each(function(weekModel) {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    if (weekDay.__COPYOF__)  {
                        remainingWeekDays[weekDay.__COPYOF__] = true;
                    }
                    
                    me.applySingleDay(weekDay, daysToAdd);
                }
            });
        });
        calendar.forEachNonStandardWeek(function(originalWeek) {
            Ext.Array.each(originalWeek.weekAvailability.concat(originalWeek.mainDay), function(originalWeekDay) {
                if (originalWeekDay && !remainingWeekDays[originalWeekDay.getId()])  {
                    daysToRemove.push(originalWeekDay);
                }
                
            });
        });
        calendar.add(daysToAdd);
        calendar.remove(daysToRemove);
        calendar.suspendCacheUpdate--;
        calendar.clearCache();
        calendar.resumeEvents();
        this.fireEvent('calendarset', calendar);
    },
    hasChanges: function() {
        if (!this.calendar)  {
            return false;
        }
        
        var dayChanges = this.dayOverridesCalendar.getModifiedRecords().length || this.dayOverridesCalendar.getRemovedRecords().length,
            weekChanges = this.weekOverridesStore.getModifiedRecords().length || this.weekOverridesStore.getRemovedRecords().length,
            // isDirty on field wouldn't work correct, so we are going to check it differently
            nameChanged = this.down('#calendarName').getValue() != this.calendar.name,
            parentId = this.calendar.parent && this.calendar.parent.calendarId || -1,
            parentChanged = this.cmbParentCalendar.getValue() != parentId,
            checkboxChanged = false;
        if (this.calendarManager) {
            checkboxChanged = this.projectCalendarCheckbox.getValue() && (this.calendarManager.getProjectCalendar() !== this.calendar);
        }
        return dayChanges || weekChanges || nameChanged || parentChanged || checkboxChanged;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.widget.calendar.CalendarManager
@extends Ext.panel.Panel
@aside guide gantt_calendars

{@img gantt/images/calendar_manager.png}

This widget can be used to manage calendars. As the input it should receive an instance of the {@link Gnt.data.CalendarManager} class.
Displays hierarchy of calendars attached to this CalendarManager and allows to edit calendar itself using {@link Gnt.data.widget.calendar.Calendar}.
Once the editing is done and user is happy with the result the {@link #applyChanges} method should be called. It will apply
all the changes user made in UI to the calendar.
This widget also checks changes in calendar when user navigates through the tree. In case changes were made widget displays confirmation
window with buttons "yes", "no", "cancel".

Note, this widget does not have the "Ok", "Apply changes" etc button intentionally, as you might want to combine it with your widgets.
See {@link Gnt.widget.calendar.CalendarManagerWindow} for this widget embedded in the Ext.window.Window instance.

    calendarManager = Ext.create('Gnt.data.CalendarManager', {});

    calendarManagerWidget = new Gnt.widget.calendar.CalendarManager({
        calendarManager : calendarManager
    });

*/
Ext.define('Gnt.widget.calendar.CalendarManager', {
    extend: 'Ext.Container',
    requires: [
        'Ext.tree.Panel',
        'Ext.menu.Menu',
        'Ext.tree.plugin.TreeViewDragDrop',
        'Gnt.patches.TreeViewDragDrop',
        'Gnt.widget.calendar.Calendar',
        'Gnt.data.calendar.BusinessTime'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarmanager',
    /**
     * @cfg {Object} treePanelConfig A configuration for the underlying tree panel
     */
    treePanelConfig: null,
    /**
     * @property {Ext.tree.Panel} treePanel Underlying tree panel
     */
    treePanel: null,
    /**
     * @cfg {Object} calendarPanelConfig A configuration for the underlying {@link Gnt.widget.calendar.Calendar calendar widget instance}
     */
    calendarPanelConfig: null,
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager Store keeping calendars to be shown in the component
     */
    calendarManager: null,
    /**
     * @cfg {Boolean} readOnly Set to true to disable editing
     */
    readOnly: false,
    /**
     * @property {Gnt.widget.calendar.Calendar} calendarPanel Underlying {@link Gnt.widget.calendar.Calendar calendar widget instance}
     */
    calendarPanel: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - addText         : 'Add',
            - removeText      : 'Remove',
            - add_child       : 'Add child',
            - add_node        : 'Add calendar',
            - add_sibling     : 'Add sibling',
            - remove          : 'Remove',
            - calendarName    : 'Calendar',
            - confirm_action  : 'Confirm action',
            - confirm_message : 'Calendar has unsaved changes. Would you like to save your changes?'
     */
    layout: 'border',
    width: 800,
    height: 600,
    initComponent: function() {
        var me = this;
        me.cls = me.cls + ' gnt-calendarmanager';
        me.treePanel = me.buildTreePanel();
        me.calendarPanel = new Gnt.widget.calendar.Calendar(Ext.apply({
            region: 'center',
            calendar: me.calendar,
            split: true,
            scrollable: true,
            calendarManager: me.calendarManager,
            readOnly: me.readOnly
        }, me.calendarPanelConfig));
        me.items = [
            me.treePanel,
            me.calendarPanel
        ];
        me.callParent(arguments);
        me.contextMenu = me.buildContextMenu();
        me.setReadOnly(me.readOnly);
        var calendarManager = me.calendarManager;
        me.setCalendar(me.calendar || calendarManager.getProjectCalendar() || calendarManager.getRoot().firstChild);
        // for debug purposes
        me.counter = 1;
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        var treePanel = this.treePanel;
        treePanel.down('#btnAdd').setDisabled(readOnly);
        treePanel.down('#btnRemove').setDisabled(readOnly);
        var treeView = treePanel.getView(),
            method = readOnly ? 'disable' : 'enable';
        if (treeView.rendered) {
            treeView.getPlugin('treeDragDrop')[method]();
        } else {
            treeView.on('render', function() {
                treeView.getPlugin('treeDragDrop')[method]();
            }, this, {
                single: true
            });
        }
        this.contextMenu.setDisabled(readOnly);
        this.calendarPanel.setReadOnly(readOnly);
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    /**
     * Returns true if the widget is currently read only.
     * @return {Boolean} readOnly
     */
    isReadOnly: function() {
        return this.getReadOnly();
    },
    buildTreePanel: function() {
        var me = this;
        return new Ext.tree.Panel(Ext.apply({
            split: true,
            region: 'west',
            width: 200,
            store: me.calendarManager,
            displayField: me.calendarManager.model.prototype.nameField,
            rootVisible: false,
            tbar: [
                {
                    itemId: 'btnAdd',
                    text: me.L('addText'),
                    action: 'add',
                    iconCls: 'gnt-action-add',
                    handler: me.doAddRootNode,
                    scope: me
                },
                {
                    itemId: 'btnRemove',
                    text: me.L('removeText'),
                    action: 'remove',
                    iconCls: 'gnt-action-remove',
                    handler: me.doRemoveCalendar,
                    scope: me
                }
            ],
            viewConfig: {
                plugins: {
                    ptype: 'treeviewdragdrop',
                    pluginId: 'treeDragDrop',
                    allowContainerDrops: true,
                    dropZone: {
                        // we want to always append child node to the hovered one
                        // this behavior isn't supported out of the box by the plugin
                        // so we override a template "onNodeDrop" method
                        onNodeDrop: function(node, dz, ev, dd) {
                            var valid = true;
                            this.overRecord = this.view.getRecord(node);
                            this.currentPosition = 'append';
                            Ext.Array.each(dd.records, function(r) {
                                if (r.contains(this.overRecord)) {
                                    valid = false;
                                    return false;
                                }
                            }, this);
                            this.valid = valid;
                            // If node is not expanded yet and we're trying to append child to it (which is not
                            // supported out of the box) ext will try to expand new parent and scroll to dropped node.
                            // But node is not visible yet, so buffered renderer will throw exception. To avoid that
                            // we set 'expanded' flag on leaf to prevent auto expand on drop and expand node later manually
                            // caught by 1121_calendar_read_only test
                            if (this.overRecord.isLeaf()) {
                                this.overRecord.set('expanded', true);
                                this.overRecord.childNodes = [];
                            }
                            // call overridden method
                            return this.self.prototype.onNodeDrop.apply(this, arguments);
                        }
                    }
                },
                getRowClass: function(record) {
                    if (me.calendarManager.getProjectCalendar() == record.calendar) {
                        return 'gnt-project-calendar-row';
                    }
                },
                listeners: {
                    drop: me.onDrop,
                    scope: me
                }
            },
            listeners: {
                containercontextmenu: me.onContainerContextMenu,
                itemcontextmenu: me.onItemContextMenu,
                selectionchange: me.onSelectionChange,
                scope: me
            }
        }, me.treePanelConfig));
    },
    buildContextMenu: function() {
        return new Ext.menu.Menu({
            margin: '0 0 10 0',
            items: [
                {
                    text: this.L('add_node'),
                    handler: this.doAddRootNode,
                    itemId: 'add-node',
                    scope: this
                },
                {
                    text: this.L('add_child'),
                    handler: this.doAddChildNode,
                    scope: this
                },
                {
                    text: this.L('add_sibling'),
                    handler: this.doAddSiblingCalendar,
                    scope: this
                },
                {
                    text: this.L('remove'),
                    handler: this.doRemoveCalendar,
                    itemId: 'remove-node',
                    scope: this
                }
            ]
        });
    },
    showContextMenu: function(e, calendar) {
        var menuItems = this.contextMenu.query('menuitem');
        Ext.Array.each(menuItems, function(x) {
            x.setVisible(!!calendar);
        });
        this.contextMenu.down('#add-node').setVisible(!calendar);
        e.stopEvent();
        this.contextMenu.showAt(e.getXY());
    },
    onContainerContextMenu: function(view, e) {
        this.showContextMenu(e);
    },
    onItemContextMenu: function(view, calendar, item, index, e) {
        this.showContextMenu(e, calendar);
    },
    hasChanges: function() {
        return this.calendarPanel.hasChanges();
    },
    onSelectionChange: function(treePanelView, selected, eOpts) {
        // Note, that when this method is called, the selection in the tree actually has already been changed.
        // But, the calendar in the center region has not been updated yet (we do it manually below with
        // calendarPanel.setCalendar() call
        // that is why `calendarPanel.calendar` still contains the data calendar from previously(!) selected calendar row in tree
        var me = this,
            calendarManager = me.calendarManager,
            calendarPanel = me.calendarPanel;
        if (selected.length > 0) {
            var selectedNode = selected[0];
            var selectedCalendar = selectedNode.getCalendar();
            var projectCalendar = calendarManager.getProjectCalendar();
            var isProjectCalendar = selectedCalendar === projectCalendar || projectCalendar && Boolean(selectedNode.findChild(selectedNode.idProperty, projectCalendar.calendarId));
            if (!me.isReadOnly()) {
                // if project calendar selected we disable remove button/menu entry
                me.treePanel.down('#btnRemove').setDisabled(isProjectCalendar);
                me.contextMenu.down('#remove-node').setDisabled(isProjectCalendar);
            }
            if (calendarPanel.calendar && calendarPanel.hasChanges()) {
                Ext.Msg.show({
                    title: me.L('confirm_action'),
                    msg: me.L('confirm_message'),
                    buttons: Ext.Msg.YESNOCANCEL,
                    icon: Ext.Msg.QUESTION,
                    fn: function(btn) {
                        // changes were accepted
                        if (btn == 'yes') {
                            me.applyChanges();
                            calendarPanel.setCalendar(selectedCalendar);
                        }
                        // changes were ignored
                        else if (btn == 'no') {
                            calendarPanel.setCalendar(selectedCalendar);
                        } else // cancel selection change
                        {
                            treePanelView.suspendEvents();
                            // select previous active node
                            treePanelView.select(calendarManager.getNodeByCalendar(calendarPanel.calendar));
                            treePanelView.resumeEvents();
                        }
                    }
                });
            } else {
                calendarPanel.setCalendar(selectedCalendar);
            }
        }
    },
    onDrop: function(node, data, overModel, dropPosition) {
        overModel = overModel || this.calendarManager.getRootNode();
        // let's expand the node in which we're dropping
        overModel.expand();
    },
    onDestroy: function() {
        this.contextMenu.destroy();
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     * @method applyChanges
     */
    applyChanges: function() {
        this.calendarPanel.applyChanges();
    },
    doAddRootNode: function() {
        this.addCalendar();
    },
    doAddChildNode: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(selection[0]);
    },
    doAddSiblingCalendar: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(selection[0] && selection[0].parentNode);
    },
    doRemoveCalendar: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.removeCalendar(selection[0]);
    },
    addCalendar: function(parent) {
        // calendar class prototype
        var calendarProto = Ext.ClassManager.get(this.calendarManager.calendarClass).prototype;
        // node class prototype
        var nodeProto = this.calendarManager.model.prototype;
        // extract calendar data to new node config
        var config = nodeProto.getModelConfig(calendarProto);
        config[nodeProto.nameField] = this.L('calendarName') + this.counter++;
        config.expanded = true;
        config.leaf = true;
        parent = parent || this.treePanel.getRootNode();
        // expand parent node
        parent.data.expanded = true;
        parent.appendChild(config);
    },
    removeCalendar: function(node) {
        var root = this.treePanel.getRootNode();
        if (node) {
            var next = node.nextSibling || node.previousSibling || (node.parentNode == root ? root.firstChild : node.parentNode);
            if (next) {
                this.treePanel.getSelectionModel().select(next);
            }
            node.remove();
        }
    },
    setCalendar: function(calendar) {
        if (calendar instanceof Gnt.model.Calendar) {
            // set focus in tree
            this.treePanel.setSelection(calendar);
        } else {
            // set focus in tree
            this.treePanel.setSelection(this.calendarManager.getNodeByCalendar(calendar));
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.widget.calendar.CalendarManagerWindow
@extends Ext.window.Window
@aside guide gantt_calendars

{@img gantt/images/calendar_manager_window.png}

This is just a {@link Gnt.widget.calendar.CalendarManager} widget, wrapped with the Ext.window.Window instance.
It proxies the {@link #calendar} config and {@link #applyChanges} method.

*/
Ext.define('Gnt.widget.calendar.CalendarManagerWindow', {
    extend: 'Ext.window.Window',
    requires: [
        'Gnt.widget.calendar.CalendarManager'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarmanagerwindow',
    layout: 'fit',
    border: false,
    constrain: true,
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}
     */
    calendarConfig: null,
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager An instance of the {@link Gnt.data.CalendarManager}
     */
    calendarManager: null,
    /**
     * @property {Gnt.widget.calendar.Calendar} panel The underlying calendar widget instance
     */
    panel: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title           : 'Calendar manager',
            - ok              : 'Ok',
            - cancel          : 'Cancel',
            - confirm_action  : 'Confirm action',
            - confirm_message : 'Calendar has unsaved changes. Would you like to save your changes?'
     */
    closing: false,
    initComponent: function() {
        this.panel = new Gnt.widget.calendar.CalendarManager({
            calendarManager: this.calendarManager,
            calendarPanelConfig: this.calendarConfig
        });
        // Only constrain width/height this way if user haven't set size
        Ext.applyIf(this, {
            width: Math.min(Ext.getBody().getWidth() - 100, 1050),
            height: Math.min(Ext.getBody().getHeight() - 100, 700)
        });
        Ext.apply(this, {
            title: this.title || this.L('title'),
            items: [
                this.panel
            ],
            buttons: [
                {
                    text: this.L('ok'),
                    handler: function() {
                        this.applyChanges();
                    },
                    scope: this
                },
                {
                    text: this.L('cancel'),
                    handler: function() {
                        this.close();
                    },
                    scope: this
                }
            ],
            listeners: {
                beforeclose: this.onBeforeClose,
                close: this.onAfterClose
            }
        });
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     */
    applyChanges: function() {
        this.panel.applyChanges();
    },
    onBeforeClose: function() {
        var me = this;
        var panel = this.panel;
        if (!me.closing && panel.hasChanges()) {
            Ext.Msg.show({
                title: me.L('confirm_action'),
                msg: me.L('confirm_message'),
                buttons: Ext.Msg.YESNOCANCEL,
                icon: Ext.Msg.QUESTION,
                fn: function(btn) {
                    switch (btn) {
                        case 'yes':
                            panel.applyChanges();
                            me.close();
                            break;
                        case 'no':
                            // set flag to skip this onBeforeClose processing again when we call me.close()
                            me.closing = true;
                            me.close();
                            break;
                    }
                }
            });
            return false;
        }
    },
    onAfterClose: function() {
        this.closing = false;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**

@class Gnt.widget.calendar.CalendarWindow
@extends Ext.window.Window
@aside guide gantt_calendars

{@img gantt/images/calendar.png}

This is just a {@link Gnt.widget.calendar.Calendar} widget, wrapped with the Ext.window.Window instance.
It proxies the {@link #calendar} config and {@link #applyChanges} method.

*/
Ext.define('Gnt.widget.calendar.CalendarWindow', {
    extend: 'Ext.window.Window',
    requires: [
        'Gnt.widget.calendar.Calendar'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarwindow',
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}
     */
    calendarConfig: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar: null,
    /**
     * @property {Gnt.widget.calendar.Calendar} calendarWidget An underlying calendar widget instance
     */
    calendarWidget: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - ok         : 'Ok',
            - cancel     : 'Cancel',
     */
    initComponent: function() {
        // Only constrain width/height this way if user haven't set size
        Ext.applyIf(this, {
            width: Math.min(Ext.getBody().getWidth() - 100, 800),
            height: Math.min(Ext.getBody().getHeight() - 100, 650)
        });
        Ext.apply(this, {
            layout: 'fit',
            title: this.title || this.L('title'),
            items: this.calendarWidget = new Gnt.widget.calendar.Calendar(Ext.apply({
                calendar: this.calendar
            }, this.calendarConfig)),
            buttons: [
                {
                    text: this.L('ok'),
                    handler: function() {
                        this.applyChanges();
                        this.close();
                    },
                    scope: this
                },
                {
                    text: this.L('cancel'),
                    handler: this.close,
                    scope: this
                }
            ]
        });
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     */
    applyChanges: function() {
        this.calendarWidget.applyChanges();
    },
    setCalendar: function(calendar) {
        this.calendarWidget.setCalendar(calendar);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Gnt.widget.calendar.ResourceCalendarGrid', {
    extend: 'Ext.grid.Panel',
    requires: [
        'Ext.data.Store',
        'Ext.grid.plugin.CellEditing',
        'Sch.util.Date',
        'Gnt.model.Calendar',
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.resourcecalendargrid',
    resourceStore: null,
    calendarStore: null,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - name      : 'Name',
            - calendar  : 'Calendar'
     */
    cellEditingConfig: null,
    initComponent: function() {
        var me = this;
        this.calendarStore = this.calendarStore || {
            xclass: 'Ext.data.Store',
            model: 'Gnt.model.Calendar'
        };
        if (!(this.calendarStore instanceof Ext.data.Store)) {
            this.calendarStore = Ext.create(this.calendarStore);
        }
        var plugin = Ext.create('Ext.grid.plugin.CellEditing', Ext.apply({
                clicksToEdit: 2
            }, this.cellEditingConfig));
        this.mon(plugin, {
            edit: function(editor, e) {
                this.onCalendarChange(e.record, e.value);
            },
            scope: this
        });
        Ext.apply(me, {
            store: me.resourceStore,
            columns: [
                {
                    header: this.L('name'),
                    dataIndex: 'Name',
                    flex: 1
                },
                {
                    header: this.L('calendar'),
                    flex: 1,
                    renderer: function(value, meta, record) {
                        var cal = record.getCalendar();
                        var fn = me.calendarStore.getModelById ? 'getModelById' : 'getById';
                        var rec = me.calendarStore[fn](cal && cal.calendarId);
                        return rec && rec.getName() || value;
                    },
                    editor: {
                        xtype: 'combobox',
                        store: me.calendarStore,
                        queryMode: 'local',
                        displayField: 'Name',
                        valueField: 'Id',
                        editable: false,
                        allowBlank: false
                    }
                }
            ],
            border: true,
            height: 180,
            plugins: plugin
        });
        this.calendarStore.loadData(this.getCalendarData());
        this.callParent(arguments);
    },
    getCalendarData: function() {
        return Ext.Array.map(Gnt.data.Calendar.getAllCalendars(), function(cal) {
            return {
                Id: cal.calendarId,
                Name: cal.name || cal.calendarId
            };
        });
    },
    onCalendarChange: function(record, calendarId) {
        record.setCalendarId(calendarId);
    },
    destroy: function() {
        this.calendarStore.destroy();
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * This class implements an event domain for CRUD manager instances (classes extending Sch.crud.AbstractManager).
 * So that when MVC approach is used a Controller would be able to attach listeners for CRUD manager events in a declarative way.
 *
 *       Ext.define('MyApplication', {
 *           extend          : 'Ext.app.Application',
 *
 *           requires        : [
 *               // we need this to enable CRUD managers domain
 *               'Sch.app.CrudManagerDomain',
 *               'Ext.window.MessageBox'
 *           ],
 *
 *           listen          : {
 *               crudmanager : {
 *                   // listen to all CRUD managers available
 *                   '*' : {
 *                       'loadfail' : 'onCrudException'
 *                       'syncfail' : 'onCrudException'
 *                   },
 *
 *                   // this selector matches to a CRUD manager having an alias set to `crudmanager.specific-crud`
 *                   'specific-crud' : {
 *                       'load' : 'onSpecificCrudLoaded'
 *                   }
 *               }
 *           },
 *
 *           onCrudException : function (crud, response, responseOptions) {
 *               Ext.Msg.show({
 *                   title    : 'Error',
 *                   msg      : response.message || 'Unknown error',
 *                   icon     : Ext.Msg.ERROR,
 *                   buttons  : Ext.Msg.OK,
 *                   minWidth : Ext.Msg.minWidth
 *               });
 *           },
 *
 *           onSpecificCrudLoaded : function () {
 *               ...
 *           },
 *
 *           ....
 *       });
 *
 *
 * Selectors are either CRUD manager's alias or '*' wildcard for any CRUD manager.
 */
Ext.define('Sch.app.CrudManagerDomain', {
    extend: 'Ext.app.EventDomain',
    singleton: true,
    requires: [
        'Sch.crud.AbstractManager'
    ],
    type: 'crudmanager',
    prefix: 'crudmanager.',
    constructor: function() {
        var me = this;
        me.callParent();
        me.monitor(Sch.crud.AbstractManager);
    },
    match: function(target, selector) {
        var result = false,
            alias = target.alias;
        if (selector === '*') {
            result = true;
        } else if (alias) {
            result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.crud.encoder.Xml
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _XML_ as an encoding system.

    // let's make new CrudManager using AJAX as a transport system and XML for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
    });

# Request structure

Load request example:

    <load requestId="123890">
        <store id="store1" page="1" pageSize="10"/>
        <store id="store2"/>
        <store id="store3"/>
    </load>

Sync request:

    <sync requestId="123890" revision="123">
        <store id="store1">
            <added>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="SomeField">smth</field>
                    ...
                </record>
                ...
            </added>
            <updated>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">new value</field>
                    ...
                </record>
                ...
            </updated>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <added>...</added>
            <updated>...</updated>
            <removed>...</removed>
        </store>
    </sync>

# Response structure

Load response example:

    <data requestId="123890" revision="123" success="true">

        <store id="store1">
            <rows total="5">
                <record>
                    <field id="Id">9000</field>
                    <field id="SomeField">xxxx</field>
                    ...
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">yyyy</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store2">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field1">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field1">bbb</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store3">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field2">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field2">bbb</field>
                    ...
                </record>
            </rows>
        </store>
    </data>

Sync response:

    <data requestId="123890" success="true" revision="124">
        <store id="store1">
            <rows>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="Id">9000</field>
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField2">2013-08-01</field>
                </record>
            </rows>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <rows>...</rows>
            <removed>...</removed>
        </store>
    </data>

# Error response

    <data requestId="123890" success="true" code="13">
        <message>Error description goes here</message>
    </data>

*/
Ext.define("Sch.crud.encoder.Xml", {
    requires: [
        'Ext.XTemplate'
    ],
    format: 'xml',
    stringReplaces: [
        [
            /&/g,
            '&amp;'
        ],
        [
            /</g,
            '&lt;'
        ],
        [
            />/g,
            '&gt;'
        ],
        [
            /"/g,
            '&quot;'
        ]
    ],
    // Translates a string characters to XML safe ones
    encodeString: function(text) {
        if (!text)  {
            return text;
        }
        
        var result = text.toString(),
            replaces = this.stringReplaces;
        for (var i = 0,
            l = replaces.length; i < l; i++) {
            result = result.replace(replaces[i][0], replaces[i][1]);
        }
        return result;
    },
    encodeRecords: function(records) {
        var result = '';
        for (var i = 0,
            l = records.length; i < l; i++) {
            result += this.encodeRecord(records[i]);
        }
        return result;
    },
    encodeRecord: function(record) {
        var result = '<record>';
        for (var i in record) {
            var field = record[i];
            result += '<field id="' + this.encodeString(i) + '">' + (field && field.$store ? this.encodeStoreChanges({
                storeId: i
            }, field) : this.encodeString(field)) + '</field>';
        }
        result += '</record>';
        return result;
    },
    encodeStoreChanges: function(store, changes) {
        var result = '<store id="' + this.encodeString(store.storeId) + '">';
        if (changes.added) {
            result += '<added>' + this.encodeRecords(changes.added) + '</added>';
        }
        if (changes.updated) {
            result += '<updated>' + this.encodeRecords(changes.updated) + '</updated>';
        }
        if (changes.removed) {
            result += '<removed>' + this.encodeRecords(changes.removed) + '</removed>';
        }
        result += '</store>';
        return result;
    },
    /**
     * Encodes an request object to _XML_ encoded string. The formats of requests are displayed in an intro.
     * @param {Object} request The request to encode.
     */
    encode: function(packet) {
        var result, i, l, store;
        switch (packet.type) {
            case 'load':
                result = '<load requestId="' + this.encodeString(packet.requestId) + '">';
                for (i = 0 , l = packet.stores.length; i < l; i++) {
                    store = packet.stores[i];
                    if (typeof store === 'string') {
                        result += '<store id="' + this.encodeString(store) + '"/>';
                    } else {
                        result += '<store id="' + this.encodeString(store.storeId) + '" page="' + this.encodeString(store.page) + '" pageSize="' + this.encodeString(store.pageSize) + '"/>';
                    }
                };
                result += '</load>';
                return result;
            case 'sync':
                result = '<sync requestId="' + this.encodeString(packet.requestId) + '" revision="' + this.encodeString(packet.revision) + '">';
                for (i in packet) {
                    if (packet.hasOwnProperty(i)) {
                        store = this.getStore(i);
                        if (store) {
                            result += this.encodeStoreChanges(store, packet[i]);
                        }
                    }
                };
                result += '</sync>';
                break;
        }
        return result;
    },
    stringToXML: function(text) {
        if (!text)  {
            return;
        }
        
        var document;
        /*global DOMParser: false, ActiveXObject: false */
        if (window.DOMParser) {
            document = (new DOMParser()).parseFromString(text, 'text/xml');
        } else if (window.ActiveXObject) {
            document = new ActiveXObject('Microsoft.XMLDOM');
            document.async = false;
            document.loadXML(text);
        }
        return document;
    },
    decodeRecords: function(rows) {
        var result = [];
        for (var j = 0,
            m = rows.length; j < m; j++) {
            result.push(this.decodeRecord(rows[j]));
        }
        return result;
    },
    decodeRecord: function(node) {
        var fields = node.childNodes,
            result = {},
            value;
        for (var i = 0,
            l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.nodeName == 'field') {
                value = '';
                if (field.firstChild) {
                    var store = this.getElementByTagName(field, 'store');
                    value = store ? this.decodeStore(store) : field.firstChild.nodeValue;
                }
                result[field.getAttribute('id')] = value;
            }
        }
        return result;
    },
    // search specified nodes only in a first level of children
    getElementsByTagName: function(node, name) {
        var children = node.childNodes,
            records = [];
        for (var i = 0,
            l = children.length; i < l; i++) {
            if (children[i].nodeName == name)  {
                records.push(children[i]);
            }
            
        }
        return records;
    },
    getElementByTagName: function(node, name) {
        var children = node.childNodes;
        for (var i = 0,
            l = children.length; i < l; i++) {
            if (children[i].nodeName == name)  {
                return children[i];
            }
            
        }
    },
    decodeStore: function(store) {
        var data = {},
            rows = this.getElementsByTagName(store, 'rows');
        if (rows.length) {
            data.rows = this.decodeRecords(this.getElementsByTagName(rows[0], 'record'));
            var total = parseInt(rows[0].getAttribute('total'), 10);
            if (isNaN(total) || total < data.rows.length)  {
                total = data.rows.length;
            }
            
            data.total = total;
        }
        var removed = this.getElementByTagName(store, 'removed');
        if (removed) {
            data.removed = this.decodeRecords(this.getElementsByTagName(removed, 'record'));
        }
        return data;
    },
    /**
     * Decodes (parses) a _XML_ response string to an object. The formats of processable server responses are displayed in an intro.
     * @param {Object} response The response to decode.
     */
    decode: function(packet) {
        var xml = typeof packet == 'string' ? this.stringToXML(packet) : packet;
        if (!xml)  {
            return;
        }
        
        var result = {},
            root = xml.documentElement,
            stores = root.getElementsByTagName('store'),
            store, storeId;
        result.requestId = root.getAttribute('requestId');
        result.revision = root.getAttribute('revision');
        result.success = root.getAttribute('success') || 'false';
        result.success = result.success.toLowerCase() == 'true';
        if (!result.success) {
            // extract error code
            result.code = root.getAttribute('code');
            var message = root.getElementsByTagName('message')[0];
            result.message = message && message.firstChild && message.firstChild.nodeValue;
        }
        for (var i = 0,
            l = stores.length; i < l; i++) {
            store = stores[i];
            storeId = store.getAttribute('id');
            if (this.getStore(storeId)) {
                result[storeId] = this.decodeStore(store);
            }
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.data.CrudManager

The Crud Manager (or "CM") is a class implementing centralized loading and saving of data in multiple stores.
Loading the stores and saving all changes is done using one ajax request. This class uses AJAX as a transport mechanism and JSON as the data encoding format.

For usage details please see [this guide](#!/guide/scheduler_crud_manager).

# Scheduler stores

The class supports Ext Scheduler specific stores (namely: resource, event and assignment stores).
For these stores, the CM has separate configs ({@link #resourceStore}, {@link #eventStore}, {@link #assignmentStore})
to register them. The class can also grab them from the task store (this behavior can be changed using
{@link #addRelatedStores} config).

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

# AJAX request configuration

To configure AJAX request parameters please take a look at the {@link #transport} config.

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url         : 'php/read.php',
                // use GET request
                method      : 'GET',
                // pass request JSON in "rq" parameter
                paramName   : 'rq',
                // extra HTTP request parameters
                params      : {
                    foo     : 'bar'
                }
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });


# Load order

The CM is aware of the proper load order for Scheduler specific stores so you don't need to worry about it.
If you provide any extra stores (using {@link #stores} config) they will be added to the start of collection before
 the Scheduler specific stores.
If you a different load order, you should use {@link #addStore} method to register your store:

    var crudManager = Ext.create('Sch.data.CrudManager', {
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        // extra user defined stores will get to the start of collection
        // so they will be loaded first
        stores          : [ store1, store2 ],
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

    // append store3 to the end so it will be loaded last
    crudManager.addStore(store3);

    // now when we registered all the stores let's load them
    crudManager.load();

*/
Ext.define('Sch.data.CrudManager', {
    extend: 'Sch.crud.AbstractManager',
    mixins: [
        'Sch.crud.encoder.Json',
        'Sch.crud.transport.Ajax'
    ],
    /**
     * @cfg {Sch.data.ResourceStore/Object} resourceStore A store with resources (or its descriptor).
     */
    /**
     * @property {Object} resourceStore The resource store descriptor.
     */
    resourceStore: null,
    /**
     * @cfg {Sch.data.EventStore/Object} eventStore A store with events (or its descriptor).
     */
    /**
     * @property {Object} eventStore The event store descriptor.
     */
    eventStore: null,
    /**
     * @cfg {Sch.data.AssignmentStore/Object} assignmentStore A store with assignments (or its descriptor).
     */
    /**
     * @property {Object} assignmentStore The assignment store descriptor.
     */
    assignmentStore: null,
    /**
     * @cfg {Sch.data.DependencyStore/Object} dependencyStore A store with dependencies (or its descriptor).
     */
    /**
     * @property {Object} dependencyStore The dependency store descriptor.
     */
    dependencyStore: null,
    /**
     * @cfg {Boolean} addRelatedStores
     * When set to `true` this class will try to get the {@link #resourceStore} and {@link #assignmentStore} stores from
     * the specified {@link #eventStore} instance.
     */
    addRelatedStores: true,
    constructor: function(config) {
        config = config || {};
        var resourceStore = config.resourceStore || this.resourceStore || new Sch.data.ResourceStore(),
            eventStore = config.eventStore || this.eventStore || new Sch.data.EventStore(),
            assignmentStore = config.assignmentStore || this.assignmentStore,
            dependencyStore = config.dependencyStore || this.dependencyStore,
            // list of stores to add
            stores = [];
        // retrieve stores registered on the provided taskStore
        if (eventStore && config.addRelatedStores !== false) {
            var extracted = this.getEventStoreInfo(eventStore, config);
            assignmentStore = assignmentStore || extracted.assignmentStore;
            resourceStore = resourceStore || extracted.resourceStore;
            dependencyStore = dependencyStore || extracted.dependencyStore;
        }
        // event store
        eventStore && stores.push(eventStore);
        // resource store
        resourceStore && stores.push(resourceStore);
        // assignment store
        assignmentStore && stores.push(assignmentStore);
        // dependency store
        dependencyStore && stores.push(dependencyStore);
        // all the Scheduler related stores will go after the user defined stores from the config.stores
        if (stores.length) {
            var syncSequence = [];
            // For applying sync results we have a different order:
            // resources -> events -> assignments -> dependencies
            resourceStore && syncSequence.push(resourceStore);
            eventStore && syncSequence.push(eventStore);
            assignmentStore && syncSequence.push(assignmentStore);
            dependencyStore && syncSequence.push(dependencyStore);
            if (syncSequence.length) {
                config.syncApplySequence = (config.syncApplySequence || config.stores || []).concat(syncSequence);
            }
            var _stores = config.stores || this.stores;
            if (_stores && !Ext.isArray(_stores))  {
                _stores = [
                    _stores
                ];
            }
            
            config.stores = (_stores || []).concat(stores);
        }
        this.callParent([
            config
        ]);
        this.eventStore = this.getStoreDescriptor(eventStore);
        this.resourceStore = this.getStoreDescriptor(resourceStore);
        this.assignmentStore = this.getStoreDescriptor(assignmentStore);
        this.dependencyStore = this.getStoreDescriptor(dependencyStore);
    },
    getEventStoreInfo: function(eventStore, config) {
        if (!eventStore.isStore) {
            if (typeof eventStore == 'string') {
                eventStore = Ext.data.StoreManager.get(eventStore);
            } else {
                eventStore = eventStore.store;
            }
        }
        var result = {},
            assignmentStore = config.assignmentStore,
            resourceStore = config.resourceStore,
            dependencyStore = config.dependencyStore;
        !assignmentStore && (result.assignmentStore = eventStore.getAssignmentStore());
        !resourceStore && (result.resourceStore = eventStore.getResourceStore());
        !dependencyStore && (result.dependencyStore = eventStore.getDependencyStore());
        return result;
    },
    /**
     * Returns the resource store bound to the CRUD manager.
     * @return {Sch.data.ResourceStore} The resource store.
     */
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store;
    },
    /**
     * Sets the resource store bound to the CRUD manager.
     * @param {Sch.data.ResourceStore} The resource store.
     */
    setResourceStore: function(store) {
        if (this.getResourceStore()) {
            this.removeStore(this.getResourceStore());
        }
        this.addStore(store);
        this.resourceStore = {
            store: store
        };
    },
    /**
     * Returns the event store bound to the CRUD manager.
     * @return {Sch.data.EventStore} The event store.
     */
    getEventStore: function() {
        return this.eventStore && this.eventStore.store;
    },
    /**
     * Sets the event store bound to the CRUD manager.
     * @param {Sch.data.EventStore} The event store.
     */
    setEventStore: function(store) {
        if (this.getEventStore()) {
            this.removeStore(this.getEventStore());
        }
        this.addStore(store);
        this.eventStore = {
            store: store
        };
    },
    /**
     * Returns the assignment store bound to the CRUD mananger.
     * @return {Sch.data.AssignmentStore} The assignment store
     */
    getAssignmentStore: function() {
        return this.assignmentStore && this.assignmentStore.store;
    },
    /**
     * Sets the assignment store bound to the CRUD mananger.
     * @param {Sch.data.AssignmentStore} The assignment store
     */
    setAssignmentStore: function(store) {
        if (this.getAssignmentStore()) {
            this.removeStore(this.getAssignmentStore());
        }
        this.addStore(store);
        this.assignmentStore = {
            store: store
        };
    },
    /**
     * Returns the dependency store bound to the CRUD mananger.
     * @return {Sch.data.DependencyStore} The dependency store
     */
    getDependencyStore: function() {
        return this.dependencyStore && this.dependencyStore.store;
    },
    /**
     * Sets the dependency store bound to the CRUD mananger.
     * @param {Sch.data.DependencyStore} The dependency store
     */
    setDependencyStore: function(store) {
        if (this.getDependencyStore()) {
            this.removeStore(this.getDependencyStore());
        }
        this.addStore(store);
        this.dependencyStore = {
            store: store
        };
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Assignment store event->resources cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.AssignmentStoreEventResourcesCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();
            Ext.Array.each(assignments, function(assignment) {
                var resource = resourceStore && resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.add(assignment.getEventId(), resource);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                {
                    me.clear(assignment.getEventId());
                }
            });
        }
        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();
            Ext.Array.each(assignments, function(assignment) {
                var resource = resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.remove(assignment.getEventId(), resource);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                {
                    me.clear(assignment.getEventId());
                }
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField],
                eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore(),
                resource;
            if (resourceIdChanged || eventIdChanged) {
                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId = eventIdChanged ? previousEventId : assignment.getEventId();
                resource = resourceStore.getModelById(previousResourceId);
                if (resource) {
                    me.remove(previousEventId, resource);
                } else {
                    me.clear(previousEventId);
                }
                resource = resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.add(assignment.getEventId(), resource);
                } else {
                    me.clear(assignment.getEventId());
                }
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.clear(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.uncache(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                idchanged: onEventIdChanged,
                remove: onEventRemove,
                clear: onEventStoreClearOrReset,
                cacheresethint: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destory(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            clear: onAssignmentStoreClearOrReset,
            cacheresethint: onAssignmentStoreClearOrReset,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForEvent(k, function mapper(assignment) {
                return assignment.getResource();
            }, function filter(resource) {
                return !!resource;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Assignment store resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.AssignmentStoreResourceEventsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();
            Ext.Array.each(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.add(assignment.getResourceId(), event);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                {
                    me.clear(assignment.getResourceId());
                }
            });
        }
        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();
            Ext.Array.each(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.remove(assignment.getResourceId(), event);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                {
                    me.clear(assignment.getResourceId());
                }
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField],
                eventStore = me.assignmentStore.getEventStore(),
                event;
            if (resourceIdChanged || eventIdChanged) {
                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId = eventIdChanged ? previousEventId : assignment.getEventId();
                event = eventStore && eventStore.getModelById(previousEventId);
                if (event) {
                    me.remove(previousResourceId, event);
                } else {
                    me.clear(previousResourceId);
                }
                event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.add(assignment.getResourceId(), event);
                } else {
                    me.clear(assignment.getResourceId());
                }
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.uncache(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(store, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                remove: onEventRemove,
                cacheresethint: onEventStoreClearOrReset,
                clear: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                cacheresethint: onResourceStoreClearOrReset,
                clear: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            cacheresethint: onAssignmentStoreClearOrReset,
            clear: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForResource(k, function mapper(assignment) {
                return assignment.getEvent();
            }, function filter(event) {
                return !!event;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Assignment store event->assignments cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.EventAssignmentsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    assignmentStoreFiltersDetacher: null,
    eventStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.add(assignment.getEventId(), assignment);
            });
        }
        function onAssignmentRemove(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.remove(assignment.getEventId(), assignment);
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField];
            if (eventIdChanged) {
                me.move(previousEventId, assignment.getEventId(), assignment);
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
        }
        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.clear(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(store) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = store && store.on({
                idchanged: onEventIdChanged,
                remove: onEventRemove,
                cacheresethint: onEventStoreClearOrReset,
                clear: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            cacheresethint: onAssignmentStoreClearOrReset,
            clear: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStoreFiltersDetacher = assignmentStore.getFilters().on({
            endupdate: onAssignmentStoreClearOrReset,
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToEventStore(eventStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'assignmentStoreFiltersDetacher', 'eventStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getEventId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Assignment store resource->assignments cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceAssignmentsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.add(assignment.getResourceId(), assignment);
            });
        }
        function onAssignmentRemove(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.remove(assignment.getResourceId(), assignment);
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField];
            if (resourceIdChanged) {
                me.move(previousResourceId, assignment.getResourceId(), assignment);
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            clear: onAssignmentStoreClearOrReset,
            cacheresethint: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStoreFiltersDetacher = assignmentStore.getFilters().on('endupdate', onAssignmentStoreClearOrReset, me, {
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'assignmentStoreFiltersDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getResourceId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?310709-ensureVisible-may-throw-exception-under-certain-conditions
Ext.define('Sch.patches.BufferedRenderer', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.BufferedRenderer',
    minVersion: '6.0.2',
    overrides: {
        onRangeFetched: function(range, start, end, options, fromLockingPartner) {
            var me = this,
                view = me.view,
                viewEl = view.el,
                rows = view.all,
                increment = 0,
                variableRowHeight = me.variableRowHeight,
                lockingPartner = (view.lockingPartner && !fromLockingPartner && !me.doNotMirror) && view.lockingPartner.bufferedRenderer,
                activeEl, calculatedTop, containsFocus, i, newRows, newTop, newFocus, noOverlap, oldStart, partnerNewRows, pos, removeCount, topAdditionSize, topBufferZone;
            // View may have been destroyed since the DelayedTask was kicked off.
            if (view.destroyed) {
                return;
            }
            // If called as a callback from the Store, the range will be passed, if called from renderRange, it won't
            if (range) {
                if (!fromLockingPartner) {
                    // Re-cache the scrollTop if there has been an asynchronous call to the server.
                    me.scrollTop = me.view.getScrollY();
                }
            } else {
                range = me.store.getRange(start, end);
                // Store may have been cleared since the DelayedTask was kicked off.
                if (!range) {
                    return;
                }
            }
            // If we contain focus now, but do not when we have rendered the new rows, we must focus the view el.
            activeEl = Ext.Element.getActiveElement();
            containsFocus = viewEl.contains(activeEl);
            // Best guess rendered block position is start row index * row height.
            // We can use this as bodyTop if the row heights are all standard.
            // We MUST use this as bodyTop if the scroll is a telporting scroll.
            // If we are incrementally scrolling, we add the rows to the bottom, and
            // remove a block of rows from the top.
            // The bodyTop is then incremented by the height of the removed block to keep
            // the visuals the same.
            //
            // We cannot always use the calculated top, and compensate by adjusting the scroll position
            // because that would break momentum scrolling on DOM scrolling platforms, and would be
            // immediately undone in the next frame update of a momentum scroll on touch scroll platforms.
            calculatedTop = start * me.rowHeight;
            // The new range encompasses the current range. Refresh and keep the scroll position stable
            if (start < rows.startIndex && end > rows.endIndex) {
                // How many rows will be added at top. So that we can reposition the table to maintain scroll position
                topAdditionSize = rows.startIndex - start;
                // MUST use View method so that itemremove events are fired so widgets can be recycled.
                view.clearViewEl(true);
                newRows = view.doAdd(range, start);
                view.fireEvent('itemadd', range, start, newRows);
                for (i = 0; i < topAdditionSize; i++) {
                    increment -= newRows[i].offsetHeight;
                }
                // We've just added a bunch of rows to the top of our range, so move upwards to keep the row appearance stable
                newTop = me.bodyTop + increment;
            } else {
                // No overlapping nodes; we'll need to render the whole range.
                // teleported flag is set in getFirstVisibleRowIndex/getLastVisibleRowIndex if
                // the table body has moved outside the viewport bounds
                noOverlap = me.teleported || start > rows.endIndex || end < rows.startIndex;
                if (noOverlap) {
                    view.clearViewEl(true);
                    me.teleported = false;
                }
                if (!rows.getCount()) {
                    newRows = view.doAdd(range, start);
                    view.fireEvent('itemadd', range, start, newRows);
                    newTop = calculatedTop;
                    // Adjust the bodyTop to place the data correctly around the scroll vieport
                    if (noOverlap && variableRowHeight) {
                        topBufferZone = me.scrollTop < me.position ? me.leadingBufferZone : me.trailingBufferZone;
                        // PATCH
                        // https://www.sencha.com/forum/showthread.php?310709-ensureVisible-may-throw-exception-under-certain-conditions
                        var index = Math.min(rows.startIndex + topBufferZone - 1, rows.endIndex);
                        newTop = Math.max(me.scrollTop - rows.item(index, true).offsetTop, 0);
                    }
                }
                // END PATCH
                // Moved down the dataset (content moved up): remove rows from top, add to end
                else if (end > rows.endIndex) {
                    removeCount = Math.max(start - rows.startIndex, 0);
                    // We only have to bump the table down by the height of removed rows if rows are not a standard size
                    if (variableRowHeight) {
                        increment = rows.item(rows.startIndex + removeCount, true).offsetTop;
                    }
                    newRows = rows.scroll(Ext.Array.slice(range, rows.endIndex + 1 - start), 1, removeCount);
                    // We only have to bump the table down by the height of removed rows if rows are not a standard size
                    if (variableRowHeight) {
                        // Bump the table downwards by the height scraped off the top
                        newTop = me.bodyTop + increment;
                    } else // If the rows are standard size, then the calculated top will be correct
                    {
                        newTop = calculatedTop;
                    }
                } else // Moved up the dataset: remove rows from end, add to top
                {
                    removeCount = Math.max(rows.endIndex - end, 0);
                    oldStart = rows.startIndex;
                    newRows = rows.scroll(Ext.Array.slice(range, 0, rows.startIndex - start), -1, removeCount);
                    // We only have to bump the table up by the height of top-added rows if rows are not a standard size
                    if (variableRowHeight) {
                        // Bump the table upwards by the height added to the top
                        newTop = me.bodyTop - rows.item(oldStart, true).offsetTop;
                        // We've arrived at row zero...
                        if (!rows.startIndex) {
                            // But the calculated top position is out. It must be zero at this point
                            // We adjust the scroll position to keep visual position of table the same.
                            if (newTop) {
                                view.setScrollY(me.position = (me.scrollTop -= newTop));
                                newTop = 0;
                            }
                        }
                        // Not at zero yet, but the position has moved into negative range
                        else if (newTop < 0) {
                            increment = rows.startIndex * me.rowHeight;
                            view.setScrollY(me.position = (me.scrollTop += increment));
                            newTop = me.bodyTop + increment;
                        }
                    } else // If the rows are standard size, then the calculated top will be correct
                    {
                        newTop = calculatedTop;
                    }
                }
                // The position property is the scrollTop value *at which the table was last correct*
                // MUST be set at table render/adjustment time
                me.position = me.scrollTop;
            }
            // We contained focus at the start, but that activeEl has been derendered.
            // Focus the cell's column header.
            if (containsFocus && !viewEl.contains(activeEl)) {
                pos = view.actionableMode ? view.actionPosition : view.lastFocused;
                if (pos && pos.column) {
                    view.onFocusLeave({});
                    // Try to focus the contextual column header.
                    // Failing that, look inside it for a tabbable element.
                    // Failing that, focus the view.
                    // Focus MUST NOT just silently die due to DOM removal
                    if (pos.column.focusable) {
                        newFocus = pos.column;
                    } else {
                        newFocus = pos.column.el.findTabbableElements()[0];
                    }
                    if (!newFocus) {
                        newFocus = view.el;
                    }
                    newFocus.focus();
                }
            }
            // Position the item container.
            newTop = Math.max(Math.floor(newTop), 0);
            if (view.positionBody) {
                me.setBodyTop(newTop);
            }
            // Sync the other side to exactly the same range from the dataset.
            // Then ensure that we are still at exactly the same scroll position.
            if (newRows && lockingPartner && !lockingPartner.disabled) {
                // Set the pointers of the partner so that its onRangeFetched believes it is at the correct position.
                lockingPartner.scrollTop = lockingPartner.position = me.scrollTop;
                if (lockingPartner.view.ownerCt.isVisible()) {
                    partnerNewRows = lockingPartner.onRangeFetched(range, start, end, options, true);
                    // Sync the row heights if configured to do so, or if one side has variableRowHeight but the other doesn't.
                    // variableRowHeight is just a flag for the buffered rendering to know how to measure row height and
                    // calculate firstVisibleRow and lastVisibleRow. It does not *necessarily* mean that row heights are going
                    // to be asymmetric between sides. For example grouping causes variableRowHeight. But the row heights
                    // each side will be symmetric.
                    // But if one side has variableRowHeight (eg, a cellWrap: true column), and the other does not, that
                    // means there could be asymmetric row heights.
                    if (view.ownerGrid.syncRowHeight || (lockingPartner.variableRowHeight !== variableRowHeight)) {
                        me.syncRowHeights(newRows, partnerNewRows);
                    }
                }
                if (lockingPartner.bodyTop !== newTop) {
                    lockingPartner.setBodyTop(newTop);
                }
                // Set the real scrollY position after the correct data has been rendered there.
                // It will not handle a scroll because the scrollTop and position have been preset.
                lockingPartner.view.setScrollY(me.scrollTop);
            }
            // If there are columns to trigger rendering, and the rendered block os not either the view size
            // or, if store count less than view size, the store count, then there's a bug.
            if (view.getVisibleColumnManager().getColumns().length && rows.getCount() !== Math.min(me.store.getCount(), me.viewSize)) {
                Ext.raise('rendered block refreshed at ' + rows.getCount() + ' rows while BufferedRenderer view size is ' + me.viewSize);
            }
            return newRows;
        },
        // In 6.0.2 there's additional check which is failing in gantt due to our refresh blockers. We simply mute
        // that condition for panels with Sch.mixin.TimelinePanel mixed in.
        // covered by 062_reload_store in gantt
        doRefreshView: function(range, startIndex, endIndex, options) {
            var me = this,
                view = me.view,
                rows = view.all,
                previousStartIndex = rows.startIndex,
                previousEndIndex = rows.endIndex,
                previousFirstItem, previousLastItem,
                prevRowCount = rows.getCount(),
                newNodes,
                viewMoved = startIndex !== rows.startIndex,
                calculatedTop, scrollIncrement, restoreFocus;
            // So that listeners to the itemremove events know that its because of a refresh.
            // And so that this class's refresh listener knows to ignore it.
            view.refreshing = me.refreshing = true;
            if (view.refreshCounter) {
                // Give CellEditors or other transient in-cell items a chance to get out of the way.
                if (view.hasListeners.beforerefresh && view.fireEvent('beforerefresh', view) === false) {
                    return view.refreshNeeded = view.refreshing = me.refreshing = false;
                }
                // If focus was in any way in the view, whether actionable or navigable, this will return
                // a function which will restore that state.
                restoreFocus = view.saveFocusState();
                view.clearViewEl(true);
                view.refreshCounter++;
                if (range.length) {
                    newNodes = view.doAdd(range, startIndex);
                    if (viewMoved) {
                        // Try to find overlap between newly rendered block and old block
                        previousFirstItem = rows.item(previousStartIndex, true);
                        previousLastItem = rows.item(previousEndIndex, true);
                        // Work out where to move the view top if there is overlap
                        if (previousFirstItem) {
                            scrollIncrement = -previousFirstItem.offsetTop;
                        } else if (previousLastItem) {
                            scrollIncrement = rows.last(true).offsetTop - previousLastItem.offsetTop;
                        }
                        // If there was an overlap, we know exactly where to move the view
                        if (scrollIncrement) {
                            me.bodyTop = Math.max(me.bodyTop + scrollIncrement, 0);
                            me.scrollTop = me.bodyTop ? me.scrollTop + scrollIncrement : 0;
                        } else // No overlap: calculate the a new body top and scrollTop.
                        {
                            // To position rows, remove table's top border
                            me.bodyTop = calculatedTop = startIndex * me.rowHeight;
                            me.scrollTop = Math.max(calculatedTop - me.rowHeight * (calculatedTop < me.bodyTop ? me.leadingBufferZone : me.trailingBufferZone , 0));
                        }
                    }
                } else // Clearing the view.
                // Ensure we jump to top.
                // Apply empty text.
                {
                    if (me.scrollTop) {
                        me.bodyTop = me.scrollTop = 0;
                    }
                    view.addEmptyText();
                }
                // Keep scroll and rendered block positions synched.
                if (viewMoved) {
                    me.setBodyTop(me.bodyTop);
                    view.suspendEvent('scroll');
                    view.setScrollY(me.position = me.scrollTop);
                    view.resumeEvent('scroll');
                }
                // Correct scroll range
                me.refreshSize();
                view.refreshSize(rows.getCount() !== prevRowCount);
                view.fireEvent('refresh', view, range);
                // If focus was in any way in this view, this will restore it
                restoreFocus();
                view.headerCt.setSortState();
            } else {
                view.refresh();
            }
            // HACK avoid this check for gantt/scheduler components
            if (!(view.ownerGrid.is('timelinegrid,timelinetree')) && // END HACK
            // If there are columns to trigger rendering, and the rendered block is not either the view size
            // or, if store count less than view size, the store count, then there's a bug.
            view.getVisibleColumnManager().getColumns().length && rows.getCount() !== Math.min(me.store.getCount(), me.viewSize)) {
                Ext.raise('rendered block refreshed at ' + rows.getCount() + ' rows while BufferedRenderer view size is ' + me.viewSize);
            }
            view.refreshNeeded = view.refreshing = me.refreshing = false;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Sch.patches.CellContext', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellContext',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                setAll: function(view, recordIndex, columnIndex, record, columnHeader) {
                    var me = this;
                    // Since we patched navigation model, nothing is focused in normal view, which means, keyevents have
                    // unexpeted target. This will lead to a situation when we are trying to set position, passing column
                    // from normal view and it's position in locked view (which is -1). In this case we want to perform
                    // new lookup in correct view.
                    // covered in 096_vertical_layout
                    if (columnHeader && columnIndex == -1 && view !== me.view) {
                        view = me.view;
                        columnIndex = view.getVisibleColumnManager().indexOf(columnHeader);
                    }
                    return this.callParent(arguments);
                }
            };
        if (Ext.getVersion().isGreaterThanOrEqual('6.0.1')) {
            // Scheduler: test 313_single_time_axis_vertical
            // When we switch mode on scheduler grid with locked cell focused (e.g. if setMode is called in itemclick
            // listener) exception is raised. Sencha tries to save focus position and restore it later.
            // In order to optimize performance we suspend refresh before reconfigure. This leads to a situation when
            // view cannot get record and column from existing cell (because grid is already recofigured but view is not
            // yet refreshed) and passing null arguments to the "setPosition" method which doesn't accept it.
            //
            // Gantt: 223_spreadsheet.t.js?Ext=6.0.1
            // Gantt bulk operations suspend events on the taskStore which prevents the cell context of knowing that rows may have been removed
            // In these cases we set row index to 0;
            overrides.setPosition = function(row, col) {
                row = row || 0;
                col = col || 0;
                return this.callParent(arguments);
            };
        }
        Ext.override(Ext.grid.CellContext, overrides);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?308572-quot-cacheDeactivatedEditors-quot-error
Ext.define('Sch.patches.CellEditing', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.CellEditing',
    // seems to be fixed in 6.0.2
    maxVersion: '6.0.2',
    // TODO: investigate if this should be moved to TreeCellEditing instead
    overrides: {
        activateCell: function(position) {
            var retVal = this.callParent(arguments);
            // When you remove row with active editor you may face a race condition, when
            // garbage collection is triggered to soon. By that time editor is removed from document body, but not yet
            // moved to detached body element. We raise this flag to let garbage collector know editor should not be
            // removed yet. We need to raise it on editor node and all nested nodes to keep editor intact
            // if beforeedit was cancelled, retVal will be undefined
            // #2715, covered by 100_cell_editing
            if (!!retVal) {
                var editor = this.getEditor(position.record, position.column);
                if (editor) {
                    // Do not move this code to separate override, or make sure that button 'add new task' in advanced gantt
                    // focuses editor.
                    editor.el.skipGarbageCollection = true;
                    editor.el.select('*').each(function(node) {
                        Ext.get(node).skipGarbageCollection = true;
                    });
                }
            }
            return retVal;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
Ext.define('Sch.patches.CellEditor', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellEditor',
    minVersion: '6.0.2',
    overrides: {
        // Sencha issue: https://www.sencha.com/forum/showthread.php?305120&p=1135354#post1135354
        // Covered by 1002_tabbing_3
        onEditComplete: function(remainVisible, canceling) {
            var me = this,
                activeElement = Ext.Element.getActiveElement();
            me.editing = false;
            // Must refresh the boundEl in case DOM has been churned during edit.
            me.boundEl = me.context.getCell();
            // PATCH
            if (me.boundEl) {
                // Restore cells content to visibility
                me.restoreCell();
                // IF we are just terminating, and NOT being terminated due to focus
                // having moved out of this editor, then we must prevent any upcoming blur
                // from letting focus fly out of the view.
                // onFocusLeave will have no effect because the editing flag is cleared.
                if (me.boundEl.contains(activeElement) && me.boundEl.dom !== activeElement) {
                    me.boundEl.focus();
                }
            }
            // END PATCH
            // When being asked to process edit completion, if we are hiding
            // move the el into detached body to protect it from garbage collection.
            if (!remainVisible) {
                me.cacheElement();
            }
            me.superclass.onEditComplete.apply(me, arguments);
            // Do not rely on events to sync state with editing plugin,
            // Inform it directly.
            if (canceling) {
                me.editingPlugin.cancelEdit(me);
            } else {
                me.editingPlugin.onEditComplete(me, me.getValue(), me.startValue);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?311875-DomScroller-bug&p=1138744#post1138744
// https://app.assembla.com/spaces/bryntum/tickets/2920/details?comment=1001310103#
// Tested in http://lh/extscheduler4.x/tests/#view/2101_view_rtl.t.js?Ext=6.0.1
Ext.define('Sch.patches.DomScroller', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.DomScroller',
    maxVersion: '6.2.0',
    overrides: {
        privates: {
            convertX: function(x) {
                if (x == null)  {
                    return null;
                }
                
                return this.callParent(arguments);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// Column menu won't expand https://www.sencha.com/forum/showthread.php?304517
Ext.define('Sch.patches.Explorer', {
    extend: 'Sch.util.Patch',
    target: [
        'Ext.util.CSS'
    ],
    minVersion: '6.0.0',
    maxVersion: '6.0.1',
    applyFn: function() {
        if (Ext.isIE9m) {
            Ext.util.CSS.createStyleSheet('.' + Ext.baseCSSPrefix + 'column-header-trigger { z-index: 10; }');
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// covered by multiple tests, e.g. 061_dragdrop_filtered_timeaxis, 069_scrollintoview, 2101_view
Ext.define('Sch.patches.RowSynchronizer', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.locking.RowSynchronizer',
    minVersion: '6.0.0',
    maxVersion: '6.0.1',
    overrides: {
        finish: function(other) {
            if (!other)  {
                return;
            }
            
            return this.callParent(arguments);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.assembla.com/spaces/bryntum/tickets/2470
// https://www.sencha.com/forum/showthread.php?307231
Ext.define('Sch.patches.TableView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.Table',
    minVersion: '6.0.1',
    maxVersion: '6.0.1.9999',
    // Since the issue seems solved in ext 6.0.2 the patch simply copies few methods from it
    overrides: {
        // in ext6.0.2 this method appears in cellediting plugin
        // but we use it here to not override two classes
        suspendCellEditing: function(actionable) {
            var me = actionable,
                editor = me.activeEditor;
            if (editor && editor.editing) {
                me.suspendedEditor = editor;
                me.suspendEvents();
                editor.suspendEvents();
                editor.cancelEdit(true);
                editor.resumeEvents();
                me.resumeEvents();
            }
        },
        // in ext6.0.2 this method appears in cellediting plugin
        // but we use it here to not override two classes
        resumeCellEditing: function(actionable, position) {
            var me = actionable,
                editor = me.activeEditor = me.suspendedEditor,
                result;
            if (editor) {
                me.suspendEvents();
                editor.suspendEvents();
                result = me.activateCell(position, true, true);
                // Sencha doesn't re-focus field if a refresh happens as a side effect while an editing is happening
                // Use case: Duration field with instant update
                // https://www.assembla.com/spaces/bryntum/tickets/2688-duration-editor-loses-focus-after-triggering-a-change-affecting-many-tasks/details#
                // Tested in Gantt 1013_duration.t.js
                editor.field && editor.field.focus(false, true);
                editor.resumeEvents();
                me.resumeEvents();
            }
            return result;
        },
        suspendActionableMode: function() {
            var me = this,
                actionables = me.grid.actionables,
                len = actionables.length,
                i;
            for (i = 0; i < len; i++) {
                var actionable = actionables[i];
                if (Ext.grid.plugin.CellEditing && actionable instanceof Ext.grid.plugin.CellEditing) {
                    me.suspendCellEditing(actionable);
                }
            }
        },
        resumeActionableMode: function(position) {
            var me = this,
                actionables = me.grid.actionables,
                len = actionables.length,
                i, activated;
            // Disable tabbability of elements within this view.
            me.toggleChildrenTabbability(false);
            for (i = 0; i < len; i++) {
                var actionable = actionables[i];
                if (!activated && Ext.grid.plugin.CellEditing && actionable instanceof Ext.grid.plugin.CellEditing) {
                    activated = me.resumeCellEditing(actionable, position);
                }
            }
            // If non of the Actionable responded, attempt to find a naturally focusable child element.
            if (!activated) {
                me.activateCell(position);
            }
        },
        saveFocusState: function() {
            var me = this,
                store = me.dataSource,
                actionableMode = me.actionableMode,
                navModel = me.getNavigationModel(),
                focusPosition = actionableMode ? me.actionPosition : navModel.getPosition(true),
                activeElement = Ext.Element.getActiveElement(true),
                focusCell = focusPosition && focusPosition.view === me && focusPosition.getCell(),
                refocusRow, refocusCol;
            // The navModel may return a position that is in a locked partner, so check that
            // the focusPosition's cell contains the focus before going forward.
            if (focusCell && focusCell.contains(activeElement)) {
                // Separate this from the instance that the nav model is using.
                focusPosition = focusPosition.clone();
                // While we deactivate the focused element, suspend focus processing on it.
                activeElement.suspendFocusEvents();
                // Suspend actionable mode.
                // Each Actionable must silently save its state
                // ready to resume when focus can be restored.
                if (actionableMode) {
                    me.suspendActionableMode();
                } else // Clear position, otherwise the setPosition onthe other side
                // will be rejected as a no-op if the resumption position is logically
                // equivalent.
                {
                    navModel.setPosition();
                }
                // Do not leave the element in tht state in case refresh fails, and restoration
                // closeure not called.
                activeElement.resumeFocusEvents();
                // The following function will attempt to refocus back in the same mode to the same cell
                // as it was at before based upon the previous record (if it's still inthe store), or the row index.
                return function() {
                    // If we still have data, attempt to refocus in the same mode.
                    if (store.getCount()) {
                        // Adjust expectations of where we are able to refocus according to what kind of destruction
                        // might have been wrought on this view's DOM during focus save.
                        refocusRow = Math.min(focusPosition.rowIdx, me.all.getCount() - 1);
                        refocusCol = Math.min(focusPosition.colIdx, me.getVisibleColumnManager().getColumns().length - 1);
                        focusPosition = new Ext.grid.CellContext(me).setPosition(store.contains(focusPosition.record) ? focusPosition.record : refocusRow, refocusCol);
                        if (actionableMode) {
                            me.resumeActionableMode(focusPosition);
                        } else {
                            // Pass "preventNavigation" as true so that that does not cause selection.
                            navModel.setPosition(focusPosition, null, null, null, true);
                        }
                    } else // No rows - focus associated column header
                    {
                        focusPosition.column.focus();
                    }
                };
            }
            return Ext.emptyFn;
        },
        // this method is part of ext6.0.2 but pulling it would force us to
        // include a lot of related code as well ..so we just use this dummy instead
        activateCell: function() {
            return true;
        },
        // #2628 - Vertical scroll is set to 0 when resizing event in vertical mode
        // In 6.0.1+ resizing start will focus event node and this will trigger actionable mode on view and focus
        // first row in view
        onFocusEnter: function(e) {
            if (!Ext.fly(e.target).hasCls('sch-event')) {
                this.callParent(arguments);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?310798-Editing-is-broken-after-view-refresh
Ext.define('Sch.patches.TableView2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.Table',
    minVersion: '6.0.2',
    maxVersion: '6.2.0',
    overrides: {
        privates: {
            setActionableMode: function(enabled, position) {
                var me = this,
                    navModel = me.getNavigationModel(),
                    activeEl,
                    actionables = me.grid.actionables,
                    len = actionables.length,
                    i, record, column,
                    isActionable = false,
                    lockingPartner;
                // No mode change.
                // ownerGrid's call will NOT fire mode change event upon false return.
                if (me.actionableMode === enabled) {
                    // If we're not actinoable already, or (we are actionable already at that position) return false.
                    // Test using mandatory passed position because we may not have an actionPosition if we are
                    // the lockingPartner of an actionable view that contained the action position.
                    //
                    // If we being told to go into actionable mode but at another position, we must continue.
                    // This is just actionable navigation.
                    if (!enabled || position.isEqual(me.actionPosition)) {
                        return false;
                    }
                }
                // If this View or its lockingPartner contains the current focus position, then make the tab bumpers tabbable
                // and move them to surround the focused row.
                if (enabled) {
                    if (position && (position.view === me || (position.view === (lockingPartner = me.lockingPartner) && lockingPartner.actionableMode))) {
                        isActionable = me.activateCell(position);
                    }
                    // Did not enter actionable mode.
                    // ownerGrid's call will NOT fire mode change event upon false return.
                    return isActionable;
                } else {
                    // Capture before exiting from actionable mode moves focus
                    activeEl = Ext.fly(Ext.Element.getActiveElement());
                    // Blur the focused descendant, but do not trigger focusLeave.
                    // This is so that when the focus is restored to the cell which contained
                    // the active content, it will not be a FocusEnter from the universe.
                    if (me.el.contains(activeEl)) {
                        // Row to return focus to.
                        record = (me.actionPosition && me.actionPosition.record) || me.getRecord(activeEl);
                        column = me.getHeaderByCell(activeEl.findParent(me.getCellSelector()));
                        // Do not allow focus to fly out of the view when the actionables are deactivated (and blurred/hidden)
                        // Restore focus to the cell in which actionable mode is active.
                        if (!position) {
                            position = new Ext.grid.CellContext(me).setPosition(record || 0, column || 0);
                        }
                        // Ext.grid.NavigationModel#onFocusMove will NOT react and navigate because the actionableMode
                        // flag is still set at this point.
                        // HACK This focus will trigger completeEdit and may cause view refresh. In this case view will
                        // try to save and restore actionable mode, we should prevent that by raising a special flag that
                        // we can check in restoreFocus method (generated by saveFocus) and decide if we should skip that
                        // Covered by 096_taskeditor in gantt
                        me._leavingActionableMode = true;
                        position.getCell().focus();
                        me._leavingActionableMode = false;
                        // END HACK
                        // Let's update the activeEl after focus here
                        activeEl = Ext.fly(Ext.Element.getActiveElement());
                        // If that focus triggered handlers (eg CellEditor after edit handlers) which
                        // programatically moved focus somewhere, and the target cell has been unfocused, defer to that,
                        // null out position, so that we do not navigate to that cell below.
                        // See EXTJS-20395
                        if (!(me.el.contains(activeEl) && activeEl.is(me.getCellSelector()))) {
                            position = null;
                        }
                    }
                    // We are exiting actionable mode.
                    // Tell all registered Actionables about this fact if they need to know.
                    for (i = 0; i < len; i++) {
                        if (actionables[i].deactivate) {
                            actionables[i].deactivate();
                        }
                    }
                    // If we had begun action (we may be a dormant lockingPartner), make any tabbables untabbable
                    if (me.actionRow) {
                        me.actionRow.saveTabbableState({
                            skipSelf: true,
                            includeSaved: false
                        });
                    }
                    if (me.destroyed) {
                        return false;
                    }
                    // These flags MUST be set before focus restoration to the owning cell.
                    // so that when Ext.grid.NavigationModel#setPosition attempts to exit actionable mode, we don't recurse.
                    me.actionableMode = me.ownerGrid.actionableMode = false;
                    me.actionPosition = navModel.actionPosition = me.actionRow = null;
                    // Push focus out to where it was requested to go.
                    if (position) {
                        navModel.setPosition(position);
                    }
                }
            }
        },
        saveFocusState: function() {
            var me = this,
                store = me.dataSource,
                actionableMode = me.actionableMode,
                navModel = me.getNavigationModel(),
                focusPosition = actionableMode ? me.actionPosition : navModel.getPosition(true),
                activeElement = Ext.Element.getActiveElement(true),
                focusCell = focusPosition && focusPosition.view === me && focusPosition.getCell(),
                refocusRow, refocusCol;
            // The navModel may return a position that is in a locked partner, so check that
            // the focusPosition's cell contains the focus before going forward.
            if (focusCell && focusCell.contains(activeElement)) {
                // Separate this from the instance that the nav model is using.
                focusPosition = focusPosition.clone();
                // While we deactivate the focused element, suspend focus processing on it.
                activeElement.suspendFocusEvents();
                // Suspend actionable mode.
                // Each Actionable must silently save its state
                // ready to resume when focus can be restored.
                if (actionableMode) {
                    me.suspendActionableMode();
                } else // Clear position, otherwise the setPosition onthe other side
                // will be rejected as a no-op if the resumption position is logically
                // equivalent.
                {
                    navModel.setPosition();
                }
                // Do not leave the element in tht state in case refresh fails, and restoration
                // closeure not called.
                activeElement.resumeFocusEvents();
                // The following function will attempt to refocus back in the same mode to the same cell
                // as it was at before based upon the previous record (if it's still inthe store), or the row index.
                return function() {
                    // If we still have data, attempt to refocus in the same mode.
                    if (store.getCount()) {
                        // Adjust expectations of where we are able to refocus according to what kind of destruction
                        // might have been wrought on this view's DOM during focus save.
                        refocusRow = Math.min(focusPosition.rowIdx, me.all.getCount() - 1);
                        refocusCol = Math.min(focusPosition.colIdx, me.getVisibleColumnManager().getColumns().length - 1);
                        focusPosition = new Ext.grid.CellContext(me).setPosition(store.contains(focusPosition.record) ? focusPosition.record : refocusRow, refocusCol);
                        // HACK
                        if (actionableMode && !me._leavingActionableMode) {
                            // END HACK
                            me.resumeActionableMode(focusPosition);
                        } else {
                            // Pass "preventNavigation" as true so that that does not cause selection.
                            navModel.setPosition(focusPosition, null, null, null, true);
                        }
                    } else // No rows - focus associated column header
                    {
                        focusPosition.column.focus();
                    }
                };
            }
            return Ext.emptyFn;
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?309960-Column-renderer-called-with-null-as-meta-object&p=1131646#post1131646
Ext.define('Sch.patches.TableView_6_0_2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.Table',
    minVersion: '6.0.2',
    maxVersion: '6.0.3',
    overrides: {
        handleUpdate: function(store, record, operation, changedFieldNames, info, allColumns) {
            operation = operation || Ext.data.Model.EDIT;
            var me = this,
                recordIndex = me.store.indexOf(record),
                rowTpl = me.rowTpl,
                markDirty = me.markDirty,
                dirtyCls = me.dirtyCls,
                clearDirty = operation !== Ext.data.Model.EDIT,
                columnsToUpdate = [],
                hasVariableRowHeight = me.variableRowHeight,
                updateTypeFlags = 0,
                ownerCt = me.ownerCt,
                cellFly = me.cellFly || (me.self.prototype.cellFly = new Ext.dom.Fly()),
                oldItemDom, oldDataRow, newItemDom, newAttrs, attLen, attName, attrIndex, overItemCls, columns, column, len, i, cellUpdateFlag, cell, fieldName, value, defaultRenderer, scope, elData, emptyValue;
            if (me.viewReady) {
                // Table row being updated
                oldItemDom = me.getNodeByRecord(record);
                // Row might not be rendered due to buffered rendering or being part of a collapsed group...
                if (oldItemDom) {
                    // refreshNode can be called on a collapsed placeholder record.
                    // Update it from a new rendering.
                    if (record.isCollapsedPlaceholder) {
                        Ext.fly(oldItemDom).syncContent(me.createRowElement(record, me.indexOfRow(record)));
                        return;
                    }
                    overItemCls = me.overItemCls;
                    columns = me.ownerCt.getVisibleColumnManager().getColumns();
                    // A refreshNode operation must update all columns, and must do a full rerender.
                    // Set the flags appropriately.
                    if (allColumns) {
                        columnsToUpdate = columns;
                        /*FIX */
                        // cellUpdateFlag = 1;
                        updateTypeFlags = 1;
                    } else /*EOF FIX */
                    {
                        // Collect an array of the columns which must be updated.
                        // If the field at this column index was changed, or column has a custom renderer
                        // (which means value could rely on any other changed field) we include the column.
                        for (i = 0 , len = columns.length; i < len; i++) {
                            column = columns[i];
                            // We are not going to update the cell, but we still need to mark it as dirty.
                            if (column.preventUpdate) {
                                cell = Ext.fly(oldItemDom).down(column.getCellSelector(), true);
                                // Mark the field's dirty status if we are configured to do so (defaults to true)
                                if (cell && !clearDirty && markDirty) {
                                    cellFly.attach(cell);
                                    if (record.isModified(column.dataIndex)) {
                                        cellFly.addCls(dirtyCls);
                                    } else {
                                        cellFly.removeCls(dirtyCls);
                                    }
                                }
                            } else {
                                // 0 = Column doesn't need update.
                                // 1 = Column needs update, and renderer has > 1 argument; We need to render a whole new HTML item.
                                // 2 = Column needs update, but renderer has 1 argument or column uses an updater.
                                cellUpdateFlag = me.shouldUpdateCell(record, column, changedFieldNames);
                                if (cellUpdateFlag) {
                                    // Track if any of the updating columns yields a flag with the 1 bit set.
                                    // This means that there is a custom renderer involved and a new TableView item
                                    // will need rendering.
                                    updateTypeFlags = updateTypeFlags | cellUpdateFlag;
                                    // jshint ignore:line
                                    columnsToUpdate[columnsToUpdate.length] = column;
                                    hasVariableRowHeight = hasVariableRowHeight || column.variableRowHeight;
                                }
                            }
                        }
                    }
                    // Give CellEditors or other transient in-cell items a chance to get out of the way
                    // if there are in the cells destined for update.
                    me.fireEvent('beforeitemupdate', record, recordIndex, oldItemDom, columnsToUpdate);
                    // If there's no data row (some other rowTpl has been used; eg group header)
                    // or we have a getRowClass
                    // or one or more columns has a custom renderer
                    // or there's more than one <TR>, we must use the full render pathway to create a whole new TableView item
                    if (me.getRowClass || !me.getRowFromItem(oldItemDom) || (updateTypeFlags & 1) || // jshint ignore:line
                    (oldItemDom.tBodies[0].childNodes.length > 1)) {
                        elData = oldItemDom._extData;
                        newItemDom = me.createRowElement(record, me.indexOfRow(record), columnsToUpdate);
                        if (Ext.fly(oldItemDom, '_internal').hasCls(overItemCls)) {
                            Ext.fly(newItemDom).addCls(overItemCls);
                        }
                        // Copy new row attributes across. Use IE-specific method if possible.
                        // In IE10, there is a problem where the className will not get updated
                        // in the view, even though the className on the dom element is correct.
                        // See EXTJSIV-9462
                        if (Ext.isIE9m && oldItemDom.mergeAttributes) {
                            oldItemDom.mergeAttributes(newItemDom, true);
                        } else {
                            newAttrs = newItemDom.attributes;
                            attLen = newAttrs.length;
                            for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
                                attName = newAttrs[attrIndex].name;
                                if (attName !== 'id') {
                                    oldItemDom.setAttribute(attName, newAttrs[attrIndex].value);
                                }
                            }
                        }
                        // The element's data is no longer synchronized. We just overwrite it in the DOM
                        if (elData) {
                            elData.isSynchronized = false;
                        }
                        // If we have columns which may *need* updating (think locked side of lockable grid with all columns unlocked)
                        // and the changed record is within our view, then update the view.
                        if (columns.length && (oldDataRow = me.getRow(oldItemDom))) {
                            me.updateColumns(oldDataRow, Ext.fly(newItemDom).down(me.rowSelector, true), columnsToUpdate);
                        }
                        // Loop thru all of rowTpls asking them to sync the content they are responsible for if any.
                        while (rowTpl) {
                            if (rowTpl.syncContent) {
                                // *IF* we are selectively updating columns (have been passed changedFieldNames), then pass the column set, else
                                // pass null, and it will sync all content.
                                if (rowTpl.syncContent(oldItemDom, newItemDom, changedFieldNames ? columnsToUpdate : null) === false) {
                                    break;
                                }
                            }
                            rowTpl = rowTpl.nextTpl;
                        }
                    } else // No custom renderers found in columns to be updated, we can simply update the existing cells.
                    {
                        // Loop through columns which need updating.
                        for (i = 0 , len = columnsToUpdate.length; i < len; i++) {
                            column = columnsToUpdate[i];
                            // The dataIndex of the column is the field name
                            fieldName = column.dataIndex;
                            value = record.get(fieldName);
                            cell = Ext.fly(oldItemDom).down(column.getCellSelector(), true);
                            cellFly.attach(cell);
                            // Mark the field's dirty status if we are configured to do so (defaults to true)
                            if (!clearDirty && markDirty) {
                                if (record.isModified(column.dataIndex)) {
                                    cellFly.addCls(dirtyCls);
                                } else {
                                    cellFly.removeCls(dirtyCls);
                                }
                            }
                            defaultRenderer = column.usingDefaultRenderer;
                            scope = defaultRenderer ? column : column.scope;
                            // Call the column updater which gets passed the TD element
                            if (column.updater) {
                                Ext.callback(column.updater, scope, [
                                    cell,
                                    value,
                                    record,
                                    me,
                                    me.dataSource
                                ], 0, column, ownerCt);
                            } else {
                                if (column.renderer) {
                                    value = Ext.callback(column.renderer, scope, [
                                        value,
                                        null,
                                        record,
                                        0,
                                        0,
                                        me.dataSource,
                                        me
                                    ], 0, column, ownerCt);
                                }
                                emptyValue = value == null || value === '';
                                value = emptyValue ? column.emptyCellText : value;
                                // Update the value of the cell's inner in the best way.
                                // We only use innerHTML of the cell's inner DIV if the renderer produces HTML
                                // Otherwise we change the value of the single text node within the inner DIV
                                // The emptyValue may be HTML, typically defaults to &#160;
                                if (column.producesHTML || emptyValue) {
                                    cellFly.down(me.innerSelector, true).innerHTML = value;
                                } else {
                                    cellFly.down(me.innerSelector, true).childNodes[0].data = value;
                                }
                            }
                            // Add the highlight class if there is one
                            if (me.highlightClass) {
                                Ext.fly(cell).addCls(me.highlightClass);
                                // Start up a DelayedTask which will purge the changedCells stack, removing the highlight class
                                // after the expiration time
                                if (!me.changedCells) {
                                    me.self.prototype.changedCells = [];
                                    me.prototype.clearChangedTask = new Ext.util.DelayedTask(me.clearChangedCells, me.prototype);
                                    me.clearChangedTask.delay(me.unhighlightDelay);
                                }
                                // Post a changed cell to the stack along with expiration time
                                me.changedCells.push({
                                    cell: cell,
                                    cls: me.highlightClass,
                                    expires: Ext.Date.now() + 1000
                                });
                            }
                        }
                    }
                    // If we have a commit or a reject, some fields may no longer be dirty but may
                    // not appear in the modified field names. Remove all the dirty class here to be sure.
                    if (clearDirty && markDirty && !record.dirty) {
                        Ext.fly(oldItemDom, '_internal').select('.' + dirtyCls).removeCls(dirtyCls);
                    }
                    // Coalesce any layouts which happen due to any itemupdate handlers (eg Widget columns) with the final refreshSize layout.
                    if (hasVariableRowHeight) {
                        Ext.suspendLayouts();
                    }
                    // Since we don't actually replace the row, we need to fire the event with the old row
                    // because it's the thing that is still in the DOM
                    me.fireEvent('itemupdate', record, recordIndex, oldItemDom);
                    // We only need to update the layout if any of the columns can change the row height.
                    if (hasVariableRowHeight) {
                        // Must climb to ownerGrid in case we've only updated one field in one side of a lockable assembly.
                        // ownerGrid is always the topmost GridPanel.
                        me.ownerGrid.updateLayout();
                        // Ensure any layouts queued by itemupdate handlers and/or the refreshSize call are executed.
                        Ext.resumeLayouts(true);
                    }
                }
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?312033
Ext.define('Sch.patches.TimelineGridView', {
    extend: 'Sch.util.Patch',
    target: 'Sch.view.TimelineGridView',
    // In chrome 53 this also became a problem in 6.0.2
    // covered by 012_dragdrop_rtl
    minVersion: '6.0.1',
    overrides: {
        initComponent: function() {
            this.callParent(arguments);
            if (this.rtl) {
                this.headerCt.on('afterlayout', function(header) {
                    header.scrollTo(this.getScrollX());
                }, this);
            }
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
// https://www.sencha.com/forum/showthread.php?324999-Locked-grid-hides-normal-grid-header&p=1154992#post1154992
Ext.define('Sch.patches.TimelinePanel', {
    extend: 'Sch.util.Patch',
    target: 'Sch.mixin.TimelinePanel',
    minVersion: '6.2.0',
    applyFn: function() {
        Sch.panel.TimelineGridPanel.override({
            hideHeaders: false
        });
        Sch.panel.TimelineTreePanel.override({
            hideHeaders: false
        });
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.CurrentTimeLine
@extends Sch.plugin.Lines

Plugin (ptype = 'scheduler_currenttimeline') indicating the current date and time as a line in the schedule.

To add this plugin to scheduler:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.CurrentTimeLine', { updateInterval : 30000 })
        ]
    });


*/
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend: "Sch.plugin.Lines",
    alias: 'plugin.scheduler_currenttimeline',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.data.JsonStore'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - tooltipText : 'Current time'
     */
    /**
     * @cfg {Ext.data.Store} store
     * @hide
     */
    /**
     * @cfg {Number} updateInterval This value (in ms) defines how often the timeline shall be refreshed. Defaults to every once every minute.
     */
    updateInterval: 60000,
    showHeaderElements: true,
    /**
     * @cfg {Boolean} autoUpdate true to automatically update the line position over time. Default value is `true`
     */
    autoUpdate: true,
    expandToFitView: true,
    timer: null,
    init: function(cmp) {
        // touch scheduler does not support header elements
        if (Ext.getVersion('touch'))  {
            this.showHeaderElements = false;
        }
        
        var store = new Ext.data.JsonStore({
                fields: [
                    'Date',
                    'Cls',
                    'Text'
                ],
                data: [
                    {
                        Date: new Date(),
                        Cls: 'sch-todayLine',
                        Text: this.L('tooltipText')
                    }
                ]
            });
        var record = store.first();
        if (this.autoUpdate) {
            this.timer = setInterval(function() {
                record.set('Date', new Date());
            }, this.updateInterval);
        }
        this.store = store;
        this.callParent(arguments);
    },
    destroy: function() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
        if (this.store.autoDestroy) {
            this.store.destroy();
        }
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.Pan

A plugin (ptype = 'scheduler_pan') enabling panning by clicking and dragging in a scheduling view.

To add this plugin to your scheduler or gantt view:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Pan', { enableVerticalPan : true })
        ]
    });
 */
Ext.define("Sch.plugin.Pan", {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.scheduler_pan',
    lockableScope: 'top',
    /**
     * @cfg {Boolean} enableVerticalPan
     * True to allow vertical panning
     */
    enableVerticalPan: true,
    statics: {
        /**
         * @property {Number} KEY_SHIFT Constant for shift key
         */
        KEY_SHIFT: 1,
        /**
         * @property {Number} KEY_CTRL Constant for ctrl / meta key
         */
        KEY_CTRL: 2,
        /**
         * @property {Number} KEY_ALT Constant for alt key
         */
        KEY_ALT: 4,
        /**
         * @property {Number} KEY_ALL Constant for all modifier keys (shift, ctrl / meta, alt)
         */
        KEY_ALL: 7
    },
    /**
     * @cfg {Number} disableOnKey Specifies which key should be pressed to disable panning.
     * See {@link #KEY_SHIFT}, {@link #KEY_CTRL}, {@link #KEY_ALT}, {@link #KEY_ALL}.
     * For example to disable panning when shift or ctrl is pressed:

     Ext.create('Sch.plugin.Pan', {
            disableOnKey : Sch.plugin.Pan.KEY_SHIFT + Sch.plugin.Pan.KEY_CTRL
        })

     */
    disableOnKey: 0,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    init: function(pnl) {
        this.view = pnl.getSchedulingView();
        this.view.on('afterrender', this.onRender, this);
    },
    onRender: function(s) {
        this.view.el.on('mousedown', this.onMouseDown, this);
    },
    onMouseDown: function(e, t) {
        // No need for pan plugin since Ext JS supports scrolling when using touch to swipe the grid area
        if (e.event.touches && e.event.touches.length > 0)  {
            return;
        }
        
        var self = this.self,
            disableOnKey = this.disableOnKey;
        // Ignore event if #disableOnKey is specified and at least one of the
        // functional keys is pressed
        if ((e.shiftKey && (disableOnKey & self.KEY_SHIFT)) || (e.ctrlKey && (disableOnKey & self.KEY_CTRL)) || (e.altKey && (disableOnKey & self.KEY_ALT))) {
            return;
        }
        // ignore actions on any rendered content on the schedule
        if (e.getTarget(this.view.timeCellSelector, 10) && !e.getTarget(this.view.timeCellSelector + ' > div > *')) {
            this.mouseX = e.getX();
            this.mouseY = e.getY();
            Ext.getBody().on('mousemove', this.onMouseMove, this);
            Ext.getDoc().on('mouseup', this.onMouseUp, this);
            // For IE (and FF if using frames), if you move mouse onto the browser chrome and release mouse button
            // we won't know about it. Next time mouse enters the body, cancel any ongoing pan activity as a fallback.
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on('mouseenter', this.onMouseUp, this);
            }
            // required for some weird chrome bug/behavior, when whole panel was scrolled-out
            e.stopEvent();
        }
    },
    onMouseMove: function(e) {
        if (this.disabled)  {
            return;
        }
        
        e.stopEvent();
        var x = e.getX();
        var y = e.getY();
        var yDelta = 0,
            xDelta = this.mouseX - x;
        if (this.enableVerticalPan) {
            yDelta = this.mouseY - y;
        }
        this.mouseX = x;
        this.mouseY = y;
        this.view.scrollBy(xDelta, yDelta, false);
        // scroll header as well to avoid "header-body" scroll bouncing
        this.view.headerCt.getScrollable().scrollBy(xDelta, yDelta, false);
    },
    onMouseUp: function(e) {
        Ext.getBody().un('mousemove', this.onMouseMove, this);
        Ext.getDoc().un('mouseup', this.onMouseUp, this);
        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un('mouseenter', this.onMouseUp, this);
        }
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.plugin.TreeCellEditing
@extends Ext.grid.plugin.CellEditing

A specialized "cell editing" plugin (ptype = 'scheduler_treecellediting'), purposed to correctly work with trees. Add it to your component (scheduler with tree view or gantt)
as usual grid plugin:

    var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This class allows us to do 'complex data editing', which is not supported by the regular CellEditing plugin or the Ext.grid.CellEditor which
 assumes a column is always tied to a single field existing on the grid store model (which is not the case for Gantt, dependencies, assignments etc).
*/
Ext.define('Sch.plugin.TreeCellEditing', {
    extend: 'Ext.grid.plugin.CellEditing',
    alias: 'plugin.scheduler_treecellediting',
    requires: [
        'Sch.patches.CellEditing',
        'Sch.patches.CellEditor'
    ],
    lockableScope: 'locked',
    editorsStarted: 0,
    init: function() {
        // This is used to prevent editing of readonly cells
        this.on('beforeedit', this.onMyBeforeEdit, this);
        this.callParent(arguments);
    },
    activateCell: function(position) {
        var editing = this.callParent(arguments);
        if (editing) {
            var editor = this.getEditor(position.record, position.column);
            // we override the editor editor.cancelEdit method
            if (!editor._cancelEdit) {
                editor._cancelEdit = editor.cancelEdit;
                editor.cancelEdit = this.myCancelEdit;
            }
            this.fireEvent('editingstart', this, editor);
        }
        return editing;
    },
    // private
    //cacheDeactivatedEditors: function() {
    //    var me = this,
    //        editors = me.editors.items,
    //        len = editors.length,
    //        i, editor,
    //        detachedBody = Ext.getDetachedBody();
    //    for (i = 0; i < len; i++) {
    //        editor = editors[i];
    //        if (!editor.isVisible()) {
    //            detachedBody.dom.appendChild(editor.el.dom);
    //            editor.container = detachedBody;
    //
    //            // Restore default properties to allow this elements to be collected by GC
    //            editor.el.skipGarbageCollection = false;
    //            editor.el.select('*').each(function (node) {
    //                Ext.get(node).skipGarbageCollection = false;
    //            });
    //        }
    //    }
    //},
    /*
     * Checks if the panel is not locked for editing, and prevents cell edits if needed
     */
    checkReadOnly: function() {
        var pnl = this.getCmp();
        if (pnl) {
            if (!pnl.isTimelineTreePanel && !pnl.isTimelineGridPanel) {
                pnl = pnl.up('tablepanel');
            }
            return !pnl.isReadOnly();
        }
    },
    // @OVERRIDE - model set() method, since we need to do more than just a simple update of a Model field in certain editors
    // Check for 'applyChanges' method and call it if exists
    onEditComplete: function(ed, value, startValue) {
        var me = this;
        // if field instance contains applyChanges() method
        // then we delegate saving to it
        // TODO: this should be refactored
        if (ed.field.applyChanges) {
            if (value !== startValue) {
                ed.field.applyChanges(ed.field.task || me.context.record);
            }
            // Calling parent with value === startValue makes it not to call record.set() method, we don't need it
            // to be called since changes are already applyed, but leaves all other functionality inplace.
            return me.callParent([
                ed,
                value,
                value
            ]);
        } else {
            return me.callParent([
                ed,
                value,
                startValue
            ]);
        }
    },
    // While canceling editing we force the field to persist "originalValue" back to the task
    // if the field is a TaskField mixed instance
    myCancelEdit: function() {
        var me = this,
            field = me.field;
        if (field && field.applyChanges) {
            var instantUpdate = field.instantUpdate;
            // we force the field to persist "originalValue" back to the task
            field.instantUpdate = true;
            var result = me._cancelEdit.apply(this, arguments);
            field.instantUpdate = instantUpdate;
            return result;
        } else {
            return me._cancelEdit.apply(this, arguments);
        }
    },
    onMyBeforeEdit: function(sender, context) {
        var field = context.column.getEditor();
        // if it's a field mixed with TaskField mixin
        if (field && field.setTask) {
            // then after setTask calling field already has correct value
            field.setTask(context.record);
            // Sencha will force value from record and will negate effect of this method, so we pass value through
            // using special property. see line 210782 in ext-all-debug 6.0.2
            context._valueFromTaskField = field.getValue();
        }
        return this.checkReadOnly();
    },
    // OVERRIDE private method
    setEditingContext: function(context) {
        if (context.hasOwnProperty('_valueFromTaskField')) {
            context.value = context.originalValue = context._valueFromTaskField;
            delete context._valueFromTaskField;
        }
        this.callParent(arguments);
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 @class Sch.template.Dependency

 The HTML template used to visualise a line between two tasks.
 */
Ext.define("Sch.template.Dependency", {
    extend: 'Ext.XTemplate',
    disableFormats: true,
    rtl: null,
    text: '<tpl if="startArrow">' + '<div style="__SIDE__:{startArrow.side}px;top:{startArrow.top}px" class="sch-dependency sch-dependency-arrow sch-dependency-start-arrow sch-dependency-arrow-{startArrow.dir} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.isHighlighted ? "sch-dependency-selected" : "" ]}" <tpl if="dependencyId">data-sch-dependency-id="{[values.dependencyId]}"</tpl>></div>' + '</tpl>' + '<tpl for="segments">' + '<div class="sch-dependency sch-dependency-line sch-dependency-line-{dir} {[ parent.isHighlighted ? "sch-dependency-selected" : "" ]} {[ this.getSuffixedCls(parent.cls, "-line") ]}" style="__SIDE__:{side}px;top:{top}px;<tpl if="width !== null && width !== undefined">width:{width}px;</tpl><tpl if="height !== null && height !== undefined">height:{height}px</tpl>" <tpl if="parent.dependencyId">data-sch-dependency-id="{parent.dependencyId}"</tpl>></div>' + '</tpl>' + '<tpl if="endArrow">' + '<div style="__SIDE__:{endArrow.side}px;top:{endArrow.top}px" class="sch-dependency sch-dependency-arrow sch-dependency-end-arrow sch-dependency-arrow-{endArrow.dir} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.isHighlighted ? "sch-dependency-selected" : "" ]}" <tpl if="dependencyId">data-sch-dependency-id="{dependencyId}"</tpl>></div>' + '</tpl>',
    constructor: function(config) {
        Ext.apply(this, config);
        this.text = this.text.replace(/__SIDE__/g, this.rtl ? 'right' : 'left');
        this.callParent([
            this.text
        ]);
    },
    getSuffixedCls: function(cls, suffix) {
        var result = '';
        if (cls && cls.indexOf(' ') != -1) {
            result = cls.replace(/^\s*(.*)\s*$/, '$1').split(/\s+/).join(suffix + ' ') + suffix;
        } else if (cls) {
            result = cls + suffix;
        }
        return result;
    }
});

/*

Ext Gantt Pro 4.2.7
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
 * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.
 */
Ext.define("Sch.util.RectangularPathFinder", {
    alias: 'schpathfinder.rectangular',
    mixins: [
        'Ext.mixin.Factoryable'
    ],
    uses: [
        'Ext.Array'
    ],
    config: {
        /**
         * @cfg {String|Boolean} startSide
         *
         * Default start connection side: 'left', 'right', 'top', 'bottom'
         */
        startSide: 'right',
        /**
         * @cfg {Number} startArrowSize
         *
         * Default start arrow size in pixels
         */
        startArrowSize: 8,
        /**
         * @cfg {Number} startArrowMargin
         *
         * Default start arrow staff size in pixels
         */
        startArrowMargin: 6,
        /**
         * @cfg {Number} startShift
         *
         * Default starting connection point shift from box's arrow pointing side middle point
         */
        startShift: 0,
        /**
         * @cfg {String|Boolean} endSide
         *
         * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'
         */
        endSide: 'left',
        /**
         * @cfg {Number} endArrowSize
         *
         * Default end arrow size in pixels
         */
        endArrowSize: 8,
        /**
         * @cfg {Number} endArrowMargin
         *
         * Default end arrow staff size in pixels
         */
        endArrowMargin: 6,
        /**
         * @cfg {Number} endShift
         *
         * Default ending connection point shift from box's arrow pointing side middle point
         */
        endShift: 0,
        /**
         * @cfg {Number} verticalMargin
         *
         * Start / End box vertical marging, the amount of pixels from top and bottom line of a box where drawing
         * is prohibited
         */
        verticalMargin: 2,
        /**
         * @cfg {Number} horizontalMargin
         *
         * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing
         * is prohibited
         */
        horizontalMargin: 5,
        /**
         * @cfg {Object[]} otherBoxes
         *
         * Other rectangular areas (obstacles) to search path through
         */
        otherBoxes: null
    },
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.initConfig(config);
    },
    /**
     * Returns list of horizontal and vertical segments connecting two boxes
     *
     *    |    | |  |    |       |
     *  --+----+----+----*-------*---
     *  --+=*Start  +----*-------*--
     *  --+----+----+----*-------*--
     *    |    | |  |    |       |
     *    |    | |  |    |       |
     *  --*----*-+-------+-------+--
     *  --*----*-+         End *=+--
     *  --*----*-+-------+-------+--
     *    |    | |  |    |       |
     *
     *  Path goes by lines (-=) and turns at intersections (+*), boxes depicted are adjusted by horizontal/vertical
     *  margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds
     *  the shortest path with minimum amount of turns. In short it's mix of "Lee" and "Dijkstra pathfinding"
     *  with turns amount taken into account for distance calculation.
     *
     *  The algorithm is not very performant though, it's O(N^2), where N is amount of
     *  points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since
     *  two box middle points are not permitted) that might be ok for now.
     *
     * @param {Object} lineDef An object containing any of the class configuration option overrides as well as `startBox`, `endBox` properties
     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties
     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties
     * @return {Object[]|false} Array of line segments or false if path cannot be found
     * @return {Number} return.x1
     * @return {Number} return.y1
     * @return {Number} return.x2
     * @return {Number} return.y2
     */
    findPath: function(lineDef) {
        var me = this,
            lineDefFull = Ext.applyIf(lineDef, me.getConfig()),
            startBox = lineDefFull.startBox,
            endBox = lineDefFull.endBox,
            startShift = lineDefFull.startShift,
            endShift = lineDefFull.endShift,
            startSide = lineDefFull.startSide,
            endSide = lineDefFull.endSide,
            startArrowSize = lineDefFull.startArrowSize,
            endArrowSize = lineDefFull.endArrowSize,
            startArrowMargin = lineDefFull.startArrowMargin,
            endArrowMargin = lineDefFull.endArrowMargin,
            horizontalMargin = lineDefFull.horizontalMargin,
            verticalMargin = lineDefFull.verticalMargin,
            otherBoxes = lineDefFull.otherBoxes,
            connStartPoint, connEndPoint, pathStartPoint, pathEndPoint, gridStartPoint, gridEndPoint, startGridBox, endGridBox, grid, path, tmp;
        startSide = me.normalizeSide(startSide);
        endSide = me.normalizeSide(endSide);
        connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
        connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);
        startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowSize, startArrowMargin, horizontalMargin, verticalMargin);
        endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowSize, endArrowMargin, horizontalMargin, verticalMargin);
        otherBoxes = otherBoxes && Ext.Array.map(otherBoxes, function(box) {
            return me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, horizontalMargin, verticalMargin);
        });
        pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
        pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
        grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
        gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
        gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
        path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);
        if (path) {
            path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
            path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
            path = me.optimizePath(path);
        }
        if (!path || path.length === 0)  {
            throw 'Path could not be found for line definition';
        }
        
        return path;
    },
    getConnectionCoordinatesFromBoxSideShift: function(box, side, shift) {
        var coords;
        switch (side) {
            case 'left':
                coords = {
                    x: box.start,
                    y: (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'right':
                coords = {
                    x: box.end,
                    y: (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'top':
                coords = {
                    x: (box.start + box.end) / 2 + shift,
                    y: box.top
                };
                break;
            case 'bottom':
                coords = {
                    x: (box.start + box.end) / 2 + shift,
                    y: box.bottom
                };
                break;
        }
        return coords;
    },
    calcGridBaseBoxFromBoxAndDrawParams: function(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
        var gridBox;
        switch (side) {
            case 'left':
                gridBox = {
                    start: box.start - Math.max(arrowSize + arrowMargin, horizontalMargin),
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'right':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + Math.max(arrowSize + arrowMargin, horizontalMargin),
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'top':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - Math.max(arrowSize + arrowMargin, verticalMargin),
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'bottom':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)
                };
                break;
            default:
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
        }
        return gridBox;
    },
    buildPathGrid: function(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
        var xs, ys, y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point,
            points = {},
            linearPoints = [];
        xs = [
            startGridBox.start,
            (startSide == 'left' || startSide == 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,
            startGridBox.end,
            endGridBox.start,
            (endSide == 'left' || endSide == 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,
            endGridBox.end
        ];
        ys = [
            startGridBox.top,
            (startSide == 'top' || startSide == 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,
            startGridBox.bottom,
            endGridBox.top,
            (endSide == 'top' || endSide == 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,
            endGridBox.bottom
        ];
        if (otherGridBoxes) {
            Ext.Array.forEach(otherGridBoxes, function(box) {
                xs.push(box.start, (box.start + box.end) / 2, box.end);
                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
            });
        }
        xs = Ext.Array.unique(Ext.Array.sort(xs, Ext.Array.numericSortFn));
        ys = Ext.Array.unique(Ext.Array.sort(ys, Ext.Array.numericSortFn));
        for (iy = 0 , yslen = ys.length; iy < yslen; ++iy) {
            points[iy] = points[iy] || {};
            y = ys[iy];
            for (ix = 0 , xslen = xs.length; ix < xslen; ++ix) {
                x = xs[ix];
                permitted = ((x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) && (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom));
                if (otherGridBoxes) {
                    for (ib = 0 , blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
                        box = otherGridBoxes[ib];
                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom);
                    }
                }
                point = {
                    distance: Math.pow(2, 53) - 1,
                    // Number.MAX_SAFE_INTEGER (not supported in Opera/IE)
                    permitted: permitted,
                    x: x,
                    y: y,
                    ix: ix,
                    iy: iy
                };
                points[iy][ix] = point;
                linearPoints.push(point);
            }
        }
        return {
            width: xs.length,
            height: ys.length,
            xs: xs,
            ys: ys,
            points: points,
            linearPoints: linearPoints
        };
    },
    convertDecartPointToGridPoint: function(grid, point) {
        var x = Ext.Array.indexOf(grid.xs, point.x),
            y = Ext.Array.indexOf(grid.ys, point.y);
        return grid.points[y][x];
    },
    findPathOnGrid: function(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
        var me = this,
            path = false;
        if (gridStartPoint.permitted && gridEndPoint.permitted) {
            grid = me.waveForward(grid, gridStartPoint, 0);
            path = me.collectPath(grid, gridEndPoint, endSide);
        }
        return path;
    },
    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)
    getGridPointNeighbors: function(grid, gridPoint, predicateFn) {
        var ix = gridPoint.ix,
            iy = gridPoint.iy,
            result = [],
            neighbor;
        // NOTE:
        // It's important to push bottom neighbors first since this method is used
        // in collectPath(), which reversively collects path from end to start node
        // and if bottom neighbors are pushed first in result array then collectPath()
        // will produce a line which is more suitable (pleasant looking) for our purposes.
        if (iy < grid.height - 1) {
            neighbor = grid.points[iy + 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (iy > 0) {
            neighbor = grid.points[iy - 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix < grid.width - 1) {
            neighbor = grid.points[iy][ix + 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix > 0) {
            neighbor = grid.points[iy][ix - 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        return result;
    },
    // This method might lead to stack overflow if there're a lot of other boxes defined for the grid,
    // a lot here means hundreds
    // TODO: refactor the method such it won't use recursion
    waveForward: function(grid, gridStartPoint, distance) {
        var me = this,
            neighbors, i, len, neighbor, neighborDistance, neighborDir, xDiff, yDiff;
        gridStartPoint.distance = distance;
        // Taking all point neigbors which are permitted for path and which distance is higher then
        // it might be if we move through this point. Initially each point has Number.MAX_SAFE_INTEGER (2^53-1) distance.
        neighbors = me.getGridPointNeighbors(grid, gridStartPoint, function(point) {
            return point.permitted && (point.distance > distance + 1);
        });
        // It's important to set neighbor distance first, before waving to a neighbor, otherwise waving might
        // get through a neighbor point setting it's distance to a value more then (distance + 1) whereas we,
        // at this point, already know that it's possibly optimal distance is (distance + 1)
        for (i = 0 , len = neighbors.length; i < len; ++i) {
            neighbor = neighbors[i];
            neighbor.distance = distance + 1;
        }
        for (i = 0 , len = neighbors.length; i < len; ++i) {
            neighbor = neighbors[i];
            me.waveForward(grid, neighbor, distance + 1);
        }
        return grid;
    },
    collectPath: function(grid, gridEndPoint, endSide) {
        var me = this,
            pathFound = true,
            neighbors, lowestDistanceNeighbor, xDiff, yDiff,
            path = [];
        while (pathFound && gridEndPoint.distance) {
            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, function(point) {
                return point.permitted && (point.distance == gridEndPoint.distance - 1);
            });
            pathFound = neighbors.length > 0;
            if (pathFound) {
                // Prefer turnless neighbors first
                neighbors = Ext.Array.sort(neighbors, function(a, b) {
                    var xDiff, yDiff;
                    xDiff = a.ix - gridEndPoint.ix;
                    yDiff = a.iy - gridEndPoint.iy;
                    var result_a = (((endSide == 'left' || endSide == 'right') && yDiff === 0) || ((endSide == 'top' || endSide == 'bottom') && xDiff === 0)) ? -1 : 1;
                    xDiff = b.ix - gridEndPoint.ix;
                    yDiff = b.iy - gridEndPoint.iy;
                    var result_b = (((endSide == 'left' || endSide == 'right') && yDiff === 0) || ((endSide == 'top' || endSide == 'bottom') && xDiff === 0)) ? -1 : 1;
                    if (result_a > result_b) {
                        return 1;
                    } else if (result_a < result_b) {
                        return -1;
                    } else if (result_a == result_b) {
                        // apply additional sorting to be sure to pick bottom path in IE
                        return a.y > b.y ? -1 : 1;
                    }
                });
                lowestDistanceNeighbor = neighbors[0];
                path.push({
                    x1: lowestDistanceNeighbor.x,
                    y1: lowestDistanceNeighbor.y,
                    x2: gridEndPoint.x,
                    y2: gridEndPoint.y
                });
                // Detecting new side, either xDiff or yDiff must be 0 (but not both)
                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;
                switch (true) {
                    case !yDiff && xDiff > 0:
                        endSide = 'left';
                        break;
                    case !yDiff && xDiff < 0:
                        endSide = 'right';
                        break;
                    case !xDiff && yDiff > 0:
                        endSide = 'top';
                        break;
                    case !xDiff && yDiff < 0:
                        endSide = 'bottom';
                        break;
                }
                gridEndPoint = lowestDistanceNeighbor;
            }
        }
        return pathFound && path.reverse() || false;
    },
    prependPathWithArrowStaffSegment: function(path, connStartPoint, startArrowSize, startSide) {
        var prependSegment, firstSegment;
        if (path.length > 0) {
            firstSegment = path[0];
            prependSegment = {
                x2: firstSegment.x1,
                y2: firstSegment.y1
            };
            switch (startSide) {
                case 'left':
                    prependSegment.x1 = connStartPoint.x - startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'right':
                    prependSegment.x1 = connStartPoint.x + startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'top':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y - startArrowSize;
                    break;
                case 'bottom':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y + startArrowSize;
                    break;
            }
            path.unshift(prependSegment);
        }
        return path;
    },
    appendPathWithArrowStaffSegment: function(path, connEndPoint, endArrowSize, endSide) {
        var appendSegment, lastSegment;
        if (path.length > 0) {
            lastSegment = path[path.length - 1];
            appendSegment = {
                x1: lastSegment.x2,
                y1: lastSegment.y2
            };
            switch (endSide) {
                case 'left':
                    appendSegment.x2 = connEndPoint.x - endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'right':
                    appendSegment.x2 = connEndPoint.x + endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'top':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y - endArrowSize;
                    break;
                case 'bottom':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y + endArrowSize;
                    break;
            }
            path.push(appendSegment);
        }
        return path;
    },
    optimizePath: function(path) {
        var optPath = [],
            prevSegment, curSegment;
        if (path.length > 0) {
            prevSegment = path.shift();
            optPath.push(prevSegment);
            while (path.length > 0) {
                curSegment = path.shift();
                // both segments are equal
                if (prevSegment.x1 == curSegment.x1 && prevSegment.y1 == curSegment.y1 && prevSegment.x2 == curSegment.x2 && prevSegment.y2 == curSegment.y2) {
                    prevSegment = curSegment;
                }
                // both segments are horizontal
                else if ((prevSegment.y1 - prevSegment.y2 === 0) && (curSegment.y1 - curSegment.y2 === 0)) {
                    prevSegment.x2 = curSegment.x2;
                }
                // both segments are vertical
                else if ((prevSegment.x1 - prevSegment.x2 === 0) && (curSegment.x1 - curSegment.x2 === 0)) {
                    prevSegment.y2 = curSegment.y2;
                } else // segments has different orientation (path turn)
                {
                    optPath.push(curSegment);
                    prevSegment = curSegment;
                }
            }
        }
        return optPath;
    },
    normalizeSide: function(side) {
        return this.self.sideToSide[side] || side;
    },
    statics: {
        sideToSide: {
            'l': 'left',
            'r': 'right',
            't': 'top',
            'b': 'bottom'
        }
    }
});
/*
window.visualizeGrid = function() {
    var grid = window.grid,
        body = Ext.getBody(),
        vpWidth = Ext.dom.Element.getViewportWidth(),
        vpHeight = Ext.dom.Element.getViewportHeight();

    Ext.destroy(window.visGridEls);

    window.visGridEls = [];

    Ext.Array.forEach(grid.ys, function(y) {
        var el = body.appendChild({
            tag : 'div',
            style : {
                position: 'absolute',
                top : y + 'px',
                left : '0px',
                width : vpWidth + 'px',
                height : '1px',
                background : 'green',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });

    Ext.Array.forEach(grid.xs, function(x) {
        var el = body.appendChild({
            tag : 'div',
            style : {
                position: 'absolute',
                top : '0px',
                left : x + 'px',
                width : '1px',
                height : vpHeight + 'px',
                background : 'green',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });

    Ext.Array.forEach(grid.linearPoints, function(point) {
        var el = body.appendChild({
            tag : 'div',
            html : point.permitted && String(point.distance) || '!',
            style : {
                position: 'absolute',
                top : point.y - 15 + 'px',
                left : point.x - 15 + 'px',
                width : '15px',
                height : '15px',
                color: 'red',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });
};
*/

